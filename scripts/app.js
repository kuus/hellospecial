/*!
 * modernizr v3.5.0
 * Build https://modernizr.com/download?-csspointerevents-csspositionsticky-cssremunit-csstransforms-csstransforms3d-cssvwunit-flexbox-inlinesvg-svg-touchevents-mq-setclasses-dontmin
 *
 * Copyright (c)
 *  Faruk Ates
 *  Paul Irish
 *  Alex Sexton
 *  Ryan Seddon
 *  Patrick Kettner
 *  Stu Cox
 *  Richard Herrera

 * MIT License
 */
!function(e,t,n){function r(e,t){return typeof e===t}function s(){return"function"!=typeof t.createElement?t.createElement(arguments[0]):x?t.createElementNS.call(t,"http://www.w3.org/2000/svg",arguments[0]):t.createElement.apply(t,arguments)}function o(){var e=t.body;return e||(e=s(x?"svg":"body"),e.fake=!0),e}function i(e,n,r,i){var a,l,u,f,c="modernizr",d=s("div"),p=o();if(parseInt(r,10))for(;r--;)u=s("div"),u.id=i?i[r]:c+(r+1),d.appendChild(u);return a=s("style"),a.type="text/css",a.id="s"+c,(p.fake?p:d).appendChild(a),p.appendChild(d),a.styleSheet?a.styleSheet.cssText=e:a.appendChild(t.createTextNode(e)),d.id=c,p.fake&&(p.style.background="",p.style.overflow="hidden",f=C.style.overflow,C.style.overflow="hidden",C.appendChild(p)),l=n(d,e),p.fake?(p.parentNode.removeChild(p),C.style.overflow=f,C.offsetHeight):d.parentNode.removeChild(d),!!l}function a(e,t){return!!~(""+e).indexOf(t)}function l(e){return e.replace(/([A-Z])/g,function(e,t){return"-"+t.toLowerCase()}).replace(/^ms-/,"-ms-")}function u(t,n,r){var s;if("getComputedStyle"in e){s=getComputedStyle.call(e,t,n);var o=e.console;if(null!==s)r&&(s=s.getPropertyValue(r));else if(o){var i=o.error?"error":"log";o[i].call(o,"getComputedStyle returning null, its possible modernizr test results are inaccurate")}}else s=!n&&t.currentStyle&&t.currentStyle[r];return s}function f(t,r){var s=t.length;if("CSS"in e&&"supports"in e.CSS){for(;s--;)if(e.CSS.supports(l(t[s]),r))return!0;return!1}if("CSSSupportsRule"in e){for(var o=[];s--;)o.push("("+l(t[s])+":"+r+")");return o=o.join(" or "),i("@supports ("+o+") { #modernizr { position: absolute; } }",function(e){return"absolute"==u(e,null,"position")})}return n}function c(e){return e.replace(/([a-z])-([a-z])/g,function(e,t,n){return t+n.toUpperCase()}).replace(/^-/,"")}function d(e,t,o,i){function l(){d&&(delete E.style,delete E.modElem)}if(i=!r(i,"undefined")&&i,!r(o,"undefined")){var u=f(e,o);if(!r(u,"undefined"))return u}for(var d,p,m,v,h,g=["modernizr","tspan","samp"];!E.style&&g.length;)d=!0,E.modElem=s(g.shift()),E.style=E.modElem.style;for(m=e.length,p=0;p<m;p++)if(v=e[p],h=E.style[v],a(v,"-")&&(v=c(v)),E.style[v]!==n){if(i||r(o,"undefined"))return l(),"pfx"!=t||v;try{E.style[v]=o}catch(e){}if(E.style[v]!=h)return l(),"pfx"!=t||v}return l(),!1}function p(e,t){return function(){return e.apply(t,arguments)}}function m(e,t,n){var s;for(var o in e)if(e[o]in t)return!1===n?e[o]:(s=t[e[o]],r(s,"function")?p(s,n||t):s);return!1}function v(e,t,n,s,o){var i=e.charAt(0).toUpperCase()+e.slice(1),a=(e+" "+P.join(i+" ")+i).split(" ");return r(t,"string")||r(t,"undefined")?d(a,t,s,o):(a=(e+" "+j.join(i+" ")+i).split(" "),m(a,t,n))}function h(e,t,r){return v(e,n,n,t,r)}var g=[],y={_version:"3.5.0",_config:{classPrefix:"",enableClasses:!0,enableJSClass:!0,usePrefixes:!0},_q:[],on:function(e,t){var n=this;setTimeout(function(){t(n[e])},0)},addTest:function(e,t,n){g.push({name:e,fn:t,options:n})},addAsyncTest:function(e){g.push({name:null,fn:e})}},w=function(){};w.prototype=y,w=new w;var S=[],C=t.documentElement,x="svg"===C.nodeName.toLowerCase(),T=function(){var t=e.matchMedia||e.msMatchMedia;return t?function(e){var n=t(e);return n&&n.matches||!1}:function(t){var n=!1;return i("@media "+t+" { #modernizr { position: absolute; } }",function(t){n="absolute"==(e.getComputedStyle?e.getComputedStyle(t,null):t.currentStyle).position}),n}}();y.mq=T,w.addTest("svg",!!t.createElementNS&&!!t.createElementNS("http://www.w3.org/2000/svg","svg").createSVGRect);var b=y._config.usePrefixes?" -webkit- -moz- -o- -ms- ".split(" "):["",""];y._prefixes=b;var z=y.testStyles=i;w.addTest("touchevents",function(){var n;if("ontouchstart"in e||e.DocumentTouch&&t instanceof DocumentTouch)n=!0;else{var r=["@media (",b.join("touch-enabled),("),"heartz",")","{#modernizr{top:9px;position:absolute}}"].join("");z(r,function(e){n=9===e.offsetTop})}return n});var _="Moz O ms Webkit",P=y._config.usePrefixes?_.split(" "):[];y._cssomPrefixes=P;var k={elem:s("modernizr")};w._q.push(function(){delete k.elem});var E={style:k.elem.style};w._q.unshift(function(){delete E.style});var j=y._config.usePrefixes?_.toLowerCase().split(" "):[];y._domPrefixes=j,y.testAllProps=v,y.testAllProps=h,w.addTest("flexbox",h("flexBasis","1px",!0)),w.addTest("csspointerevents",function(){var e=s("a").style;return e.cssText="pointer-events:auto","auto"===e.pointerEvents}),w.addTest("csspositionsticky",function(){var e="position:",t=s("a"),n=t.style;return n.cssText=e+b.join("sticky;"+e).slice(0,-e.length),-1!==n.position.indexOf("sticky")}),w.addTest("cssremunit",function(){var e=s("a").style;try{e.fontSize="3rem"}catch(e){}return/rem/.test(e.fontSize)}),w.addTest("csstransforms",function(){return-1===navigator.userAgent.indexOf("Android 2.")&&h("transform","scale(1)",!0)});var N="CSS"in e&&"supports"in e.CSS,A="supportsCSS"in e;w.addTest("supports",N||A),w.addTest("csstransforms3d",function(){var e=!!h("perspective","1px",!0),t=w._config.usePrefixes;if(e&&(!t||"webkitPerspective"in C.style)){var n;w.supports?n="@supports (perspective: 1px)":(n="@media (transform-3d)",t&&(n+=",(-webkit-transform-3d)")),n+="{#modernizr{width:7px;height:18px;margin:0;padding:0;border:0}}",z("#modernizr{width:0;height:0}"+n,function(t){e=7===t.offsetWidth&&18===t.offsetHeight})}return e}),z("#modernizr { width: 50vw; }",function(t){var n=parseInt(e.innerWidth/2,10),r=parseInt(u(t,null,"width"),10);w.addTest("cssvwunit",r==n)}),w.addTest("inlinesvg",function(){var e=s("div");return e.innerHTML="<svg/>","http://www.w3.org/2000/svg"==("undefined"!=typeof SVGRect&&e.firstChild&&e.firstChild.namespaceURI)}),function(){var e,t,n,s,o,i,a;for(var l in g)if(g.hasOwnProperty(l)){if(e=[],t=g[l],t.name&&(e.push(t.name.toLowerCase()),t.options&&t.options.aliases&&t.options.aliases.length))for(n=0;n<t.options.aliases.length;n++)e.push(t.options.aliases[n].toLowerCase());for(s=r(t.fn,"function")?t.fn():t.fn,o=0;o<e.length;o++)i=e[o],a=i.split("."),1===a.length?w[a[0]]=s:(!w[a[0]]||w[a[0]]instanceof Boolean||(w[a[0]]=new Boolean(w[a[0]])),w[a[0]][a[1]]=s),S.push((s?"":"no-")+a.join("-"))}}(),function(e){var t=C.className,n=w._config.classPrefix||"";if(x&&(t=t.baseVal),w._config.enableJSClass){var r=new RegExp("(^|\\s)"+n+"no-js(\\s|$)");t=t.replace(r,"$1"+n+"js$2")}w._config.enableClasses&&(t+=" "+n+e.join(" "+n),x?C.className.baseVal=t:C.className=t)}(S),delete y.addTest,delete y.addAsyncTest;for(var q=0;q<w._q.length;q++)w._q[q]();e.Modernizr=w}(window,document);
/*
 * This combined file was created by the DataTables downloader builder:
 *   https://datatables.net/download
 *
 * To rebuild or modify this file with the latest versions of the included
 * software please visit:
 *   https://datatables.net/download/#bs4/dt-1.10.16
 *
 * Included libraries:
 *   DataTables 1.10.16
 */

/*! DataTables 1.10.16
 * Â©2008-2017 SpryMedia Ltd - datatables.net/license
 */

/**
 * @summary     DataTables
 * @description Paginate, search and order HTML tables
 * @version     1.10.16
 * @file        jquery.dataTables.js
 * @author      SpryMedia Ltd
 * @contact     www.datatables.net
 * @copyright   Copyright 2008-2017 SpryMedia Ltd.
 *
 * This source file is free software, available under the following license:
 *   MIT license - http://datatables.net/license
 *
 * This source file is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
 * or FITNESS FOR A PARTICULAR PURPOSE. See the license files for details.
 *
 * For details please refer to: http://www.datatables.net
 */

/*jslint evil: true, undef: true, browser: true */
/*globals $,require,jQuery,define,_selector_run,_selector_opts,_selector_first,_selector_row_indexes,_ext,_Api,_api_register,_api_registerPlural,_re_new_lines,_re_html,_re_formatted_numeric,_re_escape_regex,_empty,_intVal,_numToDecimal,_isNumber,_isHtml,_htmlNumeric,_pluck,_pluck_order,_range,_stripHtml,_unique,_fnBuildAjax,_fnAjaxUpdate,_fnAjaxParameters,_fnAjaxUpdateDraw,_fnAjaxDataSrc,_fnAddColumn,_fnColumnOptions,_fnAdjustColumnSizing,_fnVisibleToColumnIndex,_fnColumnIndexToVisible,_fnVisbleColumns,_fnGetColumns,_fnColumnTypes,_fnApplyColumnDefs,_fnHungarianMap,_fnCamelToHungarian,_fnLanguageCompat,_fnBrowserDetect,_fnAddData,_fnAddTr,_fnNodeToDataIndex,_fnNodeToColumnIndex,_fnGetCellData,_fnSetCellData,_fnSplitObjNotation,_fnGetObjectDataFn,_fnSetObjectDataFn,_fnGetDataMaster,_fnClearTable,_fnDeleteIndex,_fnInvalidate,_fnGetRowElements,_fnCreateTr,_fnBuildHead,_fnDrawHead,_fnDraw,_fnReDraw,_fnAddOptionsHtml,_fnDetectHeader,_fnGetUniqueThs,_fnFeatureHtmlFilter,_fnFilterComplete,_fnFilterCustom,_fnFilterColumn,_fnFilter,_fnFilterCreateSearch,_fnEscapeRegex,_fnFilterData,_fnFeatureHtmlInfo,_fnUpdateInfo,_fnInfoMacros,_fnInitialise,_fnInitComplete,_fnLengthChange,_fnFeatureHtmlLength,_fnFeatureHtmlPaginate,_fnPageChange,_fnFeatureHtmlProcessing,_fnProcessingDisplay,_fnFeatureHtmlTable,_fnScrollDraw,_fnApplyToChildren,_fnCalculateColumnWidths,_fnThrottle,_fnConvertToWidth,_fnGetWidestNode,_fnGetMaxLenString,_fnStringToCss,_fnSortFlatten,_fnSort,_fnSortAria,_fnSortListener,_fnSortAttachListener,_fnSortingClasses,_fnSortData,_fnSaveState,_fnLoadState,_fnSettingsFromNode,_fnLog,_fnMap,_fnBindAction,_fnCallbackReg,_fnCallbackFire,_fnLengthOverflow,_fnRenderer,_fnDataSource,_fnRowAttributes*/

(function( factory ) {
  "use strict";

  if ( typeof define === 'function' && define.amd ) {
    // AMD
    define( ['jquery'], function ( $ ) {
      return factory( $, window, document );
    } );
  }
  else if ( typeof exports === 'object' ) {
    // CommonJS
    module.exports = function (root, $) {
      if ( ! root ) {
        // CommonJS environments without a window global must pass a
        // root. This will give an error otherwise
        root = window;
      }

      if ( ! $ ) {
        $ = typeof window !== 'undefined' ? // jQuery's factory checks for a global window
          require('jquery') :
          require('jquery')( root );
      }

      return factory( $, root, root.document );
    };
  }
  else {
    // Browser
    factory( jQuery, window, document );
  }
}
(function( $, window, document, undefined ) {
  "use strict";

  /**
   * DataTables is a plug-in for the jQuery Javascript library. It is a highly
   * flexible tool, based upon the foundations of progressive enhancement,
   * which will add advanced interaction controls to any HTML table. For a
   * full list of features please refer to
   * [DataTables.net](href="http://datatables.net).
   *
   * Note that the `DataTable` object is not a global variable but is aliased
   * to `jQuery.fn.DataTable` and `jQuery.fn.dataTable` through which it may
   * be  accessed.
   *
   *  @class
   *  @param {object} [init={}] Configuration object for DataTables. Options
   *    are defined by {@link DataTable.defaults}
   *  @requires jQuery 1.7+
   *
   *  @example
   *    // Basic initialisation
   *    $(document).ready( function {
   *      $('#example').dataTable();
   *    } );
   *
   *  @example
   *    // Initialisation with configuration options - in this case, disable
   *    // pagination and sorting.
   *    $(document).ready( function {
   *      $('#example').dataTable( {
   *        "paginate": false,
   *        "sort": false
   *      } );
   *    } );
   */
  var DataTable = function ( options )
  {
    /**
     * Perform a jQuery selector action on the table's TR elements (from the tbody) and
     * return the resulting jQuery object.
     *  @param {string|node|jQuery} sSelector jQuery selector or node collection to act on
     *  @param {object} [oOpts] Optional parameters for modifying the rows to be included
     *  @param {string} [oOpts.filter=none] Select TR elements that meet the current filter
     *    criterion ("applied") or all TR elements (i.e. no filter).
     *  @param {string} [oOpts.order=current] Order of the TR elements in the processed array.
     *    Can be either 'current', whereby the current sorting of the table is used, or
     *    'original' whereby the original order the data was read into the table is used.
     *  @param {string} [oOpts.page=all] Limit the selection to the currently displayed page
     *    ("current") or not ("all"). If 'current' is given, then order is assumed to be
     *    'current' and filter is 'applied', regardless of what they might be given as.
     *  @returns {object} jQuery object, filtered by the given selector.
     *  @dtopt API
     *  @deprecated Since v1.10
     *
     *  @example
     *    $(document).ready(function() {
     *      var oTable = $('#example').dataTable();
     *
     *      // Highlight every second row
     *      oTable.$('tr:odd').css('backgroundColor', 'blue');
     *    } );
     *
     *  @example
     *    $(document).ready(function() {
     *      var oTable = $('#example').dataTable();
     *
     *      // Filter to rows with 'Webkit' in them, add a background colour and then
     *      // remove the filter, thus highlighting the 'Webkit' rows only.
     *      oTable.fnFilter('Webkit');
     *      oTable.$('tr', {"search": "applied"}).css('backgroundColor', 'blue');
     *      oTable.fnFilter('');
     *    } );
     */
    this.$ = function ( sSelector, oOpts )
    {
      return this.api(true).$( sSelector, oOpts );
    };


    /**
     * Almost identical to $ in operation, but in this case returns the data for the matched
     * rows - as such, the jQuery selector used should match TR row nodes or TD/TH cell nodes
     * rather than any descendants, so the data can be obtained for the row/cell. If matching
     * rows are found, the data returned is the original data array/object that was used to
     * create the row (or a generated array if from a DOM source).
     *
     * This method is often useful in-combination with $ where both functions are given the
     * same parameters and the array indexes will match identically.
     *  @param {string|node|jQuery} sSelector jQuery selector or node collection to act on
     *  @param {object} [oOpts] Optional parameters for modifying the rows to be included
     *  @param {string} [oOpts.filter=none] Select elements that meet the current filter
     *    criterion ("applied") or all elements (i.e. no filter).
     *  @param {string} [oOpts.order=current] Order of the data in the processed array.
     *    Can be either 'current', whereby the current sorting of the table is used, or
     *    'original' whereby the original order the data was read into the table is used.
     *  @param {string} [oOpts.page=all] Limit the selection to the currently displayed page
     *    ("current") or not ("all"). If 'current' is given, then order is assumed to be
     *    'current' and filter is 'applied', regardless of what they might be given as.
     *  @returns {array} Data for the matched elements. If any elements, as a result of the
     *    selector, were not TR, TD or TH elements in the DataTable, they will have a null
     *    entry in the array.
     *  @dtopt API
     *  @deprecated Since v1.10
     *
     *  @example
     *    $(document).ready(function() {
     *      var oTable = $('#example').dataTable();
     *
     *      // Get the data from the first row in the table
     *      var data = oTable._('tr:first');
     *
     *      // Do something useful with the data
     *      alert( "First cell is: "+data[0] );
     *    } );
     *
     *  @example
     *    $(document).ready(function() {
     *      var oTable = $('#example').dataTable();
     *
     *      // Filter to 'Webkit' and get all data for
     *      oTable.fnFilter('Webkit');
     *      var data = oTable._('tr', {"search": "applied"});
     *
     *      // Do something with the data
     *      alert( data.length+" rows matched the search" );
     *    } );
     */
    this._ = function ( sSelector, oOpts )
    {
      return this.api(true).rows( sSelector, oOpts ).data();
    };


    /**
     * Create a DataTables Api instance, with the currently selected tables for
     * the Api's context.
     * @param {boolean} [traditional=false] Set the API instance's context to be
     *   only the table referred to by the `DataTable.ext.iApiIndex` option, as was
     *   used in the API presented by DataTables 1.9- (i.e. the traditional mode),
     *   or if all tables captured in the jQuery object should be used.
     * @return {DataTables.Api}
     */
    this.api = function ( traditional )
    {
      return traditional ?
        new _Api(
          _fnSettingsFromNode( this[ _ext.iApiIndex ] )
        ) :
        new _Api( this );
    };


    /**
     * Add a single new row or multiple rows of data to the table. Please note
     * that this is suitable for client-side processing only - if you are using
     * server-side processing (i.e. "bServerSide": true), then to add data, you
     * must add it to the data source, i.e. the server-side, through an Ajax call.
     *  @param {array|object} data The data to be added to the table. This can be:
     *    <ul>
     *      <li>1D array of data - add a single row with the data provided</li>
     *      <li>2D array of arrays - add multiple rows in a single call</li>
     *      <li>object - data object when using <i>mData</i></li>
     *      <li>array of objects - multiple data objects when using <i>mData</i></li>
     *    </ul>
     *  @param {bool} [redraw=true] redraw the table or not
     *  @returns {array} An array of integers, representing the list of indexes in
     *    <i>aoData</i> ({@link DataTable.models.oSettings}) that have been added to
     *    the table.
     *  @dtopt API
     *  @deprecated Since v1.10
     *
     *  @example
     *    // Global var for counter
     *    var giCount = 2;
     *
     *    $(document).ready(function() {
     *      $('#example').dataTable();
     *    } );
     *
     *    function fnClickAddRow() {
     *      $('#example').dataTable().fnAddData( [
     *        giCount+".1",
     *        giCount+".2",
     *        giCount+".3",
     *        giCount+".4" ]
     *      );
     *
     *      giCount++;
     *    }
     */
    this.fnAddData = function( data, redraw )
    {
      var api = this.api( true );

      /* Check if we want to add multiple rows or not */
      var rows = $.isArray(data) && ( $.isArray(data[0]) || $.isPlainObject(data[0]) ) ?
        api.rows.add( data ) :
        api.row.add( data );

      if ( redraw === undefined || redraw ) {
        api.draw();
      }

      return rows.flatten().toArray();
    };


    /**
     * This function will make DataTables recalculate the column sizes, based on the data
     * contained in the table and the sizes applied to the columns (in the DOM, CSS or
     * through the sWidth parameter). This can be useful when the width of the table's
     * parent element changes (for example a window resize).
     *  @param {boolean} [bRedraw=true] Redraw the table or not, you will typically want to
     *  @dtopt API
     *  @deprecated Since v1.10
     *
     *  @example
     *    $(document).ready(function() {
     *      var oTable = $('#example').dataTable( {
     *        "sScrollY": "200px",
     *        "bPaginate": false
     *      } );
     *
     *      $(window).on('resize', function () {
     *        oTable.fnAdjustColumnSizing();
     *      } );
     *    } );
     */
    this.fnAdjustColumnSizing = function ( bRedraw )
    {
      var api = this.api( true ).columns.adjust();
      var settings = api.settings()[0];
      var scroll = settings.oScroll;

      if ( bRedraw === undefined || bRedraw ) {
        api.draw( false );
      }
      else if ( scroll.sX !== "" || scroll.sY !== "" ) {
        /* If not redrawing, but scrolling, we want to apply the new column sizes anyway */
        _fnScrollDraw( settings );
      }
    };


    /**
     * Quickly and simply clear a table
     *  @param {bool} [bRedraw=true] redraw the table or not
     *  @dtopt API
     *  @deprecated Since v1.10
     *
     *  @example
     *    $(document).ready(function() {
     *      var oTable = $('#example').dataTable();
     *
     *      // Immediately 'nuke' the current rows (perhaps waiting for an Ajax callback...)
     *      oTable.fnClearTable();
     *    } );
     */
    this.fnClearTable = function( bRedraw )
    {
      var api = this.api( true ).clear();

      if ( bRedraw === undefined || bRedraw ) {
        api.draw();
      }
    };


    /**
     * The exact opposite of 'opening' a row, this function will close any rows which
     * are currently 'open'.
     *  @param {node} nTr the table row to 'close'
     *  @returns {int} 0 on success, or 1 if failed (can't find the row)
     *  @dtopt API
     *  @deprecated Since v1.10
     *
     *  @example
     *    $(document).ready(function() {
     *      var oTable;
     *
     *      // 'open' an information row when a row is clicked on
     *      $('#example tbody tr').click( function () {
     *        if ( oTable.fnIsOpen(this) ) {
     *          oTable.fnClose( this );
     *        } else {
     *          oTable.fnOpen( this, "Temporary row opened", "info_row" );
     *        }
     *      } );
     *
     *      oTable = $('#example').dataTable();
     *    } );
     */
    this.fnClose = function( nTr )
    {
      this.api( true ).row( nTr ).child.hide();
    };


    /**
     * Remove a row for the table
     *  @param {mixed} target The index of the row from aoData to be deleted, or
     *    the TR element you want to delete
     *  @param {function|null} [callBack] Callback function
     *  @param {bool} [redraw=true] Redraw the table or not
     *  @returns {array} The row that was deleted
     *  @dtopt API
     *  @deprecated Since v1.10
     *
     *  @example
     *    $(document).ready(function() {
     *      var oTable = $('#example').dataTable();
     *
     *      // Immediately remove the first row
     *      oTable.fnDeleteRow( 0 );
     *    } );
     */
    this.fnDeleteRow = function( target, callback, redraw )
    {
      var api = this.api( true );
      var rows = api.rows( target );
      var settings = rows.settings()[0];
      var data = settings.aoData[ rows[0][0] ];

      rows.remove();

      if ( callback ) {
        callback.call( this, settings, data );
      }

      if ( redraw === undefined || redraw ) {
        api.draw();
      }

      return data;
    };


    /**
     * Restore the table to it's original state in the DOM by removing all of DataTables
     * enhancements, alterations to the DOM structure of the table and event listeners.
     *  @param {boolean} [remove=false] Completely remove the table from the DOM
     *  @dtopt API
     *  @deprecated Since v1.10
     *
     *  @example
     *    $(document).ready(function() {
     *      // This example is fairly pointless in reality, but shows how fnDestroy can be used
     *      var oTable = $('#example').dataTable();
     *      oTable.fnDestroy();
     *    } );
     */
    this.fnDestroy = function ( remove )
    {
      this.api( true ).destroy( remove );
    };


    /**
     * Redraw the table
     *  @param {bool} [complete=true] Re-filter and resort (if enabled) the table before the draw.
     *  @dtopt API
     *  @deprecated Since v1.10
     *
     *  @example
     *    $(document).ready(function() {
     *      var oTable = $('#example').dataTable();
     *
     *      // Re-draw the table - you wouldn't want to do it here, but it's an example :-)
     *      oTable.fnDraw();
     *    } );
     */
    this.fnDraw = function( complete )
    {
      // Note that this isn't an exact match to the old call to _fnDraw - it takes
      // into account the new data, but can hold position.
      this.api( true ).draw( complete );
    };


    /**
     * Filter the input based on data
     *  @param {string} sInput String to filter the table on
     *  @param {int|null} [iColumn] Column to limit filtering to
     *  @param {bool} [bRegex=false] Treat as regular expression or not
     *  @param {bool} [bSmart=true] Perform smart filtering or not
     *  @param {bool} [bShowGlobal=true] Show the input global filter in it's input box(es)
     *  @param {bool} [bCaseInsensitive=true] Do case-insensitive matching (true) or not (false)
     *  @dtopt API
     *  @deprecated Since v1.10
     *
     *  @example
     *    $(document).ready(function() {
     *      var oTable = $('#example').dataTable();
     *
     *      // Sometime later - filter...
     *      oTable.fnFilter( 'test string' );
     *    } );
     */
    this.fnFilter = function( sInput, iColumn, bRegex, bSmart, bShowGlobal, bCaseInsensitive )
    {
      var api = this.api( true );

      if ( iColumn === null || iColumn === undefined ) {
        api.search( sInput, bRegex, bSmart, bCaseInsensitive );
      }
      else {
        api.column( iColumn ).search( sInput, bRegex, bSmart, bCaseInsensitive );
      }

      api.draw();
    };


    /**
     * Get the data for the whole table, an individual row or an individual cell based on the
     * provided parameters.
     *  @param {int|node} [src] A TR row node, TD/TH cell node or an integer. If given as
     *    a TR node then the data source for the whole row will be returned. If given as a
     *    TD/TH cell node then iCol will be automatically calculated and the data for the
     *    cell returned. If given as an integer, then this is treated as the aoData internal
     *    data index for the row (see fnGetPosition) and the data for that row used.
     *  @param {int} [col] Optional column index that you want the data of.
     *  @returns {array|object|string} If mRow is undefined, then the data for all rows is
     *    returned. If mRow is defined, just data for that row, and is iCol is
     *    defined, only data for the designated cell is returned.
     *  @dtopt API
     *  @deprecated Since v1.10
     *
     *  @example
     *    // Row data
     *    $(document).ready(function() {
     *      oTable = $('#example').dataTable();
     *
     *      oTable.$('tr').click( function () {
     *        var data = oTable.fnGetData( this );
     *        // ... do something with the array / object of data for the row
     *      } );
     *    } );
     *
     *  @example
     *    // Individual cell data
     *    $(document).ready(function() {
     *      oTable = $('#example').dataTable();
     *
     *      oTable.$('td').click( function () {
     *        var sData = oTable.fnGetData( this );
     *        alert( 'The cell clicked on had the value of '+sData );
     *      } );
     *    } );
     */
    this.fnGetData = function( src, col )
    {
      var api = this.api( true );

      if ( src !== undefined ) {
        var type = src.nodeName ? src.nodeName.toLowerCase() : '';

        return col !== undefined || type == 'td' || type == 'th' ?
          api.cell( src, col ).data() :
          api.row( src ).data() || null;
      }

      return api.data().toArray();
    };


    /**
     * Get an array of the TR nodes that are used in the table's body. Note that you will
     * typically want to use the '$' API method in preference to this as it is more
     * flexible.
     *  @param {int} [iRow] Optional row index for the TR element you want
     *  @returns {array|node} If iRow is undefined, returns an array of all TR elements
     *    in the table's body, or iRow is defined, just the TR element requested.
     *  @dtopt API
     *  @deprecated Since v1.10
     *
     *  @example
     *    $(document).ready(function() {
     *      var oTable = $('#example').dataTable();
     *
     *      // Get the nodes from the table
     *      var nNodes = oTable.fnGetNodes( );
     *    } );
     */
    this.fnGetNodes = function( iRow )
    {
      var api = this.api( true );

      return iRow !== undefined ?
        api.row( iRow ).node() :
        api.rows().nodes().flatten().toArray();
    };


    /**
     * Get the array indexes of a particular cell from it's DOM element
     * and column index including hidden columns
     *  @param {node} node this can either be a TR, TD or TH in the table's body
     *  @returns {int} If nNode is given as a TR, then a single index is returned, or
     *    if given as a cell, an array of [row index, column index (visible),
     *    column index (all)] is given.
     *  @dtopt API
     *  @deprecated Since v1.10
     *
     *  @example
     *    $(document).ready(function() {
     *      $('#example tbody td').click( function () {
     *        // Get the position of the current data from the node
     *        var aPos = oTable.fnGetPosition( this );
     *
     *        // Get the data array for this row
     *        var aData = oTable.fnGetData( aPos[0] );
     *
     *        // Update the data array and return the value
     *        aData[ aPos[1] ] = 'clicked';
     *        this.innerHTML = 'clicked';
     *      } );
     *
     *      // Init DataTables
     *      oTable = $('#example').dataTable();
     *    } );
     */
    this.fnGetPosition = function( node )
    {
      var api = this.api( true );
      var nodeName = node.nodeName.toUpperCase();

      if ( nodeName == 'TR' ) {
        return api.row( node ).index();
      }
      else if ( nodeName == 'TD' || nodeName == 'TH' ) {
        var cell = api.cell( node ).index();

        return [
          cell.row,
          cell.columnVisible,
          cell.column
        ];
      }
      return null;
    };


    /**
     * Check to see if a row is 'open' or not.
     *  @param {node} nTr the table row to check
     *  @returns {boolean} true if the row is currently open, false otherwise
     *  @dtopt API
     *  @deprecated Since v1.10
     *
     *  @example
     *    $(document).ready(function() {
     *      var oTable;
     *
     *      // 'open' an information row when a row is clicked on
     *      $('#example tbody tr').click( function () {
     *        if ( oTable.fnIsOpen(this) ) {
     *          oTable.fnClose( this );
     *        } else {
     *          oTable.fnOpen( this, "Temporary row opened", "info_row" );
     *        }
     *      } );
     *
     *      oTable = $('#example').dataTable();
     *    } );
     */
    this.fnIsOpen = function( nTr )
    {
      return this.api( true ).row( nTr ).child.isShown();
    };


    /**
     * This function will place a new row directly after a row which is currently
     * on display on the page, with the HTML contents that is passed into the
     * function. This can be used, for example, to ask for confirmation that a
     * particular record should be deleted.
     *  @param {node} nTr The table row to 'open'
     *  @param {string|node|jQuery} mHtml The HTML to put into the row
     *  @param {string} sClass Class to give the new TD cell
     *  @returns {node} The row opened. Note that if the table row passed in as the
     *    first parameter, is not found in the table, this method will silently
     *    return.
     *  @dtopt API
     *  @deprecated Since v1.10
     *
     *  @example
     *    $(document).ready(function() {
     *      var oTable;
     *
     *      // 'open' an information row when a row is clicked on
     *      $('#example tbody tr').click( function () {
     *        if ( oTable.fnIsOpen(this) ) {
     *          oTable.fnClose( this );
     *        } else {
     *          oTable.fnOpen( this, "Temporary row opened", "info_row" );
     *        }
     *      } );
     *
     *      oTable = $('#example').dataTable();
     *    } );
     */
    this.fnOpen = function( nTr, mHtml, sClass )
    {
      return this.api( true )
        .row( nTr )
        .child( mHtml, sClass )
        .show()
        .child()[0];
    };


    /**
     * Change the pagination - provides the internal logic for pagination in a simple API
     * function. With this function you can have a DataTables table go to the next,
     * previous, first or last pages.
     *  @param {string|int} mAction Paging action to take: "first", "previous", "next" or "last"
     *    or page number to jump to (integer), note that page 0 is the first page.
     *  @param {bool} [bRedraw=true] Redraw the table or not
     *  @dtopt API
     *  @deprecated Since v1.10
     *
     *  @example
     *    $(document).ready(function() {
     *      var oTable = $('#example').dataTable();
     *      oTable.fnPageChange( 'next' );
     *    } );
     */
    this.fnPageChange = function ( mAction, bRedraw )
    {
      var api = this.api( true ).page( mAction );

      if ( bRedraw === undefined || bRedraw ) {
        api.draw(false);
      }
    };


    /**
     * Show a particular column
     *  @param {int} iCol The column whose display should be changed
     *  @param {bool} bShow Show (true) or hide (false) the column
     *  @param {bool} [bRedraw=true] Redraw the table or not
     *  @dtopt API
     *  @deprecated Since v1.10
     *
     *  @example
     *    $(document).ready(function() {
     *      var oTable = $('#example').dataTable();
     *
     *      // Hide the second column after initialisation
     *      oTable.fnSetColumnVis( 1, false );
     *    } );
     */
    this.fnSetColumnVis = function ( iCol, bShow, bRedraw )
    {
      var api = this.api( true ).column( iCol ).visible( bShow );

      if ( bRedraw === undefined || bRedraw ) {
        api.columns.adjust().draw();
      }
    };


    /**
     * Get the settings for a particular table for external manipulation
     *  @returns {object} DataTables settings object. See
     *    {@link DataTable.models.oSettings}
     *  @dtopt API
     *  @deprecated Since v1.10
     *
     *  @example
     *    $(document).ready(function() {
     *      var oTable = $('#example').dataTable();
     *      var oSettings = oTable.fnSettings();
     *
     *      // Show an example parameter from the settings
     *      alert( oSettings._iDisplayStart );
     *    } );
     */
    this.fnSettings = function()
    {
      return _fnSettingsFromNode( this[_ext.iApiIndex] );
    };


    /**
     * Sort the table by a particular column
     *  @param {int} iCol the data index to sort on. Note that this will not match the
     *    'display index' if you have hidden data entries
     *  @dtopt API
     *  @deprecated Since v1.10
     *
     *  @example
     *    $(document).ready(function() {
     *      var oTable = $('#example').dataTable();
     *
     *      // Sort immediately with columns 0 and 1
     *      oTable.fnSort( [ [0,'asc'], [1,'asc'] ] );
     *    } );
     */
    this.fnSort = function( aaSort )
    {
      this.api( true ).order( aaSort ).draw();
    };


    /**
     * Attach a sort listener to an element for a given column
     *  @param {node} nNode the element to attach the sort listener to
     *  @param {int} iColumn the column that a click on this node will sort on
     *  @param {function} [fnCallback] callback function when sort is run
     *  @dtopt API
     *  @deprecated Since v1.10
     *
     *  @example
     *    $(document).ready(function() {
     *      var oTable = $('#example').dataTable();
     *
     *      // Sort on column 1, when 'sorter' is clicked on
     *      oTable.fnSortListener( document.getElementById('sorter'), 1 );
     *    } );
     */
    this.fnSortListener = function( nNode, iColumn, fnCallback )
    {
      this.api( true ).order.listener( nNode, iColumn, fnCallback );
    };


    /**
     * Update a table cell or row - this method will accept either a single value to
     * update the cell with, an array of values with one element for each column or
     * an object in the same format as the original data source. The function is
     * self-referencing in order to make the multi column updates easier.
     *  @param {object|array|string} mData Data to update the cell/row with
     *  @param {node|int} mRow TR element you want to update or the aoData index
     *  @param {int} [iColumn] The column to update, give as null or undefined to
     *    update a whole row.
     *  @param {bool} [bRedraw=true] Redraw the table or not
     *  @param {bool} [bAction=true] Perform pre-draw actions or not
     *  @returns {int} 0 on success, 1 on error
     *  @dtopt API
     *  @deprecated Since v1.10
     *
     *  @example
     *    $(document).ready(function() {
     *      var oTable = $('#example').dataTable();
     *      oTable.fnUpdate( 'Example update', 0, 0 ); // Single cell
     *      oTable.fnUpdate( ['a', 'b', 'c', 'd', 'e'], $('tbody tr')[0] ); // Row
     *    } );
     */
    this.fnUpdate = function( mData, mRow, iColumn, bRedraw, bAction )
    {
      var api = this.api( true );

      if ( iColumn === undefined || iColumn === null ) {
        api.row( mRow ).data( mData );
      }
      else {
        api.cell( mRow, iColumn ).data( mData );
      }

      if ( bAction === undefined || bAction ) {
        api.columns.adjust();
      }

      if ( bRedraw === undefined || bRedraw ) {
        api.draw();
      }
      return 0;
    };


    /**
     * Provide a common method for plug-ins to check the version of DataTables being used, in order
     * to ensure compatibility.
     *  @param {string} sVersion Version string to check for, in the format "X.Y.Z". Note that the
     *    formats "X" and "X.Y" are also acceptable.
     *  @returns {boolean} true if this version of DataTables is greater or equal to the required
     *    version, or false if this version of DataTales is not suitable
     *  @method
     *  @dtopt API
     *  @deprecated Since v1.10
     *
     *  @example
     *    $(document).ready(function() {
     *      var oTable = $('#example').dataTable();
     *      alert( oTable.fnVersionCheck( '1.9.0' ) );
     *    } );
     */
    this.fnVersionCheck = _ext.fnVersionCheck;


    var _that = this;
    var emptyInit = options === undefined;
    var len = this.length;

    if ( emptyInit ) {
      options = {};
    }

    this.oApi = this.internal = _ext.internal;

    // Extend with old style plug-in API methods
    for ( var fn in DataTable.ext.internal ) {
      if ( fn ) {
        this[fn] = _fnExternApiFunc(fn);
      }
    }

    this.each(function() {
      // For each initialisation we want to give it a clean initialisation
      // object that can be bashed around
      var o = {};
      var oInit = len > 1 ? // optimisation for single table case
        _fnExtend( o, options, true ) :
        options;

      /*global oInit,_that,emptyInit*/
      var i=0, iLen, j, jLen, k, kLen;
      var sId = this.getAttribute( 'id' );
      var bInitHandedOff = false;
      var defaults = DataTable.defaults;
      var $this = $(this);


      /* Sanity check */
      if ( this.nodeName.toLowerCase() != 'table' )
      {
        _fnLog( null, 0, 'Non-table node initialisation ('+this.nodeName+')', 2 );
        return;
      }

      /* Backwards compatibility for the defaults */
      _fnCompatOpts( defaults );
      _fnCompatCols( defaults.column );

      /* Convert the camel-case defaults to Hungarian */
      _fnCamelToHungarian( defaults, defaults, true );
      _fnCamelToHungarian( defaults.column, defaults.column, true );

      /* Setting up the initialisation object */
      _fnCamelToHungarian( defaults, $.extend( oInit, $this.data() ) );



      /* Check to see if we are re-initialising a table */
      var allSettings = DataTable.settings;
      for ( i=0, iLen=allSettings.length ; i<iLen ; i++ )
      {
        var s = allSettings[i];

        /* Base check on table node */
        if ( s.nTable == this || s.nTHead.parentNode == this || (s.nTFoot && s.nTFoot.parentNode == this) )
        {
          var bRetrieve = oInit.bRetrieve !== undefined ? oInit.bRetrieve : defaults.bRetrieve;
          var bDestroy = oInit.bDestroy !== undefined ? oInit.bDestroy : defaults.bDestroy;

          if ( emptyInit || bRetrieve )
          {
            return s.oInstance;
          }
          else if ( bDestroy )
          {
            s.oInstance.fnDestroy();
            break;
          }
          else
          {
            _fnLog( s, 0, 'Cannot reinitialise DataTable', 3 );
            return;
          }
        }

        /* If the element we are initialising has the same ID as a table which was previously
         * initialised, but the table nodes don't match (from before) then we destroy the old
         * instance by simply deleting it. This is under the assumption that the table has been
         * destroyed by other methods. Anyone using non-id selectors will need to do this manually
         */
        if ( s.sTableId == this.id )
        {
          allSettings.splice( i, 1 );
          break;
        }
      }

      /* Ensure the table has an ID - required for accessibility */
      if ( sId === null || sId === "" )
      {
        sId = "DataTables_Table_"+(DataTable.ext._unique++);
        this.id = sId;
      }

      /* Create the settings object for this table and set some of the default parameters */
      var oSettings = $.extend( true, {}, DataTable.models.oSettings, {
        "sDestroyWidth": $this[0].style.width,
        "sInstance":     sId,
        "sTableId":      sId
      } );
      oSettings.nTable = this;
      oSettings.oApi   = _that.internal;
      oSettings.oInit  = oInit;

      allSettings.push( oSettings );

      // Need to add the instance after the instance after the settings object has been added
      // to the settings array, so we can self reference the table instance if more than one
      oSettings.oInstance = (_that.length===1) ? _that : $this.dataTable();

      // Backwards compatibility, before we apply all the defaults
      _fnCompatOpts( oInit );

      if ( oInit.oLanguage )
      {
        _fnLanguageCompat( oInit.oLanguage );
      }

      // If the length menu is given, but the init display length is not, use the length menu
      if ( oInit.aLengthMenu && ! oInit.iDisplayLength )
      {
        oInit.iDisplayLength = $.isArray( oInit.aLengthMenu[0] ) ?
          oInit.aLengthMenu[0][0] : oInit.aLengthMenu[0];
      }

      // Apply the defaults and init options to make a single init object will all
      // options defined from defaults and instance options.
      oInit = _fnExtend( $.extend( true, {}, defaults ), oInit );


      // Map the initialisation options onto the settings object
      _fnMap( oSettings.oFeatures, oInit, [
        "bPaginate",
        "bLengthChange",
        "bFilter",
        "bSort",
        "bSortMulti",
        "bInfo",
        "bProcessing",
        "bAutoWidth",
        "bSortClasses",
        "bServerSide",
        "bDeferRender"
      ] );
      _fnMap( oSettings, oInit, [
        "asStripeClasses",
        "ajax",
        "fnServerData",
        "fnFormatNumber",
        "sServerMethod",
        "aaSorting",
        "aaSortingFixed",
        "aLengthMenu",
        "sPaginationType",
        "sAjaxSource",
        "sAjaxDataProp",
        "iStateDuration",
        "sDom",
        "bSortCellsTop",
        "iTabIndex",
        "fnStateLoadCallback",
        "fnStateSaveCallback",
        "renderer",
        "searchDelay",
        "rowId",
        [ "iCookieDuration", "iStateDuration" ], // backwards compat
        [ "oSearch", "oPreviousSearch" ],
        [ "aoSearchCols", "aoPreSearchCols" ],
        [ "iDisplayLength", "_iDisplayLength" ]
      ] );
      _fnMap( oSettings.oScroll, oInit, [
        [ "sScrollX", "sX" ],
        [ "sScrollXInner", "sXInner" ],
        [ "sScrollY", "sY" ],
        [ "bScrollCollapse", "bCollapse" ]
      ] );
      _fnMap( oSettings.oLanguage, oInit, "fnInfoCallback" );

      /* Callback functions which are array driven */
      _fnCallbackReg( oSettings, 'aoDrawCallback',       oInit.fnDrawCallback,      'user' );
      _fnCallbackReg( oSettings, 'aoServerParams',       oInit.fnServerParams,      'user' );
      _fnCallbackReg( oSettings, 'aoStateSaveParams',    oInit.fnStateSaveParams,   'user' );
      _fnCallbackReg( oSettings, 'aoStateLoadParams',    oInit.fnStateLoadParams,   'user' );
      _fnCallbackReg( oSettings, 'aoStateLoaded',        oInit.fnStateLoaded,       'user' );
      _fnCallbackReg( oSettings, 'aoRowCallback',        oInit.fnRowCallback,       'user' );
      _fnCallbackReg( oSettings, 'aoRowCreatedCallback', oInit.fnCreatedRow,        'user' );
      _fnCallbackReg( oSettings, 'aoHeaderCallback',     oInit.fnHeaderCallback,    'user' );
      _fnCallbackReg( oSettings, 'aoFooterCallback',     oInit.fnFooterCallback,    'user' );
      _fnCallbackReg( oSettings, 'aoInitComplete',       oInit.fnInitComplete,      'user' );
      _fnCallbackReg( oSettings, 'aoPreDrawCallback',    oInit.fnPreDrawCallback,   'user' );

      oSettings.rowIdFn = _fnGetObjectDataFn( oInit.rowId );

      /* Browser support detection */
      _fnBrowserDetect( oSettings );

      var oClasses = oSettings.oClasses;

      $.extend( oClasses, DataTable.ext.classes, oInit.oClasses );
      $this.addClass( oClasses.sTable );


      if ( oSettings.iInitDisplayStart === undefined )
      {
        /* Display start point, taking into account the save saving */
        oSettings.iInitDisplayStart = oInit.iDisplayStart;
        oSettings._iDisplayStart = oInit.iDisplayStart;
      }

      if ( oInit.iDeferLoading !== null )
      {
        oSettings.bDeferLoading = true;
        var tmp = $.isArray( oInit.iDeferLoading );
        oSettings._iRecordsDisplay = tmp ? oInit.iDeferLoading[0] : oInit.iDeferLoading;
        oSettings._iRecordsTotal = tmp ? oInit.iDeferLoading[1] : oInit.iDeferLoading;
      }

      /* Language definitions */
      var oLanguage = oSettings.oLanguage;
      $.extend( true, oLanguage, oInit.oLanguage );

      if ( oLanguage.sUrl )
      {
        /* Get the language definitions from a file - because this Ajax call makes the language
         * get async to the remainder of this function we use bInitHandedOff to indicate that
         * _fnInitialise will be fired by the returned Ajax handler, rather than the constructor
         */
        $.ajax( {
          dataType: 'json',
          url: oLanguage.sUrl,
          success: function ( json ) {
            _fnLanguageCompat( json );
            _fnCamelToHungarian( defaults.oLanguage, json );
            $.extend( true, oLanguage, json );
            _fnInitialise( oSettings );
          },
          error: function () {
            // Error occurred loading language file, continue on as best we can
            _fnInitialise( oSettings );
          }
        } );
        bInitHandedOff = true;
      }

      /*
       * Stripes
       */
      if ( oInit.asStripeClasses === null )
      {
        oSettings.asStripeClasses =[
          oClasses.sStripeOdd,
          oClasses.sStripeEven
        ];
      }

      /* Remove row stripe classes if they are already on the table row */
      var stripeClasses = oSettings.asStripeClasses;
      var rowOne = $this.children('tbody').find('tr').eq(0);
      if ( $.inArray( true, $.map( stripeClasses, function(el, i) {
        return rowOne.hasClass(el);
      } ) ) !== -1 ) {
        $('tbody tr', this).removeClass( stripeClasses.join(' ') );
        oSettings.asDestroyStripes = stripeClasses.slice();
      }

      /*
       * Columns
       * See if we should load columns automatically or use defined ones
       */
      var anThs = [];
      var aoColumnsInit;
      var nThead = this.getElementsByTagName('thead');
      if ( nThead.length !== 0 )
      {
        _fnDetectHeader( oSettings.aoHeader, nThead[0] );
        anThs = _fnGetUniqueThs( oSettings );
      }

      /* If not given a column array, generate one with nulls */
      if ( oInit.aoColumns === null )
      {
        aoColumnsInit = [];
        for ( i=0, iLen=anThs.length ; i<iLen ; i++ )
        {
          aoColumnsInit.push( null );
        }
      }
      else
      {
        aoColumnsInit = oInit.aoColumns;
      }

      /* Add the columns */
      for ( i=0, iLen=aoColumnsInit.length ; i<iLen ; i++ )
      {
        _fnAddColumn( oSettings, anThs ? anThs[i] : null );
      }

      /* Apply the column definitions */
      _fnApplyColumnDefs( oSettings, oInit.aoColumnDefs, aoColumnsInit, function (iCol, oDef) {
        _fnColumnOptions( oSettings, iCol, oDef );
      } );

      /* HTML5 attribute detection - build an mData object automatically if the
       * attributes are found
       */
      if ( rowOne.length ) {
        var a = function ( cell, name ) {
          return cell.getAttribute( 'data-'+name ) !== null ? name : null;
        };

        $( rowOne[0] ).children('th, td').each( function (i, cell) {
          var col = oSettings.aoColumns[i];

          if ( col.mData === i ) {
            var sort = a( cell, 'sort' ) || a( cell, 'order' );
            var filter = a( cell, 'filter' ) || a( cell, 'search' );

            if ( sort !== null || filter !== null ) {
              col.mData = {
                _:      i+'.display',
                sort:   sort !== null   ? i+'.@data-'+sort   : undefined,
                type:   sort !== null   ? i+'.@data-'+sort   : undefined,
                filter: filter !== null ? i+'.@data-'+filter : undefined
              };

              _fnColumnOptions( oSettings, i );
            }
          }
        } );
      }

      var features = oSettings.oFeatures;
      var loadedInit = function () {
        /*
         * Sorting
         * @todo For modularisation (1.11) this needs to do into a sort start up handler
         */

        // If aaSorting is not defined, then we use the first indicator in asSorting
        // in case that has been altered, so the default sort reflects that option
        if ( oInit.aaSorting === undefined ) {
          var sorting = oSettings.aaSorting;
          for ( i=0, iLen=sorting.length ; i<iLen ; i++ ) {
            sorting[i][1] = oSettings.aoColumns[ i ].asSorting[0];
          }
        }

        /* Do a first pass on the sorting classes (allows any size changes to be taken into
         * account, and also will apply sorting disabled classes if disabled
         */
        _fnSortingClasses( oSettings );

        if ( features.bSort ) {
          _fnCallbackReg( oSettings, 'aoDrawCallback', function () {
            if ( oSettings.bSorted ) {
              var aSort = _fnSortFlatten( oSettings );
              var sortedColumns = {};

              $.each( aSort, function (i, val) {
                sortedColumns[ val.src ] = val.dir;
              } );

              _fnCallbackFire( oSettings, null, 'order', [oSettings, aSort, sortedColumns] );
              _fnSortAria( oSettings );
            }
          } );
        }

        _fnCallbackReg( oSettings, 'aoDrawCallback', function () {
          if ( oSettings.bSorted || _fnDataSource( oSettings ) === 'ssp' || features.bDeferRender ) {
            _fnSortingClasses( oSettings );
          }
        }, 'sc' );


        /*
         * Final init
         * Cache the header, body and footer as required, creating them if needed
         */

        // Work around for Webkit bug 83867 - store the caption-side before removing from doc
        var captions = $this.children('caption').each( function () {
          this._captionSide = $(this).css('caption-side');
        } );

        var thead = $this.children('thead');
        if ( thead.length === 0 ) {
          thead = $('<thead/>').appendTo($this);
        }
        oSettings.nTHead = thead[0];

        var tbody = $this.children('tbody');
        if ( tbody.length === 0 ) {
          tbody = $('<tbody/>').appendTo($this);
        }
        oSettings.nTBody = tbody[0];

        var tfoot = $this.children('tfoot');
        if ( tfoot.length === 0 && captions.length > 0 && (oSettings.oScroll.sX !== "" || oSettings.oScroll.sY !== "") ) {
          // If we are a scrolling table, and no footer has been given, then we need to create
          // a tfoot element for the caption element to be appended to
          tfoot = $('<tfoot/>').appendTo($this);
        }

        if ( tfoot.length === 0 || tfoot.children().length === 0 ) {
          $this.addClass( oClasses.sNoFooter );
        }
        else if ( tfoot.length > 0 ) {
          oSettings.nTFoot = tfoot[0];
          _fnDetectHeader( oSettings.aoFooter, oSettings.nTFoot );
        }

        /* Check if there is data passing into the constructor */
        if ( oInit.aaData ) {
          for ( i=0 ; i<oInit.aaData.length ; i++ ) {
            _fnAddData( oSettings, oInit.aaData[ i ] );
          }
        }
        else if ( oSettings.bDeferLoading || _fnDataSource( oSettings ) == 'dom' ) {
          /* Grab the data from the page - only do this when deferred loading or no Ajax
           * source since there is no point in reading the DOM data if we are then going
           * to replace it with Ajax data
           */
          _fnAddTr( oSettings, $(oSettings.nTBody).children('tr') );
        }

        /* Copy the data index array */
        oSettings.aiDisplay = oSettings.aiDisplayMaster.slice();

        /* Initialisation complete - table can be drawn */
        oSettings.bInitialised = true;

        /* Check if we need to initialise the table (it might not have been handed off to the
         * language processor)
         */
        if ( bInitHandedOff === false ) {
          _fnInitialise( oSettings );
        }
      };

      /* Must be done after everything which can be overridden by the state saving! */
      if ( oInit.bStateSave )
      {
        features.bStateSave = true;
        _fnCallbackReg( oSettings, 'aoDrawCallback', _fnSaveState, 'state_save' );
        _fnLoadState( oSettings, oInit, loadedInit );
      }
      else {
        loadedInit();
      }

    } );
    _that = null;
    return this;
  };


  /*
   * It is useful to have variables which are scoped locally so only the
   * DataTables functions can access them and they don't leak into global space.
   * At the same time these functions are often useful over multiple files in the
   * core and API, so we list, or at least document, all variables which are used
   * by DataTables as private variables here. This also ensures that there is no
   * clashing of variable names and that they can easily referenced for reuse.
   */


  // Defined else where
  //  _selector_run
  //  _selector_opts
  //  _selector_first
  //  _selector_row_indexes

  var _ext; // DataTable.ext
  var _Api; // DataTable.Api
  var _api_register; // DataTable.Api.register
  var _api_registerPlural; // DataTable.Api.registerPlural

  var _re_dic = {};
  var _re_new_lines = /[\r\n]/g;
  var _re_html = /<.*?>/g;

  // This is not strict ISO8601 - Date.parse() is quite lax, although
  // implementations differ between browsers.
  var _re_date = /^\d{2,4}[\.\/\-]\d{1,2}[\.\/\-]\d{1,2}([T ]{1}\d{1,2}[:\.]\d{2}([\.:]\d{2})?)?$/;

  // Escape regular expression special characters
  var _re_escape_regex = new RegExp( '(\\' + [ '/', '.', '*', '+', '?', '|', '(', ')', '[', ']', '{', '}', '\\', '$', '^', '-' ].join('|\\') + ')', 'g' );

  // http://en.wikipedia.org/wiki/Foreign_exchange_market
  // - \u20BD - Russian ruble.
  // - \u20a9 - South Korean Won
  // - \u20BA - Turkish Lira
  // - \u20B9 - Indian Rupee
  // - R - Brazil (R$) and South Africa
  // - fr - Swiss Franc
  // - kr - Swedish krona, Norwegian krone and Danish krone
  // - \u2009 is thin space and \u202F is narrow no-break space, both used in many
  //   standards as thousands separators.
  var _re_formatted_numeric = /[',$Â£â¬Â¥%\u2009\u202F\u20BD\u20a9\u20BArfk]/gi;


  var _empty = function ( d ) {
    return !d || d === true || d === '-' ? true : false;
  };


  var _intVal = function ( s ) {
    var integer = parseInt( s, 10 );
    return !isNaN(integer) && isFinite(s) ? integer : null;
  };

  // Convert from a formatted number with characters other than `.` as the
  // decimal place, to a Javascript number
  var _numToDecimal = function ( num, decimalPoint ) {
    // Cache created regular expressions for speed as this function is called often
    if ( ! _re_dic[ decimalPoint ] ) {
      _re_dic[ decimalPoint ] = new RegExp( _fnEscapeRegex( decimalPoint ), 'g' );
    }
    return typeof num === 'string' && decimalPoint !== '.' ?
      num.replace( /\./g, '' ).replace( _re_dic[ decimalPoint ], '.' ) :
      num;
  };


  var _isNumber = function ( d, decimalPoint, formatted ) {
    var strType = typeof d === 'string';

    // If empty return immediately so there must be a number if it is a
    // formatted string (this stops the string "k", or "kr", etc being detected
    // as a formatted number for currency
    if ( _empty( d ) ) {
      return true;
    }

    if ( decimalPoint && strType ) {
      d = _numToDecimal( d, decimalPoint );
    }

    if ( formatted && strType ) {
      d = d.replace( _re_formatted_numeric, '' );
    }

    return !isNaN( parseFloat(d) ) && isFinite( d );
  };


  // A string without HTML in it can be considered to be HTML still
  var _isHtml = function ( d ) {
    return _empty( d ) || typeof d === 'string';
  };


  var _htmlNumeric = function ( d, decimalPoint, formatted ) {
    if ( _empty( d ) ) {
      return true;
    }

    var html = _isHtml( d );
    return ! html ?
      null :
      _isNumber( _stripHtml( d ), decimalPoint, formatted ) ?
        true :
        null;
  };


  var _pluck = function ( a, prop, prop2 ) {
    var out = [];
    var i=0, ien=a.length;

    // Could have the test in the loop for slightly smaller code, but speed
    // is essential here
    if ( prop2 !== undefined ) {
      for ( ; i<ien ; i++ ) {
        if ( a[i] && a[i][ prop ] ) {
          out.push( a[i][ prop ][ prop2 ] );
        }
      }
    }
    else {
      for ( ; i<ien ; i++ ) {
        if ( a[i] ) {
          out.push( a[i][ prop ] );
        }
      }
    }

    return out;
  };


  // Basically the same as _pluck, but rather than looping over `a` we use `order`
  // as the indexes to pick from `a`
  var _pluck_order = function ( a, order, prop, prop2 )
  {
    var out = [];
    var i=0, ien=order.length;

    // Could have the test in the loop for slightly smaller code, but speed
    // is essential here
    if ( prop2 !== undefined ) {
      for ( ; i<ien ; i++ ) {
        if ( a[ order[i] ][ prop ] ) {
          out.push( a[ order[i] ][ prop ][ prop2 ] );
        }
      }
    }
    else {
      for ( ; i<ien ; i++ ) {
        out.push( a[ order[i] ][ prop ] );
      }
    }

    return out;
  };


  var _range = function ( len, start )
  {
    var out = [];
    var end;

    if ( start === undefined ) {
      start = 0;
      end = len;
    }
    else {
      end = start;
      start = len;
    }

    for ( var i=start ; i<end ; i++ ) {
      out.push( i );
    }

    return out;
  };


  var _removeEmpty = function ( a )
  {
    var out = [];

    for ( var i=0, ien=a.length ; i<ien ; i++ ) {
      if ( a[i] ) { // careful - will remove all falsy values!
        out.push( a[i] );
      }
    }

    return out;
  };


  var _stripHtml = function ( d ) {
    return d.replace( _re_html, '' );
  };


  /**
   * Determine if all values in the array are unique. This means we can short
   * cut the _unique method at the cost of a single loop. A sorted array is used
   * to easily check the values.
   *
   * @param  {array} src Source array
   * @return {boolean} true if all unique, false otherwise
   * @ignore
   */
  var _areAllUnique = function ( src ) {
    if ( src.length < 2 ) {
      return true;
    }

    var sorted = src.slice().sort();
    var last = sorted[0];

    for ( var i=1, ien=sorted.length ; i<ien ; i++ ) {
      if ( sorted[i] === last ) {
        return false;
      }

      last = sorted[i];
    }

    return true;
  };


  /**
   * Find the unique elements in a source array.
   *
   * @param  {array} src Source array
   * @return {array} Array of unique items
   * @ignore
   */
  var _unique = function ( src )
  {
    if ( _areAllUnique( src ) ) {
      return src.slice();
    }

    // A faster unique method is to use object keys to identify used values,
    // but this doesn't work with arrays or objects, which we must also
    // consider. See jsperf.com/compare-array-unique-versions/4 for more
    // information.
    var
      out = [],
      val,
      i, ien=src.length,
      j, k=0;

    again: for ( i=0 ; i<ien ; i++ ) {
      val = src[i];

      for ( j=0 ; j<k ; j++ ) {
        if ( out[j] === val ) {
          continue again;
        }
      }

      out.push( val );
      k++;
    }

    return out;
  };


  /**
   * DataTables utility methods
   *
   * This namespace provides helper methods that DataTables uses internally to
   * create a DataTable, but which are not exclusively used only for DataTables.
   * These methods can be used by extension authors to save the duplication of
   * code.
   *
   *  @namespace
   */
  DataTable.util = {
    /**
     * Throttle the calls to a function. Arguments and context are maintained
     * for the throttled function.
     *
     * @param {function} fn Function to be called
     * @param {integer} freq Call frequency in mS
     * @return {function} Wrapped function
     */
    throttle: function ( fn, freq ) {
      var
        frequency = freq !== undefined ? freq : 200,
        last,
        timer;

      return function () {
        var
          that = this,
          now  = +new Date(),
          args = arguments;

        if ( last && now < last + frequency ) {
          clearTimeout( timer );

          timer = setTimeout( function () {
            last = undefined;
            fn.apply( that, args );
          }, frequency );
        }
        else {
          last = now;
          fn.apply( that, args );
        }
      };
    },


    /**
     * Escape a string such that it can be used in a regular expression
     *
     *  @param {string} val string to escape
     *  @returns {string} escaped string
     */
    escapeRegex: function ( val ) {
      return val.replace( _re_escape_regex, '\\$1' );
    }
  };



  /**
   * Create a mapping object that allows camel case parameters to be looked up
   * for their Hungarian counterparts. The mapping is stored in a private
   * parameter called `_hungarianMap` which can be accessed on the source object.
   *  @param {object} o
   *  @memberof DataTable#oApi
   */
  function _fnHungarianMap ( o )
  {
    var
      hungarian = 'a aa ai ao as b fn i m o s ',
      match,
      newKey,
      map = {};

    $.each( o, function (key, val) {
      match = key.match(/^([^A-Z]+?)([A-Z])/);

      if ( match && hungarian.indexOf(match[1]+' ') !== -1 )
      {
        newKey = key.replace( match[0], match[2].toLowerCase() );
        map[ newKey ] = key;

        if ( match[1] === 'o' )
        {
          _fnHungarianMap( o[key] );
        }
      }
    } );

    o._hungarianMap = map;
  }


  /**
   * Convert from camel case parameters to Hungarian, based on a Hungarian map
   * created by _fnHungarianMap.
   *  @param {object} src The model object which holds all parameters that can be
   *    mapped.
   *  @param {object} user The object to convert from camel case to Hungarian.
   *  @param {boolean} force When set to `true`, properties which already have a
   *    Hungarian value in the `user` object will be overwritten. Otherwise they
   *    won't be.
   *  @memberof DataTable#oApi
   */
  function _fnCamelToHungarian ( src, user, force )
  {
    if ( ! src._hungarianMap ) {
      _fnHungarianMap( src );
    }

    var hungarianKey;

    $.each( user, function (key, val) {
      hungarianKey = src._hungarianMap[ key ];

      if ( hungarianKey !== undefined && (force || user[hungarianKey] === undefined) )
      {
        // For objects, we need to buzz down into the object to copy parameters
        if ( hungarianKey.charAt(0) === 'o' )
        {
          // Copy the camelCase options over to the hungarian
          if ( ! user[ hungarianKey ] ) {
            user[ hungarianKey ] = {};
          }
          $.extend( true, user[hungarianKey], user[key] );

          _fnCamelToHungarian( src[hungarianKey], user[hungarianKey], force );
        }
        else {
          user[hungarianKey] = user[ key ];
        }
      }
    } );
  }


  /**
   * Language compatibility - when certain options are given, and others aren't, we
   * need to duplicate the values over, in order to provide backwards compatibility
   * with older language files.
   *  @param {object} oSettings dataTables settings object
   *  @memberof DataTable#oApi
   */
  function _fnLanguageCompat( lang )
  {
    var defaults = DataTable.defaults.oLanguage;
    var zeroRecords = lang.sZeroRecords;

    /* Backwards compatibility - if there is no sEmptyTable given, then use the same as
     * sZeroRecords - assuming that is given.
     */
    if ( ! lang.sEmptyTable && zeroRecords &&
      defaults.sEmptyTable === "No data available in table" )
    {
      _fnMap( lang, lang, 'sZeroRecords', 'sEmptyTable' );
    }

    /* Likewise with loading records */
    if ( ! lang.sLoadingRecords && zeroRecords &&
      defaults.sLoadingRecords === "Loading..." )
    {
      _fnMap( lang, lang, 'sZeroRecords', 'sLoadingRecords' );
    }

    // Old parameter name of the thousands separator mapped onto the new
    if ( lang.sInfoThousands ) {
      lang.sThousands = lang.sInfoThousands;
    }

    var decimal = lang.sDecimal;
    if ( decimal ) {
      _addNumericSort( decimal );
    }
  }


  /**
   * Map one parameter onto another
   *  @param {object} o Object to map
   *  @param {*} knew The new parameter name
   *  @param {*} old The old parameter name
   */
  var _fnCompatMap = function ( o, knew, old ) {
    if ( o[ knew ] !== undefined ) {
      o[ old ] = o[ knew ];
    }
  };


  /**
   * Provide backwards compatibility for the main DT options. Note that the new
   * options are mapped onto the old parameters, so this is an external interface
   * change only.
   *  @param {object} init Object to map
   */
  function _fnCompatOpts ( init )
  {
    _fnCompatMap( init, 'ordering',      'bSort' );
    _fnCompatMap( init, 'orderMulti',    'bSortMulti' );
    _fnCompatMap( init, 'orderClasses',  'bSortClasses' );
    _fnCompatMap( init, 'orderCellsTop', 'bSortCellsTop' );
    _fnCompatMap( init, 'order',         'aaSorting' );
    _fnCompatMap( init, 'orderFixed',    'aaSortingFixed' );
    _fnCompatMap( init, 'paging',        'bPaginate' );
    _fnCompatMap( init, 'pagingType',    'sPaginationType' );
    _fnCompatMap( init, 'pageLength',    'iDisplayLength' );
    _fnCompatMap( init, 'searching',     'bFilter' );

    // Boolean initialisation of x-scrolling
    if ( typeof init.sScrollX === 'boolean' ) {
      init.sScrollX = init.sScrollX ? '100%' : '';
    }
    if ( typeof init.scrollX === 'boolean' ) {
      init.scrollX = init.scrollX ? '100%' : '';
    }

    // Column search objects are in an array, so it needs to be converted
    // element by element
    var searchCols = init.aoSearchCols;

    if ( searchCols ) {
      for ( var i=0, ien=searchCols.length ; i<ien ; i++ ) {
        if ( searchCols[i] ) {
          _fnCamelToHungarian( DataTable.models.oSearch, searchCols[i] );
        }
      }
    }
  }


  /**
   * Provide backwards compatibility for column options. Note that the new options
   * are mapped onto the old parameters, so this is an external interface change
   * only.
   *  @param {object} init Object to map
   */
  function _fnCompatCols ( init )
  {
    _fnCompatMap( init, 'orderable',     'bSortable' );
    _fnCompatMap( init, 'orderData',     'aDataSort' );
    _fnCompatMap( init, 'orderSequence', 'asSorting' );
    _fnCompatMap( init, 'orderDataType', 'sortDataType' );

    // orderData can be given as an integer
    var dataSort = init.aDataSort;
    if ( typeof dataSort === 'number' && ! $.isArray( dataSort ) ) {
      init.aDataSort = [ dataSort ];
    }
  }


  /**
   * Browser feature detection for capabilities, quirks
   *  @param {object} settings dataTables settings object
   *  @memberof DataTable#oApi
   */
  function _fnBrowserDetect( settings )
  {
    // We don't need to do this every time DataTables is constructed, the values
    // calculated are specific to the browser and OS configuration which we
    // don't expect to change between initialisations
    if ( ! DataTable.__browser ) {
      var browser = {};
      DataTable.__browser = browser;

      // Scrolling feature / quirks detection
      var n = $('<div/>')
        .css( {
          position: 'fixed',
          top: 0,
          left: $(window).scrollLeft()*-1, // allow for scrolling
          height: 1,
          width: 1,
          overflow: 'hidden'
        } )
        .append(
          $('<div/>')
            .css( {
              position: 'absolute',
              top: 1,
              left: 1,
              width: 100,
              overflow: 'scroll'
            } )
            .append(
              $('<div/>')
                .css( {
                  width: '100%',
                  height: 10
                } )
            )
        )
        .appendTo( 'body' );

      var outer = n.children();
      var inner = outer.children();

      // Numbers below, in order, are:
      // inner.offsetWidth, inner.clientWidth, outer.offsetWidth, outer.clientWidth
      //
      // IE6 XP:                           100 100 100  83
      // IE7 Vista:                        100 100 100  83
      // IE 8+ Windows:                     83  83 100  83
      // Evergreen Windows:                 83  83 100  83
      // Evergreen Mac with scrollbars:     85  85 100  85
      // Evergreen Mac without scrollbars: 100 100 100 100

      // Get scrollbar width
      browser.barWidth = outer[0].offsetWidth - outer[0].clientWidth;

      // IE6/7 will oversize a width 100% element inside a scrolling element, to
      // include the width of the scrollbar, while other browsers ensure the inner
      // element is contained without forcing scrolling
      browser.bScrollOversize = inner[0].offsetWidth === 100 && outer[0].clientWidth !== 100;

      // In rtl text layout, some browsers (most, but not all) will place the
      // scrollbar on the left, rather than the right.
      browser.bScrollbarLeft = Math.round( inner.offset().left ) !== 1;

      // IE8- don't provide height and width for getBoundingClientRect
      browser.bBounding = n[0].getBoundingClientRect().width ? true : false;

      n.remove();
    }

    $.extend( settings.oBrowser, DataTable.__browser );
    settings.oScroll.iBarWidth = DataTable.__browser.barWidth;
  }


  /**
   * Array.prototype reduce[Right] method, used for browsers which don't support
   * JS 1.6. Done this way to reduce code size, since we iterate either way
   *  @param {object} settings dataTables settings object
   *  @memberof DataTable#oApi
   */
  function _fnReduce ( that, fn, init, start, end, inc )
  {
    var
      i = start,
      value,
      isSet = false;

    if ( init !== undefined ) {
      value = init;
      isSet = true;
    }

    while ( i !== end ) {
      if ( ! that.hasOwnProperty(i) ) {
        continue;
      }

      value = isSet ?
        fn( value, that[i], i, that ) :
        that[i];

      isSet = true;
      i += inc;
    }

    return value;
  }

  /**
   * Add a column to the list used for the table with default values
   *  @param {object} oSettings dataTables settings object
   *  @param {node} nTh The th element for this column
   *  @memberof DataTable#oApi
   */
  function _fnAddColumn( oSettings, nTh )
  {
    // Add column to aoColumns array
    var oDefaults = DataTable.defaults.column;
    var iCol = oSettings.aoColumns.length;
    var oCol = $.extend( {}, DataTable.models.oColumn, oDefaults, {
      "nTh": nTh ? nTh : document.createElement('th'),
      "sTitle":    oDefaults.sTitle    ? oDefaults.sTitle    : nTh ? nTh.innerHTML : '',
      "aDataSort": oDefaults.aDataSort ? oDefaults.aDataSort : [iCol],
      "mData": oDefaults.mData ? oDefaults.mData : iCol,
      idx: iCol
    } );
    oSettings.aoColumns.push( oCol );

    // Add search object for column specific search. Note that the `searchCols[ iCol ]`
    // passed into extend can be undefined. This allows the user to give a default
    // with only some of the parameters defined, and also not give a default
    var searchCols = oSettings.aoPreSearchCols;
    searchCols[ iCol ] = $.extend( {}, DataTable.models.oSearch, searchCols[ iCol ] );

    // Use the default column options function to initialise classes etc
    _fnColumnOptions( oSettings, iCol, $(nTh).data() );
  }


  /**
   * Apply options for a column
   *  @param {object} oSettings dataTables settings object
   *  @param {int} iCol column index to consider
   *  @param {object} oOptions object with sType, bVisible and bSearchable etc
   *  @memberof DataTable#oApi
   */
  function _fnColumnOptions( oSettings, iCol, oOptions )
  {
    var oCol = oSettings.aoColumns[ iCol ];
    var oClasses = oSettings.oClasses;
    var th = $(oCol.nTh);

    // Try to get width information from the DOM. We can't get it from CSS
    // as we'd need to parse the CSS stylesheet. `width` option can override
    if ( ! oCol.sWidthOrig ) {
      // Width attribute
      oCol.sWidthOrig = th.attr('width') || null;

      // Style attribute
      var t = (th.attr('style') || '').match(/width:\s*(\d+[pxem%]+)/);
      if ( t ) {
        oCol.sWidthOrig = t[1];
      }
    }

    /* User specified column options */
    if ( oOptions !== undefined && oOptions !== null )
    {
      // Backwards compatibility
      _fnCompatCols( oOptions );

      // Map camel case parameters to their Hungarian counterparts
      _fnCamelToHungarian( DataTable.defaults.column, oOptions );

      /* Backwards compatibility for mDataProp */
      if ( oOptions.mDataProp !== undefined && !oOptions.mData )
      {
        oOptions.mData = oOptions.mDataProp;
      }

      if ( oOptions.sType )
      {
        oCol._sManualType = oOptions.sType;
      }

      // `class` is a reserved word in Javascript, so we need to provide
      // the ability to use a valid name for the camel case input
      if ( oOptions.className && ! oOptions.sClass )
      {
        oOptions.sClass = oOptions.className;
      }
      if ( oOptions.sClass ) {
        th.addClass( oOptions.sClass );
      }

      $.extend( oCol, oOptions );
      _fnMap( oCol, oOptions, "sWidth", "sWidthOrig" );

      /* iDataSort to be applied (backwards compatibility), but aDataSort will take
       * priority if defined
       */
      if ( oOptions.iDataSort !== undefined )
      {
        oCol.aDataSort = [ oOptions.iDataSort ];
      }
      _fnMap( oCol, oOptions, "aDataSort" );
    }

    /* Cache the data get and set functions for speed */
    var mDataSrc = oCol.mData;
    var mData = _fnGetObjectDataFn( mDataSrc );
    var mRender = oCol.mRender ? _fnGetObjectDataFn( oCol.mRender ) : null;

    var attrTest = function( src ) {
      return typeof src === 'string' && src.indexOf('@') !== -1;
    };
    oCol._bAttrSrc = $.isPlainObject( mDataSrc ) && (
      attrTest(mDataSrc.sort) || attrTest(mDataSrc.type) || attrTest(mDataSrc.filter)
    );
    oCol._setter = null;

    oCol.fnGetData = function (rowData, type, meta) {
      var innerData = mData( rowData, type, undefined, meta );

      return mRender && type ?
        mRender( innerData, type, rowData, meta ) :
        innerData;
    };
    oCol.fnSetData = function ( rowData, val, meta ) {
      return _fnSetObjectDataFn( mDataSrc )( rowData, val, meta );
    };

    // Indicate if DataTables should read DOM data as an object or array
    // Used in _fnGetRowElements
    if ( typeof mDataSrc !== 'number' ) {
      oSettings._rowReadObject = true;
    }

    /* Feature sorting overrides column specific when off */
    if ( !oSettings.oFeatures.bSort )
    {
      oCol.bSortable = false;
      th.addClass( oClasses.sSortableNone ); // Have to add class here as order event isn't called
    }

    /* Check that the class assignment is correct for sorting */
    var bAsc = $.inArray('asc', oCol.asSorting) !== -1;
    var bDesc = $.inArray('desc', oCol.asSorting) !== -1;
    if ( !oCol.bSortable || (!bAsc && !bDesc) )
    {
      oCol.sSortingClass = oClasses.sSortableNone;
      oCol.sSortingClassJUI = "";
    }
    else if ( bAsc && !bDesc )
    {
      oCol.sSortingClass = oClasses.sSortableAsc;
      oCol.sSortingClassJUI = oClasses.sSortJUIAscAllowed;
    }
    else if ( !bAsc && bDesc )
    {
      oCol.sSortingClass = oClasses.sSortableDesc;
      oCol.sSortingClassJUI = oClasses.sSortJUIDescAllowed;
    }
    else
    {
      oCol.sSortingClass = oClasses.sSortable;
      oCol.sSortingClassJUI = oClasses.sSortJUI;
    }
  }


  /**
   * Adjust the table column widths for new data. Note: you would probably want to
   * do a redraw after calling this function!
   *  @param {object} settings dataTables settings object
   *  @memberof DataTable#oApi
   */
  function _fnAdjustColumnSizing ( settings )
  {
    /* Not interested in doing column width calculation if auto-width is disabled */
    if ( settings.oFeatures.bAutoWidth !== false )
    {
      var columns = settings.aoColumns;

      _fnCalculateColumnWidths( settings );
      for ( var i=0 , iLen=columns.length ; i<iLen ; i++ )
      {
        columns[i].nTh.style.width = columns[i].sWidth;
      }
    }

    var scroll = settings.oScroll;
    if ( scroll.sY !== '' || scroll.sX !== '')
    {
      _fnScrollDraw( settings );
    }

    _fnCallbackFire( settings, null, 'column-sizing', [settings] );
  }


  /**
   * Covert the index of a visible column to the index in the data array (take account
   * of hidden columns)
   *  @param {object} oSettings dataTables settings object
   *  @param {int} iMatch Visible column index to lookup
   *  @returns {int} i the data index
   *  @memberof DataTable#oApi
   */
  function _fnVisibleToColumnIndex( oSettings, iMatch )
  {
    var aiVis = _fnGetColumns( oSettings, 'bVisible' );

    return typeof aiVis[iMatch] === 'number' ?
      aiVis[iMatch] :
      null;
  }


  /**
   * Covert the index of an index in the data array and convert it to the visible
   *   column index (take account of hidden columns)
   *  @param {int} iMatch Column index to lookup
   *  @param {object} oSettings dataTables settings object
   *  @returns {int} i the data index
   *  @memberof DataTable#oApi
   */
  function _fnColumnIndexToVisible( oSettings, iMatch )
  {
    var aiVis = _fnGetColumns( oSettings, 'bVisible' );
    var iPos = $.inArray( iMatch, aiVis );

    return iPos !== -1 ? iPos : null;
  }


  /**
   * Get the number of visible columns
   *  @param {object} oSettings dataTables settings object
   *  @returns {int} i the number of visible columns
   *  @memberof DataTable#oApi
   */
  function _fnVisbleColumns( oSettings )
  {
    var vis = 0;

    // No reduce in IE8, use a loop for now
    $.each( oSettings.aoColumns, function ( i, col ) {
      if ( col.bVisible && $(col.nTh).css('display') !== 'none' ) {
        vis++;
      }
    } );

    return vis;
  }


  /**
   * Get an array of column indexes that match a given property
   *  @param {object} oSettings dataTables settings object
   *  @param {string} sParam Parameter in aoColumns to look for - typically
   *    bVisible or bSearchable
   *  @returns {array} Array of indexes with matched properties
   *  @memberof DataTable#oApi
   */
  function _fnGetColumns( oSettings, sParam )
  {
    var a = [];

    $.map( oSettings.aoColumns, function(val, i) {
      if ( val[sParam] ) {
        a.push( i );
      }
    } );

    return a;
  }


  /**
   * Calculate the 'type' of a column
   *  @param {object} settings dataTables settings object
   *  @memberof DataTable#oApi
   */
  function _fnColumnTypes ( settings )
  {
    var columns = settings.aoColumns;
    var data = settings.aoData;
    var types = DataTable.ext.type.detect;
    var i, ien, j, jen, k, ken;
    var col, cell, detectedType, cache;

    // For each column, spin over the
    for ( i=0, ien=columns.length ; i<ien ; i++ ) {
      col = columns[i];
      cache = [];

      if ( ! col.sType && col._sManualType ) {
        col.sType = col._sManualType;
      }
      else if ( ! col.sType ) {
        for ( j=0, jen=types.length ; j<jen ; j++ ) {
          for ( k=0, ken=data.length ; k<ken ; k++ ) {
            // Use a cache array so we only need to get the type data
            // from the formatter once (when using multiple detectors)
            if ( cache[k] === undefined ) {
              cache[k] = _fnGetCellData( settings, k, i, 'type' );
            }

            detectedType = types[j]( cache[k], settings );

            // If null, then this type can't apply to this column, so
            // rather than testing all cells, break out. There is an
            // exception for the last type which is `html`. We need to
            // scan all rows since it is possible to mix string and HTML
            // types
            if ( ! detectedType && j !== types.length-1 ) {
              break;
            }

            // Only a single match is needed for html type since it is
            // bottom of the pile and very similar to string
            if ( detectedType === 'html' ) {
              break;
            }
          }

          // Type is valid for all data points in the column - use this
          // type
          if ( detectedType ) {
            col.sType = detectedType;
            break;
          }
        }

        // Fall back - if no type was detected, always use string
        if ( ! col.sType ) {
          col.sType = 'string';
        }
      }
    }
  }


  /**
   * Take the column definitions and static columns arrays and calculate how
   * they relate to column indexes. The callback function will then apply the
   * definition found for a column to a suitable configuration object.
   *  @param {object} oSettings dataTables settings object
   *  @param {array} aoColDefs The aoColumnDefs array that is to be applied
   *  @param {array} aoCols The aoColumns array that defines columns individually
   *  @param {function} fn Callback function - takes two parameters, the calculated
   *    column index and the definition for that column.
   *  @memberof DataTable#oApi
   */
  function _fnApplyColumnDefs( oSettings, aoColDefs, aoCols, fn )
  {
    var i, iLen, j, jLen, k, kLen, def;
    var columns = oSettings.aoColumns;

    // Column definitions with aTargets
    if ( aoColDefs )
    {
      /* Loop over the definitions array - loop in reverse so first instance has priority */
      for ( i=aoColDefs.length-1 ; i>=0 ; i-- )
      {
        def = aoColDefs[i];

        /* Each definition can target multiple columns, as it is an array */
        var aTargets = def.targets !== undefined ?
          def.targets :
          def.aTargets;

        if ( ! $.isArray( aTargets ) )
        {
          aTargets = [ aTargets ];
        }

        for ( j=0, jLen=aTargets.length ; j<jLen ; j++ )
        {
          if ( typeof aTargets[j] === 'number' && aTargets[j] >= 0 )
          {
            /* Add columns that we don't yet know about */
            while( columns.length <= aTargets[j] )
            {
              _fnAddColumn( oSettings );
            }

            /* Integer, basic index */
            fn( aTargets[j], def );
          }
          else if ( typeof aTargets[j] === 'number' && aTargets[j] < 0 )
          {
            /* Negative integer, right to left column counting */
            fn( columns.length+aTargets[j], def );
          }
          else if ( typeof aTargets[j] === 'string' )
          {
            /* Class name matching on TH element */
            for ( k=0, kLen=columns.length ; k<kLen ; k++ )
            {
              if ( aTargets[j] == "_all" ||
                   $(columns[k].nTh).hasClass( aTargets[j] ) )
              {
                fn( k, def );
              }
            }
          }
        }
      }
    }

    // Statically defined columns array
    if ( aoCols )
    {
      for ( i=0, iLen=aoCols.length ; i<iLen ; i++ )
      {
        fn( i, aoCols[i] );
      }
    }
  }

  /**
   * Add a data array to the table, creating DOM node etc. This is the parallel to
   * _fnGatherData, but for adding rows from a Javascript source, rather than a
   * DOM source.
   *  @param {object} oSettings dataTables settings object
   *  @param {array} aData data array to be added
   *  @param {node} [nTr] TR element to add to the table - optional. If not given,
   *    DataTables will create a row automatically
   *  @param {array} [anTds] Array of TD|TH elements for the row - must be given
   *    if nTr is.
   *  @returns {int} >=0 if successful (index of new aoData entry), -1 if failed
   *  @memberof DataTable#oApi
   */
  function _fnAddData ( oSettings, aDataIn, nTr, anTds )
  {
    /* Create the object for storing information about this new row */
    var iRow = oSettings.aoData.length;
    var oData = $.extend( true, {}, DataTable.models.oRow, {
      src: nTr ? 'dom' : 'data',
      idx: iRow
    } );

    oData._aData = aDataIn;
    oSettings.aoData.push( oData );

    /* Create the cells */
    var nTd, sThisType;
    var columns = oSettings.aoColumns;

    // Invalidate the column types as the new data needs to be revalidated
    for ( var i=0, iLen=columns.length ; i<iLen ; i++ )
    {
      columns[i].sType = null;
    }

    /* Add to the display array */
    oSettings.aiDisplayMaster.push( iRow );

    var id = oSettings.rowIdFn( aDataIn );
    if ( id !== undefined ) {
      oSettings.aIds[ id ] = oData;
    }

    /* Create the DOM information, or register it if already present */
    if ( nTr || ! oSettings.oFeatures.bDeferRender )
    {
      _fnCreateTr( oSettings, iRow, nTr, anTds );
    }

    return iRow;
  }


  /**
   * Add one or more TR elements to the table. Generally we'd expect to
   * use this for reading data from a DOM sourced table, but it could be
   * used for an TR element. Note that if a TR is given, it is used (i.e.
   * it is not cloned).
   *  @param {object} settings dataTables settings object
   *  @param {array|node|jQuery} trs The TR element(s) to add to the table
   *  @returns {array} Array of indexes for the added rows
   *  @memberof DataTable#oApi
   */
  function _fnAddTr( settings, trs )
  {
    var row;

    // Allow an individual node to be passed in
    if ( ! (trs instanceof $) ) {
      trs = $(trs);
    }

    return trs.map( function (i, el) {
      row = _fnGetRowElements( settings, el );
      return _fnAddData( settings, row.data, el, row.cells );
    } );
  }


  /**
   * Take a TR element and convert it to an index in aoData
   *  @param {object} oSettings dataTables settings object
   *  @param {node} n the TR element to find
   *  @returns {int} index if the node is found, null if not
   *  @memberof DataTable#oApi
   */
  function _fnNodeToDataIndex( oSettings, n )
  {
    return (n._DT_RowIndex!==undefined) ? n._DT_RowIndex : null;
  }


  /**
   * Take a TD element and convert it into a column data index (not the visible index)
   *  @param {object} oSettings dataTables settings object
   *  @param {int} iRow The row number the TD/TH can be found in
   *  @param {node} n The TD/TH element to find
   *  @returns {int} index if the node is found, -1 if not
   *  @memberof DataTable#oApi
   */
  function _fnNodeToColumnIndex( oSettings, iRow, n )
  {
    return $.inArray( n, oSettings.aoData[ iRow ].anCells );
  }


  /**
   * Get the data for a given cell from the internal cache, taking into account data mapping
   *  @param {object} settings dataTables settings object
   *  @param {int} rowIdx aoData row id
   *  @param {int} colIdx Column index
   *  @param {string} type data get type ('display', 'type' 'filter' 'sort')
   *  @returns {*} Cell data
   *  @memberof DataTable#oApi
   */
  function _fnGetCellData( settings, rowIdx, colIdx, type )
  {
    var draw           = settings.iDraw;
    var col            = settings.aoColumns[colIdx];
    var rowData        = settings.aoData[rowIdx]._aData;
    var defaultContent = col.sDefaultContent;
    var cellData       = col.fnGetData( rowData, type, {
      settings: settings,
      row:      rowIdx,
      col:      colIdx
    } );

    if ( cellData === undefined ) {
      if ( settings.iDrawError != draw && defaultContent === null ) {
        _fnLog( settings, 0, "Requested unknown parameter "+
          (typeof col.mData=='function' ? '{function}' : "'"+col.mData+"'")+
          " for row "+rowIdx+", column "+colIdx, 4 );
        settings.iDrawError = draw;
      }
      return defaultContent;
    }

    // When the data source is null and a specific data type is requested (i.e.
    // not the original data), we can use default column data
    if ( (cellData === rowData || cellData === null) && defaultContent !== null && type !== undefined ) {
      cellData = defaultContent;
    }
    else if ( typeof cellData === 'function' ) {
      // If the data source is a function, then we run it and use the return,
      // executing in the scope of the data object (for instances)
      return cellData.call( rowData );
    }

    if ( cellData === null && type == 'display' ) {
      return '';
    }
    return cellData;
  }


  /**
   * Set the value for a specific cell, into the internal data cache
   *  @param {object} settings dataTables settings object
   *  @param {int} rowIdx aoData row id
   *  @param {int} colIdx Column index
   *  @param {*} val Value to set
   *  @memberof DataTable#oApi
   */
  function _fnSetCellData( settings, rowIdx, colIdx, val )
  {
    var col     = settings.aoColumns[colIdx];
    var rowData = settings.aoData[rowIdx]._aData;

    col.fnSetData( rowData, val, {
      settings: settings,
      row:      rowIdx,
      col:      colIdx
    }  );
  }


  // Private variable that is used to match action syntax in the data property object
  var __reArray = /\[.*?\]$/;
  var __reFn = /\(\)$/;

  /**
   * Split string on periods, taking into account escaped periods
   * @param  {string} str String to split
   * @return {array} Split string
   */
  function _fnSplitObjNotation( str )
  {
    return $.map( str.match(/(\\.|[^\.])+/g) || [''], function ( s ) {
      return s.replace(/\\\./g, '.');
    } );
  }


  /**
   * Return a function that can be used to get data from a source object, taking
   * into account the ability to use nested objects as a source
   *  @param {string|int|function} mSource The data source for the object
   *  @returns {function} Data get function
   *  @memberof DataTable#oApi
   */
  function _fnGetObjectDataFn( mSource )
  {
    if ( $.isPlainObject( mSource ) )
    {
      /* Build an object of get functions, and wrap them in a single call */
      var o = {};
      $.each( mSource, function (key, val) {
        if ( val ) {
          o[key] = _fnGetObjectDataFn( val );
        }
      } );

      return function (data, type, row, meta) {
        var t = o[type] || o._;
        return t !== undefined ?
          t(data, type, row, meta) :
          data;
      };
    }
    else if ( mSource === null )
    {
      /* Give an empty string for rendering / sorting etc */
      return function (data) { // type, row and meta also passed, but not used
        return data;
      };
    }
    else if ( typeof mSource === 'function' )
    {
      return function (data, type, row, meta) {
        return mSource( data, type, row, meta );
      };
    }
    else if ( typeof mSource === 'string' && (mSource.indexOf('.') !== -1 ||
            mSource.indexOf('[') !== -1 || mSource.indexOf('(') !== -1) )
    {
      /* If there is a . in the source string then the data source is in a
       * nested object so we loop over the data for each level to get the next
       * level down. On each loop we test for undefined, and if found immediately
       * return. This allows entire objects to be missing and sDefaultContent to
       * be used if defined, rather than throwing an error
       */
      var fetchData = function (data, type, src) {
        var arrayNotation, funcNotation, out, innerSrc;

        if ( src !== "" )
        {
          var a = _fnSplitObjNotation( src );

          for ( var i=0, iLen=a.length ; i<iLen ; i++ )
          {
            // Check if we are dealing with special notation
            arrayNotation = a[i].match(__reArray);
            funcNotation = a[i].match(__reFn);

            if ( arrayNotation )
            {
              // Array notation
              a[i] = a[i].replace(__reArray, '');

              // Condition allows simply [] to be passed in
              if ( a[i] !== "" ) {
                data = data[ a[i] ];
              }
              out = [];

              // Get the remainder of the nested object to get
              a.splice( 0, i+1 );
              innerSrc = a.join('.');

              // Traverse each entry in the array getting the properties requested
              if ( $.isArray( data ) ) {
                for ( var j=0, jLen=data.length ; j<jLen ; j++ ) {
                  out.push( fetchData( data[j], type, innerSrc ) );
                }
              }

              // If a string is given in between the array notation indicators, that
              // is used to join the strings together, otherwise an array is returned
              var join = arrayNotation[0].substring(1, arrayNotation[0].length-1);
              data = (join==="") ? out : out.join(join);

              // The inner call to fetchData has already traversed through the remainder
              // of the source requested, so we exit from the loop
              break;
            }
            else if ( funcNotation )
            {
              // Function call
              a[i] = a[i].replace(__reFn, '');
              data = data[ a[i] ]();
              continue;
            }

            if ( data === null || data[ a[i] ] === undefined )
            {
              return undefined;
            }
            data = data[ a[i] ];
          }
        }

        return data;
      };

      return function (data, type) { // row and meta also passed, but not used
        return fetchData( data, type, mSource );
      };
    }
    else
    {
      /* Array or flat object mapping */
      return function (data, type) { // row and meta also passed, but not used
        return data[mSource];
      };
    }
  }


  /**
   * Return a function that can be used to set data from a source object, taking
   * into account the ability to use nested objects as a source
   *  @param {string|int|function} mSource The data source for the object
   *  @returns {function} Data set function
   *  @memberof DataTable#oApi
   */
  function _fnSetObjectDataFn( mSource )
  {
    if ( $.isPlainObject( mSource ) )
    {
      /* Unlike get, only the underscore (global) option is used for for
       * setting data since we don't know the type here. This is why an object
       * option is not documented for `mData` (which is read/write), but it is
       * for `mRender` which is read only.
       */
      return _fnSetObjectDataFn( mSource._ );
    }
    else if ( mSource === null )
    {
      /* Nothing to do when the data source is null */
      return function () {};
    }
    else if ( typeof mSource === 'function' )
    {
      return function (data, val, meta) {
        mSource( data, 'set', val, meta );
      };
    }
    else if ( typeof mSource === 'string' && (mSource.indexOf('.') !== -1 ||
            mSource.indexOf('[') !== -1 || mSource.indexOf('(') !== -1) )
    {
      /* Like the get, we need to get data from a nested object */
      var setData = function (data, val, src) {
        var a = _fnSplitObjNotation( src ), b;
        var aLast = a[a.length-1];
        var arrayNotation, funcNotation, o, innerSrc;

        for ( var i=0, iLen=a.length-1 ; i<iLen ; i++ )
        {
          // Check if we are dealing with an array notation request
          arrayNotation = a[i].match(__reArray);
          funcNotation = a[i].match(__reFn);

          if ( arrayNotation )
          {
            a[i] = a[i].replace(__reArray, '');
            data[ a[i] ] = [];

            // Get the remainder of the nested object to set so we can recurse
            b = a.slice();
            b.splice( 0, i+1 );
            innerSrc = b.join('.');

            // Traverse each entry in the array setting the properties requested
            if ( $.isArray( val ) )
            {
              for ( var j=0, jLen=val.length ; j<jLen ; j++ )
              {
                o = {};
                setData( o, val[j], innerSrc );
                data[ a[i] ].push( o );
              }
            }
            else
            {
              // We've been asked to save data to an array, but it
              // isn't array data to be saved. Best that can be done
              // is to just save the value.
              data[ a[i] ] = val;
            }

            // The inner call to setData has already traversed through the remainder
            // of the source and has set the data, thus we can exit here
            return;
          }
          else if ( funcNotation )
          {
            // Function call
            a[i] = a[i].replace(__reFn, '');
            data = data[ a[i] ]( val );
          }

          // If the nested object doesn't currently exist - since we are
          // trying to set the value - create it
          if ( data[ a[i] ] === null || data[ a[i] ] === undefined )
          {
            data[ a[i] ] = {};
          }
          data = data[ a[i] ];
        }

        // Last item in the input - i.e, the actual set
        if ( aLast.match(__reFn ) )
        {
          // Function call
          data = data[ aLast.replace(__reFn, '') ]( val );
        }
        else
        {
          // If array notation is used, we just want to strip it and use the property name
          // and assign the value. If it isn't used, then we get the result we want anyway
          data[ aLast.replace(__reArray, '') ] = val;
        }
      };

      return function (data, val) { // meta is also passed in, but not used
        return setData( data, val, mSource );
      };
    }
    else
    {
      /* Array or flat object mapping */
      return function (data, val) { // meta is also passed in, but not used
        data[mSource] = val;
      };
    }
  }


  /**
   * Return an array with the full table data
   *  @param {object} oSettings dataTables settings object
   *  @returns array {array} aData Master data array
   *  @memberof DataTable#oApi
   */
  function _fnGetDataMaster ( settings )
  {
    return _pluck( settings.aoData, '_aData' );
  }


  /**
   * Nuke the table
   *  @param {object} oSettings dataTables settings object
   *  @memberof DataTable#oApi
   */
  function _fnClearTable( settings )
  {
    settings.aoData.length = 0;
    settings.aiDisplayMaster.length = 0;
    settings.aiDisplay.length = 0;
    settings.aIds = {};
  }


   /**
   * Take an array of integers (index array) and remove a target integer (value - not
   * the key!)
   *  @param {array} a Index array to target
   *  @param {int} iTarget value to find
   *  @memberof DataTable#oApi
   */
  function _fnDeleteIndex( a, iTarget, splice )
  {
    var iTargetIndex = -1;

    for ( var i=0, iLen=a.length ; i<iLen ; i++ )
    {
      if ( a[i] == iTarget )
      {
        iTargetIndex = i;
      }
      else if ( a[i] > iTarget )
      {
        a[i]--;
      }
    }

    if ( iTargetIndex != -1 && splice === undefined )
    {
      a.splice( iTargetIndex, 1 );
    }
  }


  /**
   * Mark cached data as invalid such that a re-read of the data will occur when
   * the cached data is next requested. Also update from the data source object.
   *
   * @param {object} settings DataTables settings object
   * @param {int}    rowIdx   Row index to invalidate
   * @param {string} [src]    Source to invalidate from: undefined, 'auto', 'dom'
   *     or 'data'
   * @param {int}    [colIdx] Column index to invalidate. If undefined the whole
   *     row will be invalidated
   * @memberof DataTable#oApi
   *
   * @todo For the modularisation of v1.11 this will need to become a callback, so
   *   the sort and filter methods can subscribe to it. That will required
   *   initialisation options for sorting, which is why it is not already baked in
   */
  function _fnInvalidate( settings, rowIdx, src, colIdx )
  {
    var row = settings.aoData[ rowIdx ];
    var i, ien;
    var cellWrite = function ( cell, col ) {
      // This is very frustrating, but in IE if you just write directly
      // to innerHTML, and elements that are overwritten are GC'ed,
      // even if there is a reference to them elsewhere
      while ( cell.childNodes.length ) {
        cell.removeChild( cell.firstChild );
      }

      cell.innerHTML = _fnGetCellData( settings, rowIdx, col, 'display' );
    };

    // Are we reading last data from DOM or the data object?
    if ( src === 'dom' || ((! src || src === 'auto') && row.src === 'dom') ) {
      // Read the data from the DOM
      row._aData = _fnGetRowElements(
          settings, row, colIdx, colIdx === undefined ? undefined : row._aData
        )
        .data;
    }
    else {
      // Reading from data object, update the DOM
      var cells = row.anCells;

      if ( cells ) {
        if ( colIdx !== undefined ) {
          cellWrite( cells[colIdx], colIdx );
        }
        else {
          for ( i=0, ien=cells.length ; i<ien ; i++ ) {
            cellWrite( cells[i], i );
          }
        }
      }
    }

    // For both row and cell invalidation, the cached data for sorting and
    // filtering is nulled out
    row._aSortData = null;
    row._aFilterData = null;

    // Invalidate the type for a specific column (if given) or all columns since
    // the data might have changed
    var cols = settings.aoColumns;
    if ( colIdx !== undefined ) {
      cols[ colIdx ].sType = null;
    }
    else {
      for ( i=0, ien=cols.length ; i<ien ; i++ ) {
        cols[i].sType = null;
      }

      // Update DataTables special `DT_*` attributes for the row
      _fnRowAttributes( settings, row );
    }
  }


  /**
   * Build a data source object from an HTML row, reading the contents of the
   * cells that are in the row.
   *
   * @param {object} settings DataTables settings object
   * @param {node|object} TR element from which to read data or existing row
   *   object from which to re-read the data from the cells
   * @param {int} [colIdx] Optional column index
   * @param {array|object} [d] Data source object. If `colIdx` is given then this
   *   parameter should also be given and will be used to write the data into.
   *   Only the column in question will be written
   * @returns {object} Object with two parameters: `data` the data read, in
   *   document order, and `cells` and array of nodes (they can be useful to the
   *   caller, so rather than needing a second traversal to get them, just return
   *   them from here).
   * @memberof DataTable#oApi
   */
  function _fnGetRowElements( settings, row, colIdx, d )
  {
    var
      tds = [],
      td = row.firstChild,
      name, col, o, i=0, contents,
      columns = settings.aoColumns,
      objectRead = settings._rowReadObject;

    // Allow the data object to be passed in, or construct
    d = d !== undefined ?
      d :
      objectRead ?
        {} :
        [];

    var attr = function ( str, td  ) {
      if ( typeof str === 'string' ) {
        var idx = str.indexOf('@');

        if ( idx !== -1 ) {
          var attr = str.substring( idx+1 );
          var setter = _fnSetObjectDataFn( str );
          setter( d, td.getAttribute( attr ) );
        }
      }
    };

    // Read data from a cell and store into the data object
    var cellProcess = function ( cell ) {
      if ( colIdx === undefined || colIdx === i ) {
        col = columns[i];
        contents = $.trim(cell.innerHTML);

        if ( col && col._bAttrSrc ) {
          var setter = _fnSetObjectDataFn( col.mData._ );
          setter( d, contents );

          attr( col.mData.sort, cell );
          attr( col.mData.type, cell );
          attr( col.mData.filter, cell );
        }
        else {
          // Depending on the `data` option for the columns the data can
          // be read to either an object or an array.
          if ( objectRead ) {
            if ( ! col._setter ) {
              // Cache the setter function
              col._setter = _fnSetObjectDataFn( col.mData );
            }
            col._setter( d, contents );
          }
          else {
            d[i] = contents;
          }
        }
      }

      i++;
    };

    if ( td ) {
      // `tr` element was passed in
      while ( td ) {
        name = td.nodeName.toUpperCase();

        if ( name == "TD" || name == "TH" ) {
          cellProcess( td );
          tds.push( td );
        }

        td = td.nextSibling;
      }
    }
    else {
      // Existing row object passed in
      tds = row.anCells;

      for ( var j=0, jen=tds.length ; j<jen ; j++ ) {
        cellProcess( tds[j] );
      }
    }

    // Read the ID from the DOM if present
    var rowNode = row.firstChild ? row : row.nTr;

    if ( rowNode ) {
      var id = rowNode.getAttribute( 'id' );

      if ( id ) {
        _fnSetObjectDataFn( settings.rowId )( d, id );
      }
    }

    return {
      data: d,
      cells: tds
    };
  }
  /**
   * Create a new TR element (and it's TD children) for a row
   *  @param {object} oSettings dataTables settings object
   *  @param {int} iRow Row to consider
   *  @param {node} [nTrIn] TR element to add to the table - optional. If not given,
   *    DataTables will create a row automatically
   *  @param {array} [anTds] Array of TD|TH elements for the row - must be given
   *    if nTr is.
   *  @memberof DataTable#oApi
   */
  function _fnCreateTr ( oSettings, iRow, nTrIn, anTds )
  {
    var
      row = oSettings.aoData[iRow],
      rowData = row._aData,
      cells = [],
      nTr, nTd, oCol,
      i, iLen;

    if ( row.nTr === null )
    {
      nTr = nTrIn || document.createElement('tr');

      row.nTr = nTr;
      row.anCells = cells;

      /* Use a private property on the node to allow reserve mapping from the node
       * to the aoData array for fast look up
       */
      nTr._DT_RowIndex = iRow;

      /* Special parameters can be given by the data source to be used on the row */
      _fnRowAttributes( oSettings, row );

      /* Process each column */
      for ( i=0, iLen=oSettings.aoColumns.length ; i<iLen ; i++ )
      {
        oCol = oSettings.aoColumns[i];

        nTd = nTrIn ? anTds[i] : document.createElement( oCol.sCellType );
        nTd._DT_CellIndex = {
          row: iRow,
          column: i
        };

        cells.push( nTd );

        // Need to create the HTML if new, or if a rendering function is defined
        if ( (!nTrIn || oCol.mRender || oCol.mData !== i) &&
           (!$.isPlainObject(oCol.mData) || oCol.mData._ !== i+'.display')
        ) {
          nTd.innerHTML = _fnGetCellData( oSettings, iRow, i, 'display' );
        }

        /* Add user defined class */
        if ( oCol.sClass )
        {
          nTd.className += ' '+oCol.sClass;
        }

        // Visibility - add or remove as required
        if ( oCol.bVisible && ! nTrIn )
        {
          nTr.appendChild( nTd );
        }
        else if ( ! oCol.bVisible && nTrIn )
        {
          nTd.parentNode.removeChild( nTd );
        }

        if ( oCol.fnCreatedCell )
        {
          oCol.fnCreatedCell.call( oSettings.oInstance,
            nTd, _fnGetCellData( oSettings, iRow, i ), rowData, iRow, i
          );
        }
      }

      _fnCallbackFire( oSettings, 'aoRowCreatedCallback', null, [nTr, rowData, iRow] );
    }

    // Remove once webkit bug 131819 and Chromium bug 365619 have been resolved
    // and deployed
    row.nTr.setAttribute( 'role', 'row' );
  }


  /**
   * Add attributes to a row based on the special `DT_*` parameters in a data
   * source object.
   *  @param {object} settings DataTables settings object
   *  @param {object} DataTables row object for the row to be modified
   *  @memberof DataTable#oApi
   */
  function _fnRowAttributes( settings, row )
  {
    var tr = row.nTr;
    var data = row._aData;

    if ( tr ) {
      var id = settings.rowIdFn( data );

      if ( id ) {
        tr.id = id;
      }

      if ( data.DT_RowClass ) {
        // Remove any classes added by DT_RowClass before
        var a = data.DT_RowClass.split(' ');
        row.__rowc = row.__rowc ?
          _unique( row.__rowc.concat( a ) ) :
          a;

        $(tr)
          .removeClass( row.__rowc.join(' ') )
          .addClass( data.DT_RowClass );
      }

      if ( data.DT_RowAttr ) {
        $(tr).attr( data.DT_RowAttr );
      }

      if ( data.DT_RowData ) {
        $(tr).data( data.DT_RowData );
      }
    }
  }


  /**
   * Create the HTML header for the table
   *  @param {object} oSettings dataTables settings object
   *  @memberof DataTable#oApi
   */
  function _fnBuildHead( oSettings )
  {
    var i, ien, cell, row, column;
    var thead = oSettings.nTHead;
    var tfoot = oSettings.nTFoot;
    var createHeader = $('th, td', thead).length === 0;
    var classes = oSettings.oClasses;
    var columns = oSettings.aoColumns;

    if ( createHeader ) {
      row = $('<tr/>').appendTo( thead );
    }

    for ( i=0, ien=columns.length ; i<ien ; i++ ) {
      column = columns[i];
      cell = $( column.nTh ).addClass( column.sClass );

      if ( createHeader ) {
        cell.appendTo( row );
      }

      // 1.11 move into sorting
      if ( oSettings.oFeatures.bSort ) {
        cell.addClass( column.sSortingClass );

        if ( column.bSortable !== false ) {
          cell
            .attr( 'tabindex', oSettings.iTabIndex )
            .attr( 'aria-controls', oSettings.sTableId );

          _fnSortAttachListener( oSettings, column.nTh, i );
        }
      }

      if ( column.sTitle != cell[0].innerHTML ) {
        cell.html( column.sTitle );
      }

      _fnRenderer( oSettings, 'header' )(
        oSettings, cell, column, classes
      );
    }

    if ( createHeader ) {
      _fnDetectHeader( oSettings.aoHeader, thead );
    }

    /* ARIA role for the rows */
    $(thead).find('>tr').attr('role', 'row');

    /* Deal with the footer - add classes if required */
    $(thead).find('>tr>th, >tr>td').addClass( classes.sHeaderTH );
    $(tfoot).find('>tr>th, >tr>td').addClass( classes.sFooterTH );

    // Cache the footer cells. Note that we only take the cells from the first
    // row in the footer. If there is more than one row the user wants to
    // interact with, they need to use the table().foot() method. Note also this
    // allows cells to be used for multiple columns using colspan
    if ( tfoot !== null ) {
      var cells = oSettings.aoFooter[0];

      for ( i=0, ien=cells.length ; i<ien ; i++ ) {
        column = columns[i];
        column.nTf = cells[i].cell;

        if ( column.sClass ) {
          $(column.nTf).addClass( column.sClass );
        }
      }
    }
  }


  /**
   * Draw the header (or footer) element based on the column visibility states. The
   * methodology here is to use the layout array from _fnDetectHeader, modified for
   * the instantaneous column visibility, to construct the new layout. The grid is
   * traversed over cell at a time in a rows x columns grid fashion, although each
   * cell insert can cover multiple elements in the grid - which is tracks using the
   * aApplied array. Cell inserts in the grid will only occur where there isn't
   * already a cell in that position.
   *  @param {object} oSettings dataTables settings object
   *  @param array {objects} aoSource Layout array from _fnDetectHeader
   *  @param {boolean} [bIncludeHidden=false] If true then include the hidden columns in the calc,
   *  @memberof DataTable#oApi
   */
  function _fnDrawHead( oSettings, aoSource, bIncludeHidden )
  {
    var i, iLen, j, jLen, k, kLen, n, nLocalTr;
    var aoLocal = [];
    var aApplied = [];
    var iColumns = oSettings.aoColumns.length;
    var iRowspan, iColspan;

    if ( ! aoSource )
    {
      return;
    }

    if (  bIncludeHidden === undefined )
    {
      bIncludeHidden = false;
    }

    /* Make a copy of the master layout array, but without the visible columns in it */
    for ( i=0, iLen=aoSource.length ; i<iLen ; i++ )
    {
      aoLocal[i] = aoSource[i].slice();
      aoLocal[i].nTr = aoSource[i].nTr;

      /* Remove any columns which are currently hidden */
      for ( j=iColumns-1 ; j>=0 ; j-- )
      {
        if ( !oSettings.aoColumns[j].bVisible && !bIncludeHidden )
        {
          aoLocal[i].splice( j, 1 );
        }
      }

      /* Prep the applied array - it needs an element for each row */
      aApplied.push( [] );
    }

    for ( i=0, iLen=aoLocal.length ; i<iLen ; i++ )
    {
      nLocalTr = aoLocal[i].nTr;

      /* All cells are going to be replaced, so empty out the row */
      if ( nLocalTr )
      {
        while( (n = nLocalTr.firstChild) )
        {
          nLocalTr.removeChild( n );
        }
      }

      for ( j=0, jLen=aoLocal[i].length ; j<jLen ; j++ )
      {
        iRowspan = 1;
        iColspan = 1;

        /* Check to see if there is already a cell (row/colspan) covering our target
         * insert point. If there is, then there is nothing to do.
         */
        if ( aApplied[i][j] === undefined )
        {
          nLocalTr.appendChild( aoLocal[i][j].cell );
          aApplied[i][j] = 1;

          /* Expand the cell to cover as many rows as needed */
          while ( aoLocal[i+iRowspan] !== undefined &&
                  aoLocal[i][j].cell == aoLocal[i+iRowspan][j].cell )
          {
            aApplied[i+iRowspan][j] = 1;
            iRowspan++;
          }

          /* Expand the cell to cover as many columns as needed */
          while ( aoLocal[i][j+iColspan] !== undefined &&
                  aoLocal[i][j].cell == aoLocal[i][j+iColspan].cell )
          {
            /* Must update the applied array over the rows for the columns */
            for ( k=0 ; k<iRowspan ; k++ )
            {
              aApplied[i+k][j+iColspan] = 1;
            }
            iColspan++;
          }

          /* Do the actual expansion in the DOM */
          $(aoLocal[i][j].cell)
            .attr('rowspan', iRowspan)
            .attr('colspan', iColspan);
        }
      }
    }
  }


  /**
   * Insert the required TR nodes into the table for display
   *  @param {object} oSettings dataTables settings object
   *  @memberof DataTable#oApi
   */
  function _fnDraw( oSettings )
  {
    /* Provide a pre-callback function which can be used to cancel the draw is false is returned */
    var aPreDraw = _fnCallbackFire( oSettings, 'aoPreDrawCallback', 'preDraw', [oSettings] );
    if ( $.inArray( false, aPreDraw ) !== -1 )
    {
      _fnProcessingDisplay( oSettings, false );
      return;
    }

    var i, iLen, n;
    var anRows = [];
    var iRowCount = 0;
    var asStripeClasses = oSettings.asStripeClasses;
    var iStripes = asStripeClasses.length;
    var iOpenRows = oSettings.aoOpenRows.length;
    var oLang = oSettings.oLanguage;
    var iInitDisplayStart = oSettings.iInitDisplayStart;
    var bServerSide = _fnDataSource( oSettings ) == 'ssp';
    var aiDisplay = oSettings.aiDisplay;

    oSettings.bDrawing = true;

    /* Check and see if we have an initial draw position from state saving */
    if ( iInitDisplayStart !== undefined && iInitDisplayStart !== -1 )
    {
      oSettings._iDisplayStart = bServerSide ?
        iInitDisplayStart :
        iInitDisplayStart >= oSettings.fnRecordsDisplay() ?
          0 :
          iInitDisplayStart;

      oSettings.iInitDisplayStart = -1;
    }

    var iDisplayStart = oSettings._iDisplayStart;
    var iDisplayEnd = oSettings.fnDisplayEnd();

    /* Server-side processing draw intercept */
    if ( oSettings.bDeferLoading )
    {
      oSettings.bDeferLoading = false;
      oSettings.iDraw++;
      _fnProcessingDisplay( oSettings, false );
    }
    else if ( !bServerSide )
    {
      oSettings.iDraw++;
    }
    else if ( !oSettings.bDestroying && !_fnAjaxUpdate( oSettings ) )
    {
      return;
    }

    if ( aiDisplay.length !== 0 )
    {
      var iStart = bServerSide ? 0 : iDisplayStart;
      var iEnd = bServerSide ? oSettings.aoData.length : iDisplayEnd;

      for ( var j=iStart ; j<iEnd ; j++ )
      {
        var iDataIndex = aiDisplay[j];
        var aoData = oSettings.aoData[ iDataIndex ];
        if ( aoData.nTr === null )
        {
          _fnCreateTr( oSettings, iDataIndex );
        }

        var nRow = aoData.nTr;

        /* Remove the old striping classes and then add the new one */
        if ( iStripes !== 0 )
        {
          var sStripe = asStripeClasses[ iRowCount % iStripes ];
          if ( aoData._sRowStripe != sStripe )
          {
            $(nRow).removeClass( aoData._sRowStripe ).addClass( sStripe );
            aoData._sRowStripe = sStripe;
          }
        }

        // Row callback functions - might want to manipulate the row
        // iRowCount and j are not currently documented. Are they at all
        // useful?
        _fnCallbackFire( oSettings, 'aoRowCallback', null,
          [nRow, aoData._aData, iRowCount, j] );

        anRows.push( nRow );
        iRowCount++;
      }
    }
    else
    {
      /* Table is empty - create a row with an empty message in it */
      var sZero = oLang.sZeroRecords;
      if ( oSettings.iDraw == 1 &&  _fnDataSource( oSettings ) == 'ajax' )
      {
        sZero = oLang.sLoadingRecords;
      }
      else if ( oLang.sEmptyTable && oSettings.fnRecordsTotal() === 0 )
      {
        sZero = oLang.sEmptyTable;
      }

      anRows[ 0 ] = $( '<tr/>', { 'class': iStripes ? asStripeClasses[0] : '' } )
        .append( $('<td />', {
          'valign':  'top',
          'colSpan': _fnVisbleColumns( oSettings ),
          'class':   oSettings.oClasses.sRowEmpty
        } ).html( sZero ) )[0];
    }

    /* Header and footer callbacks */
    _fnCallbackFire( oSettings, 'aoHeaderCallback', 'header', [ $(oSettings.nTHead).children('tr')[0],
      _fnGetDataMaster( oSettings ), iDisplayStart, iDisplayEnd, aiDisplay ] );

    _fnCallbackFire( oSettings, 'aoFooterCallback', 'footer', [ $(oSettings.nTFoot).children('tr')[0],
      _fnGetDataMaster( oSettings ), iDisplayStart, iDisplayEnd, aiDisplay ] );

    var body = $(oSettings.nTBody);

    body.children().detach();
    body.append( $(anRows) );

    /* Call all required callback functions for the end of a draw */
    _fnCallbackFire( oSettings, 'aoDrawCallback', 'draw', [oSettings] );

    /* Draw is complete, sorting and filtering must be as well */
    oSettings.bSorted = false;
    oSettings.bFiltered = false;
    oSettings.bDrawing = false;
  }


  /**
   * Redraw the table - taking account of the various features which are enabled
   *  @param {object} oSettings dataTables settings object
   *  @param {boolean} [holdPosition] Keep the current paging position. By default
   *    the paging is reset to the first page
   *  @memberof DataTable#oApi
   */
  function _fnReDraw( settings, holdPosition )
  {
    var
      features = settings.oFeatures,
      sort     = features.bSort,
      filter   = features.bFilter;

    if ( sort ) {
      _fnSort( settings );
    }

    if ( filter ) {
      _fnFilterComplete( settings, settings.oPreviousSearch );
    }
    else {
      // No filtering, so we want to just use the display master
      settings.aiDisplay = settings.aiDisplayMaster.slice();
    }

    if ( holdPosition !== true ) {
      settings._iDisplayStart = 0;
    }

    // Let any modules know about the draw hold position state (used by
    // scrolling internally)
    settings._drawHold = holdPosition;

    _fnDraw( settings );

    settings._drawHold = false;
  }


  /**
   * Add the options to the page HTML for the table
   *  @param {object} oSettings dataTables settings object
   *  @memberof DataTable#oApi
   */
  function _fnAddOptionsHtml ( oSettings )
  {
    var classes = oSettings.oClasses;
    var table = $(oSettings.nTable);
    var holding = $('<div/>').insertBefore( table ); // Holding element for speed
    var features = oSettings.oFeatures;

    // All DataTables are wrapped in a div
    var insert = $('<div/>', {
      id:      oSettings.sTableId+'_wrapper',
      'class': classes.sWrapper + (oSettings.nTFoot ? '' : ' '+classes.sNoFooter)
    } );

    oSettings.nHolding = holding[0];
    oSettings.nTableWrapper = insert[0];
    oSettings.nTableReinsertBefore = oSettings.nTable.nextSibling;

    /* Loop over the user set positioning and place the elements as needed */
    var aDom = oSettings.sDom.split('');
    var featureNode, cOption, nNewNode, cNext, sAttr, j;
    for ( var i=0 ; i<aDom.length ; i++ )
    {
      featureNode = null;
      cOption = aDom[i];

      if ( cOption == '<' )
      {
        /* New container div */
        nNewNode = $('<div/>')[0];

        /* Check to see if we should append an id and/or a class name to the container */
        cNext = aDom[i+1];
        if ( cNext == "'" || cNext == '"' )
        {
          sAttr = "";
          j = 2;
          while ( aDom[i+j] != cNext )
          {
            sAttr += aDom[i+j];
            j++;
          }

          /* Replace jQuery UI constants @todo depreciated */
          if ( sAttr == "H" )
          {
            sAttr = classes.sJUIHeader;
          }
          else if ( sAttr == "F" )
          {
            sAttr = classes.sJUIFooter;
          }

          /* The attribute can be in the format of "#id.class", "#id" or "class" This logic
           * breaks the string into parts and applies them as needed
           */
          if ( sAttr.indexOf('.') != -1 )
          {
            var aSplit = sAttr.split('.');
            nNewNode.id = aSplit[0].substr(1, aSplit[0].length-1);
            nNewNode.className = aSplit[1];
          }
          else if ( sAttr.charAt(0) == "#" )
          {
            nNewNode.id = sAttr.substr(1, sAttr.length-1);
          }
          else
          {
            nNewNode.className = sAttr;
          }

          i += j; /* Move along the position array */
        }

        insert.append( nNewNode );
        insert = $(nNewNode);
      }
      else if ( cOption == '>' )
      {
        /* End container div */
        insert = insert.parent();
      }
      // @todo Move options into their own plugins?
      else if ( cOption == 'l' && features.bPaginate && features.bLengthChange )
      {
        /* Length */
        featureNode = _fnFeatureHtmlLength( oSettings );
      }
      else if ( cOption == 'f' && features.bFilter )
      {
        /* Filter */
        featureNode = _fnFeatureHtmlFilter( oSettings );
      }
      else if ( cOption == 'r' && features.bProcessing )
      {
        /* pRocessing */
        featureNode = _fnFeatureHtmlProcessing( oSettings );
      }
      else if ( cOption == 't' )
      {
        /* Table */
        featureNode = _fnFeatureHtmlTable( oSettings );
      }
      else if ( cOption ==  'i' && features.bInfo )
      {
        /* Info */
        featureNode = _fnFeatureHtmlInfo( oSettings );
      }
      else if ( cOption == 'p' && features.bPaginate )
      {
        /* Pagination */
        featureNode = _fnFeatureHtmlPaginate( oSettings );
      }
      else if ( DataTable.ext.feature.length !== 0 )
      {
        /* Plug-in features */
        var aoFeatures = DataTable.ext.feature;
        for ( var k=0, kLen=aoFeatures.length ; k<kLen ; k++ )
        {
          if ( cOption == aoFeatures[k].cFeature )
          {
            featureNode = aoFeatures[k].fnInit( oSettings );
            break;
          }
        }
      }

      /* Add to the 2D features array */
      if ( featureNode )
      {
        var aanFeatures = oSettings.aanFeatures;

        if ( ! aanFeatures[cOption] )
        {
          aanFeatures[cOption] = [];
        }

        aanFeatures[cOption].push( featureNode );
        insert.append( featureNode );
      }
    }

    /* Built our DOM structure - replace the holding div with what we want */
    holding.replaceWith( insert );
    oSettings.nHolding = null;
  }


  /**
   * Use the DOM source to create up an array of header cells. The idea here is to
   * create a layout grid (array) of rows x columns, which contains a reference
   * to the cell that that point in the grid (regardless of col/rowspan), such that
   * any column / row could be removed and the new grid constructed
   *  @param array {object} aLayout Array to store the calculated layout in
   *  @param {node} nThead The header/footer element for the table
   *  @memberof DataTable#oApi
   */
  function _fnDetectHeader ( aLayout, nThead )
  {
    var nTrs = $(nThead).children('tr');
    var nTr, nCell;
    var i, k, l, iLen, jLen, iColShifted, iColumn, iColspan, iRowspan;
    var bUnique;
    var fnShiftCol = function ( a, i, j ) {
      var k = a[i];
                  while ( k[j] ) {
        j++;
      }
      return j;
    };

    aLayout.splice( 0, aLayout.length );

    /* We know how many rows there are in the layout - so prep it */
    for ( i=0, iLen=nTrs.length ; i<iLen ; i++ )
    {
      aLayout.push( [] );
    }

    /* Calculate a layout array */
    for ( i=0, iLen=nTrs.length ; i<iLen ; i++ )
    {
      nTr = nTrs[i];
      iColumn = 0;

      /* For every cell in the row... */
      nCell = nTr.firstChild;
      while ( nCell ) {
        if ( nCell.nodeName.toUpperCase() == "TD" ||
             nCell.nodeName.toUpperCase() == "TH" )
        {
          /* Get the col and rowspan attributes from the DOM and sanitise them */
          iColspan = nCell.getAttribute('colspan') * 1;
          iRowspan = nCell.getAttribute('rowspan') * 1;
          iColspan = (!iColspan || iColspan===0 || iColspan===1) ? 1 : iColspan;
          iRowspan = (!iRowspan || iRowspan===0 || iRowspan===1) ? 1 : iRowspan;

          /* There might be colspan cells already in this row, so shift our target
           * accordingly
           */
          iColShifted = fnShiftCol( aLayout, i, iColumn );

          /* Cache calculation for unique columns */
          bUnique = iColspan === 1 ? true : false;

          /* If there is col / rowspan, copy the information into the layout grid */
          for ( l=0 ; l<iColspan ; l++ )
          {
            for ( k=0 ; k<iRowspan ; k++ )
            {
              aLayout[i+k][iColShifted+l] = {
                "cell": nCell,
                "unique": bUnique
              };
              aLayout[i+k].nTr = nTr;
            }
          }
        }
        nCell = nCell.nextSibling;
      }
    }
  }


  /**
   * Get an array of unique th elements, one for each column
   *  @param {object} oSettings dataTables settings object
   *  @param {node} nHeader automatically detect the layout from this node - optional
   *  @param {array} aLayout thead/tfoot layout from _fnDetectHeader - optional
   *  @returns array {node} aReturn list of unique th's
   *  @memberof DataTable#oApi
   */
  function _fnGetUniqueThs ( oSettings, nHeader, aLayout )
  {
    var aReturn = [];
    if ( !aLayout )
    {
      aLayout = oSettings.aoHeader;
      if ( nHeader )
      {
        aLayout = [];
        _fnDetectHeader( aLayout, nHeader );
      }
    }

    for ( var i=0, iLen=aLayout.length ; i<iLen ; i++ )
    {
      for ( var j=0, jLen=aLayout[i].length ; j<jLen ; j++ )
      {
        if ( aLayout[i][j].unique &&
           (!aReturn[j] || !oSettings.bSortCellsTop) )
        {
          aReturn[j] = aLayout[i][j].cell;
        }
      }
    }

    return aReturn;
  }

  /**
   * Create an Ajax call based on the table's settings, taking into account that
   * parameters can have multiple forms, and backwards compatibility.
   *
   * @param {object} oSettings dataTables settings object
   * @param {array} data Data to send to the server, required by
   *     DataTables - may be augmented by developer callbacks
   * @param {function} fn Callback function to run when data is obtained
   */
  function _fnBuildAjax( oSettings, data, fn )
  {
    // Compatibility with 1.9-, allow fnServerData and event to manipulate
    _fnCallbackFire( oSettings, 'aoServerParams', 'serverParams', [data] );

    // Convert to object based for 1.10+ if using the old array scheme which can
    // come from server-side processing or serverParams
    if ( data && $.isArray(data) ) {
      var tmp = {};
      var rbracket = /(.*?)\[\]$/;

      $.each( data, function (key, val) {
        var match = val.name.match(rbracket);

        if ( match ) {
          // Support for arrays
          var name = match[0];

          if ( ! tmp[ name ] ) {
            tmp[ name ] = [];
          }
          tmp[ name ].push( val.value );
        }
        else {
          tmp[val.name] = val.value;
        }
      } );
      data = tmp;
    }

    var ajaxData;
    var ajax = oSettings.ajax;
    var instance = oSettings.oInstance;
    var callback = function ( json ) {
      _fnCallbackFire( oSettings, null, 'xhr', [oSettings, json, oSettings.jqXHR] );
      fn( json );
    };

    if ( $.isPlainObject( ajax ) && ajax.data )
    {
      ajaxData = ajax.data;

      var newData = $.isFunction( ajaxData ) ?
        ajaxData( data, oSettings ) :  // fn can manipulate data or return
        ajaxData;                      // an object object or array to merge

      // If the function returned something, use that alone
      data = $.isFunction( ajaxData ) && newData ?
        newData :
        $.extend( true, data, newData );

      // Remove the data property as we've resolved it already and don't want
      // jQuery to do it again (it is restored at the end of the function)
      delete ajax.data;
    }

    var baseAjax = {
      "data": data,
      "success": function (json) {
        var error = json.error || json.sError;
        if ( error ) {
          _fnLog( oSettings, 0, error );
        }

        oSettings.json = json;
        callback( json );
      },
      "dataType": "json",
      "cache": false,
      "type": oSettings.sServerMethod,
      "error": function (xhr, error, thrown) {
        var ret = _fnCallbackFire( oSettings, null, 'xhr', [oSettings, null, oSettings.jqXHR] );

        if ( $.inArray( true, ret ) === -1 ) {
          if ( error == "parsererror" ) {
            _fnLog( oSettings, 0, 'Invalid JSON response', 1 );
          }
          else if ( xhr.readyState === 4 ) {
            _fnLog( oSettings, 0, 'Ajax error', 7 );
          }
        }

        _fnProcessingDisplay( oSettings, false );
      }
    };

    // Store the data submitted for the API
    oSettings.oAjaxData = data;

    // Allow plug-ins and external processes to modify the data
    _fnCallbackFire( oSettings, null, 'preXhr', [oSettings, data] );

    if ( oSettings.fnServerData )
    {
      // DataTables 1.9- compatibility
      oSettings.fnServerData.call( instance,
        oSettings.sAjaxSource,
        $.map( data, function (val, key) { // Need to convert back to 1.9 trad format
          return { name: key, value: val };
        } ),
        callback,
        oSettings
      );
    }
    else if ( oSettings.sAjaxSource || typeof ajax === 'string' )
    {
      // DataTables 1.9- compatibility
      oSettings.jqXHR = $.ajax( $.extend( baseAjax, {
        url: ajax || oSettings.sAjaxSource
      } ) );
    }
    else if ( $.isFunction( ajax ) )
    {
      // Is a function - let the caller define what needs to be done
      oSettings.jqXHR = ajax.call( instance, data, callback, oSettings );
    }
    else
    {
      // Object to extend the base settings
      oSettings.jqXHR = $.ajax( $.extend( baseAjax, ajax ) );

      // Restore for next time around
      ajax.data = ajaxData;
    }
  }


  /**
   * Update the table using an Ajax call
   *  @param {object} settings dataTables settings object
   *  @returns {boolean} Block the table drawing or not
   *  @memberof DataTable#oApi
   */
  function _fnAjaxUpdate( settings )
  {
    if ( settings.bAjaxDataGet ) {
      settings.iDraw++;
      _fnProcessingDisplay( settings, true );

      _fnBuildAjax(
        settings,
        _fnAjaxParameters( settings ),
        function(json) {
          _fnAjaxUpdateDraw( settings, json );
        }
      );

      return false;
    }
    return true;
  }


  /**
   * Build up the parameters in an object needed for a server-side processing
   * request. Note that this is basically done twice, is different ways - a modern
   * method which is used by default in DataTables 1.10 which uses objects and
   * arrays, or the 1.9- method with is name / value pairs. 1.9 method is used if
   * the sAjaxSource option is used in the initialisation, or the legacyAjax
   * option is set.
   *  @param {object} oSettings dataTables settings object
   *  @returns {bool} block the table drawing or not
   *  @memberof DataTable#oApi
   */
  function _fnAjaxParameters( settings )
  {
    var
      columns = settings.aoColumns,
      columnCount = columns.length,
      features = settings.oFeatures,
      preSearch = settings.oPreviousSearch,
      preColSearch = settings.aoPreSearchCols,
      i, data = [], dataProp, column, columnSearch,
      sort = _fnSortFlatten( settings ),
      displayStart = settings._iDisplayStart,
      displayLength = features.bPaginate !== false ?
        settings._iDisplayLength :
        -1;

    var param = function ( name, value ) {
      data.push( { 'name': name, 'value': value } );
    };

    // DataTables 1.9- compatible method
    param( 'sEcho',          settings.iDraw );
    param( 'iColumns',       columnCount );
    param( 'sColumns',       _pluck( columns, 'sName' ).join(',') );
    param( 'iDisplayStart',  displayStart );
    param( 'iDisplayLength', displayLength );

    // DataTables 1.10+ method
    var d = {
      draw:    settings.iDraw,
      columns: [],
      order:   [],
      start:   displayStart,
      length:  displayLength,
      search:  {
        value: preSearch.sSearch,
        regex: preSearch.bRegex
      }
    };

    for ( i=0 ; i<columnCount ; i++ ) {
      column = columns[i];
      columnSearch = preColSearch[i];
      dataProp = typeof column.mData=="function" ? 'function' : column.mData ;

      d.columns.push( {
        data:       dataProp,
        name:       column.sName,
        searchable: column.bSearchable,
        orderable:  column.bSortable,
        search:     {
          value: columnSearch.sSearch,
          regex: columnSearch.bRegex
        }
      } );

      param( "mDataProp_"+i, dataProp );

      if ( features.bFilter ) {
        param( 'sSearch_'+i,     columnSearch.sSearch );
        param( 'bRegex_'+i,      columnSearch.bRegex );
        param( 'bSearchable_'+i, column.bSearchable );
      }

      if ( features.bSort ) {
        param( 'bSortable_'+i, column.bSortable );
      }
    }

    if ( features.bFilter ) {
      param( 'sSearch', preSearch.sSearch );
      param( 'bRegex', preSearch.bRegex );
    }

    if ( features.bSort ) {
      $.each( sort, function ( i, val ) {
        d.order.push( { column: val.col, dir: val.dir } );

        param( 'iSortCol_'+i, val.col );
        param( 'sSortDir_'+i, val.dir );
      } );

      param( 'iSortingCols', sort.length );
    }

    // If the legacy.ajax parameter is null, then we automatically decide which
    // form to use, based on sAjaxSource
    var legacy = DataTable.ext.legacy.ajax;
    if ( legacy === null ) {
      return settings.sAjaxSource ? data : d;
    }

    // Otherwise, if legacy has been specified then we use that to decide on the
    // form
    return legacy ? data : d;
  }


  /**
   * Data the data from the server (nuking the old) and redraw the table
   *  @param {object} oSettings dataTables settings object
   *  @param {object} json json data return from the server.
   *  @param {string} json.sEcho Tracking flag for DataTables to match requests
   *  @param {int} json.iTotalRecords Number of records in the data set, not accounting for filtering
   *  @param {int} json.iTotalDisplayRecords Number of records in the data set, accounting for filtering
   *  @param {array} json.aaData The data to display on this page
   *  @param {string} [json.sColumns] Column ordering (sName, comma separated)
   *  @memberof DataTable#oApi
   */
  function _fnAjaxUpdateDraw ( settings, json )
  {
    // v1.10 uses camelCase variables, while 1.9 uses Hungarian notation.
    // Support both
    var compat = function ( old, modern ) {
      return json[old] !== undefined ? json[old] : json[modern];
    };

    var data = _fnAjaxDataSrc( settings, json );
    var draw            = compat( 'sEcho',                'draw' );
    var recordsTotal    = compat( 'iTotalRecords',        'recordsTotal' );
    var recordsFiltered = compat( 'iTotalDisplayRecords', 'recordsFiltered' );

    if ( draw ) {
      // Protect against out of sequence returns
      if ( draw*1 < settings.iDraw ) {
        return;
      }
      settings.iDraw = draw * 1;
    }

    _fnClearTable( settings );
    settings._iRecordsTotal   = parseInt(recordsTotal, 10);
    settings._iRecordsDisplay = parseInt(recordsFiltered, 10);

    for ( var i=0, ien=data.length ; i<ien ; i++ ) {
      _fnAddData( settings, data[i] );
    }
    settings.aiDisplay = settings.aiDisplayMaster.slice();

    settings.bAjaxDataGet = false;
    _fnDraw( settings );

    if ( ! settings._bInitComplete ) {
      _fnInitComplete( settings, json );
    }

    settings.bAjaxDataGet = true;
    _fnProcessingDisplay( settings, false );
  }


  /**
   * Get the data from the JSON data source to use for drawing a table. Using
   * `_fnGetObjectDataFn` allows the data to be sourced from a property of the
   * source object, or from a processing function.
   *  @param {object} oSettings dataTables settings object
   *  @param  {object} json Data source object / array from the server
   *  @return {array} Array of data to use
   */
  function _fnAjaxDataSrc ( oSettings, json )
  {
    var dataSrc = $.isPlainObject( oSettings.ajax ) && oSettings.ajax.dataSrc !== undefined ?
      oSettings.ajax.dataSrc :
      oSettings.sAjaxDataProp; // Compatibility with 1.9-.

    // Compatibility with 1.9-. In order to read from aaData, check if the
    // default has been changed, if not, check for aaData
    if ( dataSrc === 'data' ) {
      return json.aaData || json[dataSrc];
    }

    return dataSrc !== "" ?
      _fnGetObjectDataFn( dataSrc )( json ) :
      json;
  }

  /**
   * Generate the node required for filtering text
   *  @returns {node} Filter control element
   *  @param {object} oSettings dataTables settings object
   *  @memberof DataTable#oApi
   */
  function _fnFeatureHtmlFilter ( settings )
  {
    var classes = settings.oClasses;
    var tableId = settings.sTableId;
    var language = settings.oLanguage;
    var previousSearch = settings.oPreviousSearch;
    var features = settings.aanFeatures;
    var input = '<input type="search" class="'+classes.sFilterInput+'"/>';

    var str = language.sSearch;
    str = str.match(/_INPUT_/) ?
      str.replace('_INPUT_', input) :
      str+input;

    var filter = $('<div/>', {
        'id': ! features.f ? tableId+'_filter' : null,
        'class': classes.sFilter
      } )
      .append( $('<label/>' ).append( str ) );

    var searchFn = function() {
      /* Update all other filter input elements for the new display */
      var n = features.f;
      var val = !this.value ? "" : this.value; // mental IE8 fix :-(

      /* Now do the filter */
      if ( val != previousSearch.sSearch ) {
        _fnFilterComplete( settings, {
          "sSearch": val,
          "bRegex": previousSearch.bRegex,
          "bSmart": previousSearch.bSmart ,
          "bCaseInsensitive": previousSearch.bCaseInsensitive
        } );

        // Need to redraw, without resorting
        settings._iDisplayStart = 0;
        _fnDraw( settings );
      }
    };

    var searchDelay = settings.searchDelay !== null ?
      settings.searchDelay :
      _fnDataSource( settings ) === 'ssp' ?
        400 :
        0;

    var jqFilter = $('input', filter)
      .val( previousSearch.sSearch )
      .attr( 'placeholder', language.sSearchPlaceholder )
      .on(
        'keyup.DT search.DT input.DT paste.DT cut.DT',
        searchDelay ?
          _fnThrottle( searchFn, searchDelay ) :
          searchFn
      )
      .on( 'keypress.DT', function(e) {
        /* Prevent form submission */
        if ( e.keyCode == 13 ) {
          return false;
        }
      } )
      .attr('aria-controls', tableId);

    // Update the input elements whenever the table is filtered
    $(settings.nTable).on( 'search.dt.DT', function ( ev, s ) {
      if ( settings === s ) {
        // IE9 throws an 'unknown error' if document.activeElement is used
        // inside an iframe or frame...
        try {
          if ( jqFilter[0] !== document.activeElement ) {
            jqFilter.val( previousSearch.sSearch );
          }
        }
        catch ( e ) {}
      }
    } );

    return filter[0];
  }


  /**
   * Filter the table using both the global filter and column based filtering
   *  @param {object} oSettings dataTables settings object
   *  @param {object} oSearch search information
   *  @param {int} [iForce] force a research of the master array (1) or not (undefined or 0)
   *  @memberof DataTable#oApi
   */
  function _fnFilterComplete ( oSettings, oInput, iForce )
  {
    var oPrevSearch = oSettings.oPreviousSearch;
    var aoPrevSearch = oSettings.aoPreSearchCols;
    var fnSaveFilter = function ( oFilter ) {
      /* Save the filtering values */
      oPrevSearch.sSearch = oFilter.sSearch;
      oPrevSearch.bRegex = oFilter.bRegex;
      oPrevSearch.bSmart = oFilter.bSmart;
      oPrevSearch.bCaseInsensitive = oFilter.bCaseInsensitive;
    };
    var fnRegex = function ( o ) {
      // Backwards compatibility with the bEscapeRegex option
      return o.bEscapeRegex !== undefined ? !o.bEscapeRegex : o.bRegex;
    };

    // Resolve any column types that are unknown due to addition or invalidation
    // @todo As per sort - can this be moved into an event handler?
    _fnColumnTypes( oSettings );

    /* In server-side processing all filtering is done by the server, so no point hanging around here */
    if ( _fnDataSource( oSettings ) != 'ssp' )
    {
      /* Global filter */
      _fnFilter( oSettings, oInput.sSearch, iForce, fnRegex(oInput), oInput.bSmart, oInput.bCaseInsensitive );
      fnSaveFilter( oInput );

      /* Now do the individual column filter */
      for ( var i=0 ; i<aoPrevSearch.length ; i++ )
      {
        _fnFilterColumn( oSettings, aoPrevSearch[i].sSearch, i, fnRegex(aoPrevSearch[i]),
          aoPrevSearch[i].bSmart, aoPrevSearch[i].bCaseInsensitive );
      }

      /* Custom filtering */
      _fnFilterCustom( oSettings );
    }
    else
    {
      fnSaveFilter( oInput );
    }

    /* Tell the draw function we have been filtering */
    oSettings.bFiltered = true;
    _fnCallbackFire( oSettings, null, 'search', [oSettings] );
  }


  /**
   * Apply custom filtering functions
   *  @param {object} oSettings dataTables settings object
   *  @memberof DataTable#oApi
   */
  function _fnFilterCustom( settings )
  {
    var filters = DataTable.ext.search;
    var displayRows = settings.aiDisplay;
    var row, rowIdx;

    for ( var i=0, ien=filters.length ; i<ien ; i++ ) {
      var rows = [];

      // Loop over each row and see if it should be included
      for ( var j=0, jen=displayRows.length ; j<jen ; j++ ) {
        rowIdx = displayRows[ j ];
        row = settings.aoData[ rowIdx ];

        if ( filters[i]( settings, row._aFilterData, rowIdx, row._aData, j ) ) {
          rows.push( rowIdx );
        }
      }

      // So the array reference doesn't break set the results into the
      // existing array
      displayRows.length = 0;
      $.merge( displayRows, rows );
    }
  }


  /**
   * Filter the table on a per-column basis
   *  @param {object} oSettings dataTables settings object
   *  @param {string} sInput string to filter on
   *  @param {int} iColumn column to filter
   *  @param {bool} bRegex treat search string as a regular expression or not
   *  @param {bool} bSmart use smart filtering or not
   *  @param {bool} bCaseInsensitive Do case insenstive matching or not
   *  @memberof DataTable#oApi
   */
  function _fnFilterColumn ( settings, searchStr, colIdx, regex, smart, caseInsensitive )
  {
    if ( searchStr === '' ) {
      return;
    }

    var data;
    var out = [];
    var display = settings.aiDisplay;
    var rpSearch = _fnFilterCreateSearch( searchStr, regex, smart, caseInsensitive );

    for ( var i=0 ; i<display.length ; i++ ) {
      data = settings.aoData[ display[i] ]._aFilterData[ colIdx ];

      if ( rpSearch.test( data ) ) {
        out.push( display[i] );
      }
    }

    settings.aiDisplay = out;
  }


  /**
   * Filter the data table based on user input and draw the table
   *  @param {object} settings dataTables settings object
   *  @param {string} input string to filter on
   *  @param {int} force optional - force a research of the master array (1) or not (undefined or 0)
   *  @param {bool} regex treat as a regular expression or not
   *  @param {bool} smart perform smart filtering or not
   *  @param {bool} caseInsensitive Do case insenstive matching or not
   *  @memberof DataTable#oApi
   */
  function _fnFilter( settings, input, force, regex, smart, caseInsensitive )
  {
    var rpSearch = _fnFilterCreateSearch( input, regex, smart, caseInsensitive );
    var prevSearch = settings.oPreviousSearch.sSearch;
    var displayMaster = settings.aiDisplayMaster;
    var display, invalidated, i;
    var filtered = [];

    // Need to take account of custom filtering functions - always filter
    if ( DataTable.ext.search.length !== 0 ) {
      force = true;
    }

    // Check if any of the rows were invalidated
    invalidated = _fnFilterData( settings );

    // If the input is blank - we just want the full data set
    if ( input.length <= 0 ) {
      settings.aiDisplay = displayMaster.slice();
    }
    else {
      // New search - start from the master array
      if ( invalidated ||
         force ||
         prevSearch.length > input.length ||
         input.indexOf(prevSearch) !== 0 ||
         settings.bSorted // On resort, the display master needs to be
                          // re-filtered since indexes will have changed
      ) {
        settings.aiDisplay = displayMaster.slice();
      }

      // Search the display array
      display = settings.aiDisplay;

      for ( i=0 ; i<display.length ; i++ ) {
        if ( rpSearch.test( settings.aoData[ display[i] ]._sFilterRow ) ) {
          filtered.push( display[i] );
        }
      }

      settings.aiDisplay = filtered;
    }
  }


  /**
   * Build a regular expression object suitable for searching a table
   *  @param {string} sSearch string to search for
   *  @param {bool} bRegex treat as a regular expression or not
   *  @param {bool} bSmart perform smart filtering or not
   *  @param {bool} bCaseInsensitive Do case insensitive matching or not
   *  @returns {RegExp} constructed object
   *  @memberof DataTable#oApi
   */
  function _fnFilterCreateSearch( search, regex, smart, caseInsensitive )
  {
    search = regex ?
      search :
      _fnEscapeRegex( search );

    if ( smart ) {
      /* For smart filtering we want to allow the search to work regardless of
       * word order. We also want double quoted text to be preserved, so word
       * order is important - a la google. So this is what we want to
       * generate:
       *
       * ^(?=.*?\bone\b)(?=.*?\btwo three\b)(?=.*?\bfour\b).*$
       */
      var a = $.map( search.match( /"[^"]+"|[^ ]+/g ) || [''], function ( word ) {
        if ( word.charAt(0) === '"' ) {
          var m = word.match( /^"(.*)"$/ );
          word = m ? m[1] : word;
        }

        return word.replace('"', '');
      } );

      search = '^(?=.*?'+a.join( ')(?=.*?' )+').*$';
    }

    return new RegExp( search, caseInsensitive ? 'i' : '' );
  }


  /**
   * Escape a string such that it can be used in a regular expression
   *  @param {string} sVal string to escape
   *  @returns {string} escaped string
   *  @memberof DataTable#oApi
   */
  var _fnEscapeRegex = DataTable.util.escapeRegex;

  var __filter_div = $('<div>')[0];
  var __filter_div_textContent = __filter_div.textContent !== undefined;

  // Update the filtering data for each row if needed (by invalidation or first run)
  function _fnFilterData ( settings )
  {
    var columns = settings.aoColumns;
    var column;
    var i, j, ien, jen, filterData, cellData, row;
    var fomatters = DataTable.ext.type.search;
    var wasInvalidated = false;

    for ( i=0, ien=settings.aoData.length ; i<ien ; i++ ) {
      row = settings.aoData[i];

      if ( ! row._aFilterData ) {
        filterData = [];

        for ( j=0, jen=columns.length ; j<jen ; j++ ) {
          column = columns[j];

          if ( column.bSearchable ) {
            cellData = _fnGetCellData( settings, i, j, 'filter' );

            if ( fomatters[ column.sType ] ) {
              cellData = fomatters[ column.sType ]( cellData );
            }

            // Search in DataTables 1.10 is string based. In 1.11 this
            // should be altered to also allow strict type checking.
            if ( cellData === null ) {
              cellData = '';
            }

            if ( typeof cellData !== 'string' && cellData.toString ) {
              cellData = cellData.toString();
            }
          }
          else {
            cellData = '';
          }

          // If it looks like there is an HTML entity in the string,
          // attempt to decode it so sorting works as expected. Note that
          // we could use a single line of jQuery to do this, but the DOM
          // method used here is much faster http://jsperf.com/html-decode
          if ( cellData.indexOf && cellData.indexOf('&') !== -1 ) {
            __filter_div.innerHTML = cellData;
            cellData = __filter_div_textContent ?
              __filter_div.textContent :
              __filter_div.innerText;
          }

          if ( cellData.replace ) {
            cellData = cellData.replace(/[\r\n]/g, '');
          }

          filterData.push( cellData );
        }

        row._aFilterData = filterData;
        row._sFilterRow = filterData.join('  ');
        wasInvalidated = true;
      }
    }

    return wasInvalidated;
  }


  /**
   * Convert from the internal Hungarian notation to camelCase for external
   * interaction
   *  @param {object} obj Object to convert
   *  @returns {object} Inverted object
   *  @memberof DataTable#oApi
   */
  function _fnSearchToCamel ( obj )
  {
    return {
      search:          obj.sSearch,
      smart:           obj.bSmart,
      regex:           obj.bRegex,
      caseInsensitive: obj.bCaseInsensitive
    };
  }



  /**
   * Convert from camelCase notation to the internal Hungarian. We could use the
   * Hungarian convert function here, but this is cleaner
   *  @param {object} obj Object to convert
   *  @returns {object} Inverted object
   *  @memberof DataTable#oApi
   */
  function _fnSearchToHung ( obj )
  {
    return {
      sSearch:          obj.search,
      bSmart:           obj.smart,
      bRegex:           obj.regex,
      bCaseInsensitive: obj.caseInsensitive
    };
  }

  /**
   * Generate the node required for the info display
   *  @param {object} oSettings dataTables settings object
   *  @returns {node} Information element
   *  @memberof DataTable#oApi
   */
  function _fnFeatureHtmlInfo ( settings )
  {
    var
      tid = settings.sTableId,
      nodes = settings.aanFeatures.i,
      n = $('<div/>', {
        'class': settings.oClasses.sInfo,
        'id': ! nodes ? tid+'_info' : null
      } );

    if ( ! nodes ) {
      // Update display on each draw
      settings.aoDrawCallback.push( {
        "fn": _fnUpdateInfo,
        "sName": "information"
      } );

      n
        .attr( 'role', 'status' )
        .attr( 'aria-live', 'polite' );

      // Table is described by our info div
      $(settings.nTable).attr( 'aria-describedby', tid+'_info' );
    }

    return n[0];
  }


  /**
   * Update the information elements in the display
   *  @param {object} settings dataTables settings object
   *  @memberof DataTable#oApi
   */
  function _fnUpdateInfo ( settings )
  {
    /* Show information about the table */
    var nodes = settings.aanFeatures.i;
    if ( nodes.length === 0 ) {
      return;
    }

    var
      lang  = settings.oLanguage,
      start = settings._iDisplayStart+1,
      end   = settings.fnDisplayEnd(),
      max   = settings.fnRecordsTotal(),
      total = settings.fnRecordsDisplay(),
      out   = total ?
        lang.sInfo :
        lang.sInfoEmpty;

    if ( total !== max ) {
      /* Record set after filtering */
      out += ' ' + lang.sInfoFiltered;
    }

    // Convert the macros
    out += lang.sInfoPostFix;
    out = _fnInfoMacros( settings, out );

    var callback = lang.fnInfoCallback;
    if ( callback !== null ) {
      out = callback.call( settings.oInstance,
        settings, start, end, max, total, out
      );
    }

    $(nodes).html( out );
  }


  function _fnInfoMacros ( settings, str )
  {
    // When infinite scrolling, we are always starting at 1. _iDisplayStart is used only
    // internally
    var
      formatter  = settings.fnFormatNumber,
      start      = settings._iDisplayStart+1,
      len        = settings._iDisplayLength,
      vis        = settings.fnRecordsDisplay(),
      all        = len === -1;

    return str.
      replace(/_START_/g, formatter.call( settings, start ) ).
      replace(/_END_/g,   formatter.call( settings, settings.fnDisplayEnd() ) ).
      replace(/_MAX_/g,   formatter.call( settings, settings.fnRecordsTotal() ) ).
      replace(/_TOTAL_/g, formatter.call( settings, vis ) ).
      replace(/_PAGE_/g,  formatter.call( settings, all ? 1 : Math.ceil( start / len ) ) ).
      replace(/_PAGES_/g, formatter.call( settings, all ? 1 : Math.ceil( vis / len ) ) );
  }



  /**
   * Draw the table for the first time, adding all required features
   *  @param {object} settings dataTables settings object
   *  @memberof DataTable#oApi
   */
  function _fnInitialise ( settings )
  {
    var i, iLen, iAjaxStart=settings.iInitDisplayStart;
    var columns = settings.aoColumns, column;
    var features = settings.oFeatures;
    var deferLoading = settings.bDeferLoading; // value modified by the draw

    /* Ensure that the table data is fully initialised */
    if ( ! settings.bInitialised ) {
      setTimeout( function(){ _fnInitialise( settings ); }, 200 );
      return;
    }

    /* Show the display HTML options */
    _fnAddOptionsHtml( settings );

    /* Build and draw the header / footer for the table */
    _fnBuildHead( settings );
    _fnDrawHead( settings, settings.aoHeader );
    _fnDrawHead( settings, settings.aoFooter );

    /* Okay to show that something is going on now */
    _fnProcessingDisplay( settings, true );

    /* Calculate sizes for columns */
    if ( features.bAutoWidth ) {
      _fnCalculateColumnWidths( settings );
    }

    for ( i=0, iLen=columns.length ; i<iLen ; i++ ) {
      column = columns[i];

      if ( column.sWidth ) {
        column.nTh.style.width = _fnStringToCss( column.sWidth );
      }
    }

    _fnCallbackFire( settings, null, 'preInit', [settings] );

    // If there is default sorting required - let's do it. The sort function
    // will do the drawing for us. Otherwise we draw the table regardless of the
    // Ajax source - this allows the table to look initialised for Ajax sourcing
    // data (show 'loading' message possibly)
    _fnReDraw( settings );

    // Server-side processing init complete is done by _fnAjaxUpdateDraw
    var dataSrc = _fnDataSource( settings );
    if ( dataSrc != 'ssp' || deferLoading ) {
      // if there is an ajax source load the data
      if ( dataSrc == 'ajax' ) {
        _fnBuildAjax( settings, [], function(json) {
          var aData = _fnAjaxDataSrc( settings, json );

          // Got the data - add it to the table
          for ( i=0 ; i<aData.length ; i++ ) {
            _fnAddData( settings, aData[i] );
          }

          // Reset the init display for cookie saving. We've already done
          // a filter, and therefore cleared it before. So we need to make
          // it appear 'fresh'
          settings.iInitDisplayStart = iAjaxStart;

          _fnReDraw( settings );

          _fnProcessingDisplay( settings, false );
          _fnInitComplete( settings, json );
        }, settings );
      }
      else {
        _fnProcessingDisplay( settings, false );
        _fnInitComplete( settings );
      }
    }
  }


  /**
   * Draw the table for the first time, adding all required features
   *  @param {object} oSettings dataTables settings object
   *  @param {object} [json] JSON from the server that completed the table, if using Ajax source
   *    with client-side processing (optional)
   *  @memberof DataTable#oApi
   */
  function _fnInitComplete ( settings, json )
  {
    settings._bInitComplete = true;

    // When data was added after the initialisation (data or Ajax) we need to
    // calculate the column sizing
    if ( json || settings.oInit.aaData ) {
      _fnAdjustColumnSizing( settings );
    }

    _fnCallbackFire( settings, null, 'plugin-init', [settings, json] );
    _fnCallbackFire( settings, 'aoInitComplete', 'init', [settings, json] );
  }


  function _fnLengthChange ( settings, val )
  {
    var len = parseInt( val, 10 );
    settings._iDisplayLength = len;

    _fnLengthOverflow( settings );

    // Fire length change event
    _fnCallbackFire( settings, null, 'length', [settings, len] );
  }


  /**
   * Generate the node required for user display length changing
   *  @param {object} settings dataTables settings object
   *  @returns {node} Display length feature node
   *  @memberof DataTable#oApi
   */
  function _fnFeatureHtmlLength ( settings )
  {
    var
      classes  = settings.oClasses,
      tableId  = settings.sTableId,
      menu     = settings.aLengthMenu,
      d2       = $.isArray( menu[0] ),
      lengths  = d2 ? menu[0] : menu,
      language = d2 ? menu[1] : menu;

    var select = $('<select/>', {
      'name':          tableId+'_length',
      'aria-controls': tableId,
      'class':         classes.sLengthSelect
    } );

    for ( var i=0, ien=lengths.length ; i<ien ; i++ ) {
      select[0][ i ] = new Option(
        typeof language[i] === 'number' ?
          settings.fnFormatNumber( language[i] ) :
          language[i],
        lengths[i]
      );
    }

    var div = $('<div><label/></div>').addClass( classes.sLength );
    if ( ! settings.aanFeatures.l ) {
      div[0].id = tableId+'_length';
    }

    div.children().append(
      settings.oLanguage.sLengthMenu.replace( '_MENU_', select[0].outerHTML )
    );

    // Can't use `select` variable as user might provide their own and the
    // reference is broken by the use of outerHTML
    $('select', div)
      .val( settings._iDisplayLength )
      .on( 'change.DT', function(e) {
        _fnLengthChange( settings, $(this).val() );
        _fnDraw( settings );
      } );

    // Update node value whenever anything changes the table's length
    $(settings.nTable).on( 'length.dt.DT', function (e, s, len) {
      if ( settings === s ) {
        $('select', div).val( len );
      }
    } );

    return div[0];
  }



  /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
   * Note that most of the paging logic is done in
   * DataTable.ext.pager
   */

  /**
   * Generate the node required for default pagination
   *  @param {object} oSettings dataTables settings object
   *  @returns {node} Pagination feature node
   *  @memberof DataTable#oApi
   */
  function _fnFeatureHtmlPaginate ( settings )
  {
    var
      type   = settings.sPaginationType,
      plugin = DataTable.ext.pager[ type ],
      modern = typeof plugin === 'function',
      redraw = function( settings ) {
        _fnDraw( settings );
      },
      node = $('<div/>').addClass( settings.oClasses.sPaging + type )[0],
      features = settings.aanFeatures;

    if ( ! modern ) {
      plugin.fnInit( settings, node, redraw );
    }

    /* Add a draw callback for the pagination on first instance, to update the paging display */
    if ( ! features.p )
    {
      node.id = settings.sTableId+'_paginate';

      settings.aoDrawCallback.push( {
        "fn": function( settings ) {
          if ( modern ) {
            var
              start      = settings._iDisplayStart,
              len        = settings._iDisplayLength,
              visRecords = settings.fnRecordsDisplay(),
              all        = len === -1,
              page = all ? 0 : Math.ceil( start / len ),
              pages = all ? 1 : Math.ceil( visRecords / len ),
              buttons = plugin(page, pages),
              i, ien;

            for ( i=0, ien=features.p.length ; i<ien ; i++ ) {
              _fnRenderer( settings, 'pageButton' )(
                settings, features.p[i], i, buttons, page, pages
              );
            }
          }
          else {
            plugin.fnUpdate( settings, redraw );
          }
        },
        "sName": "pagination"
      } );
    }

    return node;
  }


  /**
   * Alter the display settings to change the page
   *  @param {object} settings DataTables settings object
   *  @param {string|int} action Paging action to take: "first", "previous",
   *    "next" or "last" or page number to jump to (integer)
   *  @param [bool] redraw Automatically draw the update or not
   *  @returns {bool} true page has changed, false - no change
   *  @memberof DataTable#oApi
   */
  function _fnPageChange ( settings, action, redraw )
  {
    var
      start     = settings._iDisplayStart,
      len       = settings._iDisplayLength,
      records   = settings.fnRecordsDisplay();

    if ( records === 0 || len === -1 )
    {
      start = 0;
    }
    else if ( typeof action === "number" )
    {
      start = action * len;

      if ( start > records )
      {
        start = 0;
      }
    }
    else if ( action == "first" )
    {
      start = 0;
    }
    else if ( action == "previous" )
    {
      start = len >= 0 ?
        start - len :
        0;

      if ( start < 0 )
      {
        start = 0;
      }
    }
    else if ( action == "next" )
    {
      if ( start + len < records )
      {
        start += len;
      }
    }
    else if ( action == "last" )
    {
      start = Math.floor( (records-1) / len) * len;
    }
    else
    {
      _fnLog( settings, 0, "Unknown paging action: "+action, 5 );
    }

    var changed = settings._iDisplayStart !== start;
    settings._iDisplayStart = start;

    if ( changed ) {
      _fnCallbackFire( settings, null, 'page', [settings] );

      if ( redraw ) {
        _fnDraw( settings );
      }
    }

    return changed;
  }



  /**
   * Generate the node required for the processing node
   *  @param {object} settings dataTables settings object
   *  @returns {node} Processing element
   *  @memberof DataTable#oApi
   */
  function _fnFeatureHtmlProcessing ( settings )
  {
    return $('<div/>', {
        'id': ! settings.aanFeatures.r ? settings.sTableId+'_processing' : null,
        'class': settings.oClasses.sProcessing
      } )
      .html( settings.oLanguage.sProcessing )
      .insertBefore( settings.nTable )[0];
  }


  /**
   * Display or hide the processing indicator
   *  @param {object} settings dataTables settings object
   *  @param {bool} show Show the processing indicator (true) or not (false)
   *  @memberof DataTable#oApi
   */
  function _fnProcessingDisplay ( settings, show )
  {
    if ( settings.oFeatures.bProcessing ) {
      $(settings.aanFeatures.r).css( 'display', show ? 'block' : 'none' );
    }

    _fnCallbackFire( settings, null, 'processing', [settings, show] );
  }

  /**
   * Add any control elements for the table - specifically scrolling
   *  @param {object} settings dataTables settings object
   *  @returns {node} Node to add to the DOM
   *  @memberof DataTable#oApi
   */
  function _fnFeatureHtmlTable ( settings )
  {
    var table = $(settings.nTable);

    // Add the ARIA grid role to the table
    table.attr( 'role', 'grid' );

    // Scrolling from here on in
    var scroll = settings.oScroll;

    if ( scroll.sX === '' && scroll.sY === '' ) {
      return settings.nTable;
    }

    var scrollX = scroll.sX;
    var scrollY = scroll.sY;
    var classes = settings.oClasses;
    var caption = table.children('caption');
    var captionSide = caption.length ? caption[0]._captionSide : null;
    var headerClone = $( table[0].cloneNode(false) );
    var footerClone = $( table[0].cloneNode(false) );
    var footer = table.children('tfoot');
    var _div = '<div/>';
    var size = function ( s ) {
      return !s ? null : _fnStringToCss( s );
    };

    if ( ! footer.length ) {
      footer = null;
    }

    /*
     * The HTML structure that we want to generate in this function is:
     *  div - scroller
     *    div - scroll head
     *      div - scroll head inner
     *        table - scroll head table
     *          thead - thead
     *    div - scroll body
     *      table - table (master table)
     *        thead - thead clone for sizing
     *        tbody - tbody
     *    div - scroll foot
     *      div - scroll foot inner
     *        table - scroll foot table
     *          tfoot - tfoot
     */
    var scroller = $( _div, { 'class': classes.sScrollWrapper } )
      .append(
        $(_div, { 'class': classes.sScrollHead } )
          .css( {
            overflow: 'hidden',
            position: 'relative',
            border: 0,
            width: scrollX ? size(scrollX) : '100%'
          } )
          .append(
            $(_div, { 'class': classes.sScrollHeadInner } )
              .css( {
                'box-sizing': 'content-box',
                width: scroll.sXInner || '100%'
              } )
              .append(
                headerClone
                  .removeAttr('id')
                  .css( 'margin-left', 0 )
                  .append( captionSide === 'top' ? caption : null )
                  .append(
                    table.children('thead')
                  )
              )
          )
      )
      .append(
        $(_div, { 'class': classes.sScrollBody } )
          .css( {
            position: 'relative',
            overflow: 'auto',
            width: size( scrollX )
          } )
          .append( table )
      );

    if ( footer ) {
      scroller.append(
        $(_div, { 'class': classes.sScrollFoot } )
          .css( {
            overflow: 'hidden',
            border: 0,
            width: scrollX ? size(scrollX) : '100%'
          } )
          .append(
            $(_div, { 'class': classes.sScrollFootInner } )
              .append(
                footerClone
                  .removeAttr('id')
                  .css( 'margin-left', 0 )
                  .append( captionSide === 'bottom' ? caption : null )
                  .append(
                    table.children('tfoot')
                  )
              )
          )
      );
    }

    var children = scroller.children();
    var scrollHead = children[0];
    var scrollBody = children[1];
    var scrollFoot = footer ? children[2] : null;

    // When the body is scrolled, then we also want to scroll the headers
    if ( scrollX ) {
      $(scrollBody).on( 'scroll.DT', function (e) {
        var scrollLeft = this.scrollLeft;

        scrollHead.scrollLeft = scrollLeft;

        if ( footer ) {
          scrollFoot.scrollLeft = scrollLeft;
        }
      } );
    }

    $(scrollBody).css(
      scrollY && scroll.bCollapse ? 'max-height' : 'height',
      scrollY
    );

    settings.nScrollHead = scrollHead;
    settings.nScrollBody = scrollBody;
    settings.nScrollFoot = scrollFoot;

    // On redraw - align columns
    settings.aoDrawCallback.push( {
      "fn": _fnScrollDraw,
      "sName": "scrolling"
    } );

    return scroller[0];
  }



  /**
   * Update the header, footer and body tables for resizing - i.e. column
   * alignment.
   *
   * Welcome to the most horrible function DataTables. The process that this
   * function follows is basically:
   *   1. Re-create the table inside the scrolling div
   *   2. Take live measurements from the DOM
   *   3. Apply the measurements to align the columns
   *   4. Clean up
   *
   *  @param {object} settings dataTables settings object
   *  @memberof DataTable#oApi
   */
  function _fnScrollDraw ( settings )
  {
    // Given that this is such a monster function, a lot of variables are use
    // to try and keep the minimised size as small as possible
    var
      scroll         = settings.oScroll,
      scrollX        = scroll.sX,
      scrollXInner   = scroll.sXInner,
      scrollY        = scroll.sY,
      barWidth       = scroll.iBarWidth,
      divHeader      = $(settings.nScrollHead),
      divHeaderStyle = divHeader[0].style,
      divHeaderInner = divHeader.children('div'),
      divHeaderInnerStyle = divHeaderInner[0].style,
      divHeaderTable = divHeaderInner.children('table'),
      divBodyEl      = settings.nScrollBody,
      divBody        = $(divBodyEl),
      divBodyStyle   = divBodyEl.style,
      divFooter      = $(settings.nScrollFoot),
      divFooterInner = divFooter.children('div'),
      divFooterTable = divFooterInner.children('table'),
      header         = $(settings.nTHead),
      table          = $(settings.nTable),
      tableEl        = table[0],
      tableStyle     = tableEl.style,
      footer         = settings.nTFoot ? $(settings.nTFoot) : null,
      browser        = settings.oBrowser,
      ie67           = browser.bScrollOversize,
      dtHeaderCells  = _pluck( settings.aoColumns, 'nTh' ),
      headerTrgEls, footerTrgEls,
      headerSrcEls, footerSrcEls,
      headerCopy, footerCopy,
      headerWidths=[], footerWidths=[],
      headerContent=[], footerContent=[],
      idx, correction, sanityWidth,
      zeroOut = function(nSizer) {
        var style = nSizer.style;
        style.paddingTop = "0";
        style.paddingBottom = "0";
        style.borderTopWidth = "0";
        style.borderBottomWidth = "0";
        style.height = 0;
      };

    // If the scrollbar visibility has changed from the last draw, we need to
    // adjust the column sizes as the table width will have changed to account
    // for the scrollbar
    var scrollBarVis = divBodyEl.scrollHeight > divBodyEl.clientHeight;

    if ( settings.scrollBarVis !== scrollBarVis && settings.scrollBarVis !== undefined ) {
      settings.scrollBarVis = scrollBarVis;
      _fnAdjustColumnSizing( settings );
      return; // adjust column sizing will call this function again
    }
    else {
      settings.scrollBarVis = scrollBarVis;
    }

    /*
     * 1. Re-create the table inside the scrolling div
     */

    // Remove the old minimised thead and tfoot elements in the inner table
    table.children('thead, tfoot').remove();

    if ( footer ) {
      footerCopy = footer.clone().prependTo( table );
      footerTrgEls = footer.find('tr'); // the original tfoot is in its own table and must be sized
      footerSrcEls = footerCopy.find('tr');
    }

    // Clone the current header and footer elements and then place it into the inner table
    headerCopy = header.clone().prependTo( table );
    headerTrgEls = header.find('tr'); // original header is in its own table
    headerSrcEls = headerCopy.find('tr');
    headerCopy.find('th, td').removeAttr('tabindex');


    /*
     * 2. Take live measurements from the DOM - do not alter the DOM itself!
     */

    // Remove old sizing and apply the calculated column widths
    // Get the unique column headers in the newly created (cloned) header. We want to apply the
    // calculated sizes to this header
    if ( ! scrollX )
    {
      divBodyStyle.width = '100%';
      divHeader[0].style.width = '100%';
    }

    $.each( _fnGetUniqueThs( settings, headerCopy ), function ( i, el ) {
      idx = _fnVisibleToColumnIndex( settings, i );
      el.style.width = settings.aoColumns[idx].sWidth;
    } );

    if ( footer ) {
      _fnApplyToChildren( function(n) {
        n.style.width = "";
      }, footerSrcEls );
    }

    // Size the table as a whole
    sanityWidth = table.outerWidth();
    if ( scrollX === "" ) {
      // No x scrolling
      tableStyle.width = "100%";

      // IE7 will make the width of the table when 100% include the scrollbar
      // - which is shouldn't. When there is a scrollbar we need to take this
      // into account.
      if ( ie67 && (table.find('tbody').height() > divBodyEl.offsetHeight ||
        divBody.css('overflow-y') == "scroll")
      ) {
        tableStyle.width = _fnStringToCss( table.outerWidth() - barWidth);
      }

      // Recalculate the sanity width
      sanityWidth = table.outerWidth();
    }
    else if ( scrollXInner !== "" ) {
      // legacy x scroll inner has been given - use it
      tableStyle.width = _fnStringToCss(scrollXInner);

      // Recalculate the sanity width
      sanityWidth = table.outerWidth();
    }

    // Hidden header should have zero height, so remove padding and borders. Then
    // set the width based on the real headers

    // Apply all styles in one pass
    _fnApplyToChildren( zeroOut, headerSrcEls );

    // Read all widths in next pass
    _fnApplyToChildren( function(nSizer) {
      headerContent.push( nSizer.innerHTML );
      headerWidths.push( _fnStringToCss( $(nSizer).css('width') ) );
    }, headerSrcEls );

    // Apply all widths in final pass
    _fnApplyToChildren( function(nToSize, i) {
      // Only apply widths to the DataTables detected header cells - this
      // prevents complex headers from having contradictory sizes applied
      if ( $.inArray( nToSize, dtHeaderCells ) !== -1 ) {
        nToSize.style.width = headerWidths[i];
      }
    }, headerTrgEls );

    $(headerSrcEls).height(0);

    /* Same again with the footer if we have one */
    if ( footer )
    {
      _fnApplyToChildren( zeroOut, footerSrcEls );

      _fnApplyToChildren( function(nSizer) {
        footerContent.push( nSizer.innerHTML );
        footerWidths.push( _fnStringToCss( $(nSizer).css('width') ) );
      }, footerSrcEls );

      _fnApplyToChildren( function(nToSize, i) {
        nToSize.style.width = footerWidths[i];
      }, footerTrgEls );

      $(footerSrcEls).height(0);
    }


    /*
     * 3. Apply the measurements
     */

    // "Hide" the header and footer that we used for the sizing. We need to keep
    // the content of the cell so that the width applied to the header and body
    // both match, but we want to hide it completely. We want to also fix their
    // width to what they currently are
    _fnApplyToChildren( function(nSizer, i) {
      nSizer.innerHTML = '<div class="dataTables_sizing" style="height:0;overflow:hidden;">'+headerContent[i]+'</div>';
      nSizer.style.width = headerWidths[i];
    }, headerSrcEls );

    if ( footer )
    {
      _fnApplyToChildren( function(nSizer, i) {
        nSizer.innerHTML = '<div class="dataTables_sizing" style="height:0;overflow:hidden;">'+footerContent[i]+'</div>';
        nSizer.style.width = footerWidths[i];
      }, footerSrcEls );
    }

    // Sanity check that the table is of a sensible width. If not then we are going to get
    // misalignment - try to prevent this by not allowing the table to shrink below its min width
    if ( table.outerWidth() < sanityWidth )
    {
      // The min width depends upon if we have a vertical scrollbar visible or not */
      correction = ((divBodyEl.scrollHeight > divBodyEl.offsetHeight ||
        divBody.css('overflow-y') == "scroll")) ?
          sanityWidth+barWidth :
          sanityWidth;

      // IE6/7 are a law unto themselves...
      if ( ie67 && (divBodyEl.scrollHeight >
        divBodyEl.offsetHeight || divBody.css('overflow-y') == "scroll")
      ) {
        tableStyle.width = _fnStringToCss( correction-barWidth );
      }

      // And give the user a warning that we've stopped the table getting too small
      if ( scrollX === "" || scrollXInner !== "" ) {
        _fnLog( settings, 1, 'Possible column misalignment', 6 );
      }
    }
    else
    {
      correction = '100%';
    }

    // Apply to the container elements
    divBodyStyle.width = _fnStringToCss( correction );
    divHeaderStyle.width = _fnStringToCss( correction );

    if ( footer ) {
      settings.nScrollFoot.style.width = _fnStringToCss( correction );
    }


    /*
     * 4. Clean up
     */
    if ( ! scrollY ) {
      /* IE7< puts a vertical scrollbar in place (when it shouldn't be) due to subtracting
       * the scrollbar height from the visible display, rather than adding it on. We need to
       * set the height in order to sort this. Don't want to do it in any other browsers.
       */
      if ( ie67 ) {
        divBodyStyle.height = _fnStringToCss( tableEl.offsetHeight+barWidth );
      }
    }

    /* Finally set the width's of the header and footer tables */
    var iOuterWidth = table.outerWidth();
    divHeaderTable[0].style.width = _fnStringToCss( iOuterWidth );
    divHeaderInnerStyle.width = _fnStringToCss( iOuterWidth );

    // Figure out if there are scrollbar present - if so then we need a the header and footer to
    // provide a bit more space to allow "overflow" scrolling (i.e. past the scrollbar)
    var bScrolling = table.height() > divBodyEl.clientHeight || divBody.css('overflow-y') == "scroll";
    var padding = 'padding' + (browser.bScrollbarLeft ? 'Left' : 'Right' );
    divHeaderInnerStyle[ padding ] = bScrolling ? barWidth+"px" : "0px";

    if ( footer ) {
      divFooterTable[0].style.width = _fnStringToCss( iOuterWidth );
      divFooterInner[0].style.width = _fnStringToCss( iOuterWidth );
      divFooterInner[0].style[padding] = bScrolling ? barWidth+"px" : "0px";
    }

    // Correct DOM ordering for colgroup - comes before the thead
    table.children('colgroup').insertBefore( table.children('thead') );

    /* Adjust the position of the header in case we loose the y-scrollbar */
    divBody.scroll();

    // If sorting or filtering has occurred, jump the scrolling back to the top
    // only if we aren't holding the position
    if ( (settings.bSorted || settings.bFiltered) && ! settings._drawHold ) {
      divBodyEl.scrollTop = 0;
    }
  }



  /**
   * Apply a given function to the display child nodes of an element array (typically
   * TD children of TR rows
   *  @param {function} fn Method to apply to the objects
   *  @param array {nodes} an1 List of elements to look through for display children
   *  @param array {nodes} an2 Another list (identical structure to the first) - optional
   *  @memberof DataTable#oApi
   */
  function _fnApplyToChildren( fn, an1, an2 )
  {
    var index=0, i=0, iLen=an1.length;
    var nNode1, nNode2;

    while ( i < iLen ) {
      nNode1 = an1[i].firstChild;
      nNode2 = an2 ? an2[i].firstChild : null;

      while ( nNode1 ) {
        if ( nNode1.nodeType === 1 ) {
          if ( an2 ) {
            fn( nNode1, nNode2, index );
          }
          else {
            fn( nNode1, index );
          }

          index++;
        }

        nNode1 = nNode1.nextSibling;
        nNode2 = an2 ? nNode2.nextSibling : null;
      }

      i++;
    }
  }



  var __re_html_remove = /<.*?>/g;


  /**
   * Calculate the width of columns for the table
   *  @param {object} oSettings dataTables settings object
   *  @memberof DataTable#oApi
   */
  function _fnCalculateColumnWidths ( oSettings )
  {
    var
      table = oSettings.nTable,
      columns = oSettings.aoColumns,
      scroll = oSettings.oScroll,
      scrollY = scroll.sY,
      scrollX = scroll.sX,
      scrollXInner = scroll.sXInner,
      columnCount = columns.length,
      visibleColumns = _fnGetColumns( oSettings, 'bVisible' ),
      headerCells = $('th', oSettings.nTHead),
      tableWidthAttr = table.getAttribute('width'), // from DOM element
      tableContainer = table.parentNode,
      userInputs = false,
      i, column, columnIdx, width, outerWidth,
      browser = oSettings.oBrowser,
      ie67 = browser.bScrollOversize;

    var styleWidth = table.style.width;
    if ( styleWidth && styleWidth.indexOf('%') !== -1 ) {
      tableWidthAttr = styleWidth;
    }

    /* Convert any user input sizes into pixel sizes */
    for ( i=0 ; i<visibleColumns.length ; i++ ) {
      column = columns[ visibleColumns[i] ];

      if ( column.sWidth !== null ) {
        column.sWidth = _fnConvertToWidth( column.sWidthOrig, tableContainer );

        userInputs = true;
      }
    }

    /* If the number of columns in the DOM equals the number that we have to
     * process in DataTables, then we can use the offsets that are created by
     * the web- browser. No custom sizes can be set in order for this to happen,
     * nor scrolling used
     */
    if ( ie67 || ! userInputs && ! scrollX && ! scrollY &&
         columnCount == _fnVisbleColumns( oSettings ) &&
         columnCount == headerCells.length
    ) {
      for ( i=0 ; i<columnCount ; i++ ) {
        var colIdx = _fnVisibleToColumnIndex( oSettings, i );

        if ( colIdx !== null ) {
          columns[ colIdx ].sWidth = _fnStringToCss( headerCells.eq(i).width() );
        }
      }
    }
    else
    {
      // Otherwise construct a single row, worst case, table with the widest
      // node in the data, assign any user defined widths, then insert it into
      // the DOM and allow the browser to do all the hard work of calculating
      // table widths
      var tmpTable = $(table).clone() // don't use cloneNode - IE8 will remove events on the main table
        .css( 'visibility', 'hidden' )
        .removeAttr( 'id' );

      // Clean up the table body
      tmpTable.find('tbody tr').remove();
      var tr = $('<tr/>').appendTo( tmpTable.find('tbody') );

      // Clone the table header and footer - we can't use the header / footer
      // from the cloned table, since if scrolling is active, the table's
      // real header and footer are contained in different table tags
      tmpTable.find('thead, tfoot').remove();
      tmpTable
        .append( $(oSettings.nTHead).clone() )
        .append( $(oSettings.nTFoot).clone() );

      // Remove any assigned widths from the footer (from scrolling)
      tmpTable.find('tfoot th, tfoot td').css('width', '');

      // Apply custom sizing to the cloned header
      headerCells = _fnGetUniqueThs( oSettings, tmpTable.find('thead')[0] );

      for ( i=0 ; i<visibleColumns.length ; i++ ) {
        column = columns[ visibleColumns[i] ];

        headerCells[i].style.width = column.sWidthOrig !== null && column.sWidthOrig !== '' ?
          _fnStringToCss( column.sWidthOrig ) :
          '';

        // For scrollX we need to force the column width otherwise the
        // browser will collapse it. If this width is smaller than the
        // width the column requires, then it will have no effect
        if ( column.sWidthOrig && scrollX ) {
          $( headerCells[i] ).append( $('<div/>').css( {
            width: column.sWidthOrig,
            margin: 0,
            padding: 0,
            border: 0,
            height: 1
          } ) );
        }
      }

      // Find the widest cell for each column and put it into the table
      if ( oSettings.aoData.length ) {
        for ( i=0 ; i<visibleColumns.length ; i++ ) {
          columnIdx = visibleColumns[i];
          column = columns[ columnIdx ];

          $( _fnGetWidestNode( oSettings, columnIdx ) )
            .clone( false )
            .append( column.sContentPadding )
            .appendTo( tr );
        }
      }

      // Tidy the temporary table - remove name attributes so there aren't
      // duplicated in the dom (radio elements for example)
      $('[name]', tmpTable).removeAttr('name');

      // Table has been built, attach to the document so we can work with it.
      // A holding element is used, positioned at the top of the container
      // with minimal height, so it has no effect on if the container scrolls
      // or not. Otherwise it might trigger scrolling when it actually isn't
      // needed
      var holder = $('<div/>').css( scrollX || scrollY ?
          {
            position: 'absolute',
            top: 0,
            left: 0,
            height: 1,
            right: 0,
            overflow: 'hidden'
          } :
          {}
        )
        .append( tmpTable )
        .appendTo( tableContainer );

      // When scrolling (X or Y) we want to set the width of the table as
      // appropriate. However, when not scrolling leave the table width as it
      // is. This results in slightly different, but I think correct behaviour
      if ( scrollX && scrollXInner ) {
        tmpTable.width( scrollXInner );
      }
      else if ( scrollX ) {
        tmpTable.css( 'width', 'auto' );
        tmpTable.removeAttr('width');

        // If there is no width attribute or style, then allow the table to
        // collapse
        if ( tmpTable.width() < tableContainer.clientWidth && tableWidthAttr ) {
          tmpTable.width( tableContainer.clientWidth );
        }
      }
      else if ( scrollY ) {
        tmpTable.width( tableContainer.clientWidth );
      }
      else if ( tableWidthAttr ) {
        tmpTable.width( tableWidthAttr );
      }

      // Get the width of each column in the constructed table - we need to
      // know the inner width (so it can be assigned to the other table's
      // cells) and the outer width so we can calculate the full width of the
      // table. This is safe since DataTables requires a unique cell for each
      // column, but if ever a header can span multiple columns, this will
      // need to be modified.
      var total = 0;
      for ( i=0 ; i<visibleColumns.length ; i++ ) {
        var cell = $(headerCells[i]);
        var border = cell.outerWidth() - cell.width();

        // Use getBounding... where possible (not IE8-) because it can give
        // sub-pixel accuracy, which we then want to round up!
        var bounding = browser.bBounding ?
          Math.ceil( headerCells[i].getBoundingClientRect().width ) :
          cell.outerWidth();

        // Total is tracked to remove any sub-pixel errors as the outerWidth
        // of the table might not equal the total given here (IE!).
        total += bounding;

        // Width for each column to use
        columns[ visibleColumns[i] ].sWidth = _fnStringToCss( bounding - border );
      }

      table.style.width = _fnStringToCss( total );

      // Finished with the table - ditch it
      holder.remove();
    }

    // If there is a width attr, we want to attach an event listener which
    // allows the table sizing to automatically adjust when the window is
    // resized. Use the width attr rather than CSS, since we can't know if the
    // CSS is a relative value or absolute - DOM read is always px.
    if ( tableWidthAttr ) {
      table.style.width = _fnStringToCss( tableWidthAttr );
    }

    if ( (tableWidthAttr || scrollX) && ! oSettings._reszEvt ) {
      var bindResize = function () {
        $(window).on('resize.DT-'+oSettings.sInstance, _fnThrottle( function () {
          _fnAdjustColumnSizing( oSettings );
        } ) );
      };

      // IE6/7 will crash if we bind a resize event handler on page load.
      // To be removed in 1.11 which drops IE6/7 support
      if ( ie67 ) {
        setTimeout( bindResize, 1000 );
      }
      else {
        bindResize();
      }

      oSettings._reszEvt = true;
    }
  }


  /**
   * Throttle the calls to a function. Arguments and context are maintained for
   * the throttled function
   *  @param {function} fn Function to be called
   *  @param {int} [freq=200] call frequency in mS
   *  @returns {function} wrapped function
   *  @memberof DataTable#oApi
   */
  var _fnThrottle = DataTable.util.throttle;


  /**
   * Convert a CSS unit width to pixels (e.g. 2em)
   *  @param {string} width width to be converted
   *  @param {node} parent parent to get the with for (required for relative widths) - optional
   *  @returns {int} width in pixels
   *  @memberof DataTable#oApi
   */
  function _fnConvertToWidth ( width, parent )
  {
    if ( ! width ) {
      return 0;
    }

    var n = $('<div/>')
      .css( 'width', _fnStringToCss( width ) )
      .appendTo( parent || document.body );

    var val = n[0].offsetWidth;
    n.remove();

    return val;
  }


  /**
   * Get the widest node
   *  @param {object} settings dataTables settings object
   *  @param {int} colIdx column of interest
   *  @returns {node} widest table node
   *  @memberof DataTable#oApi
   */
  function _fnGetWidestNode( settings, colIdx )
  {
    var idx = _fnGetMaxLenString( settings, colIdx );
    if ( idx < 0 ) {
      return null;
    }

    var data = settings.aoData[ idx ];
    return ! data.nTr ? // Might not have been created when deferred rendering
      $('<td/>').html( _fnGetCellData( settings, idx, colIdx, 'display' ) )[0] :
      data.anCells[ colIdx ];
  }


  /**
   * Get the maximum strlen for each data column
   *  @param {object} settings dataTables settings object
   *  @param {int} colIdx column of interest
   *  @returns {string} max string length for each column
   *  @memberof DataTable#oApi
   */
  function _fnGetMaxLenString( settings, colIdx )
  {
    var s, max=-1, maxIdx = -1;

    for ( var i=0, ien=settings.aoData.length ; i<ien ; i++ ) {
      s = _fnGetCellData( settings, i, colIdx, 'display' )+'';
      s = s.replace( __re_html_remove, '' );
      s = s.replace( /&nbsp;/g, ' ' );

      if ( s.length > max ) {
        max = s.length;
        maxIdx = i;
      }
    }

    return maxIdx;
  }


  /**
   * Append a CSS unit (only if required) to a string
   *  @param {string} value to css-ify
   *  @returns {string} value with css unit
   *  @memberof DataTable#oApi
   */
  function _fnStringToCss( s )
  {
    if ( s === null ) {
      return '0px';
    }

    if ( typeof s == 'number' ) {
      return s < 0 ?
        '0px' :
        s+'px';
    }

    // Check it has a unit character already
    return s.match(/\d$/) ?
      s+'px' :
      s;
  }



  function _fnSortFlatten ( settings )
  {
    var
      i, iLen, k, kLen,
      aSort = [],
      aiOrig = [],
      aoColumns = settings.aoColumns,
      aDataSort, iCol, sType, srcCol,
      fixed = settings.aaSortingFixed,
      fixedObj = $.isPlainObject( fixed ),
      nestedSort = [],
      add = function ( a ) {
        if ( a.length && ! $.isArray( a[0] ) ) {
          // 1D array
          nestedSort.push( a );
        }
        else {
          // 2D array
          $.merge( nestedSort, a );
        }
      };

    // Build the sort array, with pre-fix and post-fix options if they have been
    // specified
    if ( $.isArray( fixed ) ) {
      add( fixed );
    }

    if ( fixedObj && fixed.pre ) {
      add( fixed.pre );
    }

    add( settings.aaSorting );

    if (fixedObj && fixed.post ) {
      add( fixed.post );
    }

    for ( i=0 ; i<nestedSort.length ; i++ )
    {
      srcCol = nestedSort[i][0];
      aDataSort = aoColumns[ srcCol ].aDataSort;

      for ( k=0, kLen=aDataSort.length ; k<kLen ; k++ )
      {
        iCol = aDataSort[k];
        sType = aoColumns[ iCol ].sType || 'string';

        if ( nestedSort[i]._idx === undefined ) {
          nestedSort[i]._idx = $.inArray( nestedSort[i][1], aoColumns[iCol].asSorting );
        }

        aSort.push( {
          src:       srcCol,
          col:       iCol,
          dir:       nestedSort[i][1],
          index:     nestedSort[i]._idx,
          type:      sType,
          formatter: DataTable.ext.type.order[ sType+"-pre" ]
        } );
      }
    }

    return aSort;
  }

  /**
   * Change the order of the table
   *  @param {object} oSettings dataTables settings object
   *  @memberof DataTable#oApi
   *  @todo This really needs split up!
   */
  function _fnSort ( oSettings )
  {
    var
      i, ien, iLen, j, jLen, k, kLen,
      sDataType, nTh,
      aiOrig = [],
      oExtSort = DataTable.ext.type.order,
      aoData = oSettings.aoData,
      aoColumns = oSettings.aoColumns,
      aDataSort, data, iCol, sType, oSort,
      formatters = 0,
      sortCol,
      displayMaster = oSettings.aiDisplayMaster,
      aSort;

    // Resolve any column types that are unknown due to addition or invalidation
    // @todo Can this be moved into a 'data-ready' handler which is called when
    //   data is going to be used in the table?
    _fnColumnTypes( oSettings );

    aSort = _fnSortFlatten( oSettings );

    for ( i=0, ien=aSort.length ; i<ien ; i++ ) {
      sortCol = aSort[i];

      // Track if we can use the fast sort algorithm
      if ( sortCol.formatter ) {
        formatters++;
      }

      // Load the data needed for the sort, for each cell
      _fnSortData( oSettings, sortCol.col );
    }

    /* No sorting required if server-side or no sorting array */
    if ( _fnDataSource( oSettings ) != 'ssp' && aSort.length !== 0 )
    {
      // Create a value - key array of the current row positions such that we can use their
      // current position during the sort, if values match, in order to perform stable sorting
      for ( i=0, iLen=displayMaster.length ; i<iLen ; i++ ) {
        aiOrig[ displayMaster[i] ] = i;
      }

      /* Do the sort - here we want multi-column sorting based on a given data source (column)
       * and sorting function (from oSort) in a certain direction. It's reasonably complex to
       * follow on it's own, but this is what we want (example two column sorting):
       *  fnLocalSorting = function(a,b){
       *    var iTest;
       *    iTest = oSort['string-asc']('data11', 'data12');
       *      if (iTest !== 0)
       *        return iTest;
       *    iTest = oSort['numeric-desc']('data21', 'data22');
       *    if (iTest !== 0)
       *      return iTest;
       *    return oSort['numeric-asc']( aiOrig[a], aiOrig[b] );
       *  }
       * Basically we have a test for each sorting column, if the data in that column is equal,
       * test the next column. If all columns match, then we use a numeric sort on the row
       * positions in the original data array to provide a stable sort.
       *
       * Note - I know it seems excessive to have two sorting methods, but the first is around
       * 15% faster, so the second is only maintained for backwards compatibility with sorting
       * methods which do not have a pre-sort formatting function.
       */
      if ( formatters === aSort.length ) {
        // All sort types have formatting functions
        displayMaster.sort( function ( a, b ) {
          var
            x, y, k, test, sort,
            len=aSort.length,
            dataA = aoData[a]._aSortData,
            dataB = aoData[b]._aSortData;

          for ( k=0 ; k<len ; k++ ) {
            sort = aSort[k];

            x = dataA[ sort.col ];
            y = dataB[ sort.col ];

            test = x<y ? -1 : x>y ? 1 : 0;
            if ( test !== 0 ) {
              return sort.dir === 'asc' ? test : -test;
            }
          }

          x = aiOrig[a];
          y = aiOrig[b];
          return x<y ? -1 : x>y ? 1 : 0;
        } );
      }
      else {
        // Depreciated - remove in 1.11 (providing a plug-in option)
        // Not all sort types have formatting methods, so we have to call their sorting
        // methods.
        displayMaster.sort( function ( a, b ) {
          var
            x, y, k, l, test, sort, fn,
            len=aSort.length,
            dataA = aoData[a]._aSortData,
            dataB = aoData[b]._aSortData;

          for ( k=0 ; k<len ; k++ ) {
            sort = aSort[k];

            x = dataA[ sort.col ];
            y = dataB[ sort.col ];

            fn = oExtSort[ sort.type+"-"+sort.dir ] || oExtSort[ "string-"+sort.dir ];
            test = fn( x, y );
            if ( test !== 0 ) {
              return test;
            }
          }

          x = aiOrig[a];
          y = aiOrig[b];
          return x<y ? -1 : x>y ? 1 : 0;
        } );
      }
    }

    /* Tell the draw function that we have sorted the data */
    oSettings.bSorted = true;
  }


  function _fnSortAria ( settings )
  {
    var label;
    var nextSort;
    var columns = settings.aoColumns;
    var aSort = _fnSortFlatten( settings );
    var oAria = settings.oLanguage.oAria;

    // ARIA attributes - need to loop all columns, to update all (removing old
    // attributes as needed)
    for ( var i=0, iLen=columns.length ; i<iLen ; i++ )
    {
      var col = columns[i];
      var asSorting = col.asSorting;
      var sTitle = col.sTitle.replace( /<.*?>/g, "" );
      var th = col.nTh;

      // IE7 is throwing an error when setting these properties with jQuery's
      // attr() and removeAttr() methods...
      th.removeAttribute('aria-sort');

      /* In ARIA only the first sorting column can be marked as sorting - no multi-sort option */
      if ( col.bSortable ) {
        if ( aSort.length > 0 && aSort[0].col == i ) {
          th.setAttribute('aria-sort', aSort[0].dir=="asc" ? "ascending" : "descending" );
          nextSort = asSorting[ aSort[0].index+1 ] || asSorting[0];
        }
        else {
          nextSort = asSorting[0];
        }

        label = sTitle + ( nextSort === "asc" ?
          oAria.sSortAscending :
          oAria.sSortDescending
        );
      }
      else {
        label = sTitle;
      }

      th.setAttribute('aria-label', label);
    }
  }


  /**
   * Function to run on user sort request
   *  @param {object} settings dataTables settings object
   *  @param {node} attachTo node to attach the handler to
   *  @param {int} colIdx column sorting index
   *  @param {boolean} [append=false] Append the requested sort to the existing
   *    sort if true (i.e. multi-column sort)
   *  @param {function} [callback] callback function
   *  @memberof DataTable#oApi
   */
  function _fnSortListener ( settings, colIdx, append, callback )
  {
    var col = settings.aoColumns[ colIdx ];
    var sorting = settings.aaSorting;
    var asSorting = col.asSorting;
    var nextSortIdx;
    var next = function ( a, overflow ) {
      var idx = a._idx;
      if ( idx === undefined ) {
        idx = $.inArray( a[1], asSorting );
      }

      return idx+1 < asSorting.length ?
        idx+1 :
        overflow ?
          null :
          0;
    };

    // Convert to 2D array if needed
    if ( typeof sorting[0] === 'number' ) {
      sorting = settings.aaSorting = [ sorting ];
    }

    // If appending the sort then we are multi-column sorting
    if ( append && settings.oFeatures.bSortMulti ) {
      // Are we already doing some kind of sort on this column?
      var sortIdx = $.inArray( colIdx, _pluck(sorting, '0') );

      if ( sortIdx !== -1 ) {
        // Yes, modify the sort
        nextSortIdx = next( sorting[sortIdx], true );

        if ( nextSortIdx === null && sorting.length === 1 ) {
          nextSortIdx = 0; // can't remove sorting completely
        }

        if ( nextSortIdx === null ) {
          sorting.splice( sortIdx, 1 );
        }
        else {
          sorting[sortIdx][1] = asSorting[ nextSortIdx ];
          sorting[sortIdx]._idx = nextSortIdx;
        }
      }
      else {
        // No sort on this column yet
        sorting.push( [ colIdx, asSorting[0], 0 ] );
        sorting[sorting.length-1]._idx = 0;
      }
    }
    else if ( sorting.length && sorting[0][0] == colIdx ) {
      // Single column - already sorting on this column, modify the sort
      nextSortIdx = next( sorting[0] );

      sorting.length = 1;
      sorting[0][1] = asSorting[ nextSortIdx ];
      sorting[0]._idx = nextSortIdx;
    }
    else {
      // Single column - sort only on this column
      sorting.length = 0;
      sorting.push( [ colIdx, asSorting[0] ] );
      sorting[0]._idx = 0;
    }

    // Run the sort by calling a full redraw
    _fnReDraw( settings );

    // callback used for async user interaction
    if ( typeof callback == 'function' ) {
      callback( settings );
    }
  }


  /**
   * Attach a sort handler (click) to a node
   *  @param {object} settings dataTables settings object
   *  @param {node} attachTo node to attach the handler to
   *  @param {int} colIdx column sorting index
   *  @param {function} [callback] callback function
   *  @memberof DataTable#oApi
   */
  function _fnSortAttachListener ( settings, attachTo, colIdx, callback )
  {
    var col = settings.aoColumns[ colIdx ];

    _fnBindAction( attachTo, {}, function (e) {
      /* If the column is not sortable - don't to anything */
      if ( col.bSortable === false ) {
        return;
      }

      // If processing is enabled use a timeout to allow the processing
      // display to be shown - otherwise to it synchronously
      if ( settings.oFeatures.bProcessing ) {
        _fnProcessingDisplay( settings, true );

        setTimeout( function() {
          _fnSortListener( settings, colIdx, e.shiftKey, callback );

          // In server-side processing, the draw callback will remove the
          // processing display
          if ( _fnDataSource( settings ) !== 'ssp' ) {
            _fnProcessingDisplay( settings, false );
          }
        }, 0 );
      }
      else {
        _fnSortListener( settings, colIdx, e.shiftKey, callback );
      }
    } );
  }


  /**
   * Set the sorting classes on table's body, Note: it is safe to call this function
   * when bSort and bSortClasses are false
   *  @param {object} oSettings dataTables settings object
   *  @memberof DataTable#oApi
   */
  function _fnSortingClasses( settings )
  {
    var oldSort = settings.aLastSort;
    var sortClass = settings.oClasses.sSortColumn;
    var sort = _fnSortFlatten( settings );
    var features = settings.oFeatures;
    var i, ien, colIdx;

    if ( features.bSort && features.bSortClasses ) {
      // Remove old sorting classes
      for ( i=0, ien=oldSort.length ; i<ien ; i++ ) {
        colIdx = oldSort[i].src;

        // Remove column sorting
        $( _pluck( settings.aoData, 'anCells', colIdx ) )
          .removeClass( sortClass + (i<2 ? i+1 : 3) );
      }

      // Add new column sorting
      for ( i=0, ien=sort.length ; i<ien ; i++ ) {
        colIdx = sort[i].src;

        $( _pluck( settings.aoData, 'anCells', colIdx ) )
          .addClass( sortClass + (i<2 ? i+1 : 3) );
      }
    }

    settings.aLastSort = sort;
  }


  // Get the data to sort a column, be it from cache, fresh (populating the
  // cache), or from a sort formatter
  function _fnSortData( settings, idx )
  {
    // Custom sorting function - provided by the sort data type
    var column = settings.aoColumns[ idx ];
    var customSort = DataTable.ext.order[ column.sSortDataType ];
    var customData;

    if ( customSort ) {
      customData = customSort.call( settings.oInstance, settings, idx,
        _fnColumnIndexToVisible( settings, idx )
      );
    }

    // Use / populate cache
    var row, cellData;
    var formatter = DataTable.ext.type.order[ column.sType+"-pre" ];

    for ( var i=0, ien=settings.aoData.length ; i<ien ; i++ ) {
      row = settings.aoData[i];

      if ( ! row._aSortData ) {
        row._aSortData = [];
      }

      if ( ! row._aSortData[idx] || customSort ) {
        cellData = customSort ?
          customData[i] : // If there was a custom sort function, use data from there
          _fnGetCellData( settings, i, idx, 'sort' );

        row._aSortData[ idx ] = formatter ?
          formatter( cellData ) :
          cellData;
      }
    }
  }



  /**
   * Save the state of a table
   *  @param {object} oSettings dataTables settings object
   *  @memberof DataTable#oApi
   */
  function _fnSaveState ( settings )
  {
    if ( !settings.oFeatures.bStateSave || settings.bDestroying )
    {
      return;
    }

    /* Store the interesting variables */
    var state = {
      time:    +new Date(),
      start:   settings._iDisplayStart,
      length:  settings._iDisplayLength,
      order:   $.extend( true, [], settings.aaSorting ),
      search:  _fnSearchToCamel( settings.oPreviousSearch ),
      columns: $.map( settings.aoColumns, function ( col, i ) {
        return {
          visible: col.bVisible,
          search: _fnSearchToCamel( settings.aoPreSearchCols[i] )
        };
      } )
    };

    _fnCallbackFire( settings, "aoStateSaveParams", 'stateSaveParams', [settings, state] );

    settings.oSavedState = state;
    settings.fnStateSaveCallback.call( settings.oInstance, settings, state );
  }


  /**
   * Attempt to load a saved table state
   *  @param {object} oSettings dataTables settings object
   *  @param {object} oInit DataTables init object so we can override settings
   *  @param {function} callback Callback to execute when the state has been loaded
   *  @memberof DataTable#oApi
   */
  function _fnLoadState ( settings, oInit, callback )
  {
    var i, ien;
    var columns = settings.aoColumns;
    var loaded = function ( s ) {
      if ( ! s || ! s.time ) {
        callback();
        return;
      }

      // Allow custom and plug-in manipulation functions to alter the saved data set and
      // cancelling of loading by returning false
      var abStateLoad = _fnCallbackFire( settings, 'aoStateLoadParams', 'stateLoadParams', [settings, s] );
      if ( $.inArray( false, abStateLoad ) !== -1 ) {
        callback();
        return;
      }

      // Reject old data
      var duration = settings.iStateDuration;
      if ( duration > 0 && s.time < +new Date() - (duration*1000) ) {
        callback();
        return;
      }

      // Number of columns have changed - all bets are off, no restore of settings
      if ( s.columns && columns.length !== s.columns.length ) {
        callback();
        return;
      }

      // Store the saved state so it might be accessed at any time
      settings.oLoadedState = $.extend( true, {}, s );

      // Restore key features - todo - for 1.11 this needs to be done by
      // subscribed events
      if ( s.start !== undefined ) {
        settings._iDisplayStart    = s.start;
        settings.iInitDisplayStart = s.start;
      }
      if ( s.length !== undefined ) {
        settings._iDisplayLength   = s.length;
      }

      // Order
      if ( s.order !== undefined ) {
        settings.aaSorting = [];
        $.each( s.order, function ( i, col ) {
          settings.aaSorting.push( col[0] >= columns.length ?
            [ 0, col[1] ] :
            col
          );
        } );
      }

      // Search
      if ( s.search !== undefined ) {
        $.extend( settings.oPreviousSearch, _fnSearchToHung( s.search ) );
      }

      // Columns
      //
      if ( s.columns ) {
        for ( i=0, ien=s.columns.length ; i<ien ; i++ ) {
          var col = s.columns[i];

          // Visibility
          if ( col.visible !== undefined ) {
            columns[i].bVisible = col.visible;
          }

          // Search
          if ( col.search !== undefined ) {
            $.extend( settings.aoPreSearchCols[i], _fnSearchToHung( col.search ) );
          }
        }
      }

      _fnCallbackFire( settings, 'aoStateLoaded', 'stateLoaded', [settings, s] );
      callback();
    }

    if ( ! settings.oFeatures.bStateSave ) {
      callback();
      return;
    }

    var state = settings.fnStateLoadCallback.call( settings.oInstance, settings, loaded );

    if ( state !== undefined ) {
      loaded( state );
    }
    // otherwise, wait for the loaded callback to be executed
  }


  /**
   * Return the settings object for a particular table
   *  @param {node} table table we are using as a dataTable
   *  @returns {object} Settings object - or null if not found
   *  @memberof DataTable#oApi
   */
  function _fnSettingsFromNode ( table )
  {
    var settings = DataTable.settings;
    var idx = $.inArray( table, _pluck( settings, 'nTable' ) );

    return idx !== -1 ?
      settings[ idx ] :
      null;
  }


  /**
   * Log an error message
   *  @param {object} settings dataTables settings object
   *  @param {int} level log error messages, or display them to the user
   *  @param {string} msg error message
   *  @param {int} tn Technical note id to get more information about the error.
   *  @memberof DataTable#oApi
   */
  function _fnLog( settings, level, msg, tn )
  {
    msg = 'DataTables warning: '+
      (settings ? 'table id='+settings.sTableId+' - ' : '')+msg;

    if ( tn ) {
      msg += '. For more information about this error, please see '+
      'http://datatables.net/tn/'+tn;
    }

    if ( ! level  ) {
      // Backwards compatibility pre 1.10
      var ext = DataTable.ext;
      var type = ext.sErrMode || ext.errMode;

      if ( settings ) {
        _fnCallbackFire( settings, null, 'error', [ settings, tn, msg ] );
      }

      if ( type == 'alert' ) {
        alert( msg );
      }
      else if ( type == 'throw' ) {
        throw new Error(msg);
      }
      else if ( typeof type == 'function' ) {
        type( settings, tn, msg );
      }
    }
    else if ( window.console && console.log ) {
      console.log( msg );
    }
  }


  /**
   * See if a property is defined on one object, if so assign it to the other object
   *  @param {object} ret target object
   *  @param {object} src source object
   *  @param {string} name property
   *  @param {string} [mappedName] name to map too - optional, name used if not given
   *  @memberof DataTable#oApi
   */
  function _fnMap( ret, src, name, mappedName )
  {
    if ( $.isArray( name ) ) {
      $.each( name, function (i, val) {
        if ( $.isArray( val ) ) {
          _fnMap( ret, src, val[0], val[1] );
        }
        else {
          _fnMap( ret, src, val );
        }
      } );

      return;
    }

    if ( mappedName === undefined ) {
      mappedName = name;
    }

    if ( src[name] !== undefined ) {
      ret[mappedName] = src[name];
    }
  }


  /**
   * Extend objects - very similar to jQuery.extend, but deep copy objects, and
   * shallow copy arrays. The reason we need to do this, is that we don't want to
   * deep copy array init values (such as aaSorting) since the dev wouldn't be
   * able to override them, but we do want to deep copy arrays.
   *  @param {object} out Object to extend
   *  @param {object} extender Object from which the properties will be applied to
   *      out
   *  @param {boolean} breakRefs If true, then arrays will be sliced to take an
   *      independent copy with the exception of the `data` or `aaData` parameters
   *      if they are present. This is so you can pass in a collection to
   *      DataTables and have that used as your data source without breaking the
   *      references
   *  @returns {object} out Reference, just for convenience - out === the return.
   *  @memberof DataTable#oApi
   *  @todo This doesn't take account of arrays inside the deep copied objects.
   */
  function _fnExtend( out, extender, breakRefs )
  {
    var val;

    for ( var prop in extender ) {
      if ( extender.hasOwnProperty(prop) ) {
        val = extender[prop];

        if ( $.isPlainObject( val ) ) {
          if ( ! $.isPlainObject( out[prop] ) ) {
            out[prop] = {};
          }
          $.extend( true, out[prop], val );
        }
        else if ( breakRefs && prop !== 'data' && prop !== 'aaData' && $.isArray(val) ) {
          out[prop] = val.slice();
        }
        else {
          out[prop] = val;
        }
      }
    }

    return out;
  }


  /**
   * Bind an event handers to allow a click or return key to activate the callback.
   * This is good for accessibility since a return on the keyboard will have the
   * same effect as a click, if the element has focus.
   *  @param {element} n Element to bind the action to
   *  @param {object} oData Data object to pass to the triggered function
   *  @param {function} fn Callback function for when the event is triggered
   *  @memberof DataTable#oApi
   */
  function _fnBindAction( n, oData, fn )
  {
    $(n)
      .on( 'click.DT', oData, function (e) {
          n.blur(); // Remove focus outline for mouse users
          fn(e);
        } )
      .on( 'keypress.DT', oData, function (e){
          if ( e.which === 13 ) {
            e.preventDefault();
            fn(e);
          }
        } )
      .on( 'selectstart.DT', function () {
          /* Take the brutal approach to cancelling text selection */
          return false;
        } );
  }


  /**
   * Register a callback function. Easily allows a callback function to be added to
   * an array store of callback functions that can then all be called together.
   *  @param {object} oSettings dataTables settings object
   *  @param {string} sStore Name of the array storage for the callbacks in oSettings
   *  @param {function} fn Function to be called back
   *  @param {string} sName Identifying name for the callback (i.e. a label)
   *  @memberof DataTable#oApi
   */
  function _fnCallbackReg( oSettings, sStore, fn, sName )
  {
    if ( fn )
    {
      oSettings[sStore].push( {
        "fn": fn,
        "sName": sName
      } );
    }
  }


  /**
   * Fire callback functions and trigger events. Note that the loop over the
   * callback array store is done backwards! Further note that you do not want to
   * fire off triggers in time sensitive applications (for example cell creation)
   * as its slow.
   *  @param {object} settings dataTables settings object
   *  @param {string} callbackArr Name of the array storage for the callbacks in
   *      oSettings
   *  @param {string} eventName Name of the jQuery custom event to trigger. If
   *      null no trigger is fired
   *  @param {array} args Array of arguments to pass to the callback function /
   *      trigger
   *  @memberof DataTable#oApi
   */
  function _fnCallbackFire( settings, callbackArr, eventName, args )
  {
    var ret = [];

    if ( callbackArr ) {
      ret = $.map( settings[callbackArr].slice().reverse(), function (val, i) {
        return val.fn.apply( settings.oInstance, args );
      } );
    }

    if ( eventName !== null ) {
      var e = $.Event( eventName+'.dt' );

      $(settings.nTable).trigger( e, args );

      ret.push( e.result );
    }

    return ret;
  }


  function _fnLengthOverflow ( settings )
  {
    var
      start = settings._iDisplayStart,
      end = settings.fnDisplayEnd(),
      len = settings._iDisplayLength;

    /* If we have space to show extra rows (backing up from the end point - then do so */
    if ( start >= end )
    {
      start = end - len;
    }

    // Keep the start record on the current page
    start -= (start % len);

    if ( len === -1 || start < 0 )
    {
      start = 0;
    }

    settings._iDisplayStart = start;
  }


  function _fnRenderer( settings, type )
  {
    var renderer = settings.renderer;
    var host = DataTable.ext.renderer[type];

    if ( $.isPlainObject( renderer ) && renderer[type] ) {
      // Specific renderer for this type. If available use it, otherwise use
      // the default.
      return host[renderer[type]] || host._;
    }
    else if ( typeof renderer === 'string' ) {
      // Common renderer - if there is one available for this type use it,
      // otherwise use the default
      return host[renderer] || host._;
    }

    // Use the default
    return host._;
  }


  /**
   * Detect the data source being used for the table. Used to simplify the code
   * a little (ajax) and to make it compress a little smaller.
   *
   *  @param {object} settings dataTables settings object
   *  @returns {string} Data source
   *  @memberof DataTable#oApi
   */
  function _fnDataSource ( settings )
  {
    if ( settings.oFeatures.bServerSide ) {
      return 'ssp';
    }
    else if ( settings.ajax || settings.sAjaxSource ) {
      return 'ajax';
    }
    return 'dom';
  }




  /**
   * Computed structure of the DataTables API, defined by the options passed to
   * `DataTable.Api.register()` when building the API.
   *
   * The structure is built in order to speed creation and extension of the Api
   * objects since the extensions are effectively pre-parsed.
   *
   * The array is an array of objects with the following structure, where this
   * base array represents the Api prototype base:
   *
   *     [
   *       {
   *         name:      'data'                -- string   - Property name
   *         val:       function () {},       -- function - Api method (or undefined if just an object
   *         methodExt: [ ... ],              -- array    - Array of Api object definitions to extend the method result
   *         propExt:   [ ... ]               -- array    - Array of Api object definitions to extend the property
   *       },
   *       {
   *         name:     'row'
   *         val:       {},
   *         methodExt: [ ... ],
   *         propExt:   [
   *           {
   *             name:      'data'
   *             val:       function () {},
   *             methodExt: [ ... ],
   *             propExt:   [ ... ]
   *           },
   *           ...
   *         ]
   *       }
   *     ]
   *
   * @type {Array}
   * @ignore
   */
  var __apiStruct = [];


  /**
   * `Array.prototype` reference.
   *
   * @type object
   * @ignore
   */
  var __arrayProto = Array.prototype;


  /**
   * Abstraction for `context` parameter of the `Api` constructor to allow it to
   * take several different forms for ease of use.
   *
   * Each of the input parameter types will be converted to a DataTables settings
   * object where possible.
   *
   * @param  {string|node|jQuery|object} mixed DataTable identifier. Can be one
   *   of:
   *
   *   * `string` - jQuery selector. Any DataTables' matching the given selector
   *     with be found and used.
   *   * `node` - `TABLE` node which has already been formed into a DataTable.
   *   * `jQuery` - A jQuery object of `TABLE` nodes.
   *   * `object` - DataTables settings object
   *   * `DataTables.Api` - API instance
   * @return {array|null} Matching DataTables settings objects. `null` or
   *   `undefined` is returned if no matching DataTable is found.
   * @ignore
   */
  var _toSettings = function ( mixed )
  {
    var idx, jq;
    var settings = DataTable.settings;
    var tables = $.map( settings, function (el, i) {
      return el.nTable;
    } );

    if ( ! mixed ) {
      return [];
    }
    else if ( mixed.nTable && mixed.oApi ) {
      // DataTables settings object
      return [ mixed ];
    }
    else if ( mixed.nodeName && mixed.nodeName.toLowerCase() === 'table' ) {
      // Table node
      idx = $.inArray( mixed, tables );
      return idx !== -1 ? [ settings[idx] ] : null;
    }
    else if ( mixed && typeof mixed.settings === 'function' ) {
      return mixed.settings().toArray();
    }
    else if ( typeof mixed === 'string' ) {
      // jQuery selector
      jq = $(mixed);
    }
    else if ( mixed instanceof $ ) {
      // jQuery object (also DataTables instance)
      jq = mixed;
    }

    if ( jq ) {
      return jq.map( function(i) {
        idx = $.inArray( this, tables );
        return idx !== -1 ? settings[idx] : null;
      } ).toArray();
    }
  };


  /**
   * DataTables API class - used to control and interface with  one or more
   * DataTables enhanced tables.
   *
   * The API class is heavily based on jQuery, presenting a chainable interface
   * that you can use to interact with tables. Each instance of the API class has
   * a "context" - i.e. the tables that it will operate on. This could be a single
   * table, all tables on a page or a sub-set thereof.
   *
   * Additionally the API is designed to allow you to easily work with the data in
   * the tables, retrieving and manipulating it as required. This is done by
   * presenting the API class as an array like interface. The contents of the
   * array depend upon the actions requested by each method (for example
   * `rows().nodes()` will return an array of nodes, while `rows().data()` will
   * return an array of objects or arrays depending upon your table's
   * configuration). The API object has a number of array like methods (`push`,
   * `pop`, `reverse` etc) as well as additional helper methods (`each`, `pluck`,
   * `unique` etc) to assist your working with the data held in a table.
   *
   * Most methods (those which return an Api instance) are chainable, which means
   * the return from a method call also has all of the methods available that the
   * top level object had. For example, these two calls are equivalent:
   *
   *     // Not chained
   *     api.row.add( {...} );
   *     api.draw();
   *
   *     // Chained
   *     api.row.add( {...} ).draw();
   *
   * @class DataTable.Api
   * @param {array|object|string|jQuery} context DataTable identifier. This is
   *   used to define which DataTables enhanced tables this API will operate on.
   *   Can be one of:
   *
   *   * `string` - jQuery selector. Any DataTables' matching the given selector
   *     with be found and used.
   *   * `node` - `TABLE` node which has already been formed into a DataTable.
   *   * `jQuery` - A jQuery object of `TABLE` nodes.
   *   * `object` - DataTables settings object
   * @param {array} [data] Data to initialise the Api instance with.
   *
   * @example
   *   // Direct initialisation during DataTables construction
   *   var api = $('#example').DataTable();
   *
   * @example
   *   // Initialisation using a DataTables jQuery object
   *   var api = $('#example').dataTable().api();
   *
   * @example
   *   // Initialisation as a constructor
   *   var api = new $.fn.DataTable.Api( 'table.dataTable' );
   */
  _Api = function ( context, data )
  {
    if ( ! (this instanceof _Api) ) {
      return new _Api( context, data );
    }

    var settings = [];
    var ctxSettings = function ( o ) {
      var a = _toSettings( o );
      if ( a ) {
        settings = settings.concat( a );
      }
    };

    if ( $.isArray( context ) ) {
      for ( var i=0, ien=context.length ; i<ien ; i++ ) {
        ctxSettings( context[i] );
      }
    }
    else {
      ctxSettings( context );
    }

    // Remove duplicates
    this.context = _unique( settings );

    // Initial data
    if ( data ) {
      $.merge( this, data );
    }

    // selector
    this.selector = {
      rows: null,
      cols: null,
      opts: null
    };

    _Api.extend( this, this, __apiStruct );
  };

  DataTable.Api = _Api;

  // Don't destroy the existing prototype, just extend it. Required for jQuery 2's
  // isPlainObject.
  $.extend( _Api.prototype, {
    any: function ()
    {
      return this.count() !== 0;
    },


    concat:  __arrayProto.concat,


    context: [], // array of table settings objects


    count: function ()
    {
      return this.flatten().length;
    },


    each: function ( fn )
    {
      for ( var i=0, ien=this.length ; i<ien; i++ ) {
        fn.call( this, this[i], i, this );
      }

      return this;
    },


    eq: function ( idx )
    {
      var ctx = this.context;

      return ctx.length > idx ?
        new _Api( ctx[idx], this[idx] ) :
        null;
    },


    filter: function ( fn )
    {
      var a = [];

      if ( __arrayProto.filter ) {
        a = __arrayProto.filter.call( this, fn, this );
      }
      else {
        // Compatibility for browsers without EMCA-252-5 (JS 1.6)
        for ( var i=0, ien=this.length ; i<ien ; i++ ) {
          if ( fn.call( this, this[i], i, this ) ) {
            a.push( this[i] );
          }
        }
      }

      return new _Api( this.context, a );
    },


    flatten: function ()
    {
      var a = [];
      return new _Api( this.context, a.concat.apply( a, this.toArray() ) );
    },


    join:    __arrayProto.join,


    indexOf: __arrayProto.indexOf || function (obj, start)
    {
      for ( var i=(start || 0), ien=this.length ; i<ien ; i++ ) {
        if ( this[i] === obj ) {
          return i;
        }
      }
      return -1;
    },

    iterator: function ( flatten, type, fn, alwaysNew ) {
      var
        a = [], ret,
        i, ien, j, jen,
        context = this.context,
        rows, items, item,
        selector = this.selector;

      // Argument shifting
      if ( typeof flatten === 'string' ) {
        alwaysNew = fn;
        fn = type;
        type = flatten;
        flatten = false;
      }

      for ( i=0, ien=context.length ; i<ien ; i++ ) {
        var apiInst = new _Api( context[i] );

        if ( type === 'table' ) {
          ret = fn.call( apiInst, context[i], i );

          if ( ret !== undefined ) {
            a.push( ret );
          }
        }
        else if ( type === 'columns' || type === 'rows' ) {
          // this has same length as context - one entry for each table
          ret = fn.call( apiInst, context[i], this[i], i );

          if ( ret !== undefined ) {
            a.push( ret );
          }
        }
        else if ( type === 'column' || type === 'column-rows' || type === 'row' || type === 'cell' ) {
          // columns and rows share the same structure.
          // 'this' is an array of column indexes for each context
          items = this[i];

          if ( type === 'column-rows' ) {
            rows = _selector_row_indexes( context[i], selector.opts );
          }

          for ( j=0, jen=items.length ; j<jen ; j++ ) {
            item = items[j];

            if ( type === 'cell' ) {
              ret = fn.call( apiInst, context[i], item.row, item.column, i, j );
            }
            else {
              ret = fn.call( apiInst, context[i], item, i, j, rows );
            }

            if ( ret !== undefined ) {
              a.push( ret );
            }
          }
        }
      }

      if ( a.length || alwaysNew ) {
        var api = new _Api( context, flatten ? a.concat.apply( [], a ) : a );
        var apiSelector = api.selector;
        apiSelector.rows = selector.rows;
        apiSelector.cols = selector.cols;
        apiSelector.opts = selector.opts;
        return api;
      }
      return this;
    },


    lastIndexOf: __arrayProto.lastIndexOf || function (obj, start)
    {
      // Bit cheeky...
      return this.indexOf.apply( this.toArray.reverse(), arguments );
    },


    length:  0,


    map: function ( fn )
    {
      var a = [];

      if ( __arrayProto.map ) {
        a = __arrayProto.map.call( this, fn, this );
      }
      else {
        // Compatibility for browsers without EMCA-252-5 (JS 1.6)
        for ( var i=0, ien=this.length ; i<ien ; i++ ) {
          a.push( fn.call( this, this[i], i ) );
        }
      }

      return new _Api( this.context, a );
    },


    pluck: function ( prop )
    {
      return this.map( function ( el ) {
        return el[ prop ];
      } );
    },

    pop:     __arrayProto.pop,


    push:    __arrayProto.push,


    // Does not return an API instance
    reduce: __arrayProto.reduce || function ( fn, init )
    {
      return _fnReduce( this, fn, init, 0, this.length, 1 );
    },


    reduceRight: __arrayProto.reduceRight || function ( fn, init )
    {
      return _fnReduce( this, fn, init, this.length-1, -1, -1 );
    },


    reverse: __arrayProto.reverse,


    // Object with rows, columns and opts
    selector: null,


    shift:   __arrayProto.shift,


    slice: function () {
      return new _Api( this.context, this );
    },


    sort:    __arrayProto.sort, // ? name - order?


    splice:  __arrayProto.splice,


    toArray: function ()
    {
      return __arrayProto.slice.call( this );
    },


    to$: function ()
    {
      return $( this );
    },


    toJQuery: function ()
    {
      return $( this );
    },


    unique: function ()
    {
      return new _Api( this.context, _unique(this) );
    },


    unshift: __arrayProto.unshift
  } );


  _Api.extend = function ( scope, obj, ext )
  {
    // Only extend API instances and static properties of the API
    if ( ! ext.length || ! obj || ( ! (obj instanceof _Api) && ! obj.__dt_wrapper ) ) {
      return;
    }

    var
      i, ien,
      j, jen,
      struct, inner,
      methodScoping = function ( scope, fn, struc ) {
        return function () {
          var ret = fn.apply( scope, arguments );

          // Method extension
          _Api.extend( ret, ret, struc.methodExt );
          return ret;
        };
      };

    for ( i=0, ien=ext.length ; i<ien ; i++ ) {
      struct = ext[i];

      // Value
      obj[ struct.name ] = typeof struct.val === 'function' ?
        methodScoping( scope, struct.val, struct ) :
        $.isPlainObject( struct.val ) ?
          {} :
          struct.val;

      obj[ struct.name ].__dt_wrapper = true;

      // Property extension
      _Api.extend( scope, obj[ struct.name ], struct.propExt );
    }
  };


  // @todo - Is there need for an augment function?
  // _Api.augment = function ( inst, name )
  // {
  //  // Find src object in the structure from the name
  //  var parts = name.split('.');

  //  _Api.extend( inst, obj );
  // };


  //     [
  //       {
  //         name:      'data'                -- string   - Property name
  //         val:       function () {},       -- function - Api method (or undefined if just an object
  //         methodExt: [ ... ],              -- array    - Array of Api object definitions to extend the method result
  //         propExt:   [ ... ]               -- array    - Array of Api object definitions to extend the property
  //       },
  //       {
  //         name:     'row'
  //         val:       {},
  //         methodExt: [ ... ],
  //         propExt:   [
  //           {
  //             name:      'data'
  //             val:       function () {},
  //             methodExt: [ ... ],
  //             propExt:   [ ... ]
  //           },
  //           ...
  //         ]
  //       }
  //     ]

  _Api.register = _api_register = function ( name, val )
  {
    if ( $.isArray( name ) ) {
      for ( var j=0, jen=name.length ; j<jen ; j++ ) {
        _Api.register( name[j], val );
      }
      return;
    }

    var
      i, ien,
      heir = name.split('.'),
      struct = __apiStruct,
      key, method;

    var find = function ( src, name ) {
      for ( var i=0, ien=src.length ; i<ien ; i++ ) {
        if ( src[i].name === name ) {
          return src[i];
        }
      }
      return null;
    };

    for ( i=0, ien=heir.length ; i<ien ; i++ ) {
      method = heir[i].indexOf('()') !== -1;
      key = method ?
        heir[i].replace('()', '') :
        heir[i];

      var src = find( struct, key );
      if ( ! src ) {
        src = {
          name:      key,
          val:       {},
          methodExt: [],
          propExt:   []
        };
        struct.push( src );
      }

      if ( i === ien-1 ) {
        src.val = val;
      }
      else {
        struct = method ?
          src.methodExt :
          src.propExt;
      }
    }
  };


  _Api.registerPlural = _api_registerPlural = function ( pluralName, singularName, val ) {
    _Api.register( pluralName, val );

    _Api.register( singularName, function () {
      var ret = val.apply( this, arguments );

      if ( ret === this ) {
        // Returned item is the API instance that was passed in, return it
        return this;
      }
      else if ( ret instanceof _Api ) {
        // New API instance returned, want the value from the first item
        // in the returned array for the singular result.
        return ret.length ?
          $.isArray( ret[0] ) ?
            new _Api( ret.context, ret[0] ) : // Array results are 'enhanced'
            ret[0] :
          undefined;
      }

      // Non-API return - just fire it back
      return ret;
    } );
  };


  /**
   * Selector for HTML tables. Apply the given selector to the give array of
   * DataTables settings objects.
   *
   * @param {string|integer} [selector] jQuery selector string or integer
   * @param  {array} Array of DataTables settings objects to be filtered
   * @return {array}
   * @ignore
   */
  var __table_selector = function ( selector, a )
  {
    // Integer is used to pick out a table by index
    if ( typeof selector === 'number' ) {
      return [ a[ selector ] ];
    }

    // Perform a jQuery selector on the table nodes
    var nodes = $.map( a, function (el, i) {
      return el.nTable;
    } );

    return $(nodes)
      .filter( selector )
      .map( function (i) {
        // Need to translate back from the table node to the settings
        var idx = $.inArray( this, nodes );
        return a[ idx ];
      } )
      .toArray();
  };



  /**
   * Context selector for the API's context (i.e. the tables the API instance
   * refers to.
   *
   * @name    DataTable.Api#tables
   * @param {string|integer} [selector] Selector to pick which tables the iterator
   *   should operate on. If not given, all tables in the current context are
   *   used. This can be given as a jQuery selector (for example `':gt(0)'`) to
   *   select multiple tables or as an integer to select a single table.
   * @returns {DataTable.Api} Returns a new API instance if a selector is given.
   */
  _api_register( 'tables()', function ( selector ) {
    // A new instance is created if there was a selector specified
    return selector ?
      new _Api( __table_selector( selector, this.context ) ) :
      this;
  } );


  _api_register( 'table()', function ( selector ) {
    var tables = this.tables( selector );
    var ctx = tables.context;

    // Truncate to the first matched table
    return ctx.length ?
      new _Api( ctx[0] ) :
      tables;
  } );


  _api_registerPlural( 'tables().nodes()', 'table().node()' , function () {
    return this.iterator( 'table', function ( ctx ) {
      return ctx.nTable;
    }, 1 );
  } );


  _api_registerPlural( 'tables().body()', 'table().body()' , function () {
    return this.iterator( 'table', function ( ctx ) {
      return ctx.nTBody;
    }, 1 );
  } );


  _api_registerPlural( 'tables().header()', 'table().header()' , function () {
    return this.iterator( 'table', function ( ctx ) {
      return ctx.nTHead;
    }, 1 );
  } );


  _api_registerPlural( 'tables().footer()', 'table().footer()' , function () {
    return this.iterator( 'table', function ( ctx ) {
      return ctx.nTFoot;
    }, 1 );
  } );


  _api_registerPlural( 'tables().containers()', 'table().container()' , function () {
    return this.iterator( 'table', function ( ctx ) {
      return ctx.nTableWrapper;
    }, 1 );
  } );



  /**
   * Redraw the tables in the current context.
   */
  _api_register( 'draw()', function ( paging ) {
    return this.iterator( 'table', function ( settings ) {
      if ( paging === 'page' ) {
        _fnDraw( settings );
      }
      else {
        if ( typeof paging === 'string' ) {
          paging = paging === 'full-hold' ?
            false :
            true;
        }

        _fnReDraw( settings, paging===false );
      }
    } );
  } );



  /**
   * Get the current page index.
   *
   * @return {integer} Current page index (zero based)
   *//**
   * Set the current page.
   *
   * Note that if you attempt to show a page which does not exist, DataTables will
   * not throw an error, but rather reset the paging.
   *
   * @param {integer|string} action The paging action to take. This can be one of:
   *  * `integer` - The page index to jump to
   *  * `string` - An action to take:
   *    * `first` - Jump to first page.
   *    * `next` - Jump to the next page
   *    * `previous` - Jump to previous page
   *    * `last` - Jump to the last page.
   * @returns {DataTables.Api} this
   */
  _api_register( 'page()', function ( action ) {
    if ( action === undefined ) {
      return this.page.info().page; // not an expensive call
    }

    // else, have an action to take on all tables
    return this.iterator( 'table', function ( settings ) {
      _fnPageChange( settings, action );
    } );
  } );


  /**
   * Paging information for the first table in the current context.
   *
   * If you require paging information for another table, use the `table()` method
   * with a suitable selector.
   *
   * @return {object} Object with the following properties set:
   *  * `page` - Current page index (zero based - i.e. the first page is `0`)
   *  * `pages` - Total number of pages
   *  * `start` - Display index for the first record shown on the current page
   *  * `end` - Display index for the last record shown on the current page
   *  * `length` - Display length (number of records). Note that generally `start
   *    + length = end`, but this is not always true, for example if there are
   *    only 2 records to show on the final page, with a length of 10.
   *  * `recordsTotal` - Full data set length
   *  * `recordsDisplay` - Data set length once the current filtering criterion
   *    are applied.
   */
  _api_register( 'page.info()', function ( action ) {
    if ( this.context.length === 0 ) {
      return undefined;
    }

    var
      settings   = this.context[0],
      start      = settings._iDisplayStart,
      len        = settings.oFeatures.bPaginate ? settings._iDisplayLength : -1,
      visRecords = settings.fnRecordsDisplay(),
      all        = len === -1;

    return {
      "page":           all ? 0 : Math.floor( start / len ),
      "pages":          all ? 1 : Math.ceil( visRecords / len ),
      "start":          start,
      "end":            settings.fnDisplayEnd(),
      "length":         len,
      "recordsTotal":   settings.fnRecordsTotal(),
      "recordsDisplay": visRecords,
      "serverSide":     _fnDataSource( settings ) === 'ssp'
    };
  } );


  /**
   * Get the current page length.
   *
   * @return {integer} Current page length. Note `-1` indicates that all records
   *   are to be shown.
   *//**
   * Set the current page length.
   *
   * @param {integer} Page length to set. Use `-1` to show all records.
   * @returns {DataTables.Api} this
   */
  _api_register( 'page.len()', function ( len ) {
    // Note that we can't call this function 'length()' because `length`
    // is a Javascript property of functions which defines how many arguments
    // the function expects.
    if ( len === undefined ) {
      return this.context.length !== 0 ?
        this.context[0]._iDisplayLength :
        undefined;
    }

    // else, set the page length
    return this.iterator( 'table', function ( settings ) {
      _fnLengthChange( settings, len );
    } );
  } );



  var __reload = function ( settings, holdPosition, callback ) {
    // Use the draw event to trigger a callback
    if ( callback ) {
      var api = new _Api( settings );

      api.one( 'draw', function () {
        callback( api.ajax.json() );
      } );
    }

    if ( _fnDataSource( settings ) == 'ssp' ) {
      _fnReDraw( settings, holdPosition );
    }
    else {
      _fnProcessingDisplay( settings, true );

      // Cancel an existing request
      var xhr = settings.jqXHR;
      if ( xhr && xhr.readyState !== 4 ) {
        xhr.abort();
      }

      // Trigger xhr
      _fnBuildAjax( settings, [], function( json ) {
        _fnClearTable( settings );

        var data = _fnAjaxDataSrc( settings, json );
        for ( var i=0, ien=data.length ; i<ien ; i++ ) {
          _fnAddData( settings, data[i] );
        }

        _fnReDraw( settings, holdPosition );
        _fnProcessingDisplay( settings, false );
      } );
    }
  };


  /**
   * Get the JSON response from the last Ajax request that DataTables made to the
   * server. Note that this returns the JSON from the first table in the current
   * context.
   *
   * @return {object} JSON received from the server.
   */
  _api_register( 'ajax.json()', function () {
    var ctx = this.context;

    if ( ctx.length > 0 ) {
      return ctx[0].json;
    }

    // else return undefined;
  } );


  /**
   * Get the data submitted in the last Ajax request
   */
  _api_register( 'ajax.params()', function () {
    var ctx = this.context;

    if ( ctx.length > 0 ) {
      return ctx[0].oAjaxData;
    }

    // else return undefined;
  } );


  /**
   * Reload tables from the Ajax data source. Note that this function will
   * automatically re-draw the table when the remote data has been loaded.
   *
   * @param {boolean} [reset=true] Reset (default) or hold the current paging
   *   position. A full re-sort and re-filter is performed when this method is
   *   called, which is why the pagination reset is the default action.
   * @returns {DataTables.Api} this
   */
  _api_register( 'ajax.reload()', function ( callback, resetPaging ) {
    return this.iterator( 'table', function (settings) {
      __reload( settings, resetPaging===false, callback );
    } );
  } );


  /**
   * Get the current Ajax URL. Note that this returns the URL from the first
   * table in the current context.
   *
   * @return {string} Current Ajax source URL
   *//**
   * Set the Ajax URL. Note that this will set the URL for all tables in the
   * current context.
   *
   * @param {string} url URL to set.
   * @returns {DataTables.Api} this
   */
  _api_register( 'ajax.url()', function ( url ) {
    var ctx = this.context;

    if ( url === undefined ) {
      // get
      if ( ctx.length === 0 ) {
        return undefined;
      }
      ctx = ctx[0];

      return ctx.ajax ?
        $.isPlainObject( ctx.ajax ) ?
          ctx.ajax.url :
          ctx.ajax :
        ctx.sAjaxSource;
    }

    // set
    return this.iterator( 'table', function ( settings ) {
      if ( $.isPlainObject( settings.ajax ) ) {
        settings.ajax.url = url;
      }
      else {
        settings.ajax = url;
      }
      // No need to consider sAjaxSource here since DataTables gives priority
      // to `ajax` over `sAjaxSource`. So setting `ajax` here, renders any
      // value of `sAjaxSource` redundant.
    } );
  } );


  /**
   * Load data from the newly set Ajax URL. Note that this method is only
   * available when `ajax.url()` is used to set a URL. Additionally, this method
   * has the same effect as calling `ajax.reload()` but is provided for
   * convenience when setting a new URL. Like `ajax.reload()` it will
   * automatically redraw the table once the remote data has been loaded.
   *
   * @returns {DataTables.Api} this
   */
  _api_register( 'ajax.url().load()', function ( callback, resetPaging ) {
    // Same as a reload, but makes sense to present it for easy access after a
    // url change
    return this.iterator( 'table', function ( ctx ) {
      __reload( ctx, resetPaging===false, callback );
    } );
  } );




  var _selector_run = function ( type, selector, selectFn, settings, opts )
  {
    var
      out = [], res,
      a, i, ien, j, jen,
      selectorType = typeof selector;

    // Can't just check for isArray here, as an API or jQuery instance might be
    // given with their array like look
    if ( ! selector || selectorType === 'string' || selectorType === 'function' || selector.length === undefined ) {
      selector = [ selector ];
    }

    for ( i=0, ien=selector.length ; i<ien ; i++ ) {
      // Only split on simple strings - complex expressions will be jQuery selectors
      a = selector[i] && selector[i].split && ! selector[i].match(/[\[\(:]/) ?
        selector[i].split(',') :
        [ selector[i] ];

      for ( j=0, jen=a.length ; j<jen ; j++ ) {
        res = selectFn( typeof a[j] === 'string' ? $.trim(a[j]) : a[j] );

        if ( res && res.length ) {
          out = out.concat( res );
        }
      }
    }

    // selector extensions
    var ext = _ext.selector[ type ];
    if ( ext.length ) {
      for ( i=0, ien=ext.length ; i<ien ; i++ ) {
        out = ext[i]( settings, opts, out );
      }
    }

    return _unique( out );
  };


  var _selector_opts = function ( opts )
  {
    if ( ! opts ) {
      opts = {};
    }

    // Backwards compatibility for 1.9- which used the terminology filter rather
    // than search
    if ( opts.filter && opts.search === undefined ) {
      opts.search = opts.filter;
    }

    return $.extend( {
      search: 'none',
      order: 'current',
      page: 'all'
    }, opts );
  };


  var _selector_first = function ( inst )
  {
    // Reduce the API instance to the first item found
    for ( var i=0, ien=inst.length ; i<ien ; i++ ) {
      if ( inst[i].length > 0 ) {
        // Assign the first element to the first item in the instance
        // and truncate the instance and context
        inst[0] = inst[i];
        inst[0].length = 1;
        inst.length = 1;
        inst.context = [ inst.context[i] ];

        return inst;
      }
    }

    // Not found - return an empty instance
    inst.length = 0;
    return inst;
  };


  var _selector_row_indexes = function ( settings, opts )
  {
    var
      i, ien, tmp, a=[],
      displayFiltered = settings.aiDisplay,
      displayMaster = settings.aiDisplayMaster;

    var
      search = opts.search,  // none, applied, removed
      order  = opts.order,   // applied, current, index (original - compatibility with 1.9)
      page   = opts.page;    // all, current

    if ( _fnDataSource( settings ) == 'ssp' ) {
      // In server-side processing mode, most options are irrelevant since
      // rows not shown don't exist and the index order is the applied order
      // Removed is a special case - for consistency just return an empty
      // array
      return search === 'removed' ?
        [] :
        _range( 0, displayMaster.length );
    }
    else if ( page == 'current' ) {
      // Current page implies that order=current and fitler=applied, since it is
      // fairly senseless otherwise, regardless of what order and search actually
      // are
      for ( i=settings._iDisplayStart, ien=settings.fnDisplayEnd() ; i<ien ; i++ ) {
        a.push( displayFiltered[i] );
      }
    }
    else if ( order == 'current' || order == 'applied' ) {
      a = search == 'none' ?
        displayMaster.slice() :                      // no search
        search == 'applied' ?
          displayFiltered.slice() :                // applied search
          $.map( displayMaster, function (el, i) { // removed search
            return $.inArray( el, displayFiltered ) === -1 ? el : null;
          } );
    }
    else if ( order == 'index' || order == 'original' ) {
      for ( i=0, ien=settings.aoData.length ; i<ien ; i++ ) {
        if ( search == 'none' ) {
          a.push( i );
        }
        else { // applied | removed
          tmp = $.inArray( i, displayFiltered );

          if ((tmp === -1 && search == 'removed') ||
            (tmp >= 0   && search == 'applied') )
          {
            a.push( i );
          }
        }
      }
    }

    return a;
  };


  /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
   * Rows
   *
   * {}          - no selector - use all available rows
   * {integer}   - row aoData index
   * {node}      - TR node
   * {string}    - jQuery selector to apply to the TR elements
   * {array}     - jQuery array of nodes, or simply an array of TR nodes
   *
   */


  var __row_selector = function ( settings, selector, opts )
  {
    var rows;
    var run = function ( sel ) {
      var selInt = _intVal( sel );
      var i, ien;

      // Short cut - selector is a number and no options provided (default is
      // all records, so no need to check if the index is in there, since it
      // must be - dev error if the index doesn't exist).
      if ( selInt !== null && ! opts ) {
        return [ selInt ];
      }

      if ( ! rows ) {
        rows = _selector_row_indexes( settings, opts );
      }

      if ( selInt !== null && $.inArray( selInt, rows ) !== -1 ) {
        // Selector - integer
        return [ selInt ];
      }
      else if ( sel === null || sel === undefined || sel === '' ) {
        // Selector - none
        return rows;
      }

      // Selector - function
      if ( typeof sel === 'function' ) {
        return $.map( rows, function (idx) {
          var row = settings.aoData[ idx ];
          return sel( idx, row._aData, row.nTr ) ? idx : null;
        } );
      }

      // Get nodes in the order from the `rows` array with null values removed
      var nodes = _removeEmpty(
        _pluck_order( settings.aoData, rows, 'nTr' )
      );

      // Selector - node
      if ( sel.nodeName ) {
        if ( sel._DT_RowIndex !== undefined ) {
          return [ sel._DT_RowIndex ]; // Property added by DT for fast lookup
        }
        else if ( sel._DT_CellIndex ) {
          return [ sel._DT_CellIndex.row ];
        }
        else {
          var host = $(sel).closest('*[data-dt-row]');
          return host.length ?
            [ host.data('dt-row') ] :
            [];
        }
      }

      // ID selector. Want to always be able to select rows by id, regardless
      // of if the tr element has been created or not, so can't rely upon
      // jQuery here - hence a custom implementation. This does not match
      // Sizzle's fast selector or HTML4 - in HTML5 the ID can be anything,
      // but to select it using a CSS selector engine (like Sizzle or
      // querySelect) it would need to need to be escaped for some characters.
      // DataTables simplifies this for row selectors since you can select
      // only a row. A # indicates an id any anything that follows is the id -
      // unescaped.
      if ( typeof sel === 'string' && sel.charAt(0) === '#' ) {
        // get row index from id
        var rowObj = settings.aIds[ sel.replace( /^#/, '' ) ];
        if ( rowObj !== undefined ) {
          return [ rowObj.idx ];
        }

        // need to fall through to jQuery in case there is DOM id that
        // matches
      }

      // Selector - jQuery selector string, array of nodes or jQuery object/
      // As jQuery's .filter() allows jQuery objects to be passed in filter,
      // it also allows arrays, so this will cope with all three options
      return $(nodes)
        .filter( sel )
        .map( function () {
          return this._DT_RowIndex;
        } )
        .toArray();
    };

    return _selector_run( 'row', selector, run, settings, opts );
  };


  _api_register( 'rows()', function ( selector, opts ) {
    // argument shifting
    if ( selector === undefined ) {
      selector = '';
    }
    else if ( $.isPlainObject( selector ) ) {
      opts = selector;
      selector = '';
    }

    opts = _selector_opts( opts );

    var inst = this.iterator( 'table', function ( settings ) {
      return __row_selector( settings, selector, opts );
    }, 1 );

    // Want argument shifting here and in __row_selector?
    inst.selector.rows = selector;
    inst.selector.opts = opts;

    return inst;
  } );

  _api_register( 'rows().nodes()', function () {
    return this.iterator( 'row', function ( settings, row ) {
      return settings.aoData[ row ].nTr || undefined;
    }, 1 );
  } );

  _api_register( 'rows().data()', function () {
    return this.iterator( true, 'rows', function ( settings, rows ) {
      return _pluck_order( settings.aoData, rows, '_aData' );
    }, 1 );
  } );

  _api_registerPlural( 'rows().cache()', 'row().cache()', function ( type ) {
    return this.iterator( 'row', function ( settings, row ) {
      var r = settings.aoData[ row ];
      return type === 'search' ? r._aFilterData : r._aSortData;
    }, 1 );
  } );

  _api_registerPlural( 'rows().invalidate()', 'row().invalidate()', function ( src ) {
    return this.iterator( 'row', function ( settings, row ) {
      _fnInvalidate( settings, row, src );
    } );
  } );

  _api_registerPlural( 'rows().indexes()', 'row().index()', function () {
    return this.iterator( 'row', function ( settings, row ) {
      return row;
    }, 1 );
  } );

  _api_registerPlural( 'rows().ids()', 'row().id()', function ( hash ) {
    var a = [];
    var context = this.context;

    // `iterator` will drop undefined values, but in this case we want them
    for ( var i=0, ien=context.length ; i<ien ; i++ ) {
      for ( var j=0, jen=this[i].length ; j<jen ; j++ ) {
        var id = context[i].rowIdFn( context[i].aoData[ this[i][j] ]._aData );
        a.push( (hash === true ? '#' : '' )+ id );
      }
    }

    return new _Api( context, a );
  } );

  _api_registerPlural( 'rows().remove()', 'row().remove()', function () {
    var that = this;

    this.iterator( 'row', function ( settings, row, thatIdx ) {
      var data = settings.aoData;
      var rowData = data[ row ];
      var i, ien, j, jen;
      var loopRow, loopCells;

      data.splice( row, 1 );

      // Update the cached indexes
      for ( i=0, ien=data.length ; i<ien ; i++ ) {
        loopRow = data[i];
        loopCells = loopRow.anCells;

        // Rows
        if ( loopRow.nTr !== null ) {
          loopRow.nTr._DT_RowIndex = i;
        }

        // Cells
        if ( loopCells !== null ) {
          for ( j=0, jen=loopCells.length ; j<jen ; j++ ) {
            loopCells[j]._DT_CellIndex.row = i;
          }
        }
      }

      // Delete from the display arrays
      _fnDeleteIndex( settings.aiDisplayMaster, row );
      _fnDeleteIndex( settings.aiDisplay, row );
      _fnDeleteIndex( that[ thatIdx ], row, false ); // maintain local indexes

      // For server-side processing tables - subtract the deleted row from the count
      if ( settings._iRecordsDisplay > 0 ) {
        settings._iRecordsDisplay--;
      }

      // Check for an 'overflow' they case for displaying the table
      _fnLengthOverflow( settings );

      // Remove the row's ID reference if there is one
      var id = settings.rowIdFn( rowData._aData );
      if ( id !== undefined ) {
        delete settings.aIds[ id ];
      }
    } );

    this.iterator( 'table', function ( settings ) {
      for ( var i=0, ien=settings.aoData.length ; i<ien ; i++ ) {
        settings.aoData[i].idx = i;
      }
    } );

    return this;
  } );


  _api_register( 'rows.add()', function ( rows ) {
    var newRows = this.iterator( 'table', function ( settings ) {
        var row, i, ien;
        var out = [];

        for ( i=0, ien=rows.length ; i<ien ; i++ ) {
          row = rows[i];

          if ( row.nodeName && row.nodeName.toUpperCase() === 'TR' ) {
            out.push( _fnAddTr( settings, row )[0] );
          }
          else {
            out.push( _fnAddData( settings, row ) );
          }
        }

        return out;
      }, 1 );

    // Return an Api.rows() extended instance, so rows().nodes() etc can be used
    var modRows = this.rows( -1 );
    modRows.pop();
    $.merge( modRows, newRows );

    return modRows;
  } );





  /**
   *
   */
  _api_register( 'row()', function ( selector, opts ) {
    return _selector_first( this.rows( selector, opts ) );
  } );


  _api_register( 'row().data()', function ( data ) {
    var ctx = this.context;

    if ( data === undefined ) {
      // Get
      return ctx.length && this.length ?
        ctx[0].aoData[ this[0] ]._aData :
        undefined;
    }

    // Set
    ctx[0].aoData[ this[0] ]._aData = data;

    // Automatically invalidate
    _fnInvalidate( ctx[0], this[0], 'data' );

    return this;
  } );


  _api_register( 'row().node()', function () {
    var ctx = this.context;

    return ctx.length && this.length ?
      ctx[0].aoData[ this[0] ].nTr || null :
      null;
  } );


  _api_register( 'row.add()', function ( row ) {
    // Allow a jQuery object to be passed in - only a single row is added from
    // it though - the first element in the set
    if ( row instanceof $ && row.length ) {
      row = row[0];
    }

    var rows = this.iterator( 'table', function ( settings ) {
      if ( row.nodeName && row.nodeName.toUpperCase() === 'TR' ) {
        return _fnAddTr( settings, row )[0];
      }
      return _fnAddData( settings, row );
    } );

    // Return an Api.rows() extended instance, with the newly added row selected
    return this.row( rows[0] );
  } );



  var __details_add = function ( ctx, row, data, klass )
  {
    // Convert to array of TR elements
    var rows = [];
    var addRow = function ( r, k ) {
      // Recursion to allow for arrays of jQuery objects
      if ( $.isArray( r ) || r instanceof $ ) {
        for ( var i=0, ien=r.length ; i<ien ; i++ ) {
          addRow( r[i], k );
        }
        return;
      }

      // If we get a TR element, then just add it directly - up to the dev
      // to add the correct number of columns etc
      if ( r.nodeName && r.nodeName.toLowerCase() === 'tr' ) {
        rows.push( r );
      }
      else {
        // Otherwise create a row with a wrapper
        var created = $('<tr><td/></tr>').addClass( k );
        $('td', created)
          .addClass( k )
          .html( r )
          [0].colSpan = _fnVisbleColumns( ctx );

        rows.push( created[0] );
      }
    };

    addRow( data, klass );

    if ( row._details ) {
      row._details.detach();
    }

    row._details = $(rows);

    // If the children were already shown, that state should be retained
    if ( row._detailsShow ) {
      row._details.insertAfter( row.nTr );
    }
  };


  var __details_remove = function ( api, idx )
  {
    var ctx = api.context;

    if ( ctx.length ) {
      var row = ctx[0].aoData[ idx !== undefined ? idx : api[0] ];

      if ( row && row._details ) {
        row._details.remove();

        row._detailsShow = undefined;
        row._details = undefined;
      }
    }
  };


  var __details_display = function ( api, show ) {
    var ctx = api.context;

    if ( ctx.length && api.length ) {
      var row = ctx[0].aoData[ api[0] ];

      if ( row._details ) {
        row._detailsShow = show;

        if ( show ) {
          row._details.insertAfter( row.nTr );
        }
        else {
          row._details.detach();
        }

        __details_events( ctx[0] );
      }
    }
  };


  var __details_events = function ( settings )
  {
    var api = new _Api( settings );
    var namespace = '.dt.DT_details';
    var drawEvent = 'draw'+namespace;
    var colvisEvent = 'column-visibility'+namespace;
    var destroyEvent = 'destroy'+namespace;
    var data = settings.aoData;

    api.off( drawEvent +' '+ colvisEvent +' '+ destroyEvent );

    if ( _pluck( data, '_details' ).length > 0 ) {
      // On each draw, insert the required elements into the document
      api.on( drawEvent, function ( e, ctx ) {
        if ( settings !== ctx ) {
          return;
        }

        api.rows( {page:'current'} ).eq(0).each( function (idx) {
          // Internal data grab
          var row = data[ idx ];

          if ( row._detailsShow ) {
            row._details.insertAfter( row.nTr );
          }
        } );
      } );

      // Column visibility change - update the colspan
      api.on( colvisEvent, function ( e, ctx, idx, vis ) {
        if ( settings !== ctx ) {
          return;
        }

        // Update the colspan for the details rows (note, only if it already has
        // a colspan)
        var row, visible = _fnVisbleColumns( ctx );

        for ( var i=0, ien=data.length ; i<ien ; i++ ) {
          row = data[i];

          if ( row._details ) {
            row._details.children('td[colspan]').attr('colspan', visible );
          }
        }
      } );

      // Table destroyed - nuke any child rows
      api.on( destroyEvent, function ( e, ctx ) {
        if ( settings !== ctx ) {
          return;
        }

        for ( var i=0, ien=data.length ; i<ien ; i++ ) {
          if ( data[i]._details ) {
            __details_remove( api, i );
          }
        }
      } );
    }
  };

  // Strings for the method names to help minification
  var _emp = '';
  var _child_obj = _emp+'row().child';
  var _child_mth = _child_obj+'()';

  // data can be:
  //  tr
  //  string
  //  jQuery or array of any of the above
  _api_register( _child_mth, function ( data, klass ) {
    var ctx = this.context;

    if ( data === undefined ) {
      // get
      return ctx.length && this.length ?
        ctx[0].aoData[ this[0] ]._details :
        undefined;
    }
    else if ( data === true ) {
      // show
      this.child.show();
    }
    else if ( data === false ) {
      // remove
      __details_remove( this );
    }
    else if ( ctx.length && this.length ) {
      // set
      __details_add( ctx[0], ctx[0].aoData[ this[0] ], data, klass );
    }

    return this;
  } );


  _api_register( [
    _child_obj+'.show()',
    _child_mth+'.show()' // only when `child()` was called with parameters (without
  ], function ( show ) {   // it returns an object and this method is not executed)
    __details_display( this, true );
    return this;
  } );


  _api_register( [
    _child_obj+'.hide()',
    _child_mth+'.hide()' // only when `child()` was called with parameters (without
  ], function () {         // it returns an object and this method is not executed)
    __details_display( this, false );
    return this;
  } );


  _api_register( [
    _child_obj+'.remove()',
    _child_mth+'.remove()' // only when `child()` was called with parameters (without
  ], function () {           // it returns an object and this method is not executed)
    __details_remove( this );
    return this;
  } );


  _api_register( _child_obj+'.isShown()', function () {
    var ctx = this.context;

    if ( ctx.length && this.length ) {
      // _detailsShown as false or undefined will fall through to return false
      return ctx[0].aoData[ this[0] ]._detailsShow || false;
    }
    return false;
  } );



  /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
   * Columns
   *
   * {integer}           - column index (>=0 count from left, <0 count from right)
   * "{integer}:visIdx"  - visible column index (i.e. translate to column index)  (>=0 count from left, <0 count from right)
   * "{integer}:visible" - alias for {integer}:visIdx  (>=0 count from left, <0 count from right)
   * "{string}:name"     - column name
   * "{string}"          - jQuery selector on column header nodes
   *
   */

  // can be an array of these items, comma separated list, or an array of comma
  // separated lists

  var __re_column_selector = /^([^:]+):(name|visIdx|visible)$/;


  // r1 and r2 are redundant - but it means that the parameters match for the
  // iterator callback in columns().data()
  var __columnData = function ( settings, column, r1, r2, rows ) {
    var a = [];
    for ( var row=0, ien=rows.length ; row<ien ; row++ ) {
      a.push( _fnGetCellData( settings, rows[row], column ) );
    }
    return a;
  };


  var __column_selector = function ( settings, selector, opts )
  {
    var
      columns = settings.aoColumns,
      names = _pluck( columns, 'sName' ),
      nodes = _pluck( columns, 'nTh' );

    var run = function ( s ) {
      var selInt = _intVal( s );

      // Selector - all
      if ( s === '' ) {
        return _range( columns.length );
      }

      // Selector - index
      if ( selInt !== null ) {
        return [ selInt >= 0 ?
          selInt : // Count from left
          columns.length + selInt // Count from right (+ because its a negative value)
        ];
      }

      // Selector = function
      if ( typeof s === 'function' ) {
        var rows = _selector_row_indexes( settings, opts );

        return $.map( columns, function (col, idx) {
          return s(
              idx,
              __columnData( settings, idx, 0, 0, rows ),
              nodes[ idx ]
            ) ? idx : null;
        } );
      }

      // jQuery or string selector
      var match = typeof s === 'string' ?
        s.match( __re_column_selector ) :
        '';

      if ( match ) {
        switch( match[2] ) {
          case 'visIdx':
          case 'visible':
            var idx = parseInt( match[1], 10 );
            // Visible index given, convert to column index
            if ( idx < 0 ) {
              // Counting from the right
              var visColumns = $.map( columns, function (col,i) {
                return col.bVisible ? i : null;
              } );
              return [ visColumns[ visColumns.length + idx ] ];
            }
            // Counting from the left
            return [ _fnVisibleToColumnIndex( settings, idx ) ];

          case 'name':
            // match by name. `names` is column index complete and in order
            return $.map( names, function (name, i) {
              return name === match[1] ? i : null;
            } );

          default:
            return [];
        }
      }

      // Cell in the table body
      if ( s.nodeName && s._DT_CellIndex ) {
        return [ s._DT_CellIndex.column ];
      }

      // jQuery selector on the TH elements for the columns
      var jqResult = $( nodes )
        .filter( s )
        .map( function () {
          return $.inArray( this, nodes ); // `nodes` is column index complete and in order
        } )
        .toArray();

      if ( jqResult.length || ! s.nodeName ) {
        return jqResult;
      }

      // Otherwise a node which might have a `dt-column` data attribute, or be
      // a child or such an element
      var host = $(s).closest('*[data-dt-column]');
      return host.length ?
        [ host.data('dt-column') ] :
        [];
    };

    return _selector_run( 'column', selector, run, settings, opts );
  };


  var __setColumnVis = function ( settings, column, vis ) {
    var
      cols = settings.aoColumns,
      col  = cols[ column ],
      data = settings.aoData,
      row, cells, i, ien, tr;

    // Get
    if ( vis === undefined ) {
      return col.bVisible;
    }

    // Set
    // No change
    if ( col.bVisible === vis ) {
      return;
    }

    if ( vis ) {
      // Insert column
      // Need to decide if we should use appendChild or insertBefore
      var insertBefore = $.inArray( true, _pluck(cols, 'bVisible'), column+1 );

      for ( i=0, ien=data.length ; i<ien ; i++ ) {
        tr = data[i].nTr;
        cells = data[i].anCells;

        if ( tr ) {
          // insertBefore can act like appendChild if 2nd arg is null
          tr.insertBefore( cells[ column ], cells[ insertBefore ] || null );
        }
      }
    }
    else {
      // Remove column
      $( _pluck( settings.aoData, 'anCells', column ) ).detach();
    }

    // Common actions
    col.bVisible = vis;
    _fnDrawHead( settings, settings.aoHeader );
    _fnDrawHead( settings, settings.aoFooter );

    _fnSaveState( settings );
  };


  _api_register( 'columns()', function ( selector, opts ) {
    // argument shifting
    if ( selector === undefined ) {
      selector = '';
    }
    else if ( $.isPlainObject( selector ) ) {
      opts = selector;
      selector = '';
    }

    opts = _selector_opts( opts );

    var inst = this.iterator( 'table', function ( settings ) {
      return __column_selector( settings, selector, opts );
    }, 1 );

    // Want argument shifting here and in _row_selector?
    inst.selector.cols = selector;
    inst.selector.opts = opts;

    return inst;
  } );

  _api_registerPlural( 'columns().header()', 'column().header()', function ( selector, opts ) {
    return this.iterator( 'column', function ( settings, column ) {
      return settings.aoColumns[column].nTh;
    }, 1 );
  } );

  _api_registerPlural( 'columns().footer()', 'column().footer()', function ( selector, opts ) {
    return this.iterator( 'column', function ( settings, column ) {
      return settings.aoColumns[column].nTf;
    }, 1 );
  } );

  _api_registerPlural( 'columns().data()', 'column().data()', function () {
    return this.iterator( 'column-rows', __columnData, 1 );
  } );

  _api_registerPlural( 'columns().dataSrc()', 'column().dataSrc()', function () {
    return this.iterator( 'column', function ( settings, column ) {
      return settings.aoColumns[column].mData;
    }, 1 );
  } );

  _api_registerPlural( 'columns().cache()', 'column().cache()', function ( type ) {
    return this.iterator( 'column-rows', function ( settings, column, i, j, rows ) {
      return _pluck_order( settings.aoData, rows,
        type === 'search' ? '_aFilterData' : '_aSortData', column
      );
    }, 1 );
  } );

  _api_registerPlural( 'columns().nodes()', 'column().nodes()', function () {
    return this.iterator( 'column-rows', function ( settings, column, i, j, rows ) {
      return _pluck_order( settings.aoData, rows, 'anCells', column ) ;
    }, 1 );
  } );

  _api_registerPlural( 'columns().visible()', 'column().visible()', function ( vis, calc ) {
    var ret = this.iterator( 'column', function ( settings, column ) {
      if ( vis === undefined ) {
        return settings.aoColumns[ column ].bVisible;
      } // else
      __setColumnVis( settings, column, vis );
    } );

    // Group the column visibility changes
    if ( vis !== undefined ) {
      // Second loop once the first is done for events
      this.iterator( 'column', function ( settings, column ) {
        _fnCallbackFire( settings, null, 'column-visibility', [settings, column, vis, calc] );
      } );

      if ( calc === undefined || calc ) {
        this.columns.adjust();
      }
    }

    return ret;
  } );

  _api_registerPlural( 'columns().indexes()', 'column().index()', function ( type ) {
    return this.iterator( 'column', function ( settings, column ) {
      return type === 'visible' ?
        _fnColumnIndexToVisible( settings, column ) :
        column;
    }, 1 );
  } );

  _api_register( 'columns.adjust()', function () {
    return this.iterator( 'table', function ( settings ) {
      _fnAdjustColumnSizing( settings );
    }, 1 );
  } );

  _api_register( 'column.index()', function ( type, idx ) {
    if ( this.context.length !== 0 ) {
      var ctx = this.context[0];

      if ( type === 'fromVisible' || type === 'toData' ) {
        return _fnVisibleToColumnIndex( ctx, idx );
      }
      else if ( type === 'fromData' || type === 'toVisible' ) {
        return _fnColumnIndexToVisible( ctx, idx );
      }
    }
  } );

  _api_register( 'column()', function ( selector, opts ) {
    return _selector_first( this.columns( selector, opts ) );
  } );



  var __cell_selector = function ( settings, selector, opts )
  {
    var data = settings.aoData;
    var rows = _selector_row_indexes( settings, opts );
    var cells = _removeEmpty( _pluck_order( data, rows, 'anCells' ) );
    var allCells = $( [].concat.apply([], cells) );
    var row;
    var columns = settings.aoColumns.length;
    var a, i, ien, j, o, host;

    var run = function ( s ) {
      var fnSelector = typeof s === 'function';

      if ( s === null || s === undefined || fnSelector ) {
        // All cells and function selectors
        a = [];

        for ( i=0, ien=rows.length ; i<ien ; i++ ) {
          row = rows[i];

          for ( j=0 ; j<columns ; j++ ) {
            o = {
              row: row,
              column: j
            };

            if ( fnSelector ) {
              // Selector - function
              host = data[ row ];

              if ( s( o, _fnGetCellData(settings, row, j), host.anCells ? host.anCells[j] : null ) ) {
                a.push( o );
              }
            }
            else {
              // Selector - all
              a.push( o );
            }
          }
        }

        return a;
      }

      // Selector - index
      if ( $.isPlainObject( s ) ) {
        return [s];
      }

      // Selector - jQuery filtered cells
      var jqResult = allCells
        .filter( s )
        .map( function (i, el) {
          return { // use a new object, in case someone changes the values
            row:    el._DT_CellIndex.row,
            column: el._DT_CellIndex.column
          };
        } )
        .toArray();

      if ( jqResult.length || ! s.nodeName ) {
        return jqResult;
      }

      // Otherwise the selector is a node, and there is one last option - the
      // element might be a child of an element which has dt-row and dt-column
      // data attributes
      host = $(s).closest('*[data-dt-row]');
      return host.length ?
        [ {
          row: host.data('dt-row'),
          column: host.data('dt-column')
        } ] :
        [];
    };

    return _selector_run( 'cell', selector, run, settings, opts );
  };




  _api_register( 'cells()', function ( rowSelector, columnSelector, opts ) {
    // Argument shifting
    if ( $.isPlainObject( rowSelector ) ) {
      // Indexes
      if ( rowSelector.row === undefined ) {
        // Selector options in first parameter
        opts = rowSelector;
        rowSelector = null;
      }
      else {
        // Cell index objects in first parameter
        opts = columnSelector;
        columnSelector = null;
      }
    }
    if ( $.isPlainObject( columnSelector ) ) {
      opts = columnSelector;
      columnSelector = null;
    }

    // Cell selector
    if ( columnSelector === null || columnSelector === undefined ) {
      return this.iterator( 'table', function ( settings ) {
        return __cell_selector( settings, rowSelector, _selector_opts( opts ) );
      } );
    }

    // Row + column selector
    var columns = this.columns( columnSelector, opts );
    var rows = this.rows( rowSelector, opts );
    var a, i, ien, j, jen;

    var cells = this.iterator( 'table', function ( settings, idx ) {
      a = [];

      for ( i=0, ien=rows[idx].length ; i<ien ; i++ ) {
        for ( j=0, jen=columns[idx].length ; j<jen ; j++ ) {
          a.push( {
            row:    rows[idx][i],
            column: columns[idx][j]
          } );
        }
      }

      return a;
    }, 1 );

    $.extend( cells.selector, {
      cols: columnSelector,
      rows: rowSelector,
      opts: opts
    } );

    return cells;
  } );


  _api_registerPlural( 'cells().nodes()', 'cell().node()', function () {
    return this.iterator( 'cell', function ( settings, row, column ) {
      var data = settings.aoData[ row ];

      return data && data.anCells ?
        data.anCells[ column ] :
        undefined;
    }, 1 );
  } );


  _api_register( 'cells().data()', function () {
    return this.iterator( 'cell', function ( settings, row, column ) {
      return _fnGetCellData( settings, row, column );
    }, 1 );
  } );


  _api_registerPlural( 'cells().cache()', 'cell().cache()', function ( type ) {
    type = type === 'search' ? '_aFilterData' : '_aSortData';

    return this.iterator( 'cell', function ( settings, row, column ) {
      return settings.aoData[ row ][ type ][ column ];
    }, 1 );
  } );


  _api_registerPlural( 'cells().render()', 'cell().render()', function ( type ) {
    return this.iterator( 'cell', function ( settings, row, column ) {
      return _fnGetCellData( settings, row, column, type );
    }, 1 );
  } );


  _api_registerPlural( 'cells().indexes()', 'cell().index()', function () {
    return this.iterator( 'cell', function ( settings, row, column ) {
      return {
        row: row,
        column: column,
        columnVisible: _fnColumnIndexToVisible( settings, column )
      };
    }, 1 );
  } );


  _api_registerPlural( 'cells().invalidate()', 'cell().invalidate()', function ( src ) {
    return this.iterator( 'cell', function ( settings, row, column ) {
      _fnInvalidate( settings, row, src, column );
    } );
  } );



  _api_register( 'cell()', function ( rowSelector, columnSelector, opts ) {
    return _selector_first( this.cells( rowSelector, columnSelector, opts ) );
  } );


  _api_register( 'cell().data()', function ( data ) {
    var ctx = this.context;
    var cell = this[0];

    if ( data === undefined ) {
      // Get
      return ctx.length && cell.length ?
        _fnGetCellData( ctx[0], cell[0].row, cell[0].column ) :
        undefined;
    }

    // Set
    _fnSetCellData( ctx[0], cell[0].row, cell[0].column, data );
    _fnInvalidate( ctx[0], cell[0].row, 'data', cell[0].column );

    return this;
  } );



  /**
   * Get current ordering (sorting) that has been applied to the table.
   *
   * @returns {array} 2D array containing the sorting information for the first
   *   table in the current context. Each element in the parent array represents
   *   a column being sorted upon (i.e. multi-sorting with two columns would have
   *   2 inner arrays). The inner arrays may have 2 or 3 elements. The first is
   *   the column index that the sorting condition applies to, the second is the
   *   direction of the sort (`desc` or `asc`) and, optionally, the third is the
   *   index of the sorting order from the `column.sorting` initialisation array.
   *//**
   * Set the ordering for the table.
   *
   * @param {integer} order Column index to sort upon.
   * @param {string} direction Direction of the sort to be applied (`asc` or `desc`)
   * @returns {DataTables.Api} this
   *//**
   * Set the ordering for the table.
   *
   * @param {array} order 1D array of sorting information to be applied.
   * @param {array} [...] Optional additional sorting conditions
   * @returns {DataTables.Api} this
   *//**
   * Set the ordering for the table.
   *
   * @param {array} order 2D array of sorting information to be applied.
   * @returns {DataTables.Api} this
   */
  _api_register( 'order()', function ( order, dir ) {
    var ctx = this.context;

    if ( order === undefined ) {
      // get
      return ctx.length !== 0 ?
        ctx[0].aaSorting :
        undefined;
    }

    // set
    if ( typeof order === 'number' ) {
      // Simple column / direction passed in
      order = [ [ order, dir ] ];
    }
    else if ( order.length && ! $.isArray( order[0] ) ) {
      // Arguments passed in (list of 1D arrays)
      order = Array.prototype.slice.call( arguments );
    }
    // otherwise a 2D array was passed in

    return this.iterator( 'table', function ( settings ) {
      settings.aaSorting = order.slice();
    } );
  } );


  /**
   * Attach a sort listener to an element for a given column
   *
   * @param {node|jQuery|string} node Identifier for the element(s) to attach the
   *   listener to. This can take the form of a single DOM node, a jQuery
   *   collection of nodes or a jQuery selector which will identify the node(s).
   * @param {integer} column the column that a click on this node will sort on
   * @param {function} [callback] callback function when sort is run
   * @returns {DataTables.Api} this
   */
  _api_register( 'order.listener()', function ( node, column, callback ) {
    return this.iterator( 'table', function ( settings ) {
      _fnSortAttachListener( settings, node, column, callback );
    } );
  } );


  _api_register( 'order.fixed()', function ( set ) {
    if ( ! set ) {
      var ctx = this.context;
      var fixed = ctx.length ?
        ctx[0].aaSortingFixed :
        undefined;

      return $.isArray( fixed ) ?
        { pre: fixed } :
        fixed;
    }

    return this.iterator( 'table', function ( settings ) {
      settings.aaSortingFixed = $.extend( true, {}, set );
    } );
  } );


  // Order by the selected column(s)
  _api_register( [
    'columns().order()',
    'column().order()'
  ], function ( dir ) {
    var that = this;

    return this.iterator( 'table', function ( settings, i ) {
      var sort = [];

      $.each( that[i], function (j, col) {
        sort.push( [ col, dir ] );
      } );

      settings.aaSorting = sort;
    } );
  } );



  _api_register( 'search()', function ( input, regex, smart, caseInsen ) {
    var ctx = this.context;

    if ( input === undefined ) {
      // get
      return ctx.length !== 0 ?
        ctx[0].oPreviousSearch.sSearch :
        undefined;
    }

    // set
    return this.iterator( 'table', function ( settings ) {
      if ( ! settings.oFeatures.bFilter ) {
        return;
      }

      _fnFilterComplete( settings, $.extend( {}, settings.oPreviousSearch, {
        "sSearch": input+"",
        "bRegex":  regex === null ? false : regex,
        "bSmart":  smart === null ? true  : smart,
        "bCaseInsensitive": caseInsen === null ? true : caseInsen
      } ), 1 );
    } );
  } );


  _api_registerPlural(
    'columns().search()',
    'column().search()',
    function ( input, regex, smart, caseInsen ) {
      return this.iterator( 'column', function ( settings, column ) {
        var preSearch = settings.aoPreSearchCols;

        if ( input === undefined ) {
          // get
          return preSearch[ column ].sSearch;
        }

        // set
        if ( ! settings.oFeatures.bFilter ) {
          return;
        }

        $.extend( preSearch[ column ], {
          "sSearch": input+"",
          "bRegex":  regex === null ? false : regex,
          "bSmart":  smart === null ? true  : smart,
          "bCaseInsensitive": caseInsen === null ? true : caseInsen
        } );

        _fnFilterComplete( settings, settings.oPreviousSearch, 1 );
      } );
    }
  );

  /*
   * State API methods
   */

  _api_register( 'state()', function () {
    return this.context.length ?
      this.context[0].oSavedState :
      null;
  } );


  _api_register( 'state.clear()', function () {
    return this.iterator( 'table', function ( settings ) {
      // Save an empty object
      settings.fnStateSaveCallback.call( settings.oInstance, settings, {} );
    } );
  } );


  _api_register( 'state.loaded()', function () {
    return this.context.length ?
      this.context[0].oLoadedState :
      null;
  } );


  _api_register( 'state.save()', function () {
    return this.iterator( 'table', function ( settings ) {
      _fnSaveState( settings );
    } );
  } );



  /**
   * Provide a common method for plug-ins to check the version of DataTables being
   * used, in order to ensure compatibility.
   *
   *  @param {string} version Version string to check for, in the format "X.Y.Z".
   *    Note that the formats "X" and "X.Y" are also acceptable.
   *  @returns {boolean} true if this version of DataTables is greater or equal to
   *    the required version, or false if this version of DataTales is not
   *    suitable
   *  @static
   *  @dtopt API-Static
   *
   *  @example
   *    alert( $.fn.dataTable.versionCheck( '1.9.0' ) );
   */
  DataTable.versionCheck = DataTable.fnVersionCheck = function( version )
  {
    var aThis = DataTable.version.split('.');
    var aThat = version.split('.');
    var iThis, iThat;

    for ( var i=0, iLen=aThat.length ; i<iLen ; i++ ) {
      iThis = parseInt( aThis[i], 10 ) || 0;
      iThat = parseInt( aThat[i], 10 ) || 0;

      // Parts are the same, keep comparing
      if (iThis === iThat) {
        continue;
      }

      // Parts are different, return immediately
      return iThis > iThat;
    }

    return true;
  };


  /**
   * Check if a `<table>` node is a DataTable table already or not.
   *
   *  @param {node|jquery|string} table Table node, jQuery object or jQuery
   *      selector for the table to test. Note that if more than more than one
   *      table is passed on, only the first will be checked
   *  @returns {boolean} true the table given is a DataTable, or false otherwise
   *  @static
   *  @dtopt API-Static
   *
   *  @example
   *    if ( ! $.fn.DataTable.isDataTable( '#example' ) ) {
   *      $('#example').dataTable();
   *    }
   */
  DataTable.isDataTable = DataTable.fnIsDataTable = function ( table )
  {
    var t = $(table).get(0);
    var is = false;

    if ( table instanceof DataTable.Api ) {
      return true;
    }

    $.each( DataTable.settings, function (i, o) {
      var head = o.nScrollHead ? $('table', o.nScrollHead)[0] : null;
      var foot = o.nScrollFoot ? $('table', o.nScrollFoot)[0] : null;

      if ( o.nTable === t || head === t || foot === t ) {
        is = true;
      }
    } );

    return is;
  };


  /**
   * Get all DataTable tables that have been initialised - optionally you can
   * select to get only currently visible tables.
   *
   *  @param {boolean} [visible=false] Flag to indicate if you want all (default)
   *    or visible tables only.
   *  @returns {array} Array of `table` nodes (not DataTable instances) which are
   *    DataTables
   *  @static
   *  @dtopt API-Static
   *
   *  @example
   *    $.each( $.fn.dataTable.tables(true), function () {
   *      $(table).DataTable().columns.adjust();
   *    } );
   */
  DataTable.tables = DataTable.fnTables = function ( visible )
  {
    var api = false;

    if ( $.isPlainObject( visible ) ) {
      api = visible.api;
      visible = visible.visible;
    }

    var a = $.map( DataTable.settings, function (o) {
      if ( !visible || (visible && $(o.nTable).is(':visible')) ) {
        return o.nTable;
      }
    } );

    return api ?
      new _Api( a ) :
      a;
  };


  /**
   * Convert from camel case parameters to Hungarian notation. This is made public
   * for the extensions to provide the same ability as DataTables core to accept
   * either the 1.9 style Hungarian notation, or the 1.10+ style camelCase
   * parameters.
   *
   *  @param {object} src The model object which holds all parameters that can be
   *    mapped.
   *  @param {object} user The object to convert from camel case to Hungarian.
   *  @param {boolean} force When set to `true`, properties which already have a
   *    Hungarian value in the `user` object will be overwritten. Otherwise they
   *    won't be.
   */
  DataTable.camelToHungarian = _fnCamelToHungarian;



  /**
   *
   */
  _api_register( '$()', function ( selector, opts ) {
    var
      rows   = this.rows( opts ).nodes(), // Get all rows
      jqRows = $(rows);

    return $( [].concat(
      jqRows.filter( selector ).toArray(),
      jqRows.find( selector ).toArray()
    ) );
  } );


  // jQuery functions to operate on the tables
  $.each( [ 'on', 'one', 'off' ], function (i, key) {
    _api_register( key+'()', function ( /* event, handler */ ) {
      var args = Array.prototype.slice.call(arguments);

      // Add the `dt` namespace automatically if it isn't already present
      args[0] = $.map( args[0].split( /\s/ ), function ( e ) {
        return ! e.match(/\.dt\b/) ?
          e+'.dt' :
          e;
        } ).join( ' ' );

      var inst = $( this.tables().nodes() );
      inst[key].apply( inst, args );
      return this;
    } );
  } );


  _api_register( 'clear()', function () {
    return this.iterator( 'table', function ( settings ) {
      _fnClearTable( settings );
    } );
  } );


  _api_register( 'settings()', function () {
    return new _Api( this.context, this.context );
  } );


  _api_register( 'init()', function () {
    var ctx = this.context;
    return ctx.length ? ctx[0].oInit : null;
  } );


  _api_register( 'data()', function () {
    return this.iterator( 'table', function ( settings ) {
      return _pluck( settings.aoData, '_aData' );
    } ).flatten();
  } );


  _api_register( 'destroy()', function ( remove ) {
    remove = remove || false;

    return this.iterator( 'table', function ( settings ) {
      var orig      = settings.nTableWrapper.parentNode;
      var classes   = settings.oClasses;
      var table     = settings.nTable;
      var tbody     = settings.nTBody;
      var thead     = settings.nTHead;
      var tfoot     = settings.nTFoot;
      var jqTable   = $(table);
      var jqTbody   = $(tbody);
      var jqWrapper = $(settings.nTableWrapper);
      var rows      = $.map( settings.aoData, function (r) { return r.nTr; } );
      var i, ien;

      // Flag to note that the table is currently being destroyed - no action
      // should be taken
      settings.bDestroying = true;

      // Fire off the destroy callbacks for plug-ins etc
      _fnCallbackFire( settings, "aoDestroyCallback", "destroy", [settings] );

      // If not being removed from the document, make all columns visible
      if ( ! remove ) {
        new _Api( settings ).columns().visible( true );
      }

      // Blitz all `DT` namespaced events (these are internal events, the
      // lowercase, `dt` events are user subscribed and they are responsible
      // for removing them
      jqWrapper.off('.DT').find(':not(tbody *)').off('.DT');
      $(window).off('.DT-'+settings.sInstance);

      // When scrolling we had to break the table up - restore it
      if ( table != thead.parentNode ) {
        jqTable.children('thead').detach();
        jqTable.append( thead );
      }

      if ( tfoot && table != tfoot.parentNode ) {
        jqTable.children('tfoot').detach();
        jqTable.append( tfoot );
      }

      settings.aaSorting = [];
      settings.aaSortingFixed = [];
      _fnSortingClasses( settings );

      $( rows ).removeClass( settings.asStripeClasses.join(' ') );

      $('th, td', thead).removeClass( classes.sSortable+' '+
        classes.sSortableAsc+' '+classes.sSortableDesc+' '+classes.sSortableNone
      );

      // Add the TR elements back into the table in their original order
      jqTbody.children().detach();
      jqTbody.append( rows );

      // Remove the DataTables generated nodes, events and classes
      var removedMethod = remove ? 'remove' : 'detach';
      jqTable[ removedMethod ]();
      jqWrapper[ removedMethod ]();

      // If we need to reattach the table to the document
      if ( ! remove && orig ) {
        // insertBefore acts like appendChild if !arg[1]
        orig.insertBefore( table, settings.nTableReinsertBefore );

        // Restore the width of the original table - was read from the style property,
        // so we can restore directly to that
        jqTable
          .css( 'width', settings.sDestroyWidth )
          .removeClass( classes.sTable );

        // If the were originally stripe classes - then we add them back here.
        // Note this is not fool proof (for example if not all rows had stripe
        // classes - but it's a good effort without getting carried away
        ien = settings.asDestroyStripes.length;

        if ( ien ) {
          jqTbody.children().each( function (i) {
            $(this).addClass( settings.asDestroyStripes[i % ien] );
          } );
        }
      }

      /* Remove the settings object from the settings array */
      var idx = $.inArray( settings, DataTable.settings );
      if ( idx !== -1 ) {
        DataTable.settings.splice( idx, 1 );
      }
    } );
  } );


  // Add the `every()` method for rows, columns and cells in a compact form
  $.each( [ 'column', 'row', 'cell' ], function ( i, type ) {
    _api_register( type+'s().every()', function ( fn ) {
      var opts = this.selector.opts;
      var api = this;

      return this.iterator( type, function ( settings, arg1, arg2, arg3, arg4 ) {
        // Rows and columns:
        //  arg1 - index
        //  arg2 - table counter
        //  arg3 - loop counter
        //  arg4 - undefined
        // Cells:
        //  arg1 - row index
        //  arg2 - column index
        //  arg3 - table counter
        //  arg4 - loop counter
        fn.call(
          api[ type ](
            arg1,
            type==='cell' ? arg2 : opts,
            type==='cell' ? opts : undefined
          ),
          arg1, arg2, arg3, arg4
        );
      } );
    } );
  } );


  // i18n method for extensions to be able to use the language object from the
  // DataTable
  _api_register( 'i18n()', function ( token, def, plural ) {
    var ctx = this.context[0];
    var resolved = _fnGetObjectDataFn( token )( ctx.oLanguage );

    if ( resolved === undefined ) {
      resolved = def;
    }

    if ( plural !== undefined && $.isPlainObject( resolved ) ) {
      resolved = resolved[ plural ] !== undefined ?
        resolved[ plural ] :
        resolved._;
    }

    return resolved.replace( '%d', plural ); // nb: plural might be undefined,
  } );

  /**
   * Version string for plug-ins to check compatibility. Allowed format is
   * `a.b.c-d` where: a:int, b:int, c:int, d:string(dev|beta|alpha). `d` is used
   * only for non-release builds. See http://semver.org/ for more information.
   *  @member
   *  @type string
   *  @default Version number
   */
  DataTable.version = "1.10.16";

  /**
   * Private data store, containing all of the settings objects that are
   * created for the tables on a given page.
   *
   * Note that the `DataTable.settings` object is aliased to
   * `jQuery.fn.dataTableExt` through which it may be accessed and
   * manipulated, or `jQuery.fn.dataTable.settings`.
   *  @member
   *  @type array
   *  @default []
   *  @private
   */
  DataTable.settings = [];

  /**
   * Object models container, for the various models that DataTables has
   * available to it. These models define the objects that are used to hold
   * the active state and configuration of the table.
   *  @namespace
   */
  DataTable.models = {};



  /**
   * Template object for the way in which DataTables holds information about
   * search information for the global filter and individual column filters.
   *  @namespace
   */
  DataTable.models.oSearch = {
    /**
     * Flag to indicate if the filtering should be case insensitive or not
     *  @type boolean
     *  @default true
     */
    "bCaseInsensitive": true,

    /**
     * Applied search term
     *  @type string
     *  @default <i>Empty string</i>
     */
    "sSearch": "",

    /**
     * Flag to indicate if the search term should be interpreted as a
     * regular expression (true) or not (false) and therefore and special
     * regex characters escaped.
     *  @type boolean
     *  @default false
     */
    "bRegex": false,

    /**
     * Flag to indicate if DataTables is to use its smart filtering or not.
     *  @type boolean
     *  @default true
     */
    "bSmart": true
  };




  /**
   * Template object for the way in which DataTables holds information about
   * each individual row. This is the object format used for the settings
   * aoData array.
   *  @namespace
   */
  DataTable.models.oRow = {
    /**
     * TR element for the row
     *  @type node
     *  @default null
     */
    "nTr": null,

    /**
     * Array of TD elements for each row. This is null until the row has been
     * created.
     *  @type array nodes
     *  @default []
     */
    "anCells": null,

    /**
     * Data object from the original data source for the row. This is either
     * an array if using the traditional form of DataTables, or an object if
     * using mData options. The exact type will depend on the passed in
     * data from the data source, or will be an array if using DOM a data
     * source.
     *  @type array|object
     *  @default []
     */
    "_aData": [],

    /**
     * Sorting data cache - this array is ostensibly the same length as the
     * number of columns (although each index is generated only as it is
     * needed), and holds the data that is used for sorting each column in the
     * row. We do this cache generation at the start of the sort in order that
     * the formatting of the sort data need be done only once for each cell
     * per sort. This array should not be read from or written to by anything
     * other than the master sorting methods.
     *  @type array
     *  @default null
     *  @private
     */
    "_aSortData": null,

    /**
     * Per cell filtering data cache. As per the sort data cache, used to
     * increase the performance of the filtering in DataTables
     *  @type array
     *  @default null
     *  @private
     */
    "_aFilterData": null,

    /**
     * Filtering data cache. This is the same as the cell filtering cache, but
     * in this case a string rather than an array. This is easily computed with
     * a join on `_aFilterData`, but is provided as a cache so the join isn't
     * needed on every search (memory traded for performance)
     *  @type array
     *  @default null
     *  @private
     */
    "_sFilterRow": null,

    /**
     * Cache of the class name that DataTables has applied to the row, so we
     * can quickly look at this variable rather than needing to do a DOM check
     * on className for the nTr property.
     *  @type string
     *  @default <i>Empty string</i>
     *  @private
     */
    "_sRowStripe": "",

    /**
     * Denote if the original data source was from the DOM, or the data source
     * object. This is used for invalidating data, so DataTables can
     * automatically read data from the original source, unless uninstructed
     * otherwise.
     *  @type string
     *  @default null
     *  @private
     */
    "src": null,

    /**
     * Index in the aoData array. This saves an indexOf lookup when we have the
     * object, but want to know the index
     *  @type integer
     *  @default -1
     *  @private
     */
    "idx": -1
  };


  /**
   * Template object for the column information object in DataTables. This object
   * is held in the settings aoColumns array and contains all the information that
   * DataTables needs about each individual column.
   *
   * Note that this object is related to {@link DataTable.defaults.column}
   * but this one is the internal data store for DataTables's cache of columns.
   * It should NOT be manipulated outside of DataTables. Any configuration should
   * be done through the initialisation options.
   *  @namespace
   */
  DataTable.models.oColumn = {
    /**
     * Column index. This could be worked out on-the-fly with $.inArray, but it
     * is faster to just hold it as a variable
     *  @type integer
     *  @default null
     */
    "idx": null,

    /**
     * A list of the columns that sorting should occur on when this column
     * is sorted. That this property is an array allows multi-column sorting
     * to be defined for a column (for example first name / last name columns
     * would benefit from this). The values are integers pointing to the
     * columns to be sorted on (typically it will be a single integer pointing
     * at itself, but that doesn't need to be the case).
     *  @type array
     */
    "aDataSort": null,

    /**
     * Define the sorting directions that are applied to the column, in sequence
     * as the column is repeatedly sorted upon - i.e. the first value is used
     * as the sorting direction when the column if first sorted (clicked on).
     * Sort it again (click again) and it will move on to the next index.
     * Repeat until loop.
     *  @type array
     */
    "asSorting": null,

    /**
     * Flag to indicate if the column is searchable, and thus should be included
     * in the filtering or not.
     *  @type boolean
     */
    "bSearchable": null,

    /**
     * Flag to indicate if the column is sortable or not.
     *  @type boolean
     */
    "bSortable": null,

    /**
     * Flag to indicate if the column is currently visible in the table or not
     *  @type boolean
     */
    "bVisible": null,

    /**
     * Store for manual type assignment using the `column.type` option. This
     * is held in store so we can manipulate the column's `sType` property.
     *  @type string
     *  @default null
     *  @private
     */
    "_sManualType": null,

    /**
     * Flag to indicate if HTML5 data attributes should be used as the data
     * source for filtering or sorting. True is either are.
     *  @type boolean
     *  @default false
     *  @private
     */
    "_bAttrSrc": false,

    /**
     * Developer definable function that is called whenever a cell is created (Ajax source,
     * etc) or processed for input (DOM source). This can be used as a compliment to mRender
     * allowing you to modify the DOM element (add background colour for example) when the
     * element is available.
     *  @type function
     *  @param {element} nTd The TD node that has been created
     *  @param {*} sData The Data for the cell
     *  @param {array|object} oData The data for the whole row
     *  @param {int} iRow The row index for the aoData data store
     *  @default null
     */
    "fnCreatedCell": null,

    /**
     * Function to get data from a cell in a column. You should <b>never</b>
     * access data directly through _aData internally in DataTables - always use
     * the method attached to this property. It allows mData to function as
     * required. This function is automatically assigned by the column
     * initialisation method
     *  @type function
     *  @param {array|object} oData The data array/object for the array
     *    (i.e. aoData[]._aData)
     *  @param {string} sSpecific The specific data type you want to get -
     *    'display', 'type' 'filter' 'sort'
     *  @returns {*} The data for the cell from the given row's data
     *  @default null
     */
    "fnGetData": null,

    /**
     * Function to set data for a cell in the column. You should <b>never</b>
     * set the data directly to _aData internally in DataTables - always use
     * this method. It allows mData to function as required. This function
     * is automatically assigned by the column initialisation method
     *  @type function
     *  @param {array|object} oData The data array/object for the array
     *    (i.e. aoData[]._aData)
     *  @param {*} sValue Value to set
     *  @default null
     */
    "fnSetData": null,

    /**
     * Property to read the value for the cells in the column from the data
     * source array / object. If null, then the default content is used, if a
     * function is given then the return from the function is used.
     *  @type function|int|string|null
     *  @default null
     */
    "mData": null,

    /**
     * Partner property to mData which is used (only when defined) to get
     * the data - i.e. it is basically the same as mData, but without the
     * 'set' option, and also the data fed to it is the result from mData.
     * This is the rendering method to match the data method of mData.
     *  @type function|int|string|null
     *  @default null
     */
    "mRender": null,

    /**
     * Unique header TH/TD element for this column - this is what the sorting
     * listener is attached to (if sorting is enabled.)
     *  @type node
     *  @default null
     */
    "nTh": null,

    /**
     * Unique footer TH/TD element for this column (if there is one). Not used
     * in DataTables as such, but can be used for plug-ins to reference the
     * footer for each column.
     *  @type node
     *  @default null
     */
    "nTf": null,

    /**
     * The class to apply to all TD elements in the table's TBODY for the column
     *  @type string
     *  @default null
     */
    "sClass": null,

    /**
     * When DataTables calculates the column widths to assign to each column,
     * it finds the longest string in each column and then constructs a
     * temporary table and reads the widths from that. The problem with this
     * is that "mmm" is much wider then "iiii", but the latter is a longer
     * string - thus the calculation can go wrong (doing it properly and putting
     * it into an DOM object and measuring that is horribly(!) slow). Thus as
     * a "work around" we provide this option. It will append its value to the
     * text that is found to be the longest string for the column - i.e. padding.
     *  @type string
     */
    "sContentPadding": null,

    /**
     * Allows a default value to be given for a column's data, and will be used
     * whenever a null data source is encountered (this can be because mData
     * is set to null, or because the data source itself is null).
     *  @type string
     *  @default null
     */
    "sDefaultContent": null,

    /**
     * Name for the column, allowing reference to the column by name as well as
     * by index (needs a lookup to work by name).
     *  @type string
     */
    "sName": null,

    /**
     * Custom sorting data type - defines which of the available plug-ins in
     * afnSortData the custom sorting will use - if any is defined.
     *  @type string
     *  @default std
     */
    "sSortDataType": 'std',

    /**
     * Class to be applied to the header element when sorting on this column
     *  @type string
     *  @default null
     */
    "sSortingClass": null,

    /**
     * Class to be applied to the header element when sorting on this column -
     * when jQuery UI theming is used.
     *  @type string
     *  @default null
     */
    "sSortingClassJUI": null,

    /**
     * Title of the column - what is seen in the TH element (nTh).
     *  @type string
     */
    "sTitle": null,

    /**
     * Column sorting and filtering type
     *  @type string
     *  @default null
     */
    "sType": null,

    /**
     * Width of the column
     *  @type string
     *  @default null
     */
    "sWidth": null,

    /**
     * Width of the column when it was first "encountered"
     *  @type string
     *  @default null
     */
    "sWidthOrig": null
  };


  /*
   * Developer note: The properties of the object below are given in Hungarian
   * notation, that was used as the interface for DataTables prior to v1.10, however
   * from v1.10 onwards the primary interface is camel case. In order to avoid
   * breaking backwards compatibility utterly with this change, the Hungarian
   * version is still, internally the primary interface, but is is not documented
   * - hence the @name tags in each doc comment. This allows a Javascript function
   * to create a map from Hungarian notation to camel case (going the other direction
   * would require each property to be listed, which would at around 3K to the size
   * of DataTables, while this method is about a 0.5K hit.
   *
   * Ultimately this does pave the way for Hungarian notation to be dropped
   * completely, but that is a massive amount of work and will break current
   * installs (therefore is on-hold until v2).
   */

  /**
   * Initialisation options that can be given to DataTables at initialisation
   * time.
   *  @namespace
   */
  DataTable.defaults = {
    /**
     * An array of data to use for the table, passed in at initialisation which
     * will be used in preference to any data which is already in the DOM. This is
     * particularly useful for constructing tables purely in Javascript, for
     * example with a custom Ajax call.
     *  @type array
     *  @default null
     *
     *  @dtopt Option
     *  @name DataTable.defaults.data
     *
     *  @example
     *    // Using a 2D array data source
     *    $(document).ready( function () {
     *      $('#example').dataTable( {
     *        "data": [
     *          ['Trident', 'Internet Explorer 4.0', 'Win 95+', 4, 'X'],
     *          ['Trident', 'Internet Explorer 5.0', 'Win 95+', 5, 'C'],
     *        ],
     *        "columns": [
     *          { "title": "Engine" },
     *          { "title": "Browser" },
     *          { "title": "Platform" },
     *          { "title": "Version" },
     *          { "title": "Grade" }
     *        ]
     *      } );
     *    } );
     *
     *  @example
     *    // Using an array of objects as a data source (`data`)
     *    $(document).ready( function () {
     *      $('#example').dataTable( {
     *        "data": [
     *          {
     *            "engine":   "Trident",
     *            "browser":  "Internet Explorer 4.0",
     *            "platform": "Win 95+",
     *            "version":  4,
     *            "grade":    "X"
     *          },
     *          {
     *            "engine":   "Trident",
     *            "browser":  "Internet Explorer 5.0",
     *            "platform": "Win 95+",
     *            "version":  5,
     *            "grade":    "C"
     *          }
     *        ],
     *        "columns": [
     *          { "title": "Engine",   "data": "engine" },
     *          { "title": "Browser",  "data": "browser" },
     *          { "title": "Platform", "data": "platform" },
     *          { "title": "Version",  "data": "version" },
     *          { "title": "Grade",    "data": "grade" }
     *        ]
     *      } );
     *    } );
     */
    "aaData": null,


    /**
     * If ordering is enabled, then DataTables will perform a first pass sort on
     * initialisation. You can define which column(s) the sort is performed
     * upon, and the sorting direction, with this variable. The `sorting` array
     * should contain an array for each column to be sorted initially containing
     * the column's index and a direction string ('asc' or 'desc').
     *  @type array
     *  @default [[0,'asc']]
     *
     *  @dtopt Option
     *  @name DataTable.defaults.order
     *
     *  @example
     *    // Sort by 3rd column first, and then 4th column
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "order": [[2,'asc'], [3,'desc']]
     *      } );
     *    } );
     *
     *    // No initial sorting
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "order": []
     *      } );
     *    } );
     */
    "aaSorting": [[0,'asc']],


    /**
     * This parameter is basically identical to the `sorting` parameter, but
     * cannot be overridden by user interaction with the table. What this means
     * is that you could have a column (visible or hidden) which the sorting
     * will always be forced on first - any sorting after that (from the user)
     * will then be performed as required. This can be useful for grouping rows
     * together.
     *  @type array
     *  @default null
     *
     *  @dtopt Option
     *  @name DataTable.defaults.orderFixed
     *
     *  @example
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "orderFixed": [[0,'asc']]
     *      } );
     *    } )
     */
    "aaSortingFixed": [],


    /**
     * DataTables can be instructed to load data to display in the table from a
     * Ajax source. This option defines how that Ajax call is made and where to.
     *
     * The `ajax` property has three different modes of operation, depending on
     * how it is defined. These are:
     *
     * * `string` - Set the URL from where the data should be loaded from.
     * * `object` - Define properties for `jQuery.ajax`.
     * * `function` - Custom data get function
     *
     * `string`
     * --------
     *
     * As a string, the `ajax` property simply defines the URL from which
     * DataTables will load data.
     *
     * `object`
     * --------
     *
     * As an object, the parameters in the object are passed to
     * [jQuery.ajax](http://api.jquery.com/jQuery.ajax/) allowing fine control
     * of the Ajax request. DataTables has a number of default parameters which
     * you can override using this option. Please refer to the jQuery
     * documentation for a full description of the options available, although
     * the following parameters provide additional options in DataTables or
     * require special consideration:
     *
     * * `data` - As with jQuery, `data` can be provided as an object, but it
     *   can also be used as a function to manipulate the data DataTables sends
     *   to the server. The function takes a single parameter, an object of
     *   parameters with the values that DataTables has readied for sending. An
     *   object may be returned which will be merged into the DataTables
     *   defaults, or you can add the items to the object that was passed in and
     *   not return anything from the function. This supersedes `fnServerParams`
     *   from DataTables 1.9-.
     *
     * * `dataSrc` - By default DataTables will look for the property `data` (or
     *   `aaData` for compatibility with DataTables 1.9-) when obtaining data
     *   from an Ajax source or for server-side processing - this parameter
     *   allows that property to be changed. You can use Javascript dotted
     *   object notation to get a data source for multiple levels of nesting, or
     *   it my be used as a function. As a function it takes a single parameter,
     *   the JSON returned from the server, which can be manipulated as
     *   required, with the returned value being that used by DataTables as the
     *   data source for the table. This supersedes `sAjaxDataProp` from
     *   DataTables 1.9-.
     *
     * * `success` - Should not be overridden it is used internally in
     *   DataTables. To manipulate / transform the data returned by the server
     *   use `ajax.dataSrc`, or use `ajax` as a function (see below).
     *
     * `function`
     * ----------
     *
     * As a function, making the Ajax call is left up to yourself allowing
     * complete control of the Ajax request. Indeed, if desired, a method other
     * than Ajax could be used to obtain the required data, such as Web storage
     * or an AIR database.
     *
     * The function is given four parameters and no return is required. The
     * parameters are:
     *
     * 1. _object_ - Data to send to the server
     * 2. _function_ - Callback function that must be executed when the required
     *    data has been obtained. That data should be passed into the callback
     *    as the only parameter
     * 3. _object_ - DataTables settings object for the table
     *
     * Note that this supersedes `fnServerData` from DataTables 1.9-.
     *
     *  @type string|object|function
     *  @default null
     *
     *  @dtopt Option
     *  @name DataTable.defaults.ajax
     *  @since 1.10.0
     *
     * @example
     *   // Get JSON data from a file via Ajax.
     *   // Note DataTables expects data in the form `{ data: [ ...data... ] }` by default).
     *   $('#example').dataTable( {
     *     "ajax": "data.json"
     *   } );
     *
     * @example
     *   // Get JSON data from a file via Ajax, using `dataSrc` to change
     *   // `data` to `tableData` (i.e. `{ tableData: [ ...data... ] }`)
     *   $('#example').dataTable( {
     *     "ajax": {
     *       "url": "data.json",
     *       "dataSrc": "tableData"
     *     }
     *   } );
     *
     * @example
     *   // Get JSON data from a file via Ajax, using `dataSrc` to read data
     *   // from a plain array rather than an array in an object
     *   $('#example').dataTable( {
     *     "ajax": {
     *       "url": "data.json",
     *       "dataSrc": ""
     *     }
     *   } );
     *
     * @example
     *   // Manipulate the data returned from the server - add a link to data
     *   // (note this can, should, be done using `render` for the column - this
     *   // is just a simple example of how the data can be manipulated).
     *   $('#example').dataTable( {
     *     "ajax": {
     *       "url": "data.json",
     *       "dataSrc": function ( json ) {
     *         for ( var i=0, ien=json.length ; i<ien ; i++ ) {
     *           json[i][0] = '<a href="/message/'+json[i][0]+'>View message</a>';
     *         }
     *         return json;
     *       }
     *     }
     *   } );
     *
     * @example
     *   // Add data to the request
     *   $('#example').dataTable( {
     *     "ajax": {
     *       "url": "data.json",
     *       "data": function ( d ) {
     *         return {
     *           "extra_search": $('#extra').val()
     *         };
     *       }
     *     }
     *   } );
     *
     * @example
     *   // Send request as POST
     *   $('#example').dataTable( {
     *     "ajax": {
     *       "url": "data.json",
     *       "type": "POST"
     *     }
     *   } );
     *
     * @example
     *   // Get the data from localStorage (could interface with a form for
     *   // adding, editing and removing rows).
     *   $('#example').dataTable( {
     *     "ajax": function (data, callback, settings) {
     *       callback(
     *         JSON.parse( localStorage.getItem('dataTablesData') )
     *       );
     *     }
     *   } );
     */
    "ajax": null,


    /**
     * This parameter allows you to readily specify the entries in the length drop
     * down menu that DataTables shows when pagination is enabled. It can be
     * either a 1D array of options which will be used for both the displayed
     * option and the value, or a 2D array which will use the array in the first
     * position as the value, and the array in the second position as the
     * displayed options (useful for language strings such as 'All').
     *
     * Note that the `pageLength` property will be automatically set to the
     * first value given in this array, unless `pageLength` is also provided.
     *  @type array
     *  @default [ 10, 25, 50, 100 ]
     *
     *  @dtopt Option
     *  @name DataTable.defaults.lengthMenu
     *
     *  @example
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "lengthMenu": [[10, 25, 50, -1], [10, 25, 50, "All"]]
     *      } );
     *    } );
     */
    "aLengthMenu": [ 10, 25, 50, 100 ],


    /**
     * The `columns` option in the initialisation parameter allows you to define
     * details about the way individual columns behave. For a full list of
     * column options that can be set, please see
     * {@link DataTable.defaults.column}. Note that if you use `columns` to
     * define your columns, you must have an entry in the array for every single
     * column that you have in your table (these can be null if you don't which
     * to specify any options).
     *  @member
     *
     *  @name DataTable.defaults.column
     */
    "aoColumns": null,

    /**
     * Very similar to `columns`, `columnDefs` allows you to target a specific
     * column, multiple columns, or all columns, using the `targets` property of
     * each object in the array. This allows great flexibility when creating
     * tables, as the `columnDefs` arrays can be of any length, targeting the
     * columns you specifically want. `columnDefs` may use any of the column
     * options available: {@link DataTable.defaults.column}, but it _must_
     * have `targets` defined in each object in the array. Values in the `targets`
     * array may be:
     *   <ul>
     *     <li>a string - class name will be matched on the TH for the column</li>
     *     <li>0 or a positive integer - column index counting from the left</li>
     *     <li>a negative integer - column index counting from the right</li>
     *     <li>the string "_all" - all columns (i.e. assign a default)</li>
     *   </ul>
     *  @member
     *
     *  @name DataTable.defaults.columnDefs
     */
    "aoColumnDefs": null,


    /**
     * Basically the same as `search`, this parameter defines the individual column
     * filtering state at initialisation time. The array must be of the same size
     * as the number of columns, and each element be an object with the parameters
     * `search` and `escapeRegex` (the latter is optional). 'null' is also
     * accepted and the default will be used.
     *  @type array
     *  @default []
     *
     *  @dtopt Option
     *  @name DataTable.defaults.searchCols
     *
     *  @example
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "searchCols": [
     *          null,
     *          { "search": "My filter" },
     *          null,
     *          { "search": "^[0-9]", "escapeRegex": false }
     *        ]
     *      } );
     *    } )
     */
    "aoSearchCols": [],


    /**
     * An array of CSS classes that should be applied to displayed rows. This
     * array may be of any length, and DataTables will apply each class
     * sequentially, looping when required.
     *  @type array
     *  @default null <i>Will take the values determined by the `oClasses.stripe*`
     *    options</i>
     *
     *  @dtopt Option
     *  @name DataTable.defaults.stripeClasses
     *
     *  @example
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "stripeClasses": [ 'strip1', 'strip2', 'strip3' ]
     *      } );
     *    } )
     */
    "asStripeClasses": null,


    /**
     * Enable or disable automatic column width calculation. This can be disabled
     * as an optimisation (it takes some time to calculate the widths) if the
     * tables widths are passed in using `columns`.
     *  @type boolean
     *  @default true
     *
     *  @dtopt Features
     *  @name DataTable.defaults.autoWidth
     *
     *  @example
     *    $(document).ready( function () {
     *      $('#example').dataTable( {
     *        "autoWidth": false
     *      } );
     *    } );
     */
    "bAutoWidth": true,


    /**
     * Deferred rendering can provide DataTables with a huge speed boost when you
     * are using an Ajax or JS data source for the table. This option, when set to
     * true, will cause DataTables to defer the creation of the table elements for
     * each row until they are needed for a draw - saving a significant amount of
     * time.
     *  @type boolean
     *  @default false
     *
     *  @dtopt Features
     *  @name DataTable.defaults.deferRender
     *
     *  @example
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "ajax": "sources/arrays.txt",
     *        "deferRender": true
     *      } );
     *    } );
     */
    "bDeferRender": false,


    /**
     * Replace a DataTable which matches the given selector and replace it with
     * one which has the properties of the new initialisation object passed. If no
     * table matches the selector, then the new DataTable will be constructed as
     * per normal.
     *  @type boolean
     *  @default false
     *
     *  @dtopt Options
     *  @name DataTable.defaults.destroy
     *
     *  @example
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "srollY": "200px",
     *        "paginate": false
     *      } );
     *
     *      // Some time later....
     *      $('#example').dataTable( {
     *        "filter": false,
     *        "destroy": true
     *      } );
     *    } );
     */
    "bDestroy": false,


    /**
     * Enable or disable filtering of data. Filtering in DataTables is "smart" in
     * that it allows the end user to input multiple words (space separated) and
     * will match a row containing those words, even if not in the order that was
     * specified (this allow matching across multiple columns). Note that if you
     * wish to use filtering in DataTables this must remain 'true' - to remove the
     * default filtering input box and retain filtering abilities, please use
     * {@link DataTable.defaults.dom}.
     *  @type boolean
     *  @default true
     *
     *  @dtopt Features
     *  @name DataTable.defaults.searching
     *
     *  @example
     *    $(document).ready( function () {
     *      $('#example').dataTable( {
     *        "searching": false
     *      } );
     *    } );
     */
    "bFilter": true,


    /**
     * Enable or disable the table information display. This shows information
     * about the data that is currently visible on the page, including information
     * about filtered data if that action is being performed.
     *  @type boolean
     *  @default true
     *
     *  @dtopt Features
     *  @name DataTable.defaults.info
     *
     *  @example
     *    $(document).ready( function () {
     *      $('#example').dataTable( {
     *        "info": false
     *      } );
     *    } );
     */
    "bInfo": true,


    /**
     * Allows the end user to select the size of a formatted page from a select
     * menu (sizes are 10, 25, 50 and 100). Requires pagination (`paginate`).
     *  @type boolean
     *  @default true
     *
     *  @dtopt Features
     *  @name DataTable.defaults.lengthChange
     *
     *  @example
     *    $(document).ready( function () {
     *      $('#example').dataTable( {
     *        "lengthChange": false
     *      } );
     *    } );
     */
    "bLengthChange": true,


    /**
     * Enable or disable pagination.
     *  @type boolean
     *  @default true
     *
     *  @dtopt Features
     *  @name DataTable.defaults.paging
     *
     *  @example
     *    $(document).ready( function () {
     *      $('#example').dataTable( {
     *        "paging": false
     *      } );
     *    } );
     */
    "bPaginate": true,


    /**
     * Enable or disable the display of a 'processing' indicator when the table is
     * being processed (e.g. a sort). This is particularly useful for tables with
     * large amounts of data where it can take a noticeable amount of time to sort
     * the entries.
     *  @type boolean
     *  @default false
     *
     *  @dtopt Features
     *  @name DataTable.defaults.processing
     *
     *  @example
     *    $(document).ready( function () {
     *      $('#example').dataTable( {
     *        "processing": true
     *      } );
     *    } );
     */
    "bProcessing": false,


    /**
     * Retrieve the DataTables object for the given selector. Note that if the
     * table has already been initialised, this parameter will cause DataTables
     * to simply return the object that has already been set up - it will not take
     * account of any changes you might have made to the initialisation object
     * passed to DataTables (setting this parameter to true is an acknowledgement
     * that you understand this). `destroy` can be used to reinitialise a table if
     * you need.
     *  @type boolean
     *  @default false
     *
     *  @dtopt Options
     *  @name DataTable.defaults.retrieve
     *
     *  @example
     *    $(document).ready( function() {
     *      initTable();
     *      tableActions();
     *    } );
     *
     *    function initTable ()
     *    {
     *      return $('#example').dataTable( {
     *        "scrollY": "200px",
     *        "paginate": false,
     *        "retrieve": true
     *      } );
     *    }
     *
     *    function tableActions ()
     *    {
     *      var table = initTable();
     *      // perform API operations with oTable
     *    }
     */
    "bRetrieve": false,


    /**
     * When vertical (y) scrolling is enabled, DataTables will force the height of
     * the table's viewport to the given height at all times (useful for layout).
     * However, this can look odd when filtering data down to a small data set,
     * and the footer is left "floating" further down. This parameter (when
     * enabled) will cause DataTables to collapse the table's viewport down when
     * the result set will fit within the given Y height.
     *  @type boolean
     *  @default false
     *
     *  @dtopt Options
     *  @name DataTable.defaults.scrollCollapse
     *
     *  @example
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "scrollY": "200",
     *        "scrollCollapse": true
     *      } );
     *    } );
     */
    "bScrollCollapse": false,


    /**
     * Configure DataTables to use server-side processing. Note that the
     * `ajax` parameter must also be given in order to give DataTables a
     * source to obtain the required data for each draw.
     *  @type boolean
     *  @default false
     *
     *  @dtopt Features
     *  @dtopt Server-side
     *  @name DataTable.defaults.serverSide
     *
     *  @example
     *    $(document).ready( function () {
     *      $('#example').dataTable( {
     *        "serverSide": true,
     *        "ajax": "xhr.php"
     *      } );
     *    } );
     */
    "bServerSide": false,


    /**
     * Enable or disable sorting of columns. Sorting of individual columns can be
     * disabled by the `sortable` option for each column.
     *  @type boolean
     *  @default true
     *
     *  @dtopt Features
     *  @name DataTable.defaults.ordering
     *
     *  @example
     *    $(document).ready( function () {
     *      $('#example').dataTable( {
     *        "ordering": false
     *      } );
     *    } );
     */
    "bSort": true,


    /**
     * Enable or display DataTables' ability to sort multiple columns at the
     * same time (activated by shift-click by the user).
     *  @type boolean
     *  @default true
     *
     *  @dtopt Options
     *  @name DataTable.defaults.orderMulti
     *
     *  @example
     *    // Disable multiple column sorting ability
     *    $(document).ready( function () {
     *      $('#example').dataTable( {
     *        "orderMulti": false
     *      } );
     *    } );
     */
    "bSortMulti": true,


    /**
     * Allows control over whether DataTables should use the top (true) unique
     * cell that is found for a single column, or the bottom (false - default).
     * This is useful when using complex headers.
     *  @type boolean
     *  @default false
     *
     *  @dtopt Options
     *  @name DataTable.defaults.orderCellsTop
     *
     *  @example
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "orderCellsTop": true
     *      } );
     *    } );
     */
    "bSortCellsTop": false,


    /**
     * Enable or disable the addition of the classes `sorting\_1`, `sorting\_2` and
     * `sorting\_3` to the columns which are currently being sorted on. This is
     * presented as a feature switch as it can increase processing time (while
     * classes are removed and added) so for large data sets you might want to
     * turn this off.
     *  @type boolean
     *  @default true
     *
     *  @dtopt Features
     *  @name DataTable.defaults.orderClasses
     *
     *  @example
     *    $(document).ready( function () {
     *      $('#example').dataTable( {
     *        "orderClasses": false
     *      } );
     *    } );
     */
    "bSortClasses": true,


    /**
     * Enable or disable state saving. When enabled HTML5 `localStorage` will be
     * used to save table display information such as pagination information,
     * display length, filtering and sorting. As such when the end user reloads
     * the page the display display will match what thy had previously set up.
     *
     * Due to the use of `localStorage` the default state saving is not supported
     * in IE6 or 7. If state saving is required in those browsers, use
     * `stateSaveCallback` to provide a storage solution such as cookies.
     *  @type boolean
     *  @default false
     *
     *  @dtopt Features
     *  @name DataTable.defaults.stateSave
     *
     *  @example
     *    $(document).ready( function () {
     *      $('#example').dataTable( {
     *        "stateSave": true
     *      } );
     *    } );
     */
    "bStateSave": false,


    /**
     * This function is called when a TR element is created (and all TD child
     * elements have been inserted), or registered if using a DOM source, allowing
     * manipulation of the TR element (adding classes etc).
     *  @type function
     *  @param {node} row "TR" element for the current row
     *  @param {array} data Raw data array for this row
     *  @param {int} dataIndex The index of this row in the internal aoData array
     *
     *  @dtopt Callbacks
     *  @name DataTable.defaults.createdRow
     *
     *  @example
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "createdRow": function( row, data, dataIndex ) {
     *          // Bold the grade for all 'A' grade browsers
     *          if ( data[4] == "A" )
     *          {
     *            $('td:eq(4)', row).html( '<b>A</b>' );
     *          }
     *        }
     *      } );
     *    } );
     */
    "fnCreatedRow": null,


    /**
     * This function is called on every 'draw' event, and allows you to
     * dynamically modify any aspect you want about the created DOM.
     *  @type function
     *  @param {object} settings DataTables settings object
     *
     *  @dtopt Callbacks
     *  @name DataTable.defaults.drawCallback
     *
     *  @example
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "drawCallback": function( settings ) {
     *          alert( 'DataTables has redrawn the table' );
     *        }
     *      } );
     *    } );
     */
    "fnDrawCallback": null,


    /**
     * Identical to fnHeaderCallback() but for the table footer this function
     * allows you to modify the table footer on every 'draw' event.
     *  @type function
     *  @param {node} foot "TR" element for the footer
     *  @param {array} data Full table data (as derived from the original HTML)
     *  @param {int} start Index for the current display starting point in the
     *    display array
     *  @param {int} end Index for the current display ending point in the
     *    display array
     *  @param {array int} display Index array to translate the visual position
     *    to the full data array
     *
     *  @dtopt Callbacks
     *  @name DataTable.defaults.footerCallback
     *
     *  @example
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "footerCallback": function( tfoot, data, start, end, display ) {
     *          tfoot.getElementsByTagName('th')[0].innerHTML = "Starting index is "+start;
     *        }
     *      } );
     *    } )
     */
    "fnFooterCallback": null,


    /**
     * When rendering large numbers in the information element for the table
     * (i.e. "Showing 1 to 10 of 57 entries") DataTables will render large numbers
     * to have a comma separator for the 'thousands' units (e.g. 1 million is
     * rendered as "1,000,000") to help readability for the end user. This
     * function will override the default method DataTables uses.
     *  @type function
     *  @member
     *  @param {int} toFormat number to be formatted
     *  @returns {string} formatted string for DataTables to show the number
     *
     *  @dtopt Callbacks
     *  @name DataTable.defaults.formatNumber
     *
     *  @example
     *    // Format a number using a single quote for the separator (note that
     *    // this can also be done with the language.thousands option)
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "formatNumber": function ( toFormat ) {
     *          return toFormat.toString().replace(
     *            /\B(?=(\d{3})+(?!\d))/g, "'"
     *          );
     *        };
     *      } );
     *    } );
     */
    "fnFormatNumber": function ( toFormat ) {
      return toFormat.toString().replace(
        /\B(?=(\d{3})+(?!\d))/g,
        this.oLanguage.sThousands
      );
    },


    /**
     * This function is called on every 'draw' event, and allows you to
     * dynamically modify the header row. This can be used to calculate and
     * display useful information about the table.
     *  @type function
     *  @param {node} head "TR" element for the header
     *  @param {array} data Full table data (as derived from the original HTML)
     *  @param {int} start Index for the current display starting point in the
     *    display array
     *  @param {int} end Index for the current display ending point in the
     *    display array
     *  @param {array int} display Index array to translate the visual position
     *    to the full data array
     *
     *  @dtopt Callbacks
     *  @name DataTable.defaults.headerCallback
     *
     *  @example
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "fheaderCallback": function( head, data, start, end, display ) {
     *          head.getElementsByTagName('th')[0].innerHTML = "Displaying "+(end-start)+" records";
     *        }
     *      } );
     *    } )
     */
    "fnHeaderCallback": null,


    /**
     * The information element can be used to convey information about the current
     * state of the table. Although the internationalisation options presented by
     * DataTables are quite capable of dealing with most customisations, there may
     * be times where you wish to customise the string further. This callback
     * allows you to do exactly that.
     *  @type function
     *  @param {object} oSettings DataTables settings object
     *  @param {int} start Starting position in data for the draw
     *  @param {int} end End position in data for the draw
     *  @param {int} max Total number of rows in the table (regardless of
     *    filtering)
     *  @param {int} total Total number of rows in the data set, after filtering
     *  @param {string} pre The string that DataTables has formatted using it's
     *    own rules
     *  @returns {string} The string to be displayed in the information element.
     *
     *  @dtopt Callbacks
     *  @name DataTable.defaults.infoCallback
     *
     *  @example
     *    $('#example').dataTable( {
     *      "infoCallback": function( settings, start, end, max, total, pre ) {
     *        return start +" to "+ end;
     *      }
     *    } );
     */
    "fnInfoCallback": null,


    /**
     * Called when the table has been initialised. Normally DataTables will
     * initialise sequentially and there will be no need for this function,
     * however, this does not hold true when using external language information
     * since that is obtained using an async XHR call.
     *  @type function
     *  @param {object} settings DataTables settings object
     *  @param {object} json The JSON object request from the server - only
     *    present if client-side Ajax sourced data is used
     *
     *  @dtopt Callbacks
     *  @name DataTable.defaults.initComplete
     *
     *  @example
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "initComplete": function(settings, json) {
     *          alert( 'DataTables has finished its initialisation.' );
     *        }
     *      } );
     *    } )
     */
    "fnInitComplete": null,


    /**
     * Called at the very start of each table draw and can be used to cancel the
     * draw by returning false, any other return (including undefined) results in
     * the full draw occurring).
     *  @type function
     *  @param {object} settings DataTables settings object
     *  @returns {boolean} False will cancel the draw, anything else (including no
     *    return) will allow it to complete.
     *
     *  @dtopt Callbacks
     *  @name DataTable.defaults.preDrawCallback
     *
     *  @example
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "preDrawCallback": function( settings ) {
     *          if ( $('#test').val() == 1 ) {
     *            return false;
     *          }
     *        }
     *      } );
     *    } );
     */
    "fnPreDrawCallback": null,


    /**
     * This function allows you to 'post process' each row after it have been
     * generated for each table draw, but before it is rendered on screen. This
     * function might be used for setting the row class name etc.
     *  @type function
     *  @param {node} row "TR" element for the current row
     *  @param {array} data Raw data array for this row
     *  @param {int} displayIndex The display index for the current table draw
     *  @param {int} displayIndexFull The index of the data in the full list of
     *    rows (after filtering)
     *
     *  @dtopt Callbacks
     *  @name DataTable.defaults.rowCallback
     *
     *  @example
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "rowCallback": function( row, data, displayIndex, displayIndexFull ) {
     *          // Bold the grade for all 'A' grade browsers
     *          if ( data[4] == "A" ) {
     *            $('td:eq(4)', row).html( '<b>A</b>' );
     *          }
     *        }
     *      } );
     *    } );
     */
    "fnRowCallback": null,


    /**
     * __Deprecated__ The functionality provided by this parameter has now been
     * superseded by that provided through `ajax`, which should be used instead.
     *
     * This parameter allows you to override the default function which obtains
     * the data from the server so something more suitable for your application.
     * For example you could use POST data, or pull information from a Gears or
     * AIR database.
     *  @type function
     *  @member
     *  @param {string} source HTTP source to obtain the data from (`ajax`)
     *  @param {array} data A key/value pair object containing the data to send
     *    to the server
     *  @param {function} callback to be called on completion of the data get
     *    process that will draw the data on the page.
     *  @param {object} settings DataTables settings object
     *
     *  @dtopt Callbacks
     *  @dtopt Server-side
     *  @name DataTable.defaults.serverData
     *
     *  @deprecated 1.10. Please use `ajax` for this functionality now.
     */
    "fnServerData": null,


    /**
     * __Deprecated__ The functionality provided by this parameter has now been
     * superseded by that provided through `ajax`, which should be used instead.
     *
     *  It is often useful to send extra data to the server when making an Ajax
     * request - for example custom filtering information, and this callback
     * function makes it trivial to send extra information to the server. The
     * passed in parameter is the data set that has been constructed by
     * DataTables, and you can add to this or modify it as you require.
     *  @type function
     *  @param {array} data Data array (array of objects which are name/value
     *    pairs) that has been constructed by DataTables and will be sent to the
     *    server. In the case of Ajax sourced data with server-side processing
     *    this will be an empty array, for server-side processing there will be a
     *    significant number of parameters!
     *  @returns {undefined} Ensure that you modify the data array passed in,
     *    as this is passed by reference.
     *
     *  @dtopt Callbacks
     *  @dtopt Server-side
     *  @name DataTable.defaults.serverParams
     *
     *  @deprecated 1.10. Please use `ajax` for this functionality now.
     */
    "fnServerParams": null,


    /**
     * Load the table state. With this function you can define from where, and how, the
     * state of a table is loaded. By default DataTables will load from `localStorage`
     * but you might wish to use a server-side database or cookies.
     *  @type function
     *  @member
     *  @param {object} settings DataTables settings object
     *  @param {object} callback Callback that can be executed when done. It
     *    should be passed the loaded state object.
     *  @return {object} The DataTables state object to be loaded
     *
     *  @dtopt Callbacks
     *  @name DataTable.defaults.stateLoadCallback
     *
     *  @example
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "stateSave": true,
     *        "stateLoadCallback": function (settings, callback) {
     *          $.ajax( {
     *            "url": "/state_load",
     *            "dataType": "json",
     *            "success": function (json) {
     *              callback( json );
     *            }
     *          } );
     *        }
     *      } );
     *    } );
     */
    "fnStateLoadCallback": function ( settings ) {
      try {
        return JSON.parse(
          (settings.iStateDuration === -1 ? sessionStorage : localStorage).getItem(
            'DataTables_'+settings.sInstance+'_'+location.pathname
          )
        );
      } catch (e) {}
    },


    /**
     * Callback which allows modification of the saved state prior to loading that state.
     * This callback is called when the table is loading state from the stored data, but
     * prior to the settings object being modified by the saved state. Note that for
     * plug-in authors, you should use the `stateLoadParams` event to load parameters for
     * a plug-in.
     *  @type function
     *  @param {object} settings DataTables settings object
     *  @param {object} data The state object that is to be loaded
     *
     *  @dtopt Callbacks
     *  @name DataTable.defaults.stateLoadParams
     *
     *  @example
     *    // Remove a saved filter, so filtering is never loaded
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "stateSave": true,
     *        "stateLoadParams": function (settings, data) {
     *          data.oSearch.sSearch = "";
     *        }
     *      } );
     *    } );
     *
     *  @example
     *    // Disallow state loading by returning false
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "stateSave": true,
     *        "stateLoadParams": function (settings, data) {
     *          return false;
     *        }
     *      } );
     *    } );
     */
    "fnStateLoadParams": null,


    /**
     * Callback that is called when the state has been loaded from the state saving method
     * and the DataTables settings object has been modified as a result of the loaded state.
     *  @type function
     *  @param {object} settings DataTables settings object
     *  @param {object} data The state object that was loaded
     *
     *  @dtopt Callbacks
     *  @name DataTable.defaults.stateLoaded
     *
     *  @example
     *    // Show an alert with the filtering value that was saved
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "stateSave": true,
     *        "stateLoaded": function (settings, data) {
     *          alert( 'Saved filter was: '+data.oSearch.sSearch );
     *        }
     *      } );
     *    } );
     */
    "fnStateLoaded": null,


    /**
     * Save the table state. This function allows you to define where and how the state
     * information for the table is stored By default DataTables will use `localStorage`
     * but you might wish to use a server-side database or cookies.
     *  @type function
     *  @member
     *  @param {object} settings DataTables settings object
     *  @param {object} data The state object to be saved
     *
     *  @dtopt Callbacks
     *  @name DataTable.defaults.stateSaveCallback
     *
     *  @example
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "stateSave": true,
     *        "stateSaveCallback": function (settings, data) {
     *          // Send an Ajax request to the server with the state object
     *          $.ajax( {
     *            "url": "/state_save",
     *            "data": data,
     *            "dataType": "json",
     *            "method": "POST"
     *            "success": function () {}
     *          } );
     *        }
     *      } );
     *    } );
     */
    "fnStateSaveCallback": function ( settings, data ) {
      try {
        (settings.iStateDuration === -1 ? sessionStorage : localStorage).setItem(
          'DataTables_'+settings.sInstance+'_'+location.pathname,
          JSON.stringify( data )
        );
      } catch (e) {}
    },


    /**
     * Callback which allows modification of the state to be saved. Called when the table
     * has changed state a new state save is required. This method allows modification of
     * the state saving object prior to actually doing the save, including addition or
     * other state properties or modification. Note that for plug-in authors, you should
     * use the `stateSaveParams` event to save parameters for a plug-in.
     *  @type function
     *  @param {object} settings DataTables settings object
     *  @param {object} data The state object to be saved
     *
     *  @dtopt Callbacks
     *  @name DataTable.defaults.stateSaveParams
     *
     *  @example
     *    // Remove a saved filter, so filtering is never saved
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "stateSave": true,
     *        "stateSaveParams": function (settings, data) {
     *          data.oSearch.sSearch = "";
     *        }
     *      } );
     *    } );
     */
    "fnStateSaveParams": null,


    /**
     * Duration for which the saved state information is considered valid. After this period
     * has elapsed the state will be returned to the default.
     * Value is given in seconds.
     *  @type int
     *  @default 7200 <i>(2 hours)</i>
     *
     *  @dtopt Options
     *  @name DataTable.defaults.stateDuration
     *
     *  @example
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "stateDuration": 60*60*24; // 1 day
     *      } );
     *    } )
     */
    "iStateDuration": 7200,


    /**
     * When enabled DataTables will not make a request to the server for the first
     * page draw - rather it will use the data already on the page (no sorting etc
     * will be applied to it), thus saving on an XHR at load time. `deferLoading`
     * is used to indicate that deferred loading is required, but it is also used
     * to tell DataTables how many records there are in the full table (allowing
     * the information element and pagination to be displayed correctly). In the case
     * where a filtering is applied to the table on initial load, this can be
     * indicated by giving the parameter as an array, where the first element is
     * the number of records available after filtering and the second element is the
     * number of records without filtering (allowing the table information element
     * to be shown correctly).
     *  @type int | array
     *  @default null
     *
     *  @dtopt Options
     *  @name DataTable.defaults.deferLoading
     *
     *  @example
     *    // 57 records available in the table, no filtering applied
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "serverSide": true,
     *        "ajax": "scripts/server_processing.php",
     *        "deferLoading": 57
     *      } );
     *    } );
     *
     *  @example
     *    // 57 records after filtering, 100 without filtering (an initial filter applied)
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "serverSide": true,
     *        "ajax": "scripts/server_processing.php",
     *        "deferLoading": [ 57, 100 ],
     *        "search": {
     *          "search": "my_filter"
     *        }
     *      } );
     *    } );
     */
    "iDeferLoading": null,


    /**
     * Number of rows to display on a single page when using pagination. If
     * feature enabled (`lengthChange`) then the end user will be able to override
     * this to a custom setting using a pop-up menu.
     *  @type int
     *  @default 10
     *
     *  @dtopt Options
     *  @name DataTable.defaults.pageLength
     *
     *  @example
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "pageLength": 50
     *      } );
     *    } )
     */
    "iDisplayLength": 10,


    /**
     * Define the starting point for data display when using DataTables with
     * pagination. Note that this parameter is the number of records, rather than
     * the page number, so if you have 10 records per page and want to start on
     * the third page, it should be "20".
     *  @type int
     *  @default 0
     *
     *  @dtopt Options
     *  @name DataTable.defaults.displayStart
     *
     *  @example
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "displayStart": 20
     *      } );
     *    } )
     */
    "iDisplayStart": 0,


    /**
     * By default DataTables allows keyboard navigation of the table (sorting, paging,
     * and filtering) by adding a `tabindex` attribute to the required elements. This
     * allows you to tab through the controls and press the enter key to activate them.
     * The tabindex is default 0, meaning that the tab follows the flow of the document.
     * You can overrule this using this parameter if you wish. Use a value of -1 to
     * disable built-in keyboard navigation.
     *  @type int
     *  @default 0
     *
     *  @dtopt Options
     *  @name DataTable.defaults.tabIndex
     *
     *  @example
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "tabIndex": 1
     *      } );
     *    } );
     */
    "iTabIndex": 0,


    /**
     * Classes that DataTables assigns to the various components and features
     * that it adds to the HTML table. This allows classes to be configured
     * during initialisation in addition to through the static
     * {@link DataTable.ext.oStdClasses} object).
     *  @namespace
     *  @name DataTable.defaults.classes
     */
    "oClasses": {},


    /**
     * All strings that DataTables uses in the user interface that it creates
     * are defined in this object, allowing you to modified them individually or
     * completely replace them all as required.
     *  @namespace
     *  @name DataTable.defaults.language
     */
    "oLanguage": {
      /**
       * Strings that are used for WAI-ARIA labels and controls only (these are not
       * actually visible on the page, but will be read by screenreaders, and thus
       * must be internationalised as well).
       *  @namespace
       *  @name DataTable.defaults.language.aria
       */
      "oAria": {
        /**
         * ARIA label that is added to the table headers when the column may be
         * sorted ascending by activing the column (click or return when focused).
         * Note that the column header is prefixed to this string.
         *  @type string
         *  @default : activate to sort column ascending
         *
         *  @dtopt Language
         *  @name DataTable.defaults.language.aria.sortAscending
         *
         *  @example
         *    $(document).ready( function() {
         *      $('#example').dataTable( {
         *        "language": {
         *          "aria": {
         *            "sortAscending": " - click/return to sort ascending"
         *          }
         *        }
         *      } );
         *    } );
         */
        "sSortAscending": ": activate to sort column ascending",

        /**
         * ARIA label that is added to the table headers when the column may be
         * sorted descending by activing the column (click or return when focused).
         * Note that the column header is prefixed to this string.
         *  @type string
         *  @default : activate to sort column ascending
         *
         *  @dtopt Language
         *  @name DataTable.defaults.language.aria.sortDescending
         *
         *  @example
         *    $(document).ready( function() {
         *      $('#example').dataTable( {
         *        "language": {
         *          "aria": {
         *            "sortDescending": " - click/return to sort descending"
         *          }
         *        }
         *      } );
         *    } );
         */
        "sSortDescending": ": activate to sort column descending"
      },

      /**
       * Pagination string used by DataTables for the built-in pagination
       * control types.
       *  @namespace
       *  @name DataTable.defaults.language.paginate
       */
      "oPaginate": {
        /**
         * Text to use when using the 'full_numbers' type of pagination for the
         * button to take the user to the first page.
         *  @type string
         *  @default First
         *
         *  @dtopt Language
         *  @name DataTable.defaults.language.paginate.first
         *
         *  @example
         *    $(document).ready( function() {
         *      $('#example').dataTable( {
         *        "language": {
         *          "paginate": {
         *            "first": "First page"
         *          }
         *        }
         *      } );
         *    } );
         */
        "sFirst": "First",


        /**
         * Text to use when using the 'full_numbers' type of pagination for the
         * button to take the user to the last page.
         *  @type string
         *  @default Last
         *
         *  @dtopt Language
         *  @name DataTable.defaults.language.paginate.last
         *
         *  @example
         *    $(document).ready( function() {
         *      $('#example').dataTable( {
         *        "language": {
         *          "paginate": {
         *            "last": "Last page"
         *          }
         *        }
         *      } );
         *    } );
         */
        "sLast": "Last",


        /**
         * Text to use for the 'next' pagination button (to take the user to the
         * next page).
         *  @type string
         *  @default Next
         *
         *  @dtopt Language
         *  @name DataTable.defaults.language.paginate.next
         *
         *  @example
         *    $(document).ready( function() {
         *      $('#example').dataTable( {
         *        "language": {
         *          "paginate": {
         *            "next": "Next page"
         *          }
         *        }
         *      } );
         *    } );
         */
        "sNext": "Next",


        /**
         * Text to use for the 'previous' pagination button (to take the user to
         * the previous page).
         *  @type string
         *  @default Previous
         *
         *  @dtopt Language
         *  @name DataTable.defaults.language.paginate.previous
         *
         *  @example
         *    $(document).ready( function() {
         *      $('#example').dataTable( {
         *        "language": {
         *          "paginate": {
         *            "previous": "Previous page"
         *          }
         *        }
         *      } );
         *    } );
         */
        "sPrevious": "Previous"
      },

      /**
       * This string is shown in preference to `zeroRecords` when the table is
       * empty of data (regardless of filtering). Note that this is an optional
       * parameter - if it is not given, the value of `zeroRecords` will be used
       * instead (either the default or given value).
       *  @type string
       *  @default No data available in table
       *
       *  @dtopt Language
       *  @name DataTable.defaults.language.emptyTable
       *
       *  @example
       *    $(document).ready( function() {
       *      $('#example').dataTable( {
       *        "language": {
       *          "emptyTable": "No data available in table"
       *        }
       *      } );
       *    } );
       */
      "sEmptyTable": "No data available in table",


      /**
       * This string gives information to the end user about the information
       * that is current on display on the page. The following tokens can be
       * used in the string and will be dynamically replaced as the table
       * display updates. This tokens can be placed anywhere in the string, or
       * removed as needed by the language requires:
       *
       * * `\_START\_` - Display index of the first record on the current page
       * * `\_END\_` - Display index of the last record on the current page
       * * `\_TOTAL\_` - Number of records in the table after filtering
       * * `\_MAX\_` - Number of records in the table without filtering
       * * `\_PAGE\_` - Current page number
       * * `\_PAGES\_` - Total number of pages of data in the table
       *
       *  @type string
       *  @default Showing _START_ to _END_ of _TOTAL_ entries
       *
       *  @dtopt Language
       *  @name DataTable.defaults.language.info
       *
       *  @example
       *    $(document).ready( function() {
       *      $('#example').dataTable( {
       *        "language": {
       *          "info": "Showing page _PAGE_ of _PAGES_"
       *        }
       *      } );
       *    } );
       */
      "sInfo": "Showing _START_ to _END_ of _TOTAL_ entries",


      /**
       * Display information string for when the table is empty. Typically the
       * format of this string should match `info`.
       *  @type string
       *  @default Showing 0 to 0 of 0 entries
       *
       *  @dtopt Language
       *  @name DataTable.defaults.language.infoEmpty
       *
       *  @example
       *    $(document).ready( function() {
       *      $('#example').dataTable( {
       *        "language": {
       *          "infoEmpty": "No entries to show"
       *        }
       *      } );
       *    } );
       */
      "sInfoEmpty": "Showing 0 to 0 of 0 entries",


      /**
       * When a user filters the information in a table, this string is appended
       * to the information (`info`) to give an idea of how strong the filtering
       * is. The variable _MAX_ is dynamically updated.
       *  @type string
       *  @default (filtered from _MAX_ total entries)
       *
       *  @dtopt Language
       *  @name DataTable.defaults.language.infoFiltered
       *
       *  @example
       *    $(document).ready( function() {
       *      $('#example').dataTable( {
       *        "language": {
       *          "infoFiltered": " - filtering from _MAX_ records"
       *        }
       *      } );
       *    } );
       */
      "sInfoFiltered": "(filtered from _MAX_ total entries)",


      /**
       * If can be useful to append extra information to the info string at times,
       * and this variable does exactly that. This information will be appended to
       * the `info` (`infoEmpty` and `infoFiltered` in whatever combination they are
       * being used) at all times.
       *  @type string
       *  @default <i>Empty string</i>
       *
       *  @dtopt Language
       *  @name DataTable.defaults.language.infoPostFix
       *
       *  @example
       *    $(document).ready( function() {
       *      $('#example').dataTable( {
       *        "language": {
       *          "infoPostFix": "All records shown are derived from real information."
       *        }
       *      } );
       *    } );
       */
      "sInfoPostFix": "",


      /**
       * This decimal place operator is a little different from the other
       * language options since DataTables doesn't output floating point
       * numbers, so it won't ever use this for display of a number. Rather,
       * what this parameter does is modify the sort methods of the table so
       * that numbers which are in a format which has a character other than
       * a period (`.`) as a decimal place will be sorted numerically.
       *
       * Note that numbers with different decimal places cannot be shown in
       * the same table and still be sortable, the table must be consistent.
       * However, multiple different tables on the page can use different
       * decimal place characters.
       *  @type string
       *  @default
       *
       *  @dtopt Language
       *  @name DataTable.defaults.language.decimal
       *
       *  @example
       *    $(document).ready( function() {
       *      $('#example').dataTable( {
       *        "language": {
       *          "decimal": ","
       *          "thousands": "."
       *        }
       *      } );
       *    } );
       */
      "sDecimal": "",


      /**
       * DataTables has a build in number formatter (`formatNumber`) which is
       * used to format large numbers that are used in the table information.
       * By default a comma is used, but this can be trivially changed to any
       * character you wish with this parameter.
       *  @type string
       *  @default ,
       *
       *  @dtopt Language
       *  @name DataTable.defaults.language.thousands
       *
       *  @example
       *    $(document).ready( function() {
       *      $('#example').dataTable( {
       *        "language": {
       *          "thousands": "'"
       *        }
       *      } );
       *    } );
       */
      "sThousands": ",",


      /**
       * Detail the action that will be taken when the drop down menu for the
       * pagination length option is changed. The '_MENU_' variable is replaced
       * with a default select list of 10, 25, 50 and 100, and can be replaced
       * with a custom select box if required.
       *  @type string
       *  @default Show _MENU_ entries
       *
       *  @dtopt Language
       *  @name DataTable.defaults.language.lengthMenu
       *
       *  @example
       *    // Language change only
       *    $(document).ready( function() {
       *      $('#example').dataTable( {
       *        "language": {
       *          "lengthMenu": "Display _MENU_ records"
       *        }
       *      } );
       *    } );
       *
       *  @example
       *    // Language and options change
       *    $(document).ready( function() {
       *      $('#example').dataTable( {
       *        "language": {
       *          "lengthMenu": 'Display <select>'+
       *            '<option value="10">10</option>'+
       *            '<option value="20">20</option>'+
       *            '<option value="30">30</option>'+
       *            '<option value="40">40</option>'+
       *            '<option value="50">50</option>'+
       *            '<option value="-1">All</option>'+
       *            '</select> records'
       *        }
       *      } );
       *    } );
       */
      "sLengthMenu": "Show _MENU_ entries",


      /**
       * When using Ajax sourced data and during the first draw when DataTables is
       * gathering the data, this message is shown in an empty row in the table to
       * indicate to the end user the the data is being loaded. Note that this
       * parameter is not used when loading data by server-side processing, just
       * Ajax sourced data with client-side processing.
       *  @type string
       *  @default Loading...
       *
       *  @dtopt Language
       *  @name DataTable.defaults.language.loadingRecords
       *
       *  @example
       *    $(document).ready( function() {
       *      $('#example').dataTable( {
       *        "language": {
       *          "loadingRecords": "Please wait - loading..."
       *        }
       *      } );
       *    } );
       */
      "sLoadingRecords": "Loading...",


      /**
       * Text which is displayed when the table is processing a user action
       * (usually a sort command or similar).
       *  @type string
       *  @default Processing...
       *
       *  @dtopt Language
       *  @name DataTable.defaults.language.processing
       *
       *  @example
       *    $(document).ready( function() {
       *      $('#example').dataTable( {
       *        "language": {
       *          "processing": "DataTables is currently busy"
       *        }
       *      } );
       *    } );
       */
      "sProcessing": "Processing...",


      /**
       * Details the actions that will be taken when the user types into the
       * filtering input text box. The variable "_INPUT_", if used in the string,
       * is replaced with the HTML text box for the filtering input allowing
       * control over where it appears in the string. If "_INPUT_" is not given
       * then the input box is appended to the string automatically.
       *  @type string
       *  @default Search:
       *
       *  @dtopt Language
       *  @name DataTable.defaults.language.search
       *
       *  @example
       *    // Input text box will be appended at the end automatically
       *    $(document).ready( function() {
       *      $('#example').dataTable( {
       *        "language": {
       *          "search": "Filter records:"
       *        }
       *      } );
       *    } );
       *
       *  @example
       *    // Specify where the filter should appear
       *    $(document).ready( function() {
       *      $('#example').dataTable( {
       *        "language": {
       *          "search": "Apply filter _INPUT_ to table"
       *        }
       *      } );
       *    } );
       */
      "sSearch": "Search:",


      /**
       * Assign a `placeholder` attribute to the search `input` element
       *  @type string
       *  @default
       *
       *  @dtopt Language
       *  @name DataTable.defaults.language.searchPlaceholder
       */
      "sSearchPlaceholder": "",


      /**
       * All of the language information can be stored in a file on the
       * server-side, which DataTables will look up if this parameter is passed.
       * It must store the URL of the language file, which is in a JSON format,
       * and the object has the same properties as the oLanguage object in the
       * initialiser object (i.e. the above parameters). Please refer to one of
       * the example language files to see how this works in action.
       *  @type string
       *  @default <i>Empty string - i.e. disabled</i>
       *
       *  @dtopt Language
       *  @name DataTable.defaults.language.url
       *
       *  @example
       *    $(document).ready( function() {
       *      $('#example').dataTable( {
       *        "language": {
       *          "url": "http://www.sprymedia.co.uk/dataTables/lang.txt"
       *        }
       *      } );
       *    } );
       */
      "sUrl": "",


      /**
       * Text shown inside the table records when the is no information to be
       * displayed after filtering. `emptyTable` is shown when there is simply no
       * information in the table at all (regardless of filtering).
       *  @type string
       *  @default No matching records found
       *
       *  @dtopt Language
       *  @name DataTable.defaults.language.zeroRecords
       *
       *  @example
       *    $(document).ready( function() {
       *      $('#example').dataTable( {
       *        "language": {
       *          "zeroRecords": "No records to display"
       *        }
       *      } );
       *    } );
       */
      "sZeroRecords": "No matching records found"
    },


    /**
     * This parameter allows you to have define the global filtering state at
     * initialisation time. As an object the `search` parameter must be
     * defined, but all other parameters are optional. When `regex` is true,
     * the search string will be treated as a regular expression, when false
     * (default) it will be treated as a straight string. When `smart`
     * DataTables will use it's smart filtering methods (to word match at
     * any point in the data), when false this will not be done.
     *  @namespace
     *  @extends DataTable.models.oSearch
     *
     *  @dtopt Options
     *  @name DataTable.defaults.search
     *
     *  @example
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "search": {"search": "Initial search"}
     *      } );
     *    } )
     */
    "oSearch": $.extend( {}, DataTable.models.oSearch ),


    /**
     * __Deprecated__ The functionality provided by this parameter has now been
     * superseded by that provided through `ajax`, which should be used instead.
     *
     * By default DataTables will look for the property `data` (or `aaData` for
     * compatibility with DataTables 1.9-) when obtaining data from an Ajax
     * source or for server-side processing - this parameter allows that
     * property to be changed. You can use Javascript dotted object notation to
     * get a data source for multiple levels of nesting.
     *  @type string
     *  @default data
     *
     *  @dtopt Options
     *  @dtopt Server-side
     *  @name DataTable.defaults.ajaxDataProp
     *
     *  @deprecated 1.10. Please use `ajax` for this functionality now.
     */
    "sAjaxDataProp": "data",


    /**
     * __Deprecated__ The functionality provided by this parameter has now been
     * superseded by that provided through `ajax`, which should be used instead.
     *
     * You can instruct DataTables to load data from an external
     * source using this parameter (use aData if you want to pass data in you
     * already have). Simply provide a url a JSON object can be obtained from.
     *  @type string
     *  @default null
     *
     *  @dtopt Options
     *  @dtopt Server-side
     *  @name DataTable.defaults.ajaxSource
     *
     *  @deprecated 1.10. Please use `ajax` for this functionality now.
     */
    "sAjaxSource": null,


    /**
     * This initialisation variable allows you to specify exactly where in the
     * DOM you want DataTables to inject the various controls it adds to the page
     * (for example you might want the pagination controls at the top of the
     * table). DIV elements (with or without a custom class) can also be added to
     * aid styling. The follow syntax is used:
     *   <ul>
     *     <li>The following options are allowed:
     *       <ul>
     *         <li>'l' - Length changing</li>
     *         <li>'f' - Filtering input</li>
     *         <li>'t' - The table!</li>
     *         <li>'i' - Information</li>
     *         <li>'p' - Pagination</li>
     *         <li>'r' - pRocessing</li>
     *       </ul>
     *     </li>
     *     <li>The following constants are allowed:
     *       <ul>
     *         <li>'H' - jQueryUI theme "header" classes ('fg-toolbar ui-widget-header ui-corner-tl ui-corner-tr ui-helper-clearfix')</li>
     *         <li>'F' - jQueryUI theme "footer" classes ('fg-toolbar ui-widget-header ui-corner-bl ui-corner-br ui-helper-clearfix')</li>
     *       </ul>
     *     </li>
     *     <li>The following syntax is expected:
     *       <ul>
     *         <li>'&lt;' and '&gt;' - div elements</li>
     *         <li>'&lt;"class" and '&gt;' - div with a class</li>
     *         <li>'&lt;"#id" and '&gt;' - div with an ID</li>
     *       </ul>
     *     </li>
     *     <li>Examples:
     *       <ul>
     *         <li>'&lt;"wrapper"flipt&gt;'</li>
     *         <li>'&lt;lf&lt;t&gt;ip&gt;'</li>
     *       </ul>
     *     </li>
     *   </ul>
     *  @type string
     *  @default lfrtip <i>(when `jQueryUI` is false)</i> <b>or</b>
     *    <"H"lfr>t<"F"ip> <i>(when `jQueryUI` is true)</i>
     *
     *  @dtopt Options
     *  @name DataTable.defaults.dom
     *
     *  @example
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "dom": '&lt;"top"i&gt;rt&lt;"bottom"flp&gt;&lt;"clear"&gt;'
     *      } );
     *    } );
     */
    "sDom": "lfrtip",


    /**
     * Search delay option. This will throttle full table searches that use the
     * DataTables provided search input element (it does not effect calls to
     * `dt-api search()`, providing a delay before the search is made.
     *  @type integer
     *  @default 0
     *
     *  @dtopt Options
     *  @name DataTable.defaults.searchDelay
     *
     *  @example
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "searchDelay": 200
     *      } );
     *    } )
     */
    "searchDelay": null,


    /**
     * DataTables features six different built-in options for the buttons to
     * display for pagination control:
     *
     * * `numbers` - Page number buttons only
     * * `simple` - 'Previous' and 'Next' buttons only
     * * 'simple_numbers` - 'Previous' and 'Next' buttons, plus page numbers
     * * `full` - 'First', 'Previous', 'Next' and 'Last' buttons
     * * `full_numbers` - 'First', 'Previous', 'Next' and 'Last' buttons, plus page numbers
     * * `first_last_numbers` - 'First' and 'Last' buttons, plus page numbers
     *
     * Further methods can be added using {@link DataTable.ext.oPagination}.
     *  @type string
     *  @default simple_numbers
     *
     *  @dtopt Options
     *  @name DataTable.defaults.pagingType
     *
     *  @example
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "pagingType": "full_numbers"
     *      } );
     *    } )
     */
    "sPaginationType": "simple_numbers",


    /**
     * Enable horizontal scrolling. When a table is too wide to fit into a
     * certain layout, or you have a large number of columns in the table, you
     * can enable x-scrolling to show the table in a viewport, which can be
     * scrolled. This property can be `true` which will allow the table to
     * scroll horizontally when needed, or any CSS unit, or a number (in which
     * case it will be treated as a pixel measurement). Setting as simply `true`
     * is recommended.
     *  @type boolean|string
     *  @default <i>blank string - i.e. disabled</i>
     *
     *  @dtopt Features
     *  @name DataTable.defaults.scrollX
     *
     *  @example
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "scrollX": true,
     *        "scrollCollapse": true
     *      } );
     *    } );
     */
    "sScrollX": "",


    /**
     * This property can be used to force a DataTable to use more width than it
     * might otherwise do when x-scrolling is enabled. For example if you have a
     * table which requires to be well spaced, this parameter is useful for
     * "over-sizing" the table, and thus forcing scrolling. This property can by
     * any CSS unit, or a number (in which case it will be treated as a pixel
     * measurement).
     *  @type string
     *  @default <i>blank string - i.e. disabled</i>
     *
     *  @dtopt Options
     *  @name DataTable.defaults.scrollXInner
     *
     *  @example
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "scrollX": "100%",
     *        "scrollXInner": "110%"
     *      } );
     *    } );
     */
    "sScrollXInner": "",


    /**
     * Enable vertical scrolling. Vertical scrolling will constrain the DataTable
     * to the given height, and enable scrolling for any data which overflows the
     * current viewport. This can be used as an alternative to paging to display
     * a lot of data in a small area (although paging and scrolling can both be
     * enabled at the same time). This property can be any CSS unit, or a number
     * (in which case it will be treated as a pixel measurement).
     *  @type string
     *  @default <i>blank string - i.e. disabled</i>
     *
     *  @dtopt Features
     *  @name DataTable.defaults.scrollY
     *
     *  @example
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "scrollY": "200px",
     *        "paginate": false
     *      } );
     *    } );
     */
    "sScrollY": "",


    /**
     * __Deprecated__ The functionality provided by this parameter has now been
     * superseded by that provided through `ajax`, which should be used instead.
     *
     * Set the HTTP method that is used to make the Ajax call for server-side
     * processing or Ajax sourced data.
     *  @type string
     *  @default GET
     *
     *  @dtopt Options
     *  @dtopt Server-side
     *  @name DataTable.defaults.serverMethod
     *
     *  @deprecated 1.10. Please use `ajax` for this functionality now.
     */
    "sServerMethod": "GET",


    /**
     * DataTables makes use of renderers when displaying HTML elements for
     * a table. These renderers can be added or modified by plug-ins to
     * generate suitable mark-up for a site. For example the Bootstrap
     * integration plug-in for DataTables uses a paging button renderer to
     * display pagination buttons in the mark-up required by Bootstrap.
     *
     * For further information about the renderers available see
     * DataTable.ext.renderer
     *  @type string|object
     *  @default null
     *
     *  @name DataTable.defaults.renderer
     *
     */
    "renderer": null,


    /**
     * Set the data property name that DataTables should use to get a row's id
     * to set as the `id` property in the node.
     *  @type string
     *  @default DT_RowId
     *
     *  @name DataTable.defaults.rowId
     */
    "rowId": "DT_RowId"
  };

  _fnHungarianMap( DataTable.defaults );



  /*
   * Developer note - See note in model.defaults.js about the use of Hungarian
   * notation and camel case.
   */

  /**
   * Column options that can be given to DataTables at initialisation time.
   *  @namespace
   */
  DataTable.defaults.column = {
    /**
     * Define which column(s) an order will occur on for this column. This
     * allows a column's ordering to take multiple columns into account when
     * doing a sort or use the data from a different column. For example first
     * name / last name columns make sense to do a multi-column sort over the
     * two columns.
     *  @type array|int
     *  @default null <i>Takes the value of the column index automatically</i>
     *
     *  @name DataTable.defaults.column.orderData
     *  @dtopt Columns
     *
     *  @example
     *    // Using `columnDefs`
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "columnDefs": [
     *          { "orderData": [ 0, 1 ], "targets": [ 0 ] },
     *          { "orderData": [ 1, 0 ], "targets": [ 1 ] },
     *          { "orderData": 2, "targets": [ 2 ] }
     *        ]
     *      } );
     *    } );
     *
     *  @example
     *    // Using `columns`
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "columns": [
     *          { "orderData": [ 0, 1 ] },
     *          { "orderData": [ 1, 0 ] },
     *          { "orderData": 2 },
     *          null,
     *          null
     *        ]
     *      } );
     *    } );
     */
    "aDataSort": null,
    "iDataSort": -1,


    /**
     * You can control the default ordering direction, and even alter the
     * behaviour of the sort handler (i.e. only allow ascending ordering etc)
     * using this parameter.
     *  @type array
     *  @default [ 'asc', 'desc' ]
     *
     *  @name DataTable.defaults.column.orderSequence
     *  @dtopt Columns
     *
     *  @example
     *    // Using `columnDefs`
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "columnDefs": [
     *          { "orderSequence": [ "asc" ], "targets": [ 1 ] },
     *          { "orderSequence": [ "desc", "asc", "asc" ], "targets": [ 2 ] },
     *          { "orderSequence": [ "desc" ], "targets": [ 3 ] }
     *        ]
     *      } );
     *    } );
     *
     *  @example
     *    // Using `columns`
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "columns": [
     *          null,
     *          { "orderSequence": [ "asc" ] },
     *          { "orderSequence": [ "desc", "asc", "asc" ] },
     *          { "orderSequence": [ "desc" ] },
     *          null
     *        ]
     *      } );
     *    } );
     */
    "asSorting": [ 'asc', 'desc' ],


    /**
     * Enable or disable filtering on the data in this column.
     *  @type boolean
     *  @default true
     *
     *  @name DataTable.defaults.column.searchable
     *  @dtopt Columns
     *
     *  @example
     *    // Using `columnDefs`
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "columnDefs": [
     *          { "searchable": false, "targets": [ 0 ] }
     *        ] } );
     *    } );
     *
     *  @example
     *    // Using `columns`
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "columns": [
     *          { "searchable": false },
     *          null,
     *          null,
     *          null,
     *          null
     *        ] } );
     *    } );
     */
    "bSearchable": true,


    /**
     * Enable or disable ordering on this column.
     *  @type boolean
     *  @default true
     *
     *  @name DataTable.defaults.column.orderable
     *  @dtopt Columns
     *
     *  @example
     *    // Using `columnDefs`
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "columnDefs": [
     *          { "orderable": false, "targets": [ 0 ] }
     *        ] } );
     *    } );
     *
     *  @example
     *    // Using `columns`
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "columns": [
     *          { "orderable": false },
     *          null,
     *          null,
     *          null,
     *          null
     *        ] } );
     *    } );
     */
    "bSortable": true,


    /**
     * Enable or disable the display of this column.
     *  @type boolean
     *  @default true
     *
     *  @name DataTable.defaults.column.visible
     *  @dtopt Columns
     *
     *  @example
     *    // Using `columnDefs`
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "columnDefs": [
     *          { "visible": false, "targets": [ 0 ] }
     *        ] } );
     *    } );
     *
     *  @example
     *    // Using `columns`
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "columns": [
     *          { "visible": false },
     *          null,
     *          null,
     *          null,
     *          null
     *        ] } );
     *    } );
     */
    "bVisible": true,


    /**
     * Developer definable function that is called whenever a cell is created (Ajax source,
     * etc) or processed for input (DOM source). This can be used as a compliment to mRender
     * allowing you to modify the DOM element (add background colour for example) when the
     * element is available.
     *  @type function
     *  @param {element} td The TD node that has been created
     *  @param {*} cellData The Data for the cell
     *  @param {array|object} rowData The data for the whole row
     *  @param {int} row The row index for the aoData data store
     *  @param {int} col The column index for aoColumns
     *
     *  @name DataTable.defaults.column.createdCell
     *  @dtopt Columns
     *
     *  @example
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "columnDefs": [ {
     *          "targets": [3],
     *          "createdCell": function (td, cellData, rowData, row, col) {
     *            if ( cellData == "1.7" ) {
     *              $(td).css('color', 'blue')
     *            }
     *          }
     *        } ]
     *      });
     *    } );
     */
    "fnCreatedCell": null,


    /**
     * This parameter has been replaced by `data` in DataTables to ensure naming
     * consistency. `dataProp` can still be used, as there is backwards
     * compatibility in DataTables for this option, but it is strongly
     * recommended that you use `data` in preference to `dataProp`.
     *  @name DataTable.defaults.column.dataProp
     */


    /**
     * This property can be used to read data from any data source property,
     * including deeply nested objects / properties. `data` can be given in a
     * number of different ways which effect its behaviour:
     *
     * * `integer` - treated as an array index for the data source. This is the
     *   default that DataTables uses (incrementally increased for each column).
     * * `string` - read an object property from the data source. There are
     *   three 'special' options that can be used in the string to alter how
     *   DataTables reads the data from the source object:
     *    * `.` - Dotted Javascript notation. Just as you use a `.` in
     *      Javascript to read from nested objects, so to can the options
     *      specified in `data`. For example: `browser.version` or
     *      `browser.name`. If your object parameter name contains a period, use
     *      `\\` to escape it - i.e. `first\\.name`.
     *    * `[]` - Array notation. DataTables can automatically combine data
     *      from and array source, joining the data with the characters provided
     *      between the two brackets. For example: `name[, ]` would provide a
     *      comma-space separated list from the source array. If no characters
     *      are provided between the brackets, the original array source is
     *      returned.
     *    * `()` - Function notation. Adding `()` to the end of a parameter will
     *      execute a function of the name given. For example: `browser()` for a
     *      simple function on the data source, `browser.version()` for a
     *      function in a nested property or even `browser().version` to get an
     *      object property if the function called returns an object. Note that
     *      function notation is recommended for use in `render` rather than
     *      `data` as it is much simpler to use as a renderer.
     * * `null` - use the original data source for the row rather than plucking
     *   data directly from it. This action has effects on two other
     *   initialisation options:
     *    * `defaultContent` - When null is given as the `data` option and
     *      `defaultContent` is specified for the column, the value defined by
     *      `defaultContent` will be used for the cell.
     *    * `render` - When null is used for the `data` option and the `render`
     *      option is specified for the column, the whole data source for the
     *      row is used for the renderer.
     * * `function` - the function given will be executed whenever DataTables
     *   needs to set or get the data for a cell in the column. The function
     *   takes three parameters:
     *    * Parameters:
     *      * `{array|object}` The data source for the row
     *      * `{string}` The type call data requested - this will be 'set' when
     *        setting data or 'filter', 'display', 'type', 'sort' or undefined
     *        when gathering data. Note that when `undefined` is given for the
     *        type DataTables expects to get the raw data for the object back<
     *      * `{*}` Data to set when the second parameter is 'set'.
     *    * Return:
     *      * The return value from the function is not required when 'set' is
     *        the type of call, but otherwise the return is what will be used
     *        for the data requested.
     *
     * Note that `data` is a getter and setter option. If you just require
     * formatting of data for output, you will likely want to use `render` which
     * is simply a getter and thus simpler to use.
     *
     * Note that prior to DataTables 1.9.2 `data` was called `mDataProp`. The
     * name change reflects the flexibility of this property and is consistent
     * with the naming of mRender. If 'mDataProp' is given, then it will still
     * be used by DataTables, as it automatically maps the old name to the new
     * if required.
     *
     *  @type string|int|function|null
     *  @default null <i>Use automatically calculated column index</i>
     *
     *  @name DataTable.defaults.column.data
     *  @dtopt Columns
     *
     *  @example
     *    // Read table data from objects
     *    // JSON structure for each row:
     *    //   {
     *    //      "engine": {value},
     *    //      "browser": {value},
     *    //      "platform": {value},
     *    //      "version": {value},
     *    //      "grade": {value}
     *    //   }
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "ajaxSource": "sources/objects.txt",
     *        "columns": [
     *          { "data": "engine" },
     *          { "data": "browser" },
     *          { "data": "platform" },
     *          { "data": "version" },
     *          { "data": "grade" }
     *        ]
     *      } );
     *    } );
     *
     *  @example
     *    // Read information from deeply nested objects
     *    // JSON structure for each row:
     *    //   {
     *    //      "engine": {value},
     *    //      "browser": {value},
     *    //      "platform": {
     *    //         "inner": {value}
     *    //      },
     *    //      "details": [
     *    //         {value}, {value}
     *    //      ]
     *    //   }
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "ajaxSource": "sources/deep.txt",
     *        "columns": [
     *          { "data": "engine" },
     *          { "data": "browser" },
     *          { "data": "platform.inner" },
     *          { "data": "platform.details.0" },
     *          { "data": "platform.details.1" }
     *        ]
     *      } );
     *    } );
     *
     *  @example
     *    // Using `data` as a function to provide different information for
     *    // sorting, filtering and display. In this case, currency (price)
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "columnDefs": [ {
     *          "targets": [ 0 ],
     *          "data": function ( source, type, val ) {
     *            if (type === 'set') {
     *              source.price = val;
     *              // Store the computed dislay and filter values for efficiency
     *              source.price_display = val=="" ? "" : "$"+numberFormat(val);
     *              source.price_filter  = val=="" ? "" : "$"+numberFormat(val)+" "+val;
     *              return;
     *            }
     *            else if (type === 'display') {
     *              return source.price_display;
     *            }
     *            else if (type === 'filter') {
     *              return source.price_filter;
     *            }
     *            // 'sort', 'type' and undefined all just use the integer
     *            return source.price;
     *          }
     *        } ]
     *      } );
     *    } );
     *
     *  @example
     *    // Using default content
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "columnDefs": [ {
     *          "targets": [ 0 ],
     *          "data": null,
     *          "defaultContent": "Click to edit"
     *        } ]
     *      } );
     *    } );
     *
     *  @example
     *    // Using array notation - outputting a list from an array
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "columnDefs": [ {
     *          "targets": [ 0 ],
     *          "data": "name[, ]"
     *        } ]
     *      } );
     *    } );
     *
     */
    "mData": null,


    /**
     * This property is the rendering partner to `data` and it is suggested that
     * when you want to manipulate data for display (including filtering,
     * sorting etc) without altering the underlying data for the table, use this
     * property. `render` can be considered to be the the read only companion to
     * `data` which is read / write (then as such more complex). Like `data`
     * this option can be given in a number of different ways to effect its
     * behaviour:
     *
     * * `integer` - treated as an array index for the data source. This is the
     *   default that DataTables uses (incrementally increased for each column).
     * * `string` - read an object property from the data source. There are
     *   three 'special' options that can be used in the string to alter how
     *   DataTables reads the data from the source object:
     *    * `.` - Dotted Javascript notation. Just as you use a `.` in
     *      Javascript to read from nested objects, so to can the options
     *      specified in `data`. For example: `browser.version` or
     *      `browser.name`. If your object parameter name contains a period, use
     *      `\\` to escape it - i.e. `first\\.name`.
     *    * `[]` - Array notation. DataTables can automatically combine data
     *      from and array source, joining the data with the characters provided
     *      between the two brackets. For example: `name[, ]` would provide a
     *      comma-space separated list from the source array. If no characters
     *      are provided between the brackets, the original array source is
     *      returned.
     *    * `()` - Function notation. Adding `()` to the end of a parameter will
     *      execute a function of the name given. For example: `browser()` for a
     *      simple function on the data source, `browser.version()` for a
     *      function in a nested property or even `browser().version` to get an
     *      object property if the function called returns an object.
     * * `object` - use different data for the different data types requested by
     *   DataTables ('filter', 'display', 'type' or 'sort'). The property names
     *   of the object is the data type the property refers to and the value can
     *   defined using an integer, string or function using the same rules as
     *   `render` normally does. Note that an `_` option _must_ be specified.
     *   This is the default value to use if you haven't specified a value for
     *   the data type requested by DataTables.
     * * `function` - the function given will be executed whenever DataTables
     *   needs to set or get the data for a cell in the column. The function
     *   takes three parameters:
     *    * Parameters:
     *      * {array|object} The data source for the row (based on `data`)
     *      * {string} The type call data requested - this will be 'filter',
     *        'display', 'type' or 'sort'.
     *      * {array|object} The full data source for the row (not based on
     *        `data`)
     *    * Return:
     *      * The return value from the function is what will be used for the
     *        data requested.
     *
     *  @type string|int|function|object|null
     *  @default null Use the data source value.
     *
     *  @name DataTable.defaults.column.render
     *  @dtopt Columns
     *
     *  @example
     *    // Create a comma separated list from an array of objects
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "ajaxSource": "sources/deep.txt",
     *        "columns": [
     *          { "data": "engine" },
     *          { "data": "browser" },
     *          {
     *            "data": "platform",
     *            "render": "[, ].name"
     *          }
     *        ]
     *      } );
     *    } );
     *
     *  @example
     *    // Execute a function to obtain data
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "columnDefs": [ {
     *          "targets": [ 0 ],
     *          "data": null, // Use the full data source object for the renderer's source
     *          "render": "browserName()"
     *        } ]
     *      } );
     *    } );
     *
     *  @example
     *    // As an object, extracting different data for the different types
     *    // This would be used with a data source such as:
     *    //   { "phone": 5552368, "phone_filter": "5552368 555-2368", "phone_display": "555-2368" }
     *    // Here the `phone` integer is used for sorting and type detection, while `phone_filter`
     *    // (which has both forms) is used for filtering for if a user inputs either format, while
     *    // the formatted phone number is the one that is shown in the table.
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "columnDefs": [ {
     *          "targets": [ 0 ],
     *          "data": null, // Use the full data source object for the renderer's source
     *          "render": {
     *            "_": "phone",
     *            "filter": "phone_filter",
     *            "display": "phone_display"
     *          }
     *        } ]
     *      } );
     *    } );
     *
     *  @example
     *    // Use as a function to create a link from the data source
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "columnDefs": [ {
     *          "targets": [ 0 ],
     *          "data": "download_link",
     *          "render": function ( data, type, full ) {
     *            return '<a href="'+data+'">Download</a>';
     *          }
     *        } ]
     *      } );
     *    } );
     */
    "mRender": null,


    /**
     * Change the cell type created for the column - either TD cells or TH cells. This
     * can be useful as TH cells have semantic meaning in the table body, allowing them
     * to act as a header for a row (you may wish to add scope='row' to the TH elements).
     *  @type string
     *  @default td
     *
     *  @name DataTable.defaults.column.cellType
     *  @dtopt Columns
     *
     *  @example
     *    // Make the first column use TH cells
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "columnDefs": [ {
     *          "targets": [ 0 ],
     *          "cellType": "th"
     *        } ]
     *      } );
     *    } );
     */
    "sCellType": "td",


    /**
     * Class to give to each cell in this column.
     *  @type string
     *  @default <i>Empty string</i>
     *
     *  @name DataTable.defaults.column.class
     *  @dtopt Columns
     *
     *  @example
     *    // Using `columnDefs`
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "columnDefs": [
     *          { "class": "my_class", "targets": [ 0 ] }
     *        ]
     *      } );
     *    } );
     *
     *  @example
     *    // Using `columns`
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "columns": [
     *          { "class": "my_class" },
     *          null,
     *          null,
     *          null,
     *          null
     *        ]
     *      } );
     *    } );
     */
    "sClass": "",

    /**
     * When DataTables calculates the column widths to assign to each column,
     * it finds the longest string in each column and then constructs a
     * temporary table and reads the widths from that. The problem with this
     * is that "mmm" is much wider then "iiii", but the latter is a longer
     * string - thus the calculation can go wrong (doing it properly and putting
     * it into an DOM object and measuring that is horribly(!) slow). Thus as
     * a "work around" we provide this option. It will append its value to the
     * text that is found to be the longest string for the column - i.e. padding.
     * Generally you shouldn't need this!
     *  @type string
     *  @default <i>Empty string<i>
     *
     *  @name DataTable.defaults.column.contentPadding
     *  @dtopt Columns
     *
     *  @example
     *    // Using `columns`
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "columns": [
     *          null,
     *          null,
     *          null,
     *          {
     *            "contentPadding": "mmm"
     *          }
     *        ]
     *      } );
     *    } );
     */
    "sContentPadding": "",


    /**
     * Allows a default value to be given for a column's data, and will be used
     * whenever a null data source is encountered (this can be because `data`
     * is set to null, or because the data source itself is null).
     *  @type string
     *  @default null
     *
     *  @name DataTable.defaults.column.defaultContent
     *  @dtopt Columns
     *
     *  @example
     *    // Using `columnDefs`
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "columnDefs": [
     *          {
     *            "data": null,
     *            "defaultContent": "Edit",
     *            "targets": [ -1 ]
     *          }
     *        ]
     *      } );
     *    } );
     *
     *  @example
     *    // Using `columns`
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "columns": [
     *          null,
     *          null,
     *          null,
     *          {
     *            "data": null,
     *            "defaultContent": "Edit"
     *          }
     *        ]
     *      } );
     *    } );
     */
    "sDefaultContent": null,


    /**
     * This parameter is only used in DataTables' server-side processing. It can
     * be exceptionally useful to know what columns are being displayed on the
     * client side, and to map these to database fields. When defined, the names
     * also allow DataTables to reorder information from the server if it comes
     * back in an unexpected order (i.e. if you switch your columns around on the
     * client-side, your server-side code does not also need updating).
     *  @type string
     *  @default <i>Empty string</i>
     *
     *  @name DataTable.defaults.column.name
     *  @dtopt Columns
     *
     *  @example
     *    // Using `columnDefs`
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "columnDefs": [
     *          { "name": "engine", "targets": [ 0 ] },
     *          { "name": "browser", "targets": [ 1 ] },
     *          { "name": "platform", "targets": [ 2 ] },
     *          { "name": "version", "targets": [ 3 ] },
     *          { "name": "grade", "targets": [ 4 ] }
     *        ]
     *      } );
     *    } );
     *
     *  @example
     *    // Using `columns`
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "columns": [
     *          { "name": "engine" },
     *          { "name": "browser" },
     *          { "name": "platform" },
     *          { "name": "version" },
     *          { "name": "grade" }
     *        ]
     *      } );
     *    } );
     */
    "sName": "",


    /**
     * Defines a data source type for the ordering which can be used to read
     * real-time information from the table (updating the internally cached
     * version) prior to ordering. This allows ordering to occur on user
     * editable elements such as form inputs.
     *  @type string
     *  @default std
     *
     *  @name DataTable.defaults.column.orderDataType
     *  @dtopt Columns
     *
     *  @example
     *    // Using `columnDefs`
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "columnDefs": [
     *          { "orderDataType": "dom-text", "targets": [ 2, 3 ] },
     *          { "type": "numeric", "targets": [ 3 ] },
     *          { "orderDataType": "dom-select", "targets": [ 4 ] },
     *          { "orderDataType": "dom-checkbox", "targets": [ 5 ] }
     *        ]
     *      } );
     *    } );
     *
     *  @example
     *    // Using `columns`
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "columns": [
     *          null,
     *          null,
     *          { "orderDataType": "dom-text" },
     *          { "orderDataType": "dom-text", "type": "numeric" },
     *          { "orderDataType": "dom-select" },
     *          { "orderDataType": "dom-checkbox" }
     *        ]
     *      } );
     *    } );
     */
    "sSortDataType": "std",


    /**
     * The title of this column.
     *  @type string
     *  @default null <i>Derived from the 'TH' value for this column in the
     *    original HTML table.</i>
     *
     *  @name DataTable.defaults.column.title
     *  @dtopt Columns
     *
     *  @example
     *    // Using `columnDefs`
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "columnDefs": [
     *          { "title": "My column title", "targets": [ 0 ] }
     *        ]
     *      } );
     *    } );
     *
     *  @example
     *    // Using `columns`
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "columns": [
     *          { "title": "My column title" },
     *          null,
     *          null,
     *          null,
     *          null
     *        ]
     *      } );
     *    } );
     */
    "sTitle": null,


    /**
     * The type allows you to specify how the data for this column will be
     * ordered. Four types (string, numeric, date and html (which will strip
     * HTML tags before ordering)) are currently available. Note that only date
     * formats understood by Javascript's Date() object will be accepted as type
     * date. For example: "Mar 26, 2008 5:03 PM". May take the values: 'string',
     * 'numeric', 'date' or 'html' (by default). Further types can be adding
     * through plug-ins.
     *  @type string
     *  @default null <i>Auto-detected from raw data</i>
     *
     *  @name DataTable.defaults.column.type
     *  @dtopt Columns
     *
     *  @example
     *    // Using `columnDefs`
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "columnDefs": [
     *          { "type": "html", "targets": [ 0 ] }
     *        ]
     *      } );
     *    } );
     *
     *  @example
     *    // Using `columns`
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "columns": [
     *          { "type": "html" },
     *          null,
     *          null,
     *          null,
     *          null
     *        ]
     *      } );
     *    } );
     */
    "sType": null,


    /**
     * Defining the width of the column, this parameter may take any CSS value
     * (3em, 20px etc). DataTables applies 'smart' widths to columns which have not
     * been given a specific width through this interface ensuring that the table
     * remains readable.
     *  @type string
     *  @default null <i>Automatic</i>
     *
     *  @name DataTable.defaults.column.width
     *  @dtopt Columns
     *
     *  @example
     *    // Using `columnDefs`
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "columnDefs": [
     *          { "width": "20%", "targets": [ 0 ] }
     *        ]
     *      } );
     *    } );
     *
     *  @example
     *    // Using `columns`
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "columns": [
     *          { "width": "20%" },
     *          null,
     *          null,
     *          null,
     *          null
     *        ]
     *      } );
     *    } );
     */
    "sWidth": null
  };

  _fnHungarianMap( DataTable.defaults.column );



  /**
   * DataTables settings object - this holds all the information needed for a
   * given table, including configuration, data and current application of the
   * table options. DataTables does not have a single instance for each DataTable
   * with the settings attached to that instance, but rather instances of the
   * DataTable "class" are created on-the-fly as needed (typically by a
   * $().dataTable() call) and the settings object is then applied to that
   * instance.
   *
   * Note that this object is related to {@link DataTable.defaults} but this
   * one is the internal data store for DataTables's cache of columns. It should
   * NOT be manipulated outside of DataTables. Any configuration should be done
   * through the initialisation options.
   *  @namespace
   *  @todo Really should attach the settings object to individual instances so we
   *    don't need to create new instances on each $().dataTable() call (if the
   *    table already exists). It would also save passing oSettings around and
   *    into every single function. However, this is a very significant
   *    architecture change for DataTables and will almost certainly break
   *    backwards compatibility with older installations. This is something that
   *    will be done in 2.0.
   */
  DataTable.models.oSettings = {
    /**
     * Primary features of DataTables and their enablement state.
     *  @namespace
     */
    "oFeatures": {

      /**
       * Flag to say if DataTables should automatically try to calculate the
       * optimum table and columns widths (true) or not (false).
       * Note that this parameter will be set by the initialisation routine. To
       * set a default use {@link DataTable.defaults}.
       *  @type boolean
       */
      "bAutoWidth": null,

      /**
       * Delay the creation of TR and TD elements until they are actually
       * needed by a driven page draw. This can give a significant speed
       * increase for Ajax source and Javascript source data, but makes no
       * difference at all fro DOM and server-side processing tables.
       * Note that this parameter will be set by the initialisation routine. To
       * set a default use {@link DataTable.defaults}.
       *  @type boolean
       */
      "bDeferRender": null,

      /**
       * Enable filtering on the table or not. Note that if this is disabled
       * then there is no filtering at all on the table, including fnFilter.
       * To just remove the filtering input use sDom and remove the 'f' option.
       * Note that this parameter will be set by the initialisation routine. To
       * set a default use {@link DataTable.defaults}.
       *  @type boolean
       */
      "bFilter": null,

      /**
       * Table information element (the 'Showing x of y records' div) enable
       * flag.
       * Note that this parameter will be set by the initialisation routine. To
       * set a default use {@link DataTable.defaults}.
       *  @type boolean
       */
      "bInfo": null,

      /**
       * Present a user control allowing the end user to change the page size
       * when pagination is enabled.
       * Note that this parameter will be set by the initialisation routine. To
       * set a default use {@link DataTable.defaults}.
       *  @type boolean
       */
      "bLengthChange": null,

      /**
       * Pagination enabled or not. Note that if this is disabled then length
       * changing must also be disabled.
       * Note that this parameter will be set by the initialisation routine. To
       * set a default use {@link DataTable.defaults}.
       *  @type boolean
       */
      "bPaginate": null,

      /**
       * Processing indicator enable flag whenever DataTables is enacting a
       * user request - typically an Ajax request for server-side processing.
       * Note that this parameter will be set by the initialisation routine. To
       * set a default use {@link DataTable.defaults}.
       *  @type boolean
       */
      "bProcessing": null,

      /**
       * Server-side processing enabled flag - when enabled DataTables will
       * get all data from the server for every draw - there is no filtering,
       * sorting or paging done on the client-side.
       * Note that this parameter will be set by the initialisation routine. To
       * set a default use {@link DataTable.defaults}.
       *  @type boolean
       */
      "bServerSide": null,

      /**
       * Sorting enablement flag.
       * Note that this parameter will be set by the initialisation routine. To
       * set a default use {@link DataTable.defaults}.
       *  @type boolean
       */
      "bSort": null,

      /**
       * Multi-column sorting
       * Note that this parameter will be set by the initialisation routine. To
       * set a default use {@link DataTable.defaults}.
       *  @type boolean
       */
      "bSortMulti": null,

      /**
       * Apply a class to the columns which are being sorted to provide a
       * visual highlight or not. This can slow things down when enabled since
       * there is a lot of DOM interaction.
       * Note that this parameter will be set by the initialisation routine. To
       * set a default use {@link DataTable.defaults}.
       *  @type boolean
       */
      "bSortClasses": null,

      /**
       * State saving enablement flag.
       * Note that this parameter will be set by the initialisation routine. To
       * set a default use {@link DataTable.defaults}.
       *  @type boolean
       */
      "bStateSave": null
    },


    /**
     * Scrolling settings for a table.
     *  @namespace
     */
    "oScroll": {
      /**
       * When the table is shorter in height than sScrollY, collapse the
       * table container down to the height of the table (when true).
       * Note that this parameter will be set by the initialisation routine. To
       * set a default use {@link DataTable.defaults}.
       *  @type boolean
       */
      "bCollapse": null,

      /**
       * Width of the scrollbar for the web-browser's platform. Calculated
       * during table initialisation.
       *  @type int
       *  @default 0
       */
      "iBarWidth": 0,

      /**
       * Viewport width for horizontal scrolling. Horizontal scrolling is
       * disabled if an empty string.
       * Note that this parameter will be set by the initialisation routine. To
       * set a default use {@link DataTable.defaults}.
       *  @type string
       */
      "sX": null,

      /**
       * Width to expand the table to when using x-scrolling. Typically you
       * should not need to use this.
       * Note that this parameter will be set by the initialisation routine. To
       * set a default use {@link DataTable.defaults}.
       *  @type string
       *  @deprecated
       */
      "sXInner": null,

      /**
       * Viewport height for vertical scrolling. Vertical scrolling is disabled
       * if an empty string.
       * Note that this parameter will be set by the initialisation routine. To
       * set a default use {@link DataTable.defaults}.
       *  @type string
       */
      "sY": null
    },

    /**
     * Language information for the table.
     *  @namespace
     *  @extends DataTable.defaults.oLanguage
     */
    "oLanguage": {
      /**
       * Information callback function. See
       * {@link DataTable.defaults.fnInfoCallback}
       *  @type function
       *  @default null
       */
      "fnInfoCallback": null
    },

    /**
     * Browser support parameters
     *  @namespace
     */
    "oBrowser": {
      /**
       * Indicate if the browser incorrectly calculates width:100% inside a
       * scrolling element (IE6/7)
       *  @type boolean
       *  @default false
       */
      "bScrollOversize": false,

      /**
       * Determine if the vertical scrollbar is on the right or left of the
       * scrolling container - needed for rtl language layout, although not
       * all browsers move the scrollbar (Safari).
       *  @type boolean
       *  @default false
       */
      "bScrollbarLeft": false,

      /**
       * Flag for if `getBoundingClientRect` is fully supported or not
       *  @type boolean
       *  @default false
       */
      "bBounding": false,

      /**
       * Browser scrollbar width
       *  @type integer
       *  @default 0
       */
      "barWidth": 0
    },


    "ajax": null,


    /**
     * Array referencing the nodes which are used for the features. The
     * parameters of this object match what is allowed by sDom - i.e.
     *   <ul>
     *     <li>'l' - Length changing</li>
     *     <li>'f' - Filtering input</li>
     *     <li>'t' - The table!</li>
     *     <li>'i' - Information</li>
     *     <li>'p' - Pagination</li>
     *     <li>'r' - pRocessing</li>
     *   </ul>
     *  @type array
     *  @default []
     */
    "aanFeatures": [],

    /**
     * Store data information - see {@link DataTable.models.oRow} for detailed
     * information.
     *  @type array
     *  @default []
     */
    "aoData": [],

    /**
     * Array of indexes which are in the current display (after filtering etc)
     *  @type array
     *  @default []
     */
    "aiDisplay": [],

    /**
     * Array of indexes for display - no filtering
     *  @type array
     *  @default []
     */
    "aiDisplayMaster": [],

    /**
     * Map of row ids to data indexes
     *  @type object
     *  @default {}
     */
    "aIds": {},

    /**
     * Store information about each column that is in use
     *  @type array
     *  @default []
     */
    "aoColumns": [],

    /**
     * Store information about the table's header
     *  @type array
     *  @default []
     */
    "aoHeader": [],

    /**
     * Store information about the table's footer
     *  @type array
     *  @default []
     */
    "aoFooter": [],

    /**
     * Store the applied global search information in case we want to force a
     * research or compare the old search to a new one.
     * Note that this parameter will be set by the initialisation routine. To
     * set a default use {@link DataTable.defaults}.
     *  @namespace
     *  @extends DataTable.models.oSearch
     */
    "oPreviousSearch": {},

    /**
     * Store the applied search for each column - see
     * {@link DataTable.models.oSearch} for the format that is used for the
     * filtering information for each column.
     *  @type array
     *  @default []
     */
    "aoPreSearchCols": [],

    /**
     * Sorting that is applied to the table. Note that the inner arrays are
     * used in the following manner:
     * <ul>
     *   <li>Index 0 - column number</li>
     *   <li>Index 1 - current sorting direction</li>
     * </ul>
     * Note that this parameter will be set by the initialisation routine. To
     * set a default use {@link DataTable.defaults}.
     *  @type array
     *  @todo These inner arrays should really be objects
     */
    "aaSorting": null,

    /**
     * Sorting that is always applied to the table (i.e. prefixed in front of
     * aaSorting).
     * Note that this parameter will be set by the initialisation routine. To
     * set a default use {@link DataTable.defaults}.
     *  @type array
     *  @default []
     */
    "aaSortingFixed": [],

    /**
     * Classes to use for the striping of a table.
     * Note that this parameter will be set by the initialisation routine. To
     * set a default use {@link DataTable.defaults}.
     *  @type array
     *  @default []
     */
    "asStripeClasses": null,

    /**
     * If restoring a table - we should restore its striping classes as well
     *  @type array
     *  @default []
     */
    "asDestroyStripes": [],

    /**
     * If restoring a table - we should restore its width
     *  @type int
     *  @default 0
     */
    "sDestroyWidth": 0,

    /**
     * Callback functions array for every time a row is inserted (i.e. on a draw).
     *  @type array
     *  @default []
     */
    "aoRowCallback": [],

    /**
     * Callback functions for the header on each draw.
     *  @type array
     *  @default []
     */
    "aoHeaderCallback": [],

    /**
     * Callback function for the footer on each draw.
     *  @type array
     *  @default []
     */
    "aoFooterCallback": [],

    /**
     * Array of callback functions for draw callback functions
     *  @type array
     *  @default []
     */
    "aoDrawCallback": [],

    /**
     * Array of callback functions for row created function
     *  @type array
     *  @default []
     */
    "aoRowCreatedCallback": [],

    /**
     * Callback functions for just before the table is redrawn. A return of
     * false will be used to cancel the draw.
     *  @type array
     *  @default []
     */
    "aoPreDrawCallback": [],

    /**
     * Callback functions for when the table has been initialised.
     *  @type array
     *  @default []
     */
    "aoInitComplete": [],


    /**
     * Callbacks for modifying the settings to be stored for state saving, prior to
     * saving state.
     *  @type array
     *  @default []
     */
    "aoStateSaveParams": [],

    /**
     * Callbacks for modifying the settings that have been stored for state saving
     * prior to using the stored values to restore the state.
     *  @type array
     *  @default []
     */
    "aoStateLoadParams": [],

    /**
     * Callbacks for operating on the settings object once the saved state has been
     * loaded
     *  @type array
     *  @default []
     */
    "aoStateLoaded": [],

    /**
     * Cache the table ID for quick access
     *  @type string
     *  @default <i>Empty string</i>
     */
    "sTableId": "",

    /**
     * The TABLE node for the main table
     *  @type node
     *  @default null
     */
    "nTable": null,

    /**
     * Permanent ref to the thead element
     *  @type node
     *  @default null
     */
    "nTHead": null,

    /**
     * Permanent ref to the tfoot element - if it exists
     *  @type node
     *  @default null
     */
    "nTFoot": null,

    /**
     * Permanent ref to the tbody element
     *  @type node
     *  @default null
     */
    "nTBody": null,

    /**
     * Cache the wrapper node (contains all DataTables controlled elements)
     *  @type node
     *  @default null
     */
    "nTableWrapper": null,

    /**
     * Indicate if when using server-side processing the loading of data
     * should be deferred until the second draw.
     * Note that this parameter will be set by the initialisation routine. To
     * set a default use {@link DataTable.defaults}.
     *  @type boolean
     *  @default false
     */
    "bDeferLoading": false,

    /**
     * Indicate if all required information has been read in
     *  @type boolean
     *  @default false
     */
    "bInitialised": false,

    /**
     * Information about open rows. Each object in the array has the parameters
     * 'nTr' and 'nParent'
     *  @type array
     *  @default []
     */
    "aoOpenRows": [],

    /**
     * Dictate the positioning of DataTables' control elements - see
     * {@link DataTable.model.oInit.sDom}.
     * Note that this parameter will be set by the initialisation routine. To
     * set a default use {@link DataTable.defaults}.
     *  @type string
     *  @default null
     */
    "sDom": null,

    /**
     * Search delay (in mS)
     *  @type integer
     *  @default null
     */
    "searchDelay": null,

    /**
     * Which type of pagination should be used.
     * Note that this parameter will be set by the initialisation routine. To
     * set a default use {@link DataTable.defaults}.
     *  @type string
     *  @default two_button
     */
    "sPaginationType": "two_button",

    /**
     * The state duration (for `stateSave`) in seconds.
     * Note that this parameter will be set by the initialisation routine. To
     * set a default use {@link DataTable.defaults}.
     *  @type int
     *  @default 0
     */
    "iStateDuration": 0,

    /**
     * Array of callback functions for state saving. Each array element is an
     * object with the following parameters:
     *   <ul>
     *     <li>function:fn - function to call. Takes two parameters, oSettings
     *       and the JSON string to save that has been thus far created. Returns
     *       a JSON string to be inserted into a json object
     *       (i.e. '"param": [ 0, 1, 2]')</li>
     *     <li>string:sName - name of callback</li>
     *   </ul>
     *  @type array
     *  @default []
     */
    "aoStateSave": [],

    /**
     * Array of callback functions for state loading. Each array element is an
     * object with the following parameters:
     *   <ul>
     *     <li>function:fn - function to call. Takes two parameters, oSettings
     *       and the object stored. May return false to cancel state loading</li>
     *     <li>string:sName - name of callback</li>
     *   </ul>
     *  @type array
     *  @default []
     */
    "aoStateLoad": [],

    /**
     * State that was saved. Useful for back reference
     *  @type object
     *  @default null
     */
    "oSavedState": null,

    /**
     * State that was loaded. Useful for back reference
     *  @type object
     *  @default null
     */
    "oLoadedState": null,

    /**
     * Source url for AJAX data for the table.
     * Note that this parameter will be set by the initialisation routine. To
     * set a default use {@link DataTable.defaults}.
     *  @type string
     *  @default null
     */
    "sAjaxSource": null,

    /**
     * Property from a given object from which to read the table data from. This
     * can be an empty string (when not server-side processing), in which case
     * it is  assumed an an array is given directly.
     * Note that this parameter will be set by the initialisation routine. To
     * set a default use {@link DataTable.defaults}.
     *  @type string
     */
    "sAjaxDataProp": null,

    /**
     * Note if draw should be blocked while getting data
     *  @type boolean
     *  @default true
     */
    "bAjaxDataGet": true,

    /**
     * The last jQuery XHR object that was used for server-side data gathering.
     * This can be used for working with the XHR information in one of the
     * callbacks
     *  @type object
     *  @default null
     */
    "jqXHR": null,

    /**
     * JSON returned from the server in the last Ajax request
     *  @type object
     *  @default undefined
     */
    "json": undefined,

    /**
     * Data submitted as part of the last Ajax request
     *  @type object
     *  @default undefined
     */
    "oAjaxData": undefined,

    /**
     * Function to get the server-side data.
     * Note that this parameter will be set by the initialisation routine. To
     * set a default use {@link DataTable.defaults}.
     *  @type function
     */
    "fnServerData": null,

    /**
     * Functions which are called prior to sending an Ajax request so extra
     * parameters can easily be sent to the server
     *  @type array
     *  @default []
     */
    "aoServerParams": [],

    /**
     * Send the XHR HTTP method - GET or POST (could be PUT or DELETE if
     * required).
     * Note that this parameter will be set by the initialisation routine. To
     * set a default use {@link DataTable.defaults}.
     *  @type string
     */
    "sServerMethod": null,

    /**
     * Format numbers for display.
     * Note that this parameter will be set by the initialisation routine. To
     * set a default use {@link DataTable.defaults}.
     *  @type function
     */
    "fnFormatNumber": null,

    /**
     * List of options that can be used for the user selectable length menu.
     * Note that this parameter will be set by the initialisation routine. To
     * set a default use {@link DataTable.defaults}.
     *  @type array
     *  @default []
     */
    "aLengthMenu": null,

    /**
     * Counter for the draws that the table does. Also used as a tracker for
     * server-side processing
     *  @type int
     *  @default 0
     */
    "iDraw": 0,

    /**
     * Indicate if a redraw is being done - useful for Ajax
     *  @type boolean
     *  @default false
     */
    "bDrawing": false,

    /**
     * Draw index (iDraw) of the last error when parsing the returned data
     *  @type int
     *  @default -1
     */
    "iDrawError": -1,

    /**
     * Paging display length
     *  @type int
     *  @default 10
     */
    "_iDisplayLength": 10,

    /**
     * Paging start point - aiDisplay index
     *  @type int
     *  @default 0
     */
    "_iDisplayStart": 0,

    /**
     * Server-side processing - number of records in the result set
     * (i.e. before filtering), Use fnRecordsTotal rather than
     * this property to get the value of the number of records, regardless of
     * the server-side processing setting.
     *  @type int
     *  @default 0
     *  @private
     */
    "_iRecordsTotal": 0,

    /**
     * Server-side processing - number of records in the current display set
     * (i.e. after filtering). Use fnRecordsDisplay rather than
     * this property to get the value of the number of records, regardless of
     * the server-side processing setting.
     *  @type boolean
     *  @default 0
     *  @private
     */
    "_iRecordsDisplay": 0,

    /**
     * The classes to use for the table
     *  @type object
     *  @default {}
     */
    "oClasses": {},

    /**
     * Flag attached to the settings object so you can check in the draw
     * callback if filtering has been done in the draw. Deprecated in favour of
     * events.
     *  @type boolean
     *  @default false
     *  @deprecated
     */
    "bFiltered": false,

    /**
     * Flag attached to the settings object so you can check in the draw
     * callback if sorting has been done in the draw. Deprecated in favour of
     * events.
     *  @type boolean
     *  @default false
     *  @deprecated
     */
    "bSorted": false,

    /**
     * Indicate that if multiple rows are in the header and there is more than
     * one unique cell per column, if the top one (true) or bottom one (false)
     * should be used for sorting / title by DataTables.
     * Note that this parameter will be set by the initialisation routine. To
     * set a default use {@link DataTable.defaults}.
     *  @type boolean
     */
    "bSortCellsTop": null,

    /**
     * Initialisation object that is used for the table
     *  @type object
     *  @default null
     */
    "oInit": null,

    /**
     * Destroy callback functions - for plug-ins to attach themselves to the
     * destroy so they can clean up markup and events.
     *  @type array
     *  @default []
     */
    "aoDestroyCallback": [],


    /**
     * Get the number of records in the current record set, before filtering
     *  @type function
     */
    "fnRecordsTotal": function ()
    {
      return _fnDataSource( this ) == 'ssp' ?
        this._iRecordsTotal * 1 :
        this.aiDisplayMaster.length;
    },

    /**
     * Get the number of records in the current record set, after filtering
     *  @type function
     */
    "fnRecordsDisplay": function ()
    {
      return _fnDataSource( this ) == 'ssp' ?
        this._iRecordsDisplay * 1 :
        this.aiDisplay.length;
    },

    /**
     * Get the display end point - aiDisplay index
     *  @type function
     */
    "fnDisplayEnd": function ()
    {
      var
        len      = this._iDisplayLength,
        start    = this._iDisplayStart,
        calc     = start + len,
        records  = this.aiDisplay.length,
        features = this.oFeatures,
        paginate = features.bPaginate;

      if ( features.bServerSide ) {
        return paginate === false || len === -1 ?
          start + records :
          Math.min( start+len, this._iRecordsDisplay );
      }
      else {
        return ! paginate || calc>records || len===-1 ?
          records :
          calc;
      }
    },

    /**
     * The DataTables object for this table
     *  @type object
     *  @default null
     */
    "oInstance": null,

    /**
     * Unique identifier for each instance of the DataTables object. If there
     * is an ID on the table node, then it takes that value, otherwise an
     * incrementing internal counter is used.
     *  @type string
     *  @default null
     */
    "sInstance": null,

    /**
     * tabindex attribute value that is added to DataTables control elements, allowing
     * keyboard navigation of the table and its controls.
     */
    "iTabIndex": 0,

    /**
     * DIV container for the footer scrolling table if scrolling
     */
    "nScrollHead": null,

    /**
     * DIV container for the footer scrolling table if scrolling
     */
    "nScrollFoot": null,

    /**
     * Last applied sort
     *  @type array
     *  @default []
     */
    "aLastSort": [],

    /**
     * Stored plug-in instances
     *  @type object
     *  @default {}
     */
    "oPlugins": {},

    /**
     * Function used to get a row's id from the row's data
     *  @type function
     *  @default null
     */
    "rowIdFn": null,

    /**
     * Data location where to store a row's id
     *  @type string
     *  @default null
     */
    "rowId": null
  };

  /**
   * Extension object for DataTables that is used to provide all extension
   * options.
   *
   * Note that the `DataTable.ext` object is available through
   * `jQuery.fn.dataTable.ext` where it may be accessed and manipulated. It is
   * also aliased to `jQuery.fn.dataTableExt` for historic reasons.
   *  @namespace
   *  @extends DataTable.models.ext
   */


  /**
   * DataTables extensions
   *
   * This namespace acts as a collection area for plug-ins that can be used to
   * extend DataTables capabilities. Indeed many of the build in methods
   * use this method to provide their own capabilities (sorting methods for
   * example).
   *
   * Note that this namespace is aliased to `jQuery.fn.dataTableExt` for legacy
   * reasons
   *
   *  @namespace
   */
  DataTable.ext = _ext = {
    /**
     * Buttons. For use with the Buttons extension for DataTables. This is
     * defined here so other extensions can define buttons regardless of load
     * order. It is _not_ used by DataTables core.
     *
     *  @type object
     *  @default {}
     */
    buttons: {},


    /**
     * Element class names
     *
     *  @type object
     *  @default {}
     */
    classes: {},


    /**
     * DataTables build type (expanded by the download builder)
     *
     *  @type string
     */
    build:"bs4/dt-1.10.16",


    /**
     * Error reporting.
     *
     * How should DataTables report an error. Can take the value 'alert',
     * 'throw', 'none' or a function.
     *
     *  @type string|function
     *  @default alert
     */
    errMode: "alert",


    /**
     * Feature plug-ins.
     *
     * This is an array of objects which describe the feature plug-ins that are
     * available to DataTables. These feature plug-ins are then available for
     * use through the `dom` initialisation option.
     *
     * Each feature plug-in is described by an object which must have the
     * following properties:
     *
     * * `fnInit` - function that is used to initialise the plug-in,
     * * `cFeature` - a character so the feature can be enabled by the `dom`
     *   instillation option. This is case sensitive.
     *
     * The `fnInit` function has the following input parameters:
     *
     * 1. `{object}` DataTables settings object: see
     *    {@link DataTable.models.oSettings}
     *
     * And the following return is expected:
     *
     * * {node|null} The element which contains your feature. Note that the
     *   return may also be void if your plug-in does not require to inject any
     *   DOM elements into DataTables control (`dom`) - for example this might
     *   be useful when developing a plug-in which allows table control via
     *   keyboard entry
     *
     *  @type array
     *
     *  @example
     *    $.fn.dataTable.ext.features.push( {
     *      "fnInit": function( oSettings ) {
     *        return new TableTools( { "oDTSettings": oSettings } );
     *      },
     *      "cFeature": "T"
     *    } );
     */
    feature: [],


    /**
     * Row searching.
     *
     * This method of searching is complimentary to the default type based
     * searching, and a lot more comprehensive as it allows you complete control
     * over the searching logic. Each element in this array is a function
     * (parameters described below) that is called for every row in the table,
     * and your logic decides if it should be included in the searching data set
     * or not.
     *
     * Searching functions have the following input parameters:
     *
     * 1. `{object}` DataTables settings object: see
     *    {@link DataTable.models.oSettings}
     * 2. `{array|object}` Data for the row to be processed (same as the
     *    original format that was passed in as the data source, or an array
     *    from a DOM data source
     * 3. `{int}` Row index ({@link DataTable.models.oSettings.aoData}), which
     *    can be useful to retrieve the `TR` element if you need DOM interaction.
     *
     * And the following return is expected:
     *
     * * {boolean} Include the row in the searched result set (true) or not
     *   (false)
     *
     * Note that as with the main search ability in DataTables, technically this
     * is "filtering", since it is subtractive. However, for consistency in
     * naming we call it searching here.
     *
     *  @type array
     *  @default []
     *
     *  @example
     *    // The following example shows custom search being applied to the
     *    // fourth column (i.e. the data[3] index) based on two input values
     *    // from the end-user, matching the data in a certain range.
     *    $.fn.dataTable.ext.search.push(
     *      function( settings, data, dataIndex ) {
     *        var min = document.getElementById('min').value * 1;
     *        var max = document.getElementById('max').value * 1;
     *        var version = data[3] == "-" ? 0 : data[3]*1;
     *
     *        if ( min == "" && max == "" ) {
     *          return true;
     *        }
     *        else if ( min == "" && version < max ) {
     *          return true;
     *        }
     *        else if ( min < version && "" == max ) {
     *          return true;
     *        }
     *        else if ( min < version && version < max ) {
     *          return true;
     *        }
     *        return false;
     *      }
     *    );
     */
    search: [],


    /**
     * Selector extensions
     *
     * The `selector` option can be used to extend the options available for the
     * selector modifier options (`selector-modifier` object data type) that
     * each of the three built in selector types offer (row, column and cell +
     * their plural counterparts). For example the Select extension uses this
     * mechanism to provide an option to select only rows, columns and cells
     * that have been marked as selected by the end user (`{selected: true}`),
     * which can be used in conjunction with the existing built in selector
     * options.
     *
     * Each property is an array to which functions can be pushed. The functions
     * take three attributes:
     *
     * * Settings object for the host table
     * * Options object (`selector-modifier` object type)
     * * Array of selected item indexes
     *
     * The return is an array of the resulting item indexes after the custom
     * selector has been applied.
     *
     *  @type object
     */
    selector: {
      cell: [],
      column: [],
      row: []
    },


    /**
     * Internal functions, exposed for used in plug-ins.
     *
     * Please note that you should not need to use the internal methods for
     * anything other than a plug-in (and even then, try to avoid if possible).
     * The internal function may change between releases.
     *
     *  @type object
     *  @default {}
     */
    internal: {},


    /**
     * Legacy configuration options. Enable and disable legacy options that
     * are available in DataTables.
     *
     *  @type object
     */
    legacy: {
      /**
       * Enable / disable DataTables 1.9 compatible server-side processing
       * requests
       *
       *  @type boolean
       *  @default null
       */
      ajax: null
    },


    /**
     * Pagination plug-in methods.
     *
     * Each entry in this object is a function and defines which buttons should
     * be shown by the pagination rendering method that is used for the table:
     * {@link DataTable.ext.renderer.pageButton}. The renderer addresses how the
     * buttons are displayed in the document, while the functions here tell it
     * what buttons to display. This is done by returning an array of button
     * descriptions (what each button will do).
     *
     * Pagination types (the four built in options and any additional plug-in
     * options defined here) can be used through the `paginationType`
     * initialisation parameter.
     *
     * The functions defined take two parameters:
     *
     * 1. `{int} page` The current page index
     * 2. `{int} pages` The number of pages in the table
     *
     * Each function is expected to return an array where each element of the
     * array can be one of:
     *
     * * `first` - Jump to first page when activated
     * * `last` - Jump to last page when activated
     * * `previous` - Show previous page when activated
     * * `next` - Show next page when activated
     * * `{int}` - Show page of the index given
     * * `{array}` - A nested array containing the above elements to add a
     *   containing 'DIV' element (might be useful for styling).
     *
     * Note that DataTables v1.9- used this object slightly differently whereby
     * an object with two functions would be defined for each plug-in. That
     * ability is still supported by DataTables 1.10+ to provide backwards
     * compatibility, but this option of use is now decremented and no longer
     * documented in DataTables 1.10+.
     *
     *  @type object
     *  @default {}
     *
     *  @example
     *    // Show previous, next and current page buttons only
     *    $.fn.dataTableExt.oPagination.current = function ( page, pages ) {
     *      return [ 'previous', page, 'next' ];
     *    };
     */
    pager: {},


    renderer: {
      pageButton: {},
      header: {}
    },


    /**
     * Ordering plug-ins - custom data source
     *
     * The extension options for ordering of data available here is complimentary
     * to the default type based ordering that DataTables typically uses. It
     * allows much greater control over the the data that is being used to
     * order a column, but is necessarily therefore more complex.
     *
     * This type of ordering is useful if you want to do ordering based on data
     * live from the DOM (for example the contents of an 'input' element) rather
     * than just the static string that DataTables knows of.
     *
     * The way these plug-ins work is that you create an array of the values you
     * wish to be ordering for the column in question and then return that
     * array. The data in the array much be in the index order of the rows in
     * the table (not the currently ordering order!). Which order data gathering
     * function is run here depends on the `dt-init columns.orderDataType`
     * parameter that is used for the column (if any).
     *
     * The functions defined take two parameters:
     *
     * 1. `{object}` DataTables settings object: see
     *    {@link DataTable.models.oSettings}
     * 2. `{int}` Target column index
     *
     * Each function is expected to return an array:
     *
     * * `{array}` Data for the column to be ordering upon
     *
     *  @type array
     *
     *  @example
     *    // Ordering using `input` node values
     *    $.fn.dataTable.ext.order['dom-text'] = function  ( settings, col )
     *    {
     *      return this.api().column( col, {order:'index'} ).nodes().map( function ( td, i ) {
     *        return $('input', td).val();
     *      } );
     *    }
     */
    order: {},


    /**
     * Type based plug-ins.
     *
     * Each column in DataTables has a type assigned to it, either by automatic
     * detection or by direct assignment using the `type` option for the column.
     * The type of a column will effect how it is ordering and search (plug-ins
     * can also make use of the column type if required).
     *
     * @namespace
     */
    type: {
      /**
       * Type detection functions.
       *
       * The functions defined in this object are used to automatically detect
       * a column's type, making initialisation of DataTables super easy, even
       * when complex data is in the table.
       *
       * The functions defined take two parameters:
       *
         *  1. `{*}` Data from the column cell to be analysed
         *  2. `{settings}` DataTables settings object. This can be used to
         *     perform context specific type detection - for example detection
         *     based on language settings such as using a comma for a decimal
         *     place. Generally speaking the options from the settings will not
         *     be required
       *
       * Each function is expected to return:
       *
       * * `{string|null}` Data type detected, or null if unknown (and thus
       *   pass it on to the other type detection functions.
       *
       *  @type array
       *
       *  @example
       *    // Currency type detection plug-in:
       *    $.fn.dataTable.ext.type.detect.push(
       *      function ( data, settings ) {
       *        // Check the numeric part
       *        if ( ! $.isNumeric( data.substring(1) ) ) {
       *          return null;
       *        }
       *
       *        // Check prefixed by currency
       *        if ( data.charAt(0) == '$' || data.charAt(0) == '&pound;' ) {
       *          return 'currency';
       *        }
       *        return null;
       *      }
       *    );
       */
      detect: [],


      /**
       * Type based search formatting.
       *
       * The type based searching functions can be used to pre-format the
       * data to be search on. For example, it can be used to strip HTML
       * tags or to de-format telephone numbers for numeric only searching.
       *
       * Note that is a search is not defined for a column of a given type,
       * no search formatting will be performed.
       *
       * Pre-processing of searching data plug-ins - When you assign the sType
       * for a column (or have it automatically detected for you by DataTables
       * or a type detection plug-in), you will typically be using this for
       * custom sorting, but it can also be used to provide custom searching
       * by allowing you to pre-processing the data and returning the data in
       * the format that should be searched upon. This is done by adding
       * functions this object with a parameter name which matches the sType
       * for that target column. This is the corollary of <i>afnSortData</i>
       * for searching data.
       *
       * The functions defined take a single parameter:
       *
         *  1. `{*}` Data from the column cell to be prepared for searching
       *
       * Each function is expected to return:
       *
       * * `{string|null}` Formatted string that will be used for the searching.
       *
       *  @type object
       *  @default {}
       *
       *  @example
       *    $.fn.dataTable.ext.type.search['title-numeric'] = function ( d ) {
       *      return d.replace(/\n/g," ").replace( /<.*?>/g, "" );
       *    }
       */
      search: {},


      /**
       * Type based ordering.
       *
       * The column type tells DataTables what ordering to apply to the table
       * when a column is sorted upon. The order for each type that is defined,
       * is defined by the functions available in this object.
       *
       * Each ordering option can be described by three properties added to
       * this object:
       *
       * * `{type}-pre` - Pre-formatting function
       * * `{type}-asc` - Ascending order function
       * * `{type}-desc` - Descending order function
       *
       * All three can be used together, only `{type}-pre` or only
       * `{type}-asc` and `{type}-desc` together. It is generally recommended
       * that only `{type}-pre` is used, as this provides the optimal
       * implementation in terms of speed, although the others are provided
       * for compatibility with existing Javascript sort functions.
       *
       * `{type}-pre`: Functions defined take a single parameter:
       *
         *  1. `{*}` Data from the column cell to be prepared for ordering
       *
       * And return:
       *
       * * `{*}` Data to be sorted upon
       *
       * `{type}-asc` and `{type}-desc`: Functions are typical Javascript sort
       * functions, taking two parameters:
       *
         *  1. `{*}` Data to compare to the second parameter
         *  2. `{*}` Data to compare to the first parameter
       *
       * And returning:
       *
       * * `{*}` Ordering match: <0 if first parameter should be sorted lower
       *   than the second parameter, ===0 if the two parameters are equal and
       *   >0 if the first parameter should be sorted height than the second
       *   parameter.
       *
       *  @type object
       *  @default {}
       *
       *  @example
       *    // Numeric ordering of formatted numbers with a pre-formatter
       *    $.extend( $.fn.dataTable.ext.type.order, {
       *      "string-pre": function(x) {
       *        a = (a === "-" || a === "") ? 0 : a.replace( /[^\d\-\.]/g, "" );
       *        return parseFloat( a );
       *      }
       *    } );
       *
       *  @example
       *    // Case-sensitive string ordering, with no pre-formatting method
       *    $.extend( $.fn.dataTable.ext.order, {
       *      "string-case-asc": function(x,y) {
       *        return ((x < y) ? -1 : ((x > y) ? 1 : 0));
       *      },
       *      "string-case-desc": function(x,y) {
       *        return ((x < y) ? 1 : ((x > y) ? -1 : 0));
       *      }
       *    } );
       */
      order: {}
    },

    /**
     * Unique DataTables instance counter
     *
     * @type int
     * @private
     */
    _unique: 0,


    //
    // Depreciated
    // The following properties are retained for backwards compatiblity only.
    // The should not be used in new projects and will be removed in a future
    // version
    //

    /**
     * Version check function.
     *  @type function
     *  @depreciated Since 1.10
     */
    fnVersionCheck: DataTable.fnVersionCheck,


    /**
     * Index for what 'this' index API functions should use
     *  @type int
     *  @deprecated Since v1.10
     */
    iApiIndex: 0,


    /**
     * jQuery UI class container
     *  @type object
     *  @deprecated Since v1.10
     */
    oJUIClasses: {},


    /**
     * Software version
     *  @type string
     *  @deprecated Since v1.10
     */
    sVersion: DataTable.version
  };


  //
  // Backwards compatibility. Alias to pre 1.10 Hungarian notation counter parts
  //
  $.extend( _ext, {
    afnFiltering: _ext.search,
    aTypes:       _ext.type.detect,
    ofnSearch:    _ext.type.search,
    oSort:        _ext.type.order,
    afnSortData:  _ext.order,
    aoFeatures:   _ext.feature,
    oApi:         _ext.internal,
    oStdClasses:  _ext.classes,
    oPagination:  _ext.pager
  } );


  $.extend( DataTable.ext.classes, {
    "sTable": "dataTable",
    "sNoFooter": "no-footer",

    /* Paging buttons */
    "sPageButton": "paginate_button",
    "sPageButtonActive": "current",
    "sPageButtonDisabled": "disabled",

    /* Striping classes */
    "sStripeOdd": "odd",
    "sStripeEven": "even",

    /* Empty row */
    "sRowEmpty": "dataTables_empty",

    /* Features */
    "sWrapper": "dataTables_wrapper",
    "sFilter": "dataTables_filter",
    "sInfo": "dataTables_info",
    "sPaging": "dataTables_paginate paging_", /* Note that the type is postfixed */
    "sLength": "dataTables_length",
    "sProcessing": "dataTables_processing",

    /* Sorting */
    "sSortAsc": "sorting_asc",
    "sSortDesc": "sorting_desc",
    "sSortable": "sorting", /* Sortable in both directions */
    "sSortableAsc": "sorting_asc_disabled",
    "sSortableDesc": "sorting_desc_disabled",
    "sSortableNone": "sorting_disabled",
    "sSortColumn": "sorting_", /* Note that an int is postfixed for the sorting order */

    /* Filtering */
    "sFilterInput": "",

    /* Page length */
    "sLengthSelect": "",

    /* Scrolling */
    "sScrollWrapper": "dataTables_scroll",
    "sScrollHead": "dataTables_scrollHead",
    "sScrollHeadInner": "dataTables_scrollHeadInner",
    "sScrollBody": "dataTables_scrollBody",
    "sScrollFoot": "dataTables_scrollFoot",
    "sScrollFootInner": "dataTables_scrollFootInner",

    /* Misc */
    "sHeaderTH": "",
    "sFooterTH": "",

    // Deprecated
    "sSortJUIAsc": "",
    "sSortJUIDesc": "",
    "sSortJUI": "",
    "sSortJUIAscAllowed": "",
    "sSortJUIDescAllowed": "",
    "sSortJUIWrapper": "",
    "sSortIcon": "",
    "sJUIHeader": "",
    "sJUIFooter": ""
  } );


  var extPagination = DataTable.ext.pager;

  function _numbers ( page, pages ) {
    var
      numbers = [],
      buttons = extPagination.numbers_length,
      half = Math.floor( buttons / 2 ),
      i = 1;

    if ( pages <= buttons ) {
      numbers = _range( 0, pages );
    }
    else if ( page <= half ) {
      numbers = _range( 0, buttons-2 );
      numbers.push( 'ellipsis' );
      numbers.push( pages-1 );
    }
    else if ( page >= pages - 1 - half ) {
      numbers = _range( pages-(buttons-2), pages );
      numbers.splice( 0, 0, 'ellipsis' ); // no unshift in ie6
      numbers.splice( 0, 0, 0 );
    }
    else {
      numbers = _range( page-half+2, page+half-1 );
      numbers.push( 'ellipsis' );
      numbers.push( pages-1 );
      numbers.splice( 0, 0, 'ellipsis' );
      numbers.splice( 0, 0, 0 );
    }

    numbers.DT_el = 'span';
    return numbers;
  }


  $.extend( extPagination, {
    simple: function ( page, pages ) {
      return [ 'previous', 'next' ];
    },

    full: function ( page, pages ) {
      return [  'first', 'previous', 'next', 'last' ];
    },

    numbers: function ( page, pages ) {
      return [ _numbers(page, pages) ];
    },

    simple_numbers: function ( page, pages ) {
      return [ 'previous', _numbers(page, pages), 'next' ];
    },

    full_numbers: function ( page, pages ) {
      return [ 'first', 'previous', _numbers(page, pages), 'next', 'last' ];
    },

    first_last_numbers: function (page, pages) {
      return ['first', _numbers(page, pages), 'last'];
    },

    // For testing and plug-ins to use
    _numbers: _numbers,

    // Number of number buttons (including ellipsis) to show. _Must be odd!_
    numbers_length: 7
  } );


  $.extend( true, DataTable.ext.renderer, {
    pageButton: {
      _: function ( settings, host, idx, buttons, page, pages ) {
        var classes = settings.oClasses;
        var lang = settings.oLanguage.oPaginate;
        var aria = settings.oLanguage.oAria.paginate || {};
        var btnDisplay, btnClass, counter=0;

        var attach = function( container, buttons ) {
          var i, ien, node, button;
          var clickHandler = function ( e ) {
            _fnPageChange( settings, e.data.action, true );
          };

          for ( i=0, ien=buttons.length ; i<ien ; i++ ) {
            button = buttons[i];

            if ( $.isArray( button ) ) {
              var inner = $( '<'+(button.DT_el || 'div')+'/>' )
                .appendTo( container );
              attach( inner, button );
            }
            else {
              btnDisplay = null;
              btnClass = '';

              switch ( button ) {
                case 'ellipsis':
                  container.append('<span class="ellipsis">&#x2026;</span>');
                  break;

                case 'first':
                  btnDisplay = lang.sFirst;
                  btnClass = button + (page > 0 ?
                    '' : ' '+classes.sPageButtonDisabled);
                  break;

                case 'previous':
                  btnDisplay = lang.sPrevious;
                  btnClass = button + (page > 0 ?
                    '' : ' '+classes.sPageButtonDisabled);
                  break;

                case 'next':
                  btnDisplay = lang.sNext;
                  btnClass = button + (page < pages-1 ?
                    '' : ' '+classes.sPageButtonDisabled);
                  break;

                case 'last':
                  btnDisplay = lang.sLast;
                  btnClass = button + (page < pages-1 ?
                    '' : ' '+classes.sPageButtonDisabled);
                  break;

                default:
                  btnDisplay = button + 1;
                  btnClass = page === button ?
                    classes.sPageButtonActive : '';
                  break;
              }

              if ( btnDisplay !== null ) {
                node = $('<a>', {
                    'class': classes.sPageButton+' '+btnClass,
                    'aria-controls': settings.sTableId,
                    'aria-label': aria[ button ],
                    'data-dt-idx': counter,
                    'tabindex': settings.iTabIndex,
                    'id': idx === 0 && typeof button === 'string' ?
                      settings.sTableId +'_'+ button :
                      null
                  } )
                  .html( btnDisplay )
                  .appendTo( container );

                _fnBindAction(
                  node, {action: button}, clickHandler
                );

                counter++;
              }
            }
          }
        };

        // IE9 throws an 'unknown error' if document.activeElement is used
        // inside an iframe or frame. Try / catch the error. Not good for
        // accessibility, but neither are frames.
        var activeEl;

        try {
          // Because this approach is destroying and recreating the paging
          // elements, focus is lost on the select button which is bad for
          // accessibility. So we want to restore focus once the draw has
          // completed
          activeEl = $(host).find(document.activeElement).data('dt-idx');
        }
        catch (e) {}

        attach( $(host).empty(), buttons );

        if ( activeEl !== undefined ) {
          $(host).find( '[data-dt-idx='+activeEl+']' ).focus();
        }
      }
    }
  } );



  // Built in type detection. See model.ext.aTypes for information about
  // what is required from this methods.
  $.extend( DataTable.ext.type.detect, [
    // Plain numbers - first since V8 detects some plain numbers as dates
    // e.g. Date.parse('55') (but not all, e.g. Date.parse('22')...).
    function ( d, settings )
    {
      var decimal = settings.oLanguage.sDecimal;
      return _isNumber( d, decimal ) ? 'num'+decimal : null;
    },

    // Dates (only those recognised by the browser's Date.parse)
    function ( d, settings )
    {
      // V8 tries _very_ hard to make a string passed into `Date.parse()`
      // valid, so we need to use a regex to restrict date formats. Use a
      // plug-in for anything other than ISO8601 style strings
      if ( d && !(d instanceof Date) && ! _re_date.test(d) ) {
        return null;
      }
      var parsed = Date.parse(d);
      return (parsed !== null && !isNaN(parsed)) || _empty(d) ? 'date' : null;
    },

    // Formatted numbers
    function ( d, settings )
    {
      var decimal = settings.oLanguage.sDecimal;
      return _isNumber( d, decimal, true ) ? 'num-fmt'+decimal : null;
    },

    // HTML numeric
    function ( d, settings )
    {
      var decimal = settings.oLanguage.sDecimal;
      return _htmlNumeric( d, decimal ) ? 'html-num'+decimal : null;
    },

    // HTML numeric, formatted
    function ( d, settings )
    {
      var decimal = settings.oLanguage.sDecimal;
      return _htmlNumeric( d, decimal, true ) ? 'html-num-fmt'+decimal : null;
    },

    // HTML (this is strict checking - there must be html)
    function ( d, settings )
    {
      return _empty( d ) || (typeof d === 'string' && d.indexOf('<') !== -1) ?
        'html' : null;
    }
  ] );



  // Filter formatting functions. See model.ext.ofnSearch for information about
  // what is required from these methods.
  //
  // Note that additional search methods are added for the html numbers and
  // html formatted numbers by `_addNumericSort()` when we know what the decimal
  // place is


  $.extend( DataTable.ext.type.search, {
    html: function ( data ) {
      return _empty(data) ?
        data :
        typeof data === 'string' ?
          data
            .replace( _re_new_lines, " " )
            .replace( _re_html, "" ) :
          '';
    },

    string: function ( data ) {
      return _empty(data) ?
        data :
        typeof data === 'string' ?
          data.replace( _re_new_lines, " " ) :
          data;
    }
  } );



  var __numericReplace = function ( d, decimalPlace, re1, re2 ) {
    if ( d !== 0 && (!d || d === '-') ) {
      return -Infinity;
    }

    // If a decimal place other than `.` is used, it needs to be given to the
    // function so we can detect it and replace with a `.` which is the only
    // decimal place Javascript recognises - it is not locale aware.
    if ( decimalPlace ) {
      d = _numToDecimal( d, decimalPlace );
    }

    if ( d.replace ) {
      if ( re1 ) {
        d = d.replace( re1, '' );
      }

      if ( re2 ) {
        d = d.replace( re2, '' );
      }
    }

    return d * 1;
  };


  // Add the numeric 'deformatting' functions for sorting and search. This is done
  // in a function to provide an easy ability for the language options to add
  // additional methods if a non-period decimal place is used.
  function _addNumericSort ( decimalPlace ) {
    $.each(
      {
        // Plain numbers
        "num": function ( d ) {
          return __numericReplace( d, decimalPlace );
        },

        // Formatted numbers
        "num-fmt": function ( d ) {
          return __numericReplace( d, decimalPlace, _re_formatted_numeric );
        },

        // HTML numeric
        "html-num": function ( d ) {
          return __numericReplace( d, decimalPlace, _re_html );
        },

        // HTML numeric, formatted
        "html-num-fmt": function ( d ) {
          return __numericReplace( d, decimalPlace, _re_html, _re_formatted_numeric );
        }
      },
      function ( key, fn ) {
        // Add the ordering method
        _ext.type.order[ key+decimalPlace+'-pre' ] = fn;

        // For HTML types add a search formatter that will strip the HTML
        if ( key.match(/^html\-/) ) {
          _ext.type.search[ key+decimalPlace ] = _ext.type.search.html;
        }
      }
    );
  }


  // Default sort methods
  $.extend( _ext.type.order, {
    // Dates
    "date-pre": function ( d ) {
      return Date.parse( d ) || -Infinity;
    },

    // html
    "html-pre": function ( a ) {
      return _empty(a) ?
        '' :
        a.replace ?
          a.replace( /<.*?>/g, "" ).toLowerCase() :
          a+'';
    },

    // string
    "string-pre": function ( a ) {
      // This is a little complex, but faster than always calling toString,
      // http://jsperf.com/tostring-v-check
      return _empty(a) ?
        '' :
        typeof a === 'string' ?
          a.toLowerCase() :
          ! a.toString ?
            '' :
            a.toString();
    },

    // string-asc and -desc are retained only for compatibility with the old
    // sort methods
    "string-asc": function ( x, y ) {
      return ((x < y) ? -1 : ((x > y) ? 1 : 0));
    },

    "string-desc": function ( x, y ) {
      return ((x < y) ? 1 : ((x > y) ? -1 : 0));
    }
  } );


  // Numeric sorting types - order doesn't matter here
  _addNumericSort( '' );


  $.extend( true, DataTable.ext.renderer, {
    header: {
      _: function ( settings, cell, column, classes ) {
        // No additional mark-up required
        // Attach a sort listener to update on sort - note that using the
        // `DT` namespace will allow the event to be removed automatically
        // on destroy, while the `dt` namespaced event is the one we are
        // listening for
        $(settings.nTable).on( 'order.dt.DT', function ( e, ctx, sorting, columns ) {
          if ( settings !== ctx ) { // need to check this this is the host
            return;               // table, not a nested one
          }

          var colIdx = column.idx;

          cell
            .removeClass(
              column.sSortingClass +' '+
              classes.sSortAsc +' '+
              classes.sSortDesc
            )
            .addClass( columns[ colIdx ] == 'asc' ?
              classes.sSortAsc : columns[ colIdx ] == 'desc' ?
                classes.sSortDesc :
                column.sSortingClass
            );
        } );
      },

      jqueryui: function ( settings, cell, column, classes ) {
        $('<div/>')
          .addClass( classes.sSortJUIWrapper )
          .append( cell.contents() )
          .append( $('<span/>')
            .addClass( classes.sSortIcon+' '+column.sSortingClassJUI )
          )
          .appendTo( cell );

        // Attach a sort listener to update on sort
        $(settings.nTable).on( 'order.dt.DT', function ( e, ctx, sorting, columns ) {
          if ( settings !== ctx ) {
            return;
          }

          var colIdx = column.idx;

          cell
            .removeClass( classes.sSortAsc +" "+classes.sSortDesc )
            .addClass( columns[ colIdx ] == 'asc' ?
              classes.sSortAsc : columns[ colIdx ] == 'desc' ?
                classes.sSortDesc :
                column.sSortingClass
            );

          cell
            .find( 'span.'+classes.sSortIcon )
            .removeClass(
              classes.sSortJUIAsc +" "+
              classes.sSortJUIDesc +" "+
              classes.sSortJUI +" "+
              classes.sSortJUIAscAllowed +" "+
              classes.sSortJUIDescAllowed
            )
            .addClass( columns[ colIdx ] == 'asc' ?
              classes.sSortJUIAsc : columns[ colIdx ] == 'desc' ?
                classes.sSortJUIDesc :
                column.sSortingClassJUI
            );
        } );
      }
    }
  } );

  /*
   * Public helper functions. These aren't used internally by DataTables, or
   * called by any of the options passed into DataTables, but they can be used
   * externally by developers working with DataTables. They are helper functions
   * to make working with DataTables a little bit easier.
   */

  var __htmlEscapeEntities = function ( d ) {
    return typeof d === 'string' ?
      d.replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;') :
      d;
  };

  /**
   * Helpers for `columns.render`.
   *
   * The options defined here can be used with the `columns.render` initialisation
   * option to provide a display renderer. The following functions are defined:
   *
   * * `number` - Will format numeric data (defined by `columns.data`) for
   *   display, retaining the original unformatted data for sorting and filtering.
   *   It takes 5 parameters:
   *   * `string` - Thousands grouping separator
   *   * `string` - Decimal point indicator
   *   * `integer` - Number of decimal points to show
   *   * `string` (optional) - Prefix.
   *   * `string` (optional) - Postfix (/suffix).
   * * `text` - Escape HTML to help prevent XSS attacks. It has no optional
   *   parameters.
   *
   * @example
   *   // Column definition using the number renderer
   *   {
   *     data: "salary",
   *     render: $.fn.dataTable.render.number( '\'', '.', 0, '$' )
   *   }
   *
   * @namespace
   */
  DataTable.render = {
    number: function ( thousands, decimal, precision, prefix, postfix ) {
      return {
        display: function ( d ) {
          if ( typeof d !== 'number' && typeof d !== 'string' ) {
            return d;
          }

          var negative = d < 0 ? '-' : '';
          var flo = parseFloat( d );

          // If NaN then there isn't much formatting that we can do - just
          // return immediately, escaping any HTML (this was supposed to
          // be a number after all)
          if ( isNaN( flo ) ) {
            return __htmlEscapeEntities( d );
          }

          flo = flo.toFixed( precision );
          d = Math.abs( flo );

          var intPart = parseInt( d, 10 );
          var floatPart = precision ?
            decimal+(d - intPart).toFixed( precision ).substring( 2 ):
            '';

          return negative + (prefix||'') +
            intPart.toString().replace(
              /\B(?=(\d{3})+(?!\d))/g, thousands
            ) +
            floatPart +
            (postfix||'');
        }
      };
    },

    text: function () {
      return {
        display: __htmlEscapeEntities
      };
    }
  };


  /*
   * This is really a good bit rubbish this method of exposing the internal methods
   * publicly... - To be fixed in 2.0 using methods on the prototype
   */


  /**
   * Create a wrapper function for exporting an internal functions to an external API.
   *  @param {string} fn API function name
   *  @returns {function} wrapped function
   *  @memberof DataTable#internal
   */
  function _fnExternApiFunc (fn)
  {
    return function() {
      var args = [_fnSettingsFromNode( this[DataTable.ext.iApiIndex] )].concat(
        Array.prototype.slice.call(arguments)
      );
      return DataTable.ext.internal[fn].apply( this, args );
    };
  }


  /**
   * Reference to internal functions for use by plug-in developers. Note that
   * these methods are references to internal functions and are considered to be
   * private. If you use these methods, be aware that they are liable to change
   * between versions.
   *  @namespace
   */
  $.extend( DataTable.ext.internal, {
    _fnExternApiFunc: _fnExternApiFunc,
    _fnBuildAjax: _fnBuildAjax,
    _fnAjaxUpdate: _fnAjaxUpdate,
    _fnAjaxParameters: _fnAjaxParameters,
    _fnAjaxUpdateDraw: _fnAjaxUpdateDraw,
    _fnAjaxDataSrc: _fnAjaxDataSrc,
    _fnAddColumn: _fnAddColumn,
    _fnColumnOptions: _fnColumnOptions,
    _fnAdjustColumnSizing: _fnAdjustColumnSizing,
    _fnVisibleToColumnIndex: _fnVisibleToColumnIndex,
    _fnColumnIndexToVisible: _fnColumnIndexToVisible,
    _fnVisbleColumns: _fnVisbleColumns,
    _fnGetColumns: _fnGetColumns,
    _fnColumnTypes: _fnColumnTypes,
    _fnApplyColumnDefs: _fnApplyColumnDefs,
    _fnHungarianMap: _fnHungarianMap,
    _fnCamelToHungarian: _fnCamelToHungarian,
    _fnLanguageCompat: _fnLanguageCompat,
    _fnBrowserDetect: _fnBrowserDetect,
    _fnAddData: _fnAddData,
    _fnAddTr: _fnAddTr,
    _fnNodeToDataIndex: _fnNodeToDataIndex,
    _fnNodeToColumnIndex: _fnNodeToColumnIndex,
    _fnGetCellData: _fnGetCellData,
    _fnSetCellData: _fnSetCellData,
    _fnSplitObjNotation: _fnSplitObjNotation,
    _fnGetObjectDataFn: _fnGetObjectDataFn,
    _fnSetObjectDataFn: _fnSetObjectDataFn,
    _fnGetDataMaster: _fnGetDataMaster,
    _fnClearTable: _fnClearTable,
    _fnDeleteIndex: _fnDeleteIndex,
    _fnInvalidate: _fnInvalidate,
    _fnGetRowElements: _fnGetRowElements,
    _fnCreateTr: _fnCreateTr,
    _fnBuildHead: _fnBuildHead,
    _fnDrawHead: _fnDrawHead,
    _fnDraw: _fnDraw,
    _fnReDraw: _fnReDraw,
    _fnAddOptionsHtml: _fnAddOptionsHtml,
    _fnDetectHeader: _fnDetectHeader,
    _fnGetUniqueThs: _fnGetUniqueThs,
    _fnFeatureHtmlFilter: _fnFeatureHtmlFilter,
    _fnFilterComplete: _fnFilterComplete,
    _fnFilterCustom: _fnFilterCustom,
    _fnFilterColumn: _fnFilterColumn,
    _fnFilter: _fnFilter,
    _fnFilterCreateSearch: _fnFilterCreateSearch,
    _fnEscapeRegex: _fnEscapeRegex,
    _fnFilterData: _fnFilterData,
    _fnFeatureHtmlInfo: _fnFeatureHtmlInfo,
    _fnUpdateInfo: _fnUpdateInfo,
    _fnInfoMacros: _fnInfoMacros,
    _fnInitialise: _fnInitialise,
    _fnInitComplete: _fnInitComplete,
    _fnLengthChange: _fnLengthChange,
    _fnFeatureHtmlLength: _fnFeatureHtmlLength,
    _fnFeatureHtmlPaginate: _fnFeatureHtmlPaginate,
    _fnPageChange: _fnPageChange,
    _fnFeatureHtmlProcessing: _fnFeatureHtmlProcessing,
    _fnProcessingDisplay: _fnProcessingDisplay,
    _fnFeatureHtmlTable: _fnFeatureHtmlTable,
    _fnScrollDraw: _fnScrollDraw,
    _fnApplyToChildren: _fnApplyToChildren,
    _fnCalculateColumnWidths: _fnCalculateColumnWidths,
    _fnThrottle: _fnThrottle,
    _fnConvertToWidth: _fnConvertToWidth,
    _fnGetWidestNode: _fnGetWidestNode,
    _fnGetMaxLenString: _fnGetMaxLenString,
    _fnStringToCss: _fnStringToCss,
    _fnSortFlatten: _fnSortFlatten,
    _fnSort: _fnSort,
    _fnSortAria: _fnSortAria,
    _fnSortListener: _fnSortListener,
    _fnSortAttachListener: _fnSortAttachListener,
    _fnSortingClasses: _fnSortingClasses,
    _fnSortData: _fnSortData,
    _fnSaveState: _fnSaveState,
    _fnLoadState: _fnLoadState,
    _fnSettingsFromNode: _fnSettingsFromNode,
    _fnLog: _fnLog,
    _fnMap: _fnMap,
    _fnBindAction: _fnBindAction,
    _fnCallbackReg: _fnCallbackReg,
    _fnCallbackFire: _fnCallbackFire,
    _fnLengthOverflow: _fnLengthOverflow,
    _fnRenderer: _fnRenderer,
    _fnDataSource: _fnDataSource,
    _fnRowAttributes: _fnRowAttributes,
    _fnCalculateEnd: function () {} // Used by a lot of plug-ins, but redundant
                                    // in 1.10, so this dead-end function is
                                    // added to prevent errors
  } );


  // jQuery access
  $.fn.dataTable = DataTable;

  // Provide access to the host jQuery object (circular reference)
  DataTable.$ = $;

  // Legacy aliases
  $.fn.dataTableSettings = DataTable.settings;
  $.fn.dataTableExt = DataTable.ext;

  // With a capital `D` we return a DataTables API instance rather than a
  // jQuery object
  $.fn.DataTable = function ( opts ) {
    return $(this).dataTable( opts ).api();
  };

  // All properties that are available to $.fn.dataTable should also be
  // available on $.fn.DataTable
  $.each( DataTable, function ( prop, val ) {
    $.fn.DataTable[ prop ] = val;
  } );


  // Information about events fired by DataTables - for documentation.
  /**
   * Draw event, fired whenever the table is redrawn on the page, at the same
   * point as fnDrawCallback. This may be useful for binding events or
   * performing calculations when the table is altered at all.
   *  @name DataTable#draw.dt
   *  @event
   *  @param {event} e jQuery event object
   *  @param {object} o DataTables settings object {@link DataTable.models.oSettings}
   */

  /**
   * Search event, fired when the searching applied to the table (using the
   * built-in global search, or column filters) is altered.
   *  @name DataTable#search.dt
   *  @event
   *  @param {event} e jQuery event object
   *  @param {object} o DataTables settings object {@link DataTable.models.oSettings}
   */

  /**
   * Page change event, fired when the paging of the table is altered.
   *  @name DataTable#page.dt
   *  @event
   *  @param {event} e jQuery event object
   *  @param {object} o DataTables settings object {@link DataTable.models.oSettings}
   */

  /**
   * Order event, fired when the ordering applied to the table is altered.
   *  @name DataTable#order.dt
   *  @event
   *  @param {event} e jQuery event object
   *  @param {object} o DataTables settings object {@link DataTable.models.oSettings}
   */

  /**
   * DataTables initialisation complete event, fired when the table is fully
   * drawn, including Ajax data loaded, if Ajax data is required.
   *  @name DataTable#init.dt
   *  @event
   *  @param {event} e jQuery event object
   *  @param {object} oSettings DataTables settings object
   *  @param {object} json The JSON object request from the server - only
   *    present if client-side Ajax sourced data is used</li></ol>
   */

  /**
   * State save event, fired when the table has changed state a new state save
   * is required. This event allows modification of the state saving object
   * prior to actually doing the save, including addition or other state
   * properties (for plug-ins) or modification of a DataTables core property.
   *  @name DataTable#stateSaveParams.dt
   *  @event
   *  @param {event} e jQuery event object
   *  @param {object} oSettings DataTables settings object
   *  @param {object} json The state information to be saved
   */

  /**
   * State load event, fired when the table is loading state from the stored
   * data, but prior to the settings object being modified by the saved state
   * - allowing modification of the saved state is required or loading of
   * state for a plug-in.
   *  @name DataTable#stateLoadParams.dt
   *  @event
   *  @param {event} e jQuery event object
   *  @param {object} oSettings DataTables settings object
   *  @param {object} json The saved state information
   */

  /**
   * State loaded event, fired when state has been loaded from stored data and
   * the settings object has been modified by the loaded data.
   *  @name DataTable#stateLoaded.dt
   *  @event
   *  @param {event} e jQuery event object
   *  @param {object} oSettings DataTables settings object
   *  @param {object} json The saved state information
   */

  /**
   * Processing event, fired when DataTables is doing some kind of processing
   * (be it, order, searcg or anything else). It can be used to indicate to
   * the end user that there is something happening, or that something has
   * finished.
   *  @name DataTable#processing.dt
   *  @event
   *  @param {event} e jQuery event object
   *  @param {object} oSettings DataTables settings object
   *  @param {boolean} bShow Flag for if DataTables is doing processing or not
   */

  /**
   * Ajax (XHR) event, fired whenever an Ajax request is completed from a
   * request to made to the server for new data. This event is called before
   * DataTables processed the returned data, so it can also be used to pre-
   * process the data returned from the server, if needed.
   *
   * Note that this trigger is called in `fnServerData`, if you override
   * `fnServerData` and which to use this event, you need to trigger it in you
   * success function.
   *  @name DataTable#xhr.dt
   *  @event
   *  @param {event} e jQuery event object
   *  @param {object} o DataTables settings object {@link DataTable.models.oSettings}
   *  @param {object} json JSON returned from the server
   *
   *  @example
   *     // Use a custom property returned from the server in another DOM element
   *     $('#table').dataTable().on('xhr.dt', function (e, settings, json) {
   *       $('#status').html( json.status );
   *     } );
   *
   *  @example
   *     // Pre-process the data returned from the server
   *     $('#table').dataTable().on('xhr.dt', function (e, settings, json) {
   *       for ( var i=0, ien=json.aaData.length ; i<ien ; i++ ) {
   *         json.aaData[i].sum = json.aaData[i].one + json.aaData[i].two;
   *       }
   *       // Note no return - manipulate the data directly in the JSON object.
   *     } );
   */

  /**
   * Destroy event, fired when the DataTable is destroyed by calling fnDestroy
   * or passing the bDestroy:true parameter in the initialisation object. This
   * can be used to remove bound events, added DOM nodes, etc.
   *  @name DataTable#destroy.dt
   *  @event
   *  @param {event} e jQuery event object
   *  @param {object} o DataTables settings object {@link DataTable.models.oSettings}
   */

  /**
   * Page length change event, fired when number of records to show on each
   * page (the length) is changed.
   *  @name DataTable#length.dt
   *  @event
   *  @param {event} e jQuery event object
   *  @param {object} o DataTables settings object {@link DataTable.models.oSettings}
   *  @param {integer} len New length
   */

  /**
   * Column sizing has changed.
   *  @name DataTable#column-sizing.dt
   *  @event
   *  @param {event} e jQuery event object
   *  @param {object} o DataTables settings object {@link DataTable.models.oSettings}
   */

  /**
   * Column visibility has changed.
   *  @name DataTable#column-visibility.dt
   *  @event
   *  @param {event} e jQuery event object
   *  @param {object} o DataTables settings object {@link DataTable.models.oSettings}
   *  @param {int} column Column index
   *  @param {bool} vis `false` if column now hidden, or `true` if visible
   */

  return $.fn.dataTable;
}));


/*! DataTables Bootstrap 3 integration
 * Â©2011-2015 SpryMedia Ltd - datatables.net/license
 */

/**
 * DataTables integration for Bootstrap 3. This requires Bootstrap 3 and
 * DataTables 1.10 or newer.
 *
 * This file sets the defaults and adds options to DataTables to style its
 * controls using Bootstrap. See http://datatables.net/manual/styling/bootstrap
 * for further information.
 */
(function( factory ){
  if ( typeof define === 'function' && define.amd ) {
    // AMD
    define( ['jquery', 'datatables.net'], function ( $ ) {
      return factory( $, window, document );
    } );
  }
  else if ( typeof exports === 'object' ) {
    // CommonJS
    module.exports = function (root, $) {
      if ( ! root ) {
        root = window;
      }

      if ( ! $ || ! $.fn.dataTable ) {
        // Require DataTables, which attaches to jQuery, including
        // jQuery if needed and have a $ property so we can access the
        // jQuery object that is used
        $ = require('datatables.net')(root, $).$;
      }

      return factory( $, root, root.document );
    };
  }
  else {
    // Browser
    factory( jQuery, window, document );
  }
}(function( $, window, document, undefined ) {
'use strict';
var DataTable = $.fn.dataTable;


/* Set the defaults for DataTables initialisation */
$.extend( true, DataTable.defaults, {
  dom:
    "<'row'<'col-sm-12 col-md-6'l><'col-sm-12 col-md-6'f>>" +
    "<'row'<'col-sm-12'tr>>" +
    "<'row'<'col-sm-12 col-md-5'i><'col-sm-12 col-md-7'p>>",
  renderer: 'bootstrap'
} );


/* Default class modification */
$.extend( DataTable.ext.classes, {
  sWrapper:      "dataTables_wrapper container-fluid dt-bootstrap4",
  sFilterInput:  "form-control form-control-sm",
  sLengthSelect: "form-control form-control-sm",
  sProcessing:   "dataTables_processing card",
  sPageButton:   "paginate_button page-item"
} );


/* Bootstrap paging button renderer */
DataTable.ext.renderer.pageButton.bootstrap = function ( settings, host, idx, buttons, page, pages ) {
  var api     = new DataTable.Api( settings );
  var classes = settings.oClasses;
  var lang    = settings.oLanguage.oPaginate;
  var aria = settings.oLanguage.oAria.paginate || {};
  var btnDisplay, btnClass, counter=0;

  var attach = function( container, buttons ) {
    var i, ien, node, button;
    var clickHandler = function ( e ) {
      e.preventDefault();
      if ( !$(e.currentTarget).hasClass('disabled') && api.page() != e.data.action ) {
        api.page( e.data.action ).draw( 'page' );
      }
    };

    for ( i=0, ien=buttons.length ; i<ien ; i++ ) {
      button = buttons[i];

      if ( $.isArray( button ) ) {
        attach( container, button );
      }
      else {
        btnDisplay = '';
        btnClass = '';

        switch ( button ) {
          case 'ellipsis':
            btnDisplay = '&#x2026;';
            btnClass = 'disabled';
            break;

          case 'first':
            btnDisplay = lang.sFirst;
            btnClass = button + (page > 0 ?
              '' : ' disabled');
            break;

          case 'previous':
            btnDisplay = lang.sPrevious;
            btnClass = button + (page > 0 ?
              '' : ' disabled');
            break;

          case 'next':
            btnDisplay = lang.sNext;
            btnClass = button + (page < pages-1 ?
              '' : ' disabled');
            break;

          case 'last':
            btnDisplay = lang.sLast;
            btnClass = button + (page < pages-1 ?
              '' : ' disabled');
            break;

          default:
            btnDisplay = button + 1;
            btnClass = page === button ?
              'active' : '';
            break;
        }

        if ( btnDisplay ) {
          node = $('<li>', {
              'class': classes.sPageButton+' '+btnClass,
              'id': idx === 0 && typeof button === 'string' ?
                settings.sTableId +'_'+ button :
                null
            } )
            .append( $('<a>', {
                'href': '#',
                'aria-controls': settings.sTableId,
                'aria-label': aria[ button ],
                'data-dt-idx': counter,
                'tabindex': settings.iTabIndex,
                'class': 'page-link'
              } )
              .html( btnDisplay )
            )
            .appendTo( container );

          settings.oApi._fnBindAction(
            node, {action: button}, clickHandler
          );

          counter++;
        }
      }
    }
  };

  // IE9 throws an 'unknown error' if document.activeElement is used
  // inside an iframe or frame.
  var activeEl;

  try {
    // Because this approach is destroying and recreating the paging
    // elements, focus is lost on the select button which is bad for
    // accessibility. So we want to restore focus once the draw has
    // completed
    activeEl = $(host).find(document.activeElement).data('dt-idx');
  }
  catch (e) {}

  attach(
    $(host).empty().html('<ul class="pagination"/>').children('ul'),
    buttons
  );

  if ( activeEl !== undefined ) {
    $(host).find( '[data-dt-idx='+activeEl+']' ).focus();
  }
};


return DataTable;
}));



/*
 * jQuery Highlight plugin
 *
 * Based on highlight v3 by Johann Burkard
 * http://johannburkard.de/blog/programming/javascript/highlight-javascript-text-higlighting-jquery-plugin.html
 *
 * Code a little bit refactored and cleaned (in my humble opinion).
 * Most important changes:
 *  - has an option to highlight only entire words (wordsOnly - false by default),
 *  - has an option to be case sensitive (caseSensitive - false by default)
 *  - highlight element tag and class names can be specified in options
 *
 * Usage:
 *   // wrap every occurrance of text 'lorem' in content
 *   // with <span class='highlight'> (default options)
 *   $('#content').highlight('lorem');
 *
 *   // search for and highlight more terms at once
 *   // so you can save some time on traversing DOM
 *   $('#content').highlight(['lorem', 'ipsum']);
 *   $('#content').highlight('lorem ipsum');
 *
 *   // search only for entire word 'lorem'
 *   $('#content').highlight('lorem', { wordsOnly: true });
 *
 *   // don't ignore case during search of term 'lorem'
 *   $('#content').highlight('lorem', { caseSensitive: true });
 *
 *   // wrap every occurrance of term 'ipsum' in content
 *   // with <em class='important'>
 *   $('#content').highlight('ipsum', { element: 'em', className: 'important' });
 *
 *   // remove default highlight
 *   $('#content').unhighlight();
 *
 *   // remove custom highlight
 *   $('#content').unhighlight({ element: 'em', className: 'important' });
 *
 *
 * Copyright (c) 2009 Bartek Szopka
 *
 * Licensed under MIT license.
 *
 */

jQuery.extend({
    highlight: function (node, re, nodeName, className) {
        if (node.nodeType === 3) {
            var match = node.data.match(re);
            if (match) {
                var highlight = document.createElement(nodeName || 'span');
                highlight.className = className || 'highlight';
                var wordNode = node.splitText(match.index);
                wordNode.splitText(match[0].length);
                var wordClone = wordNode.cloneNode(true);
                highlight.appendChild(wordClone);
                wordNode.parentNode.replaceChild(highlight, wordNode);
                return 1; //skip added node in parent
            }
        } else if ((node.nodeType === 1 && node.childNodes) && // only element nodes that have children
                !/(script|style)/i.test(node.tagName) && // ignore script and style nodes
                !(node.tagName === nodeName.toUpperCase() && node.className === className)) { // skip if already highlighted
            for (var i = 0; i < node.childNodes.length; i++) {
                i += jQuery.highlight(node.childNodes[i], re, nodeName, className);
            }
        }
        return 0;
    }
});

jQuery.fn.unhighlight = function (options) {
    var settings = { className: 'highlight', element: 'span' };
    jQuery.extend(settings, options);

    return this.find(settings.element + "." + settings.className).each(function () {
        var parent = this.parentNode;
        parent.replaceChild(this.firstChild, this);
        parent.normalize();
    }).end();
};

jQuery.fn.highlight = function (words, options) {
    var settings = { className: 'highlight', element: 'span', caseSensitive: false, wordsOnly: false };
    jQuery.extend(settings, options);

    if (words.constructor === String) {
        words = [words];
    }
    words = jQuery.grep(words, function(word, i){
      return word != '';
    });
    words = jQuery.map(words, function(word, i) {
      return word.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
    });
    if (words.length == 0) { return this; };

    var flag = settings.caseSensitive ? "" : "i";
    var pattern = "(" + words.join("|") + ")";
    if (settings.wordsOnly) {
        pattern = "\\b" + pattern + "\\b";
    }
    var re = new RegExp(pattern, flag);

    return this.each(function () {
        jQuery.highlight(this, re, settings.element, settings.className);
    });
};
/*
 * jQuery.liveFilter
 *
 * Copyright (c) 2009 Mike Merritt
 *
 * Forked by Lim Chee Aun (cheeaun.com)
 *
 */

(function($){
  $.fn.liveFilter = function(inputEl, filterEl, options){
    var defaults = {
      filterChildSelector: null,
      filter: function(el, val){
        return $(el).text().toUpperCase().indexOf(val.toUpperCase()) >= 0;
      },
      before: function(){},
      after: function(){}
    };
    var options = $.extend(defaults, options);

    var el = $(this).find(filterEl);
    if (options.filterChildSelector) el = el.find(options.filterChildSelector);

    var filter = options.filter;
    $(inputEl).keyup(function(){
      var val = $(this).val();
      var contains = el.filter(function(){
        return filter(this, val);
      });
      var containsNot = el.not(contains);
      if (options.filterChildSelector){
        contains = contains.parents(filterEl);
        containsNot = containsNot.parents(filterEl).hide();
      }

      options.before.call(this, contains, containsNot);

      contains.show();
      containsNot.hide();

      if (val === '') {
        contains.show();
        containsNot.show();
      }

      options.after.call(this, contains, containsNot);
    });
  }
})(jQuery);

/**
* jquery-match-height 0.7.2 by @liabru
* http://brm.io/jquery-match-height/
* License: MIT
*/

(function(factory) { // eslint-disable-line no-extra-semi
    'use strict';
    if (typeof define === 'function' && define.amd) {
        // AMD
        define(['jquery'], factory);
    } else if (typeof module !== 'undefined' && module.exports) {
        // CommonJS
        module.exports = factory(require('jquery'));
    } else {
        // Global
        factory(jQuery);
    }
})(function($) {
    /*
    *  internal
    */

    var _previousResizeWidth = -1,
        _updateTimeout = -1;

    /*
    *  _parse
    *  value parse utility function
    */

    var _parse = function(value) {
        // parse value and convert NaN to 0
        return parseFloat(value) || 0;
    };

    /*
    *  _rows
    *  utility function returns array of jQuery selections representing each row
    *  (as displayed after float wrapping applied by browser)
    */

    var _rows = function(elements) {
        var tolerance = 1,
            $elements = $(elements),
            lastTop = null,
            rows = [];

        // group elements by their top position
        $elements.each(function(){
            var $that = $(this),
                top = $that.offset().top - _parse($that.css('margin-top')),
                lastRow = rows.length > 0 ? rows[rows.length - 1] : null;

            if (lastRow === null) {
                // first item on the row, so just push it
                rows.push($that);
            } else {
                // if the row top is the same, add to the row group
                if (Math.floor(Math.abs(lastTop - top)) <= tolerance) {
                    rows[rows.length - 1] = lastRow.add($that);
                } else {
                    // otherwise start a new row group
                    rows.push($that);
                }
            }

            // keep track of the last row top
            lastTop = top;
        });

        return rows;
    };

    /*
    *  _parseOptions
    *  handle plugin options
    */

    var _parseOptions = function(options) {
        var opts = {
            byRow: true,
            property: 'height',
            target: null,
            remove: false
        };

        if (typeof options === 'object') {
            return $.extend(opts, options);
        }

        if (typeof options === 'boolean') {
            opts.byRow = options;
        } else if (options === 'remove') {
            opts.remove = true;
        }

        return opts;
    };

    /*
    *  matchHeight
    *  plugin definition
    */

    var matchHeight = $.fn.matchHeight = function(options) {
        var opts = _parseOptions(options);

        // handle remove
        if (opts.remove) {
            var that = this;

            // remove fixed height from all selected elements
            this.css(opts.property, '');

            // remove selected elements from all groups
            $.each(matchHeight._groups, function(key, group) {
                group.elements = group.elements.not(that);
            });

            // TODO: cleanup empty groups

            return this;
        }

        if (this.length <= 1 && !opts.target) {
            return this;
        }

        // keep track of this group so we can re-apply later on load and resize events
        matchHeight._groups.push({
            elements: this,
            options: opts
        });

        // match each element's height to the tallest element in the selection
        matchHeight._apply(this, opts);

        return this;
    };

    /*
    *  plugin global options
    */

    matchHeight.version = '0.7.2';
    matchHeight._groups = [];
    matchHeight._throttle = 80;
    matchHeight._maintainScroll = false;
    matchHeight._beforeUpdate = null;
    matchHeight._afterUpdate = null;
    matchHeight._rows = _rows;
    matchHeight._parse = _parse;
    matchHeight._parseOptions = _parseOptions;

    /*
    *  matchHeight._apply
    *  apply matchHeight to given elements
    */

    matchHeight._apply = function(elements, options) {
        var opts = _parseOptions(options),
            $elements = $(elements),
            rows = [$elements];

        // take note of scroll position
        var scrollTop = $(window).scrollTop(),
            htmlHeight = $('html').outerHeight(true);

        // get hidden parents
        var $hiddenParents = $elements.parents().filter(':hidden');

        // cache the original inline style
        $hiddenParents.each(function() {
            var $that = $(this);
            $that.data('style-cache', $that.attr('style'));
        });

        // temporarily must force hidden parents visible
        $hiddenParents.css('display', 'block');

        // get rows if using byRow, otherwise assume one row
        if (opts.byRow && !opts.target) {

            // must first force an arbitrary equal height so floating elements break evenly
            $elements.each(function() {
                var $that = $(this),
                    display = $that.css('display');

                // temporarily force a usable display value
                if (display !== 'inline-block' && display !== 'flex' && display !== 'inline-flex') {
                    display = 'block';
                }

                // cache the original inline style
                $that.data('style-cache', $that.attr('style'));

                $that.css({
                    'display': display,
                    'padding-top': '0',
                    'padding-bottom': '0',
                    'margin-top': '0',
                    'margin-bottom': '0',
                    'border-top-width': '0',
                    'border-bottom-width': '0',
                    'height': '100px',
                    'overflow': 'hidden'
                });
            });

            // get the array of rows (based on element top position)
            rows = _rows($elements);

            // revert original inline styles
            $elements.each(function() {
                var $that = $(this);
                $that.attr('style', $that.data('style-cache') || '');
            });
        }

        $.each(rows, function(key, row) {
            var $row = $(row),
                targetHeight = 0;

            if (!opts.target) {
                // skip apply to rows with only one item
                if (opts.byRow && $row.length <= 1) {
                    $row.css(opts.property, '');
                    return;
                }

                // iterate the row and find the max height
                $row.each(function(){
                    var $that = $(this),
                        style = $that.attr('style'),
                        display = $that.css('display');

                    // temporarily force a usable display value
                    if (display !== 'inline-block' && display !== 'flex' && display !== 'inline-flex') {
                        display = 'block';
                    }

                    // ensure we get the correct actual height (and not a previously set height value)
                    var css = { 'display': display };
                    css[opts.property] = '';
                    $that.css(css);

                    // find the max height (including padding, but not margin)
                    if ($that.outerHeight(false) > targetHeight) {
                        targetHeight = $that.outerHeight(false);
                    }

                    // revert styles
                    if (style) {
                        $that.attr('style', style);
                    } else {
                        $that.css('display', '');
                    }
                });
            } else {
                // if target set, use the height of the target element
                targetHeight = opts.target.outerHeight(false);
            }

            // iterate the row and apply the height to all elements
            $row.each(function(){
                var $that = $(this),
                    verticalPadding = 0;

                // don't apply to a target
                if (opts.target && $that.is(opts.target)) {
                    return;
                }

                // handle padding and border correctly (required when not using border-box)
                if ($that.css('box-sizing') !== 'border-box') {
                    verticalPadding += _parse($that.css('border-top-width')) + _parse($that.css('border-bottom-width'));
                    verticalPadding += _parse($that.css('padding-top')) + _parse($that.css('padding-bottom'));
                }

                // set the height (accounting for padding and border)
                $that.css(opts.property, (targetHeight - verticalPadding) + 'px');
            });
        });

        // revert hidden parents
        $hiddenParents.each(function() {
            var $that = $(this);
            $that.attr('style', $that.data('style-cache') || null);
        });

        // restore scroll position if enabled
        if (matchHeight._maintainScroll) {
            $(window).scrollTop((scrollTop / htmlHeight) * $('html').outerHeight(true));
        }

        return this;
    };

    /*
    *  matchHeight._applyDataApi
    *  applies matchHeight to all elements with a data-match-height attribute
    */

    matchHeight._applyDataApi = function() {
        var groups = {};

        // generate groups by their groupId set by elements using data-match-height
        $('[data-match-height], [data-mh]').each(function() {
            var $this = $(this),
                groupId = $this.attr('data-mh') || $this.attr('data-match-height');

            if (groupId in groups) {
                groups[groupId] = groups[groupId].add($this);
            } else {
                groups[groupId] = $this;
            }
        });

        // apply matchHeight to each group
        $.each(groups, function() {
            this.matchHeight(true);
        });
    };

    /*
    *  matchHeight._update
    *  updates matchHeight on all current groups with their correct options
    */

    var _update = function(event) {
        if (matchHeight._beforeUpdate) {
            matchHeight._beforeUpdate(event, matchHeight._groups);
        }

        $.each(matchHeight._groups, function() {
            matchHeight._apply(this.elements, this.options);
        });

        if (matchHeight._afterUpdate) {
            matchHeight._afterUpdate(event, matchHeight._groups);
        }
    };

    matchHeight._update = function(throttle, event) {
        // prevent update if fired from a resize event
        // where the viewport width hasn't actually changed
        // fixes an event looping bug in IE8
        if (event && event.type === 'resize') {
            var windowWidth = $(window).width();
            if (windowWidth === _previousResizeWidth) {
                return;
            }
            _previousResizeWidth = windowWidth;
        }

        // throttle updates
        if (!throttle) {
            _update(event);
        } else if (_updateTimeout === -1) {
            _updateTimeout = setTimeout(function() {
                _update(event);
                _updateTimeout = -1;
            }, matchHeight._throttle);
        }
    };

    /*
    *  bind events
    */

    // apply on DOM ready event
    $(matchHeight._applyDataApi);

    // use on or bind where supported
    var on = $.fn.on ? 'on' : 'bind';

    // update heights on load and resize events
    $(window)[on]('load', function(event) {
        matchHeight._update(false, event);
    });

    // throttled update heights on resize events
    $(window)[on]('resize orientationchange', function(event) {
        matchHeight._update(true, event);
    });

});

/*
     _ _      _       _
 ___| (_) ___| | __  (_)___
/ __| | |/ __| |/ /  | / __|
\__ \ | | (__|   < _ | \__ \
|___/_|_|\___|_|\_(_)/ |___/
                   |__/

 Version: 1.8.1
  Author: Ken Wheeler
 Website: http://kenwheeler.github.io
    Docs: http://kenwheeler.github.io/slick
    Repo: http://github.com/kenwheeler/slick
  Issues: http://github.com/kenwheeler/slick/issues

 */
/* global window, document, define, jQuery, setInterval, clearInterval */
(function(factory) {
    'use strict';
    if (typeof define === 'function' && define.amd) {
        define(['jquery'], factory);
    } else if (typeof exports !== 'undefined') {
        module.exports = factory(require('jquery'));
    } else {
        factory(jQuery);
    }

}(function($) {
    'use strict';
    var Slick = window.Slick || {};

    Slick = (function() {

        var instanceUid = 0;

        function Slick(element, settings) {

            var _ = this, dataSettings;

            _.defaults = {
                accessibility: true,
                adaptiveHeight: false,
                appendArrows: $(element),
                appendDots: $(element),
                arrows: true,
                asNavFor: null,
                prevArrow: '<button class="slick-prev" aria-label="Previous" type="button">Previous</button>',
                nextArrow: '<button class="slick-next" aria-label="Next" type="button">Next</button>',
                autoplay: false,
                autoplaySpeed: 3000,
                centerMode: false,
                centerPadding: '50px',
                cssEase: 'ease',
                customPaging: function(slider, i) {
                    return $('<button type="button" />').text(i + 1);
                },
                dots: false,
                dotsClass: 'slick-dots',
                draggable: true,
                easing: 'linear',
                edgeFriction: 0.35,
                fade: false,
                focusOnSelect: false,
                focusOnChange: false,
                infinite: true,
                initialSlide: 0,
                lazyLoad: 'ondemand',
                mobileFirst: false,
                pauseOnHover: true,
                pauseOnFocus: true,
                pauseOnDotsHover: false,
                respondTo: 'window',
                responsive: null,
                rows: 1,
                rtl: false,
                slide: '',
                slidesPerRow: 1,
                slidesToShow: 1,
                slidesToScroll: 1,
                speed: 500,
                swipe: true,
                swipeToSlide: false,
                touchMove: true,
                touchThreshold: 5,
                useCSS: true,
                useTransform: true,
                variableWidth: false,
                vertical: false,
                verticalSwiping: false,
                waitForAnimate: true,
                zIndex: 1000
            };

            _.initials = {
                animating: false,
                dragging: false,
                autoPlayTimer: null,
                currentDirection: 0,
                currentLeft: null,
                currentSlide: 0,
                direction: 1,
                $dots: null,
                listWidth: null,
                listHeight: null,
                loadIndex: 0,
                $nextArrow: null,
                $prevArrow: null,
                scrolling: false,
                slideCount: null,
                slideWidth: null,
                $slideTrack: null,
                $slides: null,
                sliding: false,
                slideOffset: 0,
                swipeLeft: null,
                swiping: false,
                $list: null,
                touchObject: {},
                transformsEnabled: false,
                unslicked: false
            };

            $.extend(_, _.initials);

            _.activeBreakpoint = null;
            _.animType = null;
            _.animProp = null;
            _.breakpoints = [];
            _.breakpointSettings = [];
            _.cssTransitions = false;
            _.focussed = false;
            _.interrupted = false;
            _.hidden = 'hidden';
            _.paused = true;
            _.positionProp = null;
            _.respondTo = null;
            _.rowCount = 1;
            _.shouldClick = true;
            _.$slider = $(element);
            _.$slidesCache = null;
            _.transformType = null;
            _.transitionType = null;
            _.visibilityChange = 'visibilitychange';
            _.windowWidth = 0;
            _.windowTimer = null;

            dataSettings = $(element).data('slick') || {};

            _.options = $.extend({}, _.defaults, settings, dataSettings);

            _.currentSlide = _.options.initialSlide;

            _.originalSettings = _.options;

            if (typeof document.mozHidden !== 'undefined') {
                _.hidden = 'mozHidden';
                _.visibilityChange = 'mozvisibilitychange';
            } else if (typeof document.webkitHidden !== 'undefined') {
                _.hidden = 'webkitHidden';
                _.visibilityChange = 'webkitvisibilitychange';
            }

            _.autoPlay = $.proxy(_.autoPlay, _);
            _.autoPlayClear = $.proxy(_.autoPlayClear, _);
            _.autoPlayIterator = $.proxy(_.autoPlayIterator, _);
            _.changeSlide = $.proxy(_.changeSlide, _);
            _.clickHandler = $.proxy(_.clickHandler, _);
            _.selectHandler = $.proxy(_.selectHandler, _);
            _.setPosition = $.proxy(_.setPosition, _);
            _.swipeHandler = $.proxy(_.swipeHandler, _);
            _.dragHandler = $.proxy(_.dragHandler, _);
            _.keyHandler = $.proxy(_.keyHandler, _);

            _.instanceUid = instanceUid++;

            // A simple way to check for HTML strings
            // Strict HTML recognition (must start with <)
            // Extracted from jQuery v1.11 source
            _.htmlExpr = /^(?:\s*(<[\w\W]+>)[^>]*)$/;


            _.registerBreakpoints();
            _.init(true);

        }

        return Slick;

    }());

    Slick.prototype.activateADA = function() {
        var _ = this;

        _.$slideTrack.find('.slick-active').attr({
            'aria-hidden': 'false'
        }).find('a, input, button, select').attr({
            'tabindex': '0'
        });

    };

    Slick.prototype.addSlide = Slick.prototype.slickAdd = function(markup, index, addBefore) {

        var _ = this;

        if (typeof(index) === 'boolean') {
            addBefore = index;
            index = null;
        } else if (index < 0 || (index >= _.slideCount)) {
            return false;
        }

        _.unload();

        if (typeof(index) === 'number') {
            if (index === 0 && _.$slides.length === 0) {
                $(markup).appendTo(_.$slideTrack);
            } else if (addBefore) {
                $(markup).insertBefore(_.$slides.eq(index));
            } else {
                $(markup).insertAfter(_.$slides.eq(index));
            }
        } else {
            if (addBefore === true) {
                $(markup).prependTo(_.$slideTrack);
            } else {
                $(markup).appendTo(_.$slideTrack);
            }
        }

        _.$slides = _.$slideTrack.children(this.options.slide);

        _.$slideTrack.children(this.options.slide).detach();

        _.$slideTrack.append(_.$slides);

        _.$slides.each(function(index, element) {
            $(element).attr('data-slick-index', index);
        });

        _.$slidesCache = _.$slides;

        _.reinit();

    };

    Slick.prototype.animateHeight = function() {
        var _ = this;
        if (_.options.slidesToShow === 1 && _.options.adaptiveHeight === true && _.options.vertical === false) {
            var targetHeight = _.$slides.eq(_.currentSlide).outerHeight(true);
            _.$list.animate({
                height: targetHeight
            }, _.options.speed);
        }
    };

    Slick.prototype.animateSlide = function(targetLeft, callback) {

        var animProps = {},
            _ = this;

        _.animateHeight();

        if (_.options.rtl === true && _.options.vertical === false) {
            targetLeft = -targetLeft;
        }
        if (_.transformsEnabled === false) {
            if (_.options.vertical === false) {
                _.$slideTrack.animate({
                    left: targetLeft
                }, _.options.speed, _.options.easing, callback);
            } else {
                _.$slideTrack.animate({
                    top: targetLeft
                }, _.options.speed, _.options.easing, callback);
            }

        } else {

            if (_.cssTransitions === false) {
                if (_.options.rtl === true) {
                    _.currentLeft = -(_.currentLeft);
                }
                $({
                    animStart: _.currentLeft
                }).animate({
                    animStart: targetLeft
                }, {
                    duration: _.options.speed,
                    easing: _.options.easing,
                    step: function(now) {
                        now = Math.ceil(now);
                        if (_.options.vertical === false) {
                            animProps[_.animType] = 'translate(' +
                                now + 'px, 0px)';
                            _.$slideTrack.css(animProps);
                        } else {
                            animProps[_.animType] = 'translate(0px,' +
                                now + 'px)';
                            _.$slideTrack.css(animProps);
                        }
                    },
                    complete: function() {
                        if (callback) {
                            callback.call();
                        }
                    }
                });

            } else {

                _.applyTransition();
                targetLeft = Math.ceil(targetLeft);

                if (_.options.vertical === false) {
                    animProps[_.animType] = 'translate3d(' + targetLeft + 'px, 0px, 0px)';
                } else {
                    animProps[_.animType] = 'translate3d(0px,' + targetLeft + 'px, 0px)';
                }
                _.$slideTrack.css(animProps);

                if (callback) {
                    setTimeout(function() {

                        _.disableTransition();

                        callback.call();
                    }, _.options.speed);
                }

            }

        }

    };

    Slick.prototype.getNavTarget = function() {

        var _ = this,
            asNavFor = _.options.asNavFor;

        if ( asNavFor && asNavFor !== null ) {
            asNavFor = $(asNavFor).not(_.$slider);
        }

        return asNavFor;

    };

    Slick.prototype.asNavFor = function(index) {

        var _ = this,
            asNavFor = _.getNavTarget();

        if ( asNavFor !== null && typeof asNavFor === 'object' ) {
            asNavFor.each(function() {
                var target = $(this).slick('getSlick');
                if(!target.unslicked) {
                    target.slideHandler(index, true);
                }
            });
        }

    };

    Slick.prototype.applyTransition = function(slide) {

        var _ = this,
            transition = {};

        if (_.options.fade === false) {
            transition[_.transitionType] = _.transformType + ' ' + _.options.speed + 'ms ' + _.options.cssEase;
        } else {
            transition[_.transitionType] = 'opacity ' + _.options.speed + 'ms ' + _.options.cssEase;
        }

        if (_.options.fade === false) {
            _.$slideTrack.css(transition);
        } else {
            _.$slides.eq(slide).css(transition);
        }

    };

    Slick.prototype.autoPlay = function() {

        var _ = this;

        _.autoPlayClear();

        if ( _.slideCount > _.options.slidesToShow ) {
            _.autoPlayTimer = setInterval( _.autoPlayIterator, _.options.autoplaySpeed );
        }

    };

    Slick.prototype.autoPlayClear = function() {

        var _ = this;

        if (_.autoPlayTimer) {
            clearInterval(_.autoPlayTimer);
        }

    };

    Slick.prototype.autoPlayIterator = function() {

        var _ = this,
            slideTo = _.currentSlide + _.options.slidesToScroll;

        if ( !_.paused && !_.interrupted && !_.focussed ) {

            if ( _.options.infinite === false ) {

                if ( _.direction === 1 && ( _.currentSlide + 1 ) === ( _.slideCount - 1 )) {
                    _.direction = 0;
                }

                else if ( _.direction === 0 ) {

                    slideTo = _.currentSlide - _.options.slidesToScroll;

                    if ( _.currentSlide - 1 === 0 ) {
                        _.direction = 1;
                    }

                }

            }

            _.slideHandler( slideTo );

        }

    };

    Slick.prototype.buildArrows = function() {

        var _ = this;

        if (_.options.arrows === true ) {

            _.$prevArrow = $(_.options.prevArrow).addClass('slick-arrow');
            _.$nextArrow = $(_.options.nextArrow).addClass('slick-arrow');

            if( _.slideCount > _.options.slidesToShow ) {

                _.$prevArrow.removeClass('slick-hidden').removeAttr('aria-hidden tabindex');
                _.$nextArrow.removeClass('slick-hidden').removeAttr('aria-hidden tabindex');

                if (_.htmlExpr.test(_.options.prevArrow)) {
                    _.$prevArrow.prependTo(_.options.appendArrows);
                }

                if (_.htmlExpr.test(_.options.nextArrow)) {
                    _.$nextArrow.appendTo(_.options.appendArrows);
                }

                if (_.options.infinite !== true) {
                    _.$prevArrow
                        .addClass('slick-disabled')
                        .attr('aria-disabled', 'true');
                }

            } else {

                _.$prevArrow.add( _.$nextArrow )

                    .addClass('slick-hidden')
                    .attr({
                        'aria-disabled': 'true',
                        'tabindex': '-1'
                    });

            }

        }

    };

    Slick.prototype.buildDots = function() {

        var _ = this,
            i, dot;

        if (_.options.dots === true && _.slideCount > _.options.slidesToShow) {

            _.$slider.addClass('slick-dotted');

            dot = $('<ul />').addClass(_.options.dotsClass);

            for (i = 0; i <= _.getDotCount(); i += 1) {
                dot.append($('<li />').append(_.options.customPaging.call(this, _, i)));
            }

            _.$dots = dot.appendTo(_.options.appendDots);

            _.$dots.find('li').first().addClass('slick-active');

        }

    };

    Slick.prototype.buildOut = function() {

        var _ = this;

        _.$slides =
            _.$slider
                .children( _.options.slide + ':not(.slick-cloned)')
                .addClass('slick-slide');

        _.slideCount = _.$slides.length;

        _.$slides.each(function(index, element) {
            $(element)
                .attr('data-slick-index', index)
                .data('originalStyling', $(element).attr('style') || '');
        });

        _.$slider.addClass('slick-slider');

        _.$slideTrack = (_.slideCount === 0) ?
            $('<div class="slick-track"/>').appendTo(_.$slider) :
            _.$slides.wrapAll('<div class="slick-track"/>').parent();

        _.$list = _.$slideTrack.wrap(
            '<div class="slick-list"/>').parent();
        _.$slideTrack.css('opacity', 0);

        if (_.options.centerMode === true || _.options.swipeToSlide === true) {
            _.options.slidesToScroll = 1;
        }

        $('img[data-lazy]', _.$slider).not('[src]').addClass('slick-loading');

        _.setupInfinite();

        _.buildArrows();

        _.buildDots();

        _.updateDots();


        _.setSlideClasses(typeof _.currentSlide === 'number' ? _.currentSlide : 0);

        if (_.options.draggable === true) {
            _.$list.addClass('draggable');
        }

    };

    Slick.prototype.buildRows = function() {

        var _ = this, a, b, c, newSlides, numOfSlides, originalSlides,slidesPerSection;

        newSlides = document.createDocumentFragment();
        originalSlides = _.$slider.children();

        if(_.options.rows > 0) {

            slidesPerSection = _.options.slidesPerRow * _.options.rows;
            numOfSlides = Math.ceil(
                originalSlides.length / slidesPerSection
            );

            for(a = 0; a < numOfSlides; a++){
                var slide = document.createElement('div');
                for(b = 0; b < _.options.rows; b++) {
                    var row = document.createElement('div');
                    for(c = 0; c < _.options.slidesPerRow; c++) {
                        var target = (a * slidesPerSection + ((b * _.options.slidesPerRow) + c));
                        if (originalSlides.get(target)) {
                            row.appendChild(originalSlides.get(target));
                        }
                    }
                    slide.appendChild(row);
                }
                newSlides.appendChild(slide);
            }

            _.$slider.empty().append(newSlides);
            _.$slider.children().children().children()
                .css({
                    'width':(100 / _.options.slidesPerRow) + '%',
                    'display': 'inline-block'
                });

        }

    };

    Slick.prototype.checkResponsive = function(initial, forceUpdate) {

        var _ = this,
            breakpoint, targetBreakpoint, respondToWidth, triggerBreakpoint = false;
        var sliderWidth = _.$slider.width();
        var windowWidth = window.innerWidth || $(window).width();

        if (_.respondTo === 'window') {
            respondToWidth = windowWidth;
        } else if (_.respondTo === 'slider') {
            respondToWidth = sliderWidth;
        } else if (_.respondTo === 'min') {
            respondToWidth = Math.min(windowWidth, sliderWidth);
        }

        if ( _.options.responsive &&
            _.options.responsive.length &&
            _.options.responsive !== null) {

            targetBreakpoint = null;

            for (breakpoint in _.breakpoints) {
                if (_.breakpoints.hasOwnProperty(breakpoint)) {
                    if (_.originalSettings.mobileFirst === false) {
                        if (respondToWidth < _.breakpoints[breakpoint]) {
                            targetBreakpoint = _.breakpoints[breakpoint];
                        }
                    } else {
                        if (respondToWidth > _.breakpoints[breakpoint]) {
                            targetBreakpoint = _.breakpoints[breakpoint];
                        }
                    }
                }
            }

            if (targetBreakpoint !== null) {
                if (_.activeBreakpoint !== null) {
                    if (targetBreakpoint !== _.activeBreakpoint || forceUpdate) {
                        _.activeBreakpoint =
                            targetBreakpoint;
                        if (_.breakpointSettings[targetBreakpoint] === 'unslick') {
                            _.unslick(targetBreakpoint);
                        } else {
                            _.options = $.extend({}, _.originalSettings,
                                _.breakpointSettings[
                                    targetBreakpoint]);
                            if (initial === true) {
                                _.currentSlide = _.options.initialSlide;
                            }
                            _.refresh(initial);
                        }
                        triggerBreakpoint = targetBreakpoint;
                    }
                } else {
                    _.activeBreakpoint = targetBreakpoint;
                    if (_.breakpointSettings[targetBreakpoint] === 'unslick') {
                        _.unslick(targetBreakpoint);
                    } else {
                        _.options = $.extend({}, _.originalSettings,
                            _.breakpointSettings[
                                targetBreakpoint]);
                        if (initial === true) {
                            _.currentSlide = _.options.initialSlide;
                        }
                        _.refresh(initial);
                    }
                    triggerBreakpoint = targetBreakpoint;
                }
            } else {
                if (_.activeBreakpoint !== null) {
                    _.activeBreakpoint = null;
                    _.options = _.originalSettings;
                    if (initial === true) {
                        _.currentSlide = _.options.initialSlide;
                    }
                    _.refresh(initial);
                    triggerBreakpoint = targetBreakpoint;
                }
            }

            // only trigger breakpoints during an actual break. not on initialize.
            if( !initial && triggerBreakpoint !== false ) {
                _.$slider.trigger('breakpoint', [_, triggerBreakpoint]);
            }
        }

    };

    Slick.prototype.changeSlide = function(event, dontAnimate) {

        var _ = this,
            $target = $(event.currentTarget),
            indexOffset, slideOffset, unevenOffset;

        // If target is a link, prevent default action.
        if($target.is('a')) {
            event.preventDefault();
        }

        // If target is not the <li> element (ie: a child), find the <li>.
        if(!$target.is('li')) {
            $target = $target.closest('li');
        }

        unevenOffset = (_.slideCount % _.options.slidesToScroll !== 0);
        indexOffset = unevenOffset ? 0 : (_.slideCount - _.currentSlide) % _.options.slidesToScroll;

        switch (event.data.message) {

            case 'previous':
                slideOffset = indexOffset === 0 ? _.options.slidesToScroll : _.options.slidesToShow - indexOffset;
                if (_.slideCount > _.options.slidesToShow) {
                    _.slideHandler(_.currentSlide - slideOffset, false, dontAnimate);
                }
                break;

            case 'next':
                slideOffset = indexOffset === 0 ? _.options.slidesToScroll : indexOffset;
                if (_.slideCount > _.options.slidesToShow) {
                    _.slideHandler(_.currentSlide + slideOffset, false, dontAnimate);
                }
                break;

            case 'index':
                var index = event.data.index === 0 ? 0 :
                    event.data.index || $target.index() * _.options.slidesToScroll;

                _.slideHandler(_.checkNavigable(index), false, dontAnimate);
                $target.children().trigger('focus');
                break;

            default:
                return;
        }

    };

    Slick.prototype.checkNavigable = function(index) {

        var _ = this,
            navigables, prevNavigable;

        navigables = _.getNavigableIndexes();
        prevNavigable = 0;
        if (index > navigables[navigables.length - 1]) {
            index = navigables[navigables.length - 1];
        } else {
            for (var n in navigables) {
                if (index < navigables[n]) {
                    index = prevNavigable;
                    break;
                }
                prevNavigable = navigables[n];
            }
        }

        return index;
    };

    Slick.prototype.cleanUpEvents = function() {

        var _ = this;

        if (_.options.dots && _.$dots !== null) {

            $('li', _.$dots)
                .off('click.slick', _.changeSlide)
                .off('mouseenter.slick', $.proxy(_.interrupt, _, true))
                .off('mouseleave.slick', $.proxy(_.interrupt, _, false));

            if (_.options.accessibility === true) {
                _.$dots.off('keydown.slick', _.keyHandler);
            }
        }

        _.$slider.off('focus.slick blur.slick');

        if (_.options.arrows === true && _.slideCount > _.options.slidesToShow) {
            _.$prevArrow && _.$prevArrow.off('click.slick', _.changeSlide);
            _.$nextArrow && _.$nextArrow.off('click.slick', _.changeSlide);

            if (_.options.accessibility === true) {
                _.$prevArrow && _.$prevArrow.off('keydown.slick', _.keyHandler);
                _.$nextArrow && _.$nextArrow.off('keydown.slick', _.keyHandler);
            }
        }

        _.$list.off('touchstart.slick mousedown.slick', _.swipeHandler);
        _.$list.off('touchmove.slick mousemove.slick', _.swipeHandler);
        _.$list.off('touchend.slick mouseup.slick', _.swipeHandler);
        _.$list.off('touchcancel.slick mouseleave.slick', _.swipeHandler);

        _.$list.off('click.slick', _.clickHandler);

        $(document).off(_.visibilityChange, _.visibility);

        _.cleanUpSlideEvents();

        if (_.options.accessibility === true) {
            _.$list.off('keydown.slick', _.keyHandler);
        }

        if (_.options.focusOnSelect === true) {
            $(_.$slideTrack).children().off('click.slick', _.selectHandler);
        }

        $(window).off('orientationchange.slick.slick-' + _.instanceUid, _.orientationChange);

        $(window).off('resize.slick.slick-' + _.instanceUid, _.resize);

        $('[draggable!=true]', _.$slideTrack).off('dragstart', _.preventDefault);

        $(window).off('load.slick.slick-' + _.instanceUid, _.setPosition);

    };

    Slick.prototype.cleanUpSlideEvents = function() {

        var _ = this;

        _.$list.off('mouseenter.slick', $.proxy(_.interrupt, _, true));
        _.$list.off('mouseleave.slick', $.proxy(_.interrupt, _, false));

    };

    Slick.prototype.cleanUpRows = function() {

        var _ = this, originalSlides;

        if(_.options.rows > 0) {
            originalSlides = _.$slides.children().children();
            originalSlides.removeAttr('style');
            _.$slider.empty().append(originalSlides);
        }

    };

    Slick.prototype.clickHandler = function(event) {

        var _ = this;

        if (_.shouldClick === false) {
            event.stopImmediatePropagation();
            event.stopPropagation();
            event.preventDefault();
        }

    };

    Slick.prototype.destroy = function(refresh) {

        var _ = this;

        _.autoPlayClear();

        _.touchObject = {};

        _.cleanUpEvents();

        $('.slick-cloned', _.$slider).detach();

        if (_.$dots) {
            _.$dots.remove();
        }

        if ( _.$prevArrow && _.$prevArrow.length ) {

            _.$prevArrow
                .removeClass('slick-disabled slick-arrow slick-hidden')
                .removeAttr('aria-hidden aria-disabled tabindex')
                .css('display','');

            if ( _.htmlExpr.test( _.options.prevArrow )) {
                _.$prevArrow.remove();
            }
        }

        if ( _.$nextArrow && _.$nextArrow.length ) {

            _.$nextArrow
                .removeClass('slick-disabled slick-arrow slick-hidden')
                .removeAttr('aria-hidden aria-disabled tabindex')
                .css('display','');

            if ( _.htmlExpr.test( _.options.nextArrow )) {
                _.$nextArrow.remove();
            }
        }


        if (_.$slides) {

            _.$slides
                .removeClass('slick-slide slick-active slick-center slick-visible slick-current')
                .removeAttr('aria-hidden')
                .removeAttr('data-slick-index')
                .each(function(){
                    $(this).attr('style', $(this).data('originalStyling'));
                });

            _.$slideTrack.children(this.options.slide).detach();

            _.$slideTrack.detach();

            _.$list.detach();

            _.$slider.append(_.$slides);
        }

        _.cleanUpRows();

        _.$slider.removeClass('slick-slider');
        _.$slider.removeClass('slick-initialized');
        _.$slider.removeClass('slick-dotted');

        _.unslicked = true;

        if(!refresh) {
            _.$slider.trigger('destroy', [_]);
        }

    };

    Slick.prototype.disableTransition = function(slide) {

        var _ = this,
            transition = {};

        transition[_.transitionType] = '';

        if (_.options.fade === false) {
            _.$slideTrack.css(transition);
        } else {
            _.$slides.eq(slide).css(transition);
        }

    };

    Slick.prototype.fadeSlide = function(slideIndex, callback) {

        var _ = this;

        if (_.cssTransitions === false) {

            _.$slides.eq(slideIndex).css({
                zIndex: _.options.zIndex
            });

            _.$slides.eq(slideIndex).animate({
                opacity: 1
            }, _.options.speed, _.options.easing, callback);

        } else {

            _.applyTransition(slideIndex);

            _.$slides.eq(slideIndex).css({
                opacity: 1,
                zIndex: _.options.zIndex
            });

            if (callback) {
                setTimeout(function() {

                    _.disableTransition(slideIndex);

                    callback.call();
                }, _.options.speed);
            }

        }

    };

    Slick.prototype.fadeSlideOut = function(slideIndex) {

        var _ = this;

        if (_.cssTransitions === false) {

            _.$slides.eq(slideIndex).animate({
                opacity: 0,
                zIndex: _.options.zIndex - 2
            }, _.options.speed, _.options.easing);

        } else {

            _.applyTransition(slideIndex);

            _.$slides.eq(slideIndex).css({
                opacity: 0,
                zIndex: _.options.zIndex - 2
            });

        }

    };

    Slick.prototype.filterSlides = Slick.prototype.slickFilter = function(filter) {

        var _ = this;

        if (filter !== null) {

            _.$slidesCache = _.$slides;

            _.unload();

            _.$slideTrack.children(this.options.slide).detach();

            _.$slidesCache.filter(filter).appendTo(_.$slideTrack);

            _.reinit();

        }

    };

    Slick.prototype.focusHandler = function() {

        var _ = this;

        _.$slider
            .off('focus.slick blur.slick')
            .on('focus.slick blur.slick', '*', function(event) {

            event.stopImmediatePropagation();
            var $sf = $(this);

            setTimeout(function() {

                if( _.options.pauseOnFocus ) {
                    _.focussed = $sf.is(':focus');
                    _.autoPlay();
                }

            }, 0);

        });
    };

    Slick.prototype.getCurrent = Slick.prototype.slickCurrentSlide = function() {

        var _ = this;
        return _.currentSlide;

    };

    Slick.prototype.getDotCount = function() {

        var _ = this;

        var breakPoint = 0;
        var counter = 0;
        var pagerQty = 0;

        if (_.options.infinite === true) {
            if (_.slideCount <= _.options.slidesToShow) {
                 ++pagerQty;
            } else {
                while (breakPoint < _.slideCount) {
                    ++pagerQty;
                    breakPoint = counter + _.options.slidesToScroll;
                    counter += _.options.slidesToScroll <= _.options.slidesToShow ? _.options.slidesToScroll : _.options.slidesToShow;
                }
            }
        } else if (_.options.centerMode === true) {
            pagerQty = _.slideCount;
        } else if(!_.options.asNavFor) {
            pagerQty = 1 + Math.ceil((_.slideCount - _.options.slidesToShow) / _.options.slidesToScroll);
        }else {
            while (breakPoint < _.slideCount) {
                ++pagerQty;
                breakPoint = counter + _.options.slidesToScroll;
                counter += _.options.slidesToScroll <= _.options.slidesToShow ? _.options.slidesToScroll : _.options.slidesToShow;
            }
        }

        return pagerQty - 1;

    };

    Slick.prototype.getLeft = function(slideIndex) {

        var _ = this,
            targetLeft,
            verticalHeight,
            verticalOffset = 0,
            targetSlide,
            coef;

        _.slideOffset = 0;
        verticalHeight = _.$slides.first().outerHeight(true);

        if (_.options.infinite === true) {
            if (_.slideCount > _.options.slidesToShow) {
                _.slideOffset = (_.slideWidth * _.options.slidesToShow) * -1;
                coef = -1

                if (_.options.vertical === true && _.options.centerMode === true) {
                    if (_.options.slidesToShow === 2) {
                        coef = -1.5;
                    } else if (_.options.slidesToShow === 1) {
                        coef = -2
                    }
                }
                verticalOffset = (verticalHeight * _.options.slidesToShow) * coef;
            }
            if (_.slideCount % _.options.slidesToScroll !== 0) {
                if (slideIndex + _.options.slidesToScroll > _.slideCount && _.slideCount > _.options.slidesToShow) {
                    if (slideIndex > _.slideCount) {
                        _.slideOffset = ((_.options.slidesToShow - (slideIndex - _.slideCount)) * _.slideWidth) * -1;
                        verticalOffset = ((_.options.slidesToShow - (slideIndex - _.slideCount)) * verticalHeight) * -1;
                    } else {
                        _.slideOffset = ((_.slideCount % _.options.slidesToScroll) * _.slideWidth) * -1;
                        verticalOffset = ((_.slideCount % _.options.slidesToScroll) * verticalHeight) * -1;
                    }
                }
            }
        } else {
            if (slideIndex + _.options.slidesToShow > _.slideCount) {
                _.slideOffset = ((slideIndex + _.options.slidesToShow) - _.slideCount) * _.slideWidth;
                verticalOffset = ((slideIndex + _.options.slidesToShow) - _.slideCount) * verticalHeight;
            }
        }

        if (_.slideCount <= _.options.slidesToShow) {
            _.slideOffset = 0;
            verticalOffset = 0;
        }

        if (_.options.centerMode === true && _.slideCount <= _.options.slidesToShow) {
            _.slideOffset = ((_.slideWidth * Math.floor(_.options.slidesToShow)) / 2) - ((_.slideWidth * _.slideCount) / 2);
        } else if (_.options.centerMode === true && _.options.infinite === true) {
            _.slideOffset += _.slideWidth * Math.floor(_.options.slidesToShow / 2) - _.slideWidth;
        } else if (_.options.centerMode === true) {
            _.slideOffset = 0;
            _.slideOffset += _.slideWidth * Math.floor(_.options.slidesToShow / 2);
        }

        if (_.options.vertical === false) {
            targetLeft = ((slideIndex * _.slideWidth) * -1) + _.slideOffset;
        } else {
            targetLeft = ((slideIndex * verticalHeight) * -1) + verticalOffset;
        }

        if (_.options.variableWidth === true) {

            if (_.slideCount <= _.options.slidesToShow || _.options.infinite === false) {
                targetSlide = _.$slideTrack.children('.slick-slide').eq(slideIndex);
            } else {
                targetSlide = _.$slideTrack.children('.slick-slide').eq(slideIndex + _.options.slidesToShow);
            }

            if (_.options.rtl === true) {
                if (targetSlide[0]) {
                    targetLeft = (_.$slideTrack.width() - targetSlide[0].offsetLeft - targetSlide.width()) * -1;
                } else {
                    targetLeft =  0;
                }
            } else {
                targetLeft = targetSlide[0] ? targetSlide[0].offsetLeft * -1 : 0;
            }

            if (_.options.centerMode === true) {
                if (_.slideCount <= _.options.slidesToShow || _.options.infinite === false) {
                    targetSlide = _.$slideTrack.children('.slick-slide').eq(slideIndex);
                } else {
                    targetSlide = _.$slideTrack.children('.slick-slide').eq(slideIndex + _.options.slidesToShow + 1);
                }

                if (_.options.rtl === true) {
                    if (targetSlide[0]) {
                        targetLeft = (_.$slideTrack.width() - targetSlide[0].offsetLeft - targetSlide.width()) * -1;
                    } else {
                        targetLeft =  0;
                    }
                } else {
                    targetLeft = targetSlide[0] ? targetSlide[0].offsetLeft * -1 : 0;
                }

                targetLeft += (_.$list.width() - targetSlide.outerWidth()) / 2;
            }
        }

        return targetLeft;

    };

    Slick.prototype.getOption = Slick.prototype.slickGetOption = function(option) {

        var _ = this;

        return _.options[option];

    };

    Slick.prototype.getNavigableIndexes = function() {

        var _ = this,
            breakPoint = 0,
            counter = 0,
            indexes = [],
            max;

        if (_.options.infinite === false) {
            max = _.slideCount;
        } else {
            breakPoint = _.options.slidesToScroll * -1;
            counter = _.options.slidesToScroll * -1;
            max = _.slideCount * 2;
        }

        while (breakPoint < max) {
            indexes.push(breakPoint);
            breakPoint = counter + _.options.slidesToScroll;
            counter += _.options.slidesToScroll <= _.options.slidesToShow ? _.options.slidesToScroll : _.options.slidesToShow;
        }

        return indexes;

    };

    Slick.prototype.getSlick = function() {

        return this;

    };

    Slick.prototype.getSlideCount = function() {

        var _ = this,
            slidesTraversed, swipedSlide, centerOffset;

        centerOffset = _.options.centerMode === true ? _.slideWidth * Math.floor(_.options.slidesToShow / 2) : 0;

        if (_.options.swipeToSlide === true) {
            _.$slideTrack.find('.slick-slide').each(function(index, slide) {
                if (slide.offsetLeft - centerOffset + ($(slide).outerWidth() / 2) > (_.swipeLeft * -1)) {
                    swipedSlide = slide;
                    return false;
                }
            });

            slidesTraversed = Math.abs($(swipedSlide).attr('data-slick-index') - _.currentSlide) || 1;

            return slidesTraversed;

        } else {
            return _.options.slidesToScroll;
        }

    };

    Slick.prototype.goTo = Slick.prototype.slickGoTo = function(slide, dontAnimate) {

        var _ = this;

        _.changeSlide({
            data: {
                message: 'index',
                index: parseInt(slide)
            }
        }, dontAnimate);

    };

    Slick.prototype.init = function(creation) {

        var _ = this;

        if (!$(_.$slider).hasClass('slick-initialized')) {

            $(_.$slider).addClass('slick-initialized');

            _.buildRows();
            _.buildOut();
            _.setProps();
            _.startLoad();
            _.loadSlider();
            _.initializeEvents();
            _.updateArrows();
            _.updateDots();
            _.checkResponsive(true);
            _.focusHandler();

        }

        if (creation) {
            _.$slider.trigger('init', [_]);
        }

        if (_.options.accessibility === true) {
            _.initADA();
        }

        if ( _.options.autoplay ) {

            _.paused = false;
            _.autoPlay();

        }

    };

    Slick.prototype.initADA = function() {
        var _ = this,
                numDotGroups = Math.ceil(_.slideCount / _.options.slidesToShow),
                tabControlIndexes = _.getNavigableIndexes().filter(function(val) {
                    return (val >= 0) && (val < _.slideCount);
                });

        _.$slides.add(_.$slideTrack.find('.slick-cloned')).attr({
            'aria-hidden': 'true',
            'tabindex': '-1'
        }).find('a, input, button, select').attr({
            'tabindex': '-1'
        });

        if (_.$dots !== null) {
            _.$slides.not(_.$slideTrack.find('.slick-cloned')).each(function(i) {
                var slideControlIndex = tabControlIndexes.indexOf(i);

                $(this).attr({
                    'role': 'tabpanel',
                    'id': 'slick-slide' + _.instanceUid + i,
                    'tabindex': -1
                });

                if (slideControlIndex !== -1) {
                   var ariaButtonControl = 'slick-slide-control' + _.instanceUid + slideControlIndex
                   if ($('#' + ariaButtonControl).length) {
                     $(this).attr({
                         'aria-describedby': ariaButtonControl
                     });
                   }
                }
            });

            _.$dots.attr('role', 'tablist').find('li').each(function(i) {
                var mappedSlideIndex = tabControlIndexes[i];

                $(this).attr({
                    'role': 'presentation'
                });

                $(this).find('button').first().attr({
                    'role': 'tab',
                    'id': 'slick-slide-control' + _.instanceUid + i,
                    'aria-controls': 'slick-slide' + _.instanceUid + mappedSlideIndex,
                    'aria-label': (i + 1) + ' of ' + numDotGroups,
                    'aria-selected': null,
                    'tabindex': '-1'
                });

            }).eq(_.currentSlide).find('button').attr({
                'aria-selected': 'true',
                'tabindex': '0'
            }).end();
        }

        for (var i=_.currentSlide, max=i+_.options.slidesToShow; i < max; i++) {
          if (_.options.focusOnChange) {
            _.$slides.eq(i).attr({'tabindex': '0'});
          } else {
            _.$slides.eq(i).removeAttr('tabindex');
          }
        }

        _.activateADA();

    };

    Slick.prototype.initArrowEvents = function() {

        var _ = this;

        if (_.options.arrows === true && _.slideCount > _.options.slidesToShow) {
            _.$prevArrow
               .off('click.slick')
               .on('click.slick', {
                    message: 'previous'
               }, _.changeSlide);
            _.$nextArrow
               .off('click.slick')
               .on('click.slick', {
                    message: 'next'
               }, _.changeSlide);

            if (_.options.accessibility === true) {
                _.$prevArrow.on('keydown.slick', _.keyHandler);
                _.$nextArrow.on('keydown.slick', _.keyHandler);
            }
        }

    };

    Slick.prototype.initDotEvents = function() {

        var _ = this;

        if (_.options.dots === true && _.slideCount > _.options.slidesToShow) {
            $('li', _.$dots).on('click.slick', {
                message: 'index'
            }, _.changeSlide);

            if (_.options.accessibility === true) {
                _.$dots.on('keydown.slick', _.keyHandler);
            }
        }

        if (_.options.dots === true && _.options.pauseOnDotsHover === true && _.slideCount > _.options.slidesToShow) {

            $('li', _.$dots)
                .on('mouseenter.slick', $.proxy(_.interrupt, _, true))
                .on('mouseleave.slick', $.proxy(_.interrupt, _, false));

        }

    };

    Slick.prototype.initSlideEvents = function() {

        var _ = this;

        if ( _.options.pauseOnHover ) {

            _.$list.on('mouseenter.slick', $.proxy(_.interrupt, _, true));
            _.$list.on('mouseleave.slick', $.proxy(_.interrupt, _, false));

        }

    };

    Slick.prototype.initializeEvents = function() {

        var _ = this;

        _.initArrowEvents();

        _.initDotEvents();
        _.initSlideEvents();

        _.$list.on('touchstart.slick mousedown.slick', {
            action: 'start'
        }, _.swipeHandler);
        _.$list.on('touchmove.slick mousemove.slick', {
            action: 'move'
        }, _.swipeHandler);
        _.$list.on('touchend.slick mouseup.slick', {
            action: 'end'
        }, _.swipeHandler);
        _.$list.on('touchcancel.slick mouseleave.slick', {
            action: 'end'
        }, _.swipeHandler);

        _.$list.on('click.slick', _.clickHandler);

        $(document).on(_.visibilityChange, $.proxy(_.visibility, _));

        if (_.options.accessibility === true) {
            _.$list.on('keydown.slick', _.keyHandler);
        }

        if (_.options.focusOnSelect === true) {
            $(_.$slideTrack).children().on('click.slick', _.selectHandler);
        }

        $(window).on('orientationchange.slick.slick-' + _.instanceUid, $.proxy(_.orientationChange, _));

        $(window).on('resize.slick.slick-' + _.instanceUid, $.proxy(_.resize, _));

        $('[draggable!=true]', _.$slideTrack).on('dragstart', _.preventDefault);

        $(window).on('load.slick.slick-' + _.instanceUid, _.setPosition);
        $(_.setPosition);

    };

    Slick.prototype.initUI = function() {

        var _ = this;

        if (_.options.arrows === true && _.slideCount > _.options.slidesToShow) {

            _.$prevArrow.show();
            _.$nextArrow.show();

        }

        if (_.options.dots === true && _.slideCount > _.options.slidesToShow) {

            _.$dots.show();

        }

    };

    Slick.prototype.keyHandler = function(event) {

        var _ = this;
         //Dont slide if the cursor is inside the form fields and arrow keys are pressed
        if(!event.target.tagName.match('TEXTAREA|INPUT|SELECT')) {
            if (event.keyCode === 37 && _.options.accessibility === true) {
                _.changeSlide({
                    data: {
                        message: _.options.rtl === true ? 'next' :  'previous'
                    }
                });
            } else if (event.keyCode === 39 && _.options.accessibility === true) {
                _.changeSlide({
                    data: {
                        message: _.options.rtl === true ? 'previous' : 'next'
                    }
                });
            }
        }

    };

    Slick.prototype.lazyLoad = function() {

        var _ = this,
            loadRange, cloneRange, rangeStart, rangeEnd;

        function loadImages(imagesScope) {

            $('img[data-lazy]', imagesScope).each(function() {

                var image = $(this),
                    imageSource = $(this).attr('data-lazy'),
                    imageSrcSet = $(this).attr('data-srcset'),
                    imageSizes  = $(this).attr('data-sizes') || _.$slider.attr('data-sizes'),
                    imageToLoad = document.createElement('img');

                imageToLoad.onload = function() {

                    image
                        .animate({ opacity: 0 }, 100, function() {

                            if (imageSrcSet) {
                                image
                                    .attr('srcset', imageSrcSet );

                                if (imageSizes) {
                                    image
                                        .attr('sizes', imageSizes );
                                }
                            }

                            image
                                .attr('src', imageSource)
                                .animate({ opacity: 1 }, 200, function() {
                                    image
                                        .removeAttr('data-lazy data-srcset data-sizes')
                                        .removeClass('slick-loading');
                                });
                            _.$slider.trigger('lazyLoaded', [_, image, imageSource]);
                        });

                };

                imageToLoad.onerror = function() {

                    image
                        .removeAttr( 'data-lazy' )
                        .removeClass( 'slick-loading' )
                        .addClass( 'slick-lazyload-error' );

                    _.$slider.trigger('lazyLoadError', [ _, image, imageSource ]);

                };

                imageToLoad.src = imageSource;

            });

        }

        if (_.options.centerMode === true) {
            if (_.options.infinite === true) {
                rangeStart = _.currentSlide + (_.options.slidesToShow / 2 + 1);
                rangeEnd = rangeStart + _.options.slidesToShow + 2;
            } else {
                rangeStart = Math.max(0, _.currentSlide - (_.options.slidesToShow / 2 + 1));
                rangeEnd = 2 + (_.options.slidesToShow / 2 + 1) + _.currentSlide;
            }
        } else {
            rangeStart = _.options.infinite ? _.options.slidesToShow + _.currentSlide : _.currentSlide;
            rangeEnd = Math.ceil(rangeStart + _.options.slidesToShow);
            if (_.options.fade === true) {
                if (rangeStart > 0) rangeStart--;
                if (rangeEnd <= _.slideCount) rangeEnd++;
            }
        }

        loadRange = _.$slider.find('.slick-slide').slice(rangeStart, rangeEnd);

        if (_.options.lazyLoad === 'anticipated') {
            var prevSlide = rangeStart - 1,
                nextSlide = rangeEnd,
                $slides = _.$slider.find('.slick-slide');

            for (var i = 0; i < _.options.slidesToScroll; i++) {
                if (prevSlide < 0) prevSlide = _.slideCount - 1;
                loadRange = loadRange.add($slides.eq(prevSlide));
                loadRange = loadRange.add($slides.eq(nextSlide));
                prevSlide--;
                nextSlide++;
            }
        }

        loadImages(loadRange);

        if (_.slideCount <= _.options.slidesToShow) {
            cloneRange = _.$slider.find('.slick-slide');
            loadImages(cloneRange);
        } else
        if (_.currentSlide >= _.slideCount - _.options.slidesToShow) {
            cloneRange = _.$slider.find('.slick-cloned').slice(0, _.options.slidesToShow);
            loadImages(cloneRange);
        } else if (_.currentSlide === 0) {
            cloneRange = _.$slider.find('.slick-cloned').slice(_.options.slidesToShow * -1);
            loadImages(cloneRange);
        }

    };

    Slick.prototype.loadSlider = function() {

        var _ = this;

        _.setPosition();

        _.$slideTrack.css({
            opacity: 1
        });

        _.$slider.removeClass('slick-loading');

        _.initUI();

        if (_.options.lazyLoad === 'progressive') {
            _.progressiveLazyLoad();
        }

    };

    Slick.prototype.next = Slick.prototype.slickNext = function() {

        var _ = this;

        _.changeSlide({
            data: {
                message: 'next'
            }
        });

    };

    Slick.prototype.orientationChange = function() {

        var _ = this;

        _.checkResponsive();
        _.setPosition();

    };

    Slick.prototype.pause = Slick.prototype.slickPause = function() {

        var _ = this;

        _.autoPlayClear();
        _.paused = true;

    };

    Slick.prototype.play = Slick.prototype.slickPlay = function() {

        var _ = this;

        _.autoPlay();
        _.options.autoplay = true;
        _.paused = false;
        _.focussed = false;
        _.interrupted = false;

    };

    Slick.prototype.postSlide = function(index) {

        var _ = this;

        if( !_.unslicked ) {

            _.$slider.trigger('afterChange', [_, index]);

            _.animating = false;

            if (_.slideCount > _.options.slidesToShow) {
                _.setPosition();
            }

            _.swipeLeft = null;

            if ( _.options.autoplay ) {
                _.autoPlay();
            }

            if (_.options.accessibility === true) {
                _.initADA();

                if (_.options.focusOnChange) {
                    var $currentSlide = $(_.$slides.get(_.currentSlide));
                    $currentSlide.attr('tabindex', 0).focus();
                }
            }

        }

    };

    Slick.prototype.prev = Slick.prototype.slickPrev = function() {

        var _ = this;

        _.changeSlide({
            data: {
                message: 'previous'
            }
        });

    };

    Slick.prototype.preventDefault = function(event) {

        event.preventDefault();

    };

    Slick.prototype.progressiveLazyLoad = function( tryCount ) {

        tryCount = tryCount || 1;

        var _ = this,
            $imgsToLoad = $( 'img[data-lazy]', _.$slider ),
            image,
            imageSource,
            imageSrcSet,
            imageSizes,
            imageToLoad;

        if ( $imgsToLoad.length ) {

            image = $imgsToLoad.first();
            imageSource = image.attr('data-lazy');
            imageSrcSet = image.attr('data-srcset');
            imageSizes  = image.attr('data-sizes') || _.$slider.attr('data-sizes');
            imageToLoad = document.createElement('img');

            imageToLoad.onload = function() {

                if (imageSrcSet) {
                    image
                        .attr('srcset', imageSrcSet );

                    if (imageSizes) {
                        image
                            .attr('sizes', imageSizes );
                    }
                }

                image
                    .attr( 'src', imageSource )
                    .removeAttr('data-lazy data-srcset data-sizes')
                    .removeClass('slick-loading');

                if ( _.options.adaptiveHeight === true ) {
                    _.setPosition();
                }

                _.$slider.trigger('lazyLoaded', [ _, image, imageSource ]);
                _.progressiveLazyLoad();

            };

            imageToLoad.onerror = function() {

                if ( tryCount < 3 ) {

                    /**
                     * try to load the image 3 times,
                     * leave a slight delay so we don't get
                     * servers blocking the request.
                     */
                    setTimeout( function() {
                        _.progressiveLazyLoad( tryCount + 1 );
                    }, 500 );

                } else {

                    image
                        .removeAttr( 'data-lazy' )
                        .removeClass( 'slick-loading' )
                        .addClass( 'slick-lazyload-error' );

                    _.$slider.trigger('lazyLoadError', [ _, image, imageSource ]);

                    _.progressiveLazyLoad();

                }

            };

            imageToLoad.src = imageSource;

        } else {

            _.$slider.trigger('allImagesLoaded', [ _ ]);

        }

    };

    Slick.prototype.refresh = function( initializing ) {

        var _ = this, currentSlide, lastVisibleIndex;

        lastVisibleIndex = _.slideCount - _.options.slidesToShow;

        // in non-infinite sliders, we don't want to go past the
        // last visible index.
        if( !_.options.infinite && ( _.currentSlide > lastVisibleIndex )) {
            _.currentSlide = lastVisibleIndex;
        }

        // if less slides than to show, go to start.
        if ( _.slideCount <= _.options.slidesToShow ) {
            _.currentSlide = 0;

        }

        currentSlide = _.currentSlide;

        _.destroy(true);

        $.extend(_, _.initials, { currentSlide: currentSlide });

        _.init();

        if( !initializing ) {

            _.changeSlide({
                data: {
                    message: 'index',
                    index: currentSlide
                }
            }, false);

        }

    };

    Slick.prototype.registerBreakpoints = function() {

        var _ = this, breakpoint, currentBreakpoint, l,
            responsiveSettings = _.options.responsive || null;

        if ( $.type(responsiveSettings) === 'array' && responsiveSettings.length ) {

            _.respondTo = _.options.respondTo || 'window';

            for ( breakpoint in responsiveSettings ) {

                l = _.breakpoints.length-1;

                if (responsiveSettings.hasOwnProperty(breakpoint)) {
                    currentBreakpoint = responsiveSettings[breakpoint].breakpoint;

                    // loop through the breakpoints and cut out any existing
                    // ones with the same breakpoint number, we don't want dupes.
                    while( l >= 0 ) {
                        if( _.breakpoints[l] && _.breakpoints[l] === currentBreakpoint ) {
                            _.breakpoints.splice(l,1);
                        }
                        l--;
                    }

                    _.breakpoints.push(currentBreakpoint);
                    _.breakpointSettings[currentBreakpoint] = responsiveSettings[breakpoint].settings;

                }

            }

            _.breakpoints.sort(function(a, b) {
                return ( _.options.mobileFirst ) ? a-b : b-a;
            });

        }

    };

    Slick.prototype.reinit = function() {

        var _ = this;

        _.$slides =
            _.$slideTrack
                .children(_.options.slide)
                .addClass('slick-slide');

        _.slideCount = _.$slides.length;

        if (_.currentSlide >= _.slideCount && _.currentSlide !== 0) {
            _.currentSlide = _.currentSlide - _.options.slidesToScroll;
        }

        if (_.slideCount <= _.options.slidesToShow) {
            _.currentSlide = 0;
        }

        _.registerBreakpoints();

        _.setProps();
        _.setupInfinite();
        _.buildArrows();
        _.updateArrows();
        _.initArrowEvents();
        _.buildDots();
        _.updateDots();
        _.initDotEvents();
        _.cleanUpSlideEvents();
        _.initSlideEvents();

        _.checkResponsive(false, true);

        if (_.options.focusOnSelect === true) {
            $(_.$slideTrack).children().on('click.slick', _.selectHandler);
        }

        _.setSlideClasses(typeof _.currentSlide === 'number' ? _.currentSlide : 0);

        _.setPosition();
        _.focusHandler();

        _.paused = !_.options.autoplay;
        _.autoPlay();

        _.$slider.trigger('reInit', [_]);

    };

    Slick.prototype.resize = function() {

        var _ = this;

        if ($(window).width() !== _.windowWidth) {
            clearTimeout(_.windowDelay);
            _.windowDelay = window.setTimeout(function() {
                _.windowWidth = $(window).width();
                _.checkResponsive();
                if( !_.unslicked ) { _.setPosition(); }
            }, 50);
        }
    };

    Slick.prototype.removeSlide = Slick.prototype.slickRemove = function(index, removeBefore, removeAll) {

        var _ = this;

        if (typeof(index) === 'boolean') {
            removeBefore = index;
            index = removeBefore === true ? 0 : _.slideCount - 1;
        } else {
            index = removeBefore === true ? --index : index;
        }

        if (_.slideCount < 1 || index < 0 || index > _.slideCount - 1) {
            return false;
        }

        _.unload();

        if (removeAll === true) {
            _.$slideTrack.children().remove();
        } else {
            _.$slideTrack.children(this.options.slide).eq(index).remove();
        }

        _.$slides = _.$slideTrack.children(this.options.slide);

        _.$slideTrack.children(this.options.slide).detach();

        _.$slideTrack.append(_.$slides);

        _.$slidesCache = _.$slides;

        _.reinit();

    };

    Slick.prototype.setCSS = function(position) {

        var _ = this,
            positionProps = {},
            x, y;

        if (_.options.rtl === true) {
            position = -position;
        }
        x = _.positionProp == 'left' ? Math.ceil(position) + 'px' : '0px';
        y = _.positionProp == 'top' ? Math.ceil(position) + 'px' : '0px';

        positionProps[_.positionProp] = position;

        if (_.transformsEnabled === false) {
            _.$slideTrack.css(positionProps);
        } else {
            positionProps = {};
            if (_.cssTransitions === false) {
                positionProps[_.animType] = 'translate(' + x + ', ' + y + ')';
                _.$slideTrack.css(positionProps);
            } else {
                positionProps[_.animType] = 'translate3d(' + x + ', ' + y + ', 0px)';
                _.$slideTrack.css(positionProps);
            }
        }

    };

    Slick.prototype.setDimensions = function() {

        var _ = this;

        if (_.options.vertical === false) {
            if (_.options.centerMode === true) {
                _.$list.css({
                    padding: ('0px ' + _.options.centerPadding)
                });
            }
        } else {
            _.$list.height(_.$slides.first().outerHeight(true) * _.options.slidesToShow);
            if (_.options.centerMode === true) {
                _.$list.css({
                    padding: (_.options.centerPadding + ' 0px')
                });
            }
        }

        _.listWidth = _.$list.width();
        _.listHeight = _.$list.height();


        if (_.options.vertical === false && _.options.variableWidth === false) {
            _.slideWidth = Math.ceil(_.listWidth / _.options.slidesToShow);
            _.$slideTrack.width(Math.ceil((_.slideWidth * _.$slideTrack.children('.slick-slide').length)));

        } else if (_.options.variableWidth === true) {
            _.$slideTrack.width(5000 * _.slideCount);
        } else {
            _.slideWidth = Math.ceil(_.listWidth);
            _.$slideTrack.height(Math.ceil((_.$slides.first().outerHeight(true) * _.$slideTrack.children('.slick-slide').length)));
        }

        var offset = _.$slides.first().outerWidth(true) - _.$slides.first().width();
        if (_.options.variableWidth === false) _.$slideTrack.children('.slick-slide').width(_.slideWidth - offset);

    };

    Slick.prototype.setFade = function() {

        var _ = this,
            targetLeft;

        _.$slides.each(function(index, element) {
            targetLeft = (_.slideWidth * index) * -1;
            if (_.options.rtl === true) {
                $(element).css({
                    position: 'relative',
                    right: targetLeft,
                    top: 0,
                    zIndex: _.options.zIndex - 2,
                    opacity: 0
                });
            } else {
                $(element).css({
                    position: 'relative',
                    left: targetLeft,
                    top: 0,
                    zIndex: _.options.zIndex - 2,
                    opacity: 0
                });
            }
        });

        _.$slides.eq(_.currentSlide).css({
            zIndex: _.options.zIndex - 1,
            opacity: 1
        });

    };

    Slick.prototype.setHeight = function() {

        var _ = this;

        if (_.options.slidesToShow === 1 && _.options.adaptiveHeight === true && _.options.vertical === false) {
            var targetHeight = _.$slides.eq(_.currentSlide).outerHeight(true);
            _.$list.css('height', targetHeight);
        }

    };

    Slick.prototype.setOption =
    Slick.prototype.slickSetOption = function() {

        /**
         * accepts arguments in format of:
         *
         *  - for changing a single option's value:
         *     .slick("setOption", option, value, refresh )
         *
         *  - for changing a set of responsive options:
         *     .slick("setOption", 'responsive', [{}, ...], refresh )
         *
         *  - for updating multiple values at once (not responsive)
         *     .slick("setOption", { 'option': value, ... }, refresh )
         */

        var _ = this, l, item, option, value, refresh = false, type;

        if( $.type( arguments[0] ) === 'object' ) {

            option =  arguments[0];
            refresh = arguments[1];
            type = 'multiple';

        } else if ( $.type( arguments[0] ) === 'string' ) {

            option =  arguments[0];
            value = arguments[1];
            refresh = arguments[2];

            if ( arguments[0] === 'responsive' && $.type( arguments[1] ) === 'array' ) {

                type = 'responsive';

            } else if ( typeof arguments[1] !== 'undefined' ) {

                type = 'single';

            }

        }

        if ( type === 'single' ) {

            _.options[option] = value;


        } else if ( type === 'multiple' ) {

            $.each( option , function( opt, val ) {

                _.options[opt] = val;

            });


        } else if ( type === 'responsive' ) {

            for ( item in value ) {

                if( $.type( _.options.responsive ) !== 'array' ) {

                    _.options.responsive = [ value[item] ];

                } else {

                    l = _.options.responsive.length-1;

                    // loop through the responsive object and splice out duplicates.
                    while( l >= 0 ) {

                        if( _.options.responsive[l].breakpoint === value[item].breakpoint ) {

                            _.options.responsive.splice(l,1);

                        }

                        l--;

                    }

                    _.options.responsive.push( value[item] );

                }

            }

        }

        if ( refresh ) {

            _.unload();
            _.reinit();

        }

    };

    Slick.prototype.setPosition = function() {

        var _ = this;

        _.setDimensions();

        _.setHeight();

        if (_.options.fade === false) {
            _.setCSS(_.getLeft(_.currentSlide));
        } else {
            _.setFade();
        }

        _.$slider.trigger('setPosition', [_]);

    };

    Slick.prototype.setProps = function() {

        var _ = this,
            bodyStyle = document.body.style;

        _.positionProp = _.options.vertical === true ? 'top' : 'left';

        if (_.positionProp === 'top') {
            _.$slider.addClass('slick-vertical');
        } else {
            _.$slider.removeClass('slick-vertical');
        }

        if (bodyStyle.WebkitTransition !== undefined ||
            bodyStyle.MozTransition !== undefined ||
            bodyStyle.msTransition !== undefined) {
            if (_.options.useCSS === true) {
                _.cssTransitions = true;
            }
        }

        if ( _.options.fade ) {
            if ( typeof _.options.zIndex === 'number' ) {
                if( _.options.zIndex < 3 ) {
                    _.options.zIndex = 3;
                }
            } else {
                _.options.zIndex = _.defaults.zIndex;
            }
        }

        if (bodyStyle.OTransform !== undefined) {
            _.animType = 'OTransform';
            _.transformType = '-o-transform';
            _.transitionType = 'OTransition';
            if (bodyStyle.perspectiveProperty === undefined && bodyStyle.webkitPerspective === undefined) _.animType = false;
        }
        if (bodyStyle.MozTransform !== undefined) {
            _.animType = 'MozTransform';
            _.transformType = '-moz-transform';
            _.transitionType = 'MozTransition';
            if (bodyStyle.perspectiveProperty === undefined && bodyStyle.MozPerspective === undefined) _.animType = false;
        }
        if (bodyStyle.webkitTransform !== undefined) {
            _.animType = 'webkitTransform';
            _.transformType = '-webkit-transform';
            _.transitionType = 'webkitTransition';
            if (bodyStyle.perspectiveProperty === undefined && bodyStyle.webkitPerspective === undefined) _.animType = false;
        }
        if (bodyStyle.msTransform !== undefined) {
            _.animType = 'msTransform';
            _.transformType = '-ms-transform';
            _.transitionType = 'msTransition';
            if (bodyStyle.msTransform === undefined) _.animType = false;
        }
        if (bodyStyle.transform !== undefined && _.animType !== false) {
            _.animType = 'transform';
            _.transformType = 'transform';
            _.transitionType = 'transition';
        }
        _.transformsEnabled = _.options.useTransform && (_.animType !== null && _.animType !== false);
    };


    Slick.prototype.setSlideClasses = function(index) {

        var _ = this,
            centerOffset, allSlides, indexOffset, remainder;

        allSlides = _.$slider
            .find('.slick-slide')
            .removeClass('slick-active slick-center slick-current')
            .attr('aria-hidden', 'true');

        _.$slides
            .eq(index)
            .addClass('slick-current');

        if (_.options.centerMode === true) {

            var evenCoef = _.options.slidesToShow % 2 === 0 ? 1 : 0;

            centerOffset = Math.floor(_.options.slidesToShow / 2);

            if (_.options.infinite === true) {

                if (index >= centerOffset && index <= (_.slideCount - 1) - centerOffset) {
                    _.$slides
                        .slice(index - centerOffset + evenCoef, index + centerOffset + 1)
                        .addClass('slick-active')
                        .attr('aria-hidden', 'false');

                } else {

                    indexOffset = _.options.slidesToShow + index;
                    allSlides
                        .slice(indexOffset - centerOffset + 1 + evenCoef, indexOffset + centerOffset + 2)
                        .addClass('slick-active')
                        .attr('aria-hidden', 'false');

                }

                if (index === 0) {

                    allSlides
                        .eq(allSlides.length - 1 - _.options.slidesToShow)
                        .addClass('slick-center');

                } else if (index === _.slideCount - 1) {

                    allSlides
                        .eq(_.options.slidesToShow)
                        .addClass('slick-center');

                }

            }

            _.$slides
                .eq(index)
                .addClass('slick-center');

        } else {

            if (index >= 0 && index <= (_.slideCount - _.options.slidesToShow)) {

                _.$slides
                    .slice(index, index + _.options.slidesToShow)
                    .addClass('slick-active')
                    .attr('aria-hidden', 'false');

            } else if (allSlides.length <= _.options.slidesToShow) {

                allSlides
                    .addClass('slick-active')
                    .attr('aria-hidden', 'false');

            } else {

                remainder = _.slideCount % _.options.slidesToShow;
                indexOffset = _.options.infinite === true ? _.options.slidesToShow + index : index;

                if (_.options.slidesToShow == _.options.slidesToScroll && (_.slideCount - index) < _.options.slidesToShow) {

                    allSlides
                        .slice(indexOffset - (_.options.slidesToShow - remainder), indexOffset + remainder)
                        .addClass('slick-active')
                        .attr('aria-hidden', 'false');

                } else {

                    allSlides
                        .slice(indexOffset, indexOffset + _.options.slidesToShow)
                        .addClass('slick-active')
                        .attr('aria-hidden', 'false');

                }

            }

        }

        if (_.options.lazyLoad === 'ondemand' || _.options.lazyLoad === 'anticipated') {
            _.lazyLoad();
        }
    };

    Slick.prototype.setupInfinite = function() {

        var _ = this,
            i, slideIndex, infiniteCount;

        if (_.options.fade === true) {
            _.options.centerMode = false;
        }

        if (_.options.infinite === true && _.options.fade === false) {

            slideIndex = null;

            if (_.slideCount > _.options.slidesToShow) {

                if (_.options.centerMode === true) {
                    infiniteCount = _.options.slidesToShow + 1;
                } else {
                    infiniteCount = _.options.slidesToShow;
                }

                for (i = _.slideCount; i > (_.slideCount -
                        infiniteCount); i -= 1) {
                    slideIndex = i - 1;
                    $(_.$slides[slideIndex]).clone(true).attr('id', '')
                        .attr('data-slick-index', slideIndex - _.slideCount)
                        .prependTo(_.$slideTrack).addClass('slick-cloned');
                }
                for (i = 0; i < infiniteCount  + _.slideCount; i += 1) {
                    slideIndex = i;
                    $(_.$slides[slideIndex]).clone(true).attr('id', '')
                        .attr('data-slick-index', slideIndex + _.slideCount)
                        .appendTo(_.$slideTrack).addClass('slick-cloned');
                }
                _.$slideTrack.find('.slick-cloned').find('[id]').each(function() {
                    $(this).attr('id', '');
                });

            }

        }

    };

    Slick.prototype.interrupt = function( toggle ) {

        var _ = this;

        if( !toggle ) {
            _.autoPlay();
        }
        _.interrupted = toggle;

    };

    Slick.prototype.selectHandler = function(event) {

        var _ = this;

        var targetElement =
            $(event.target).is('.slick-slide') ?
                $(event.target) :
                $(event.target).parents('.slick-slide');

        var index = parseInt(targetElement.attr('data-slick-index'));

        if (!index) index = 0;

        if (_.slideCount <= _.options.slidesToShow) {

            _.slideHandler(index, false, true);
            return;

        }

        _.slideHandler(index);

    };

    Slick.prototype.slideHandler = function(index, sync, dontAnimate) {

        var targetSlide, animSlide, oldSlide, slideLeft, targetLeft = null,
            _ = this, navTarget;

        sync = sync || false;

        if (_.animating === true && _.options.waitForAnimate === true) {
            return;
        }

        if (_.options.fade === true && _.currentSlide === index) {
            return;
        }

        if (sync === false) {
            _.asNavFor(index);
        }

        targetSlide = index;
        targetLeft = _.getLeft(targetSlide);
        slideLeft = _.getLeft(_.currentSlide);

        _.currentLeft = _.swipeLeft === null ? slideLeft : _.swipeLeft;

        if (_.options.infinite === false && _.options.centerMode === false && (index < 0 || index > _.getDotCount() * _.options.slidesToScroll)) {
            if (_.options.fade === false) {
                targetSlide = _.currentSlide;
                if (dontAnimate !== true && _.slideCount > _.options.slidesToShow) {
                    _.animateSlide(slideLeft, function() {
                        _.postSlide(targetSlide);
                    });
                } else {
                    _.postSlide(targetSlide);
                }
            }
            return;
        } else if (_.options.infinite === false && _.options.centerMode === true && (index < 0 || index > (_.slideCount - _.options.slidesToScroll))) {
            if (_.options.fade === false) {
                targetSlide = _.currentSlide;
                if (dontAnimate !== true && _.slideCount > _.options.slidesToShow) {
                    _.animateSlide(slideLeft, function() {
                        _.postSlide(targetSlide);
                    });
                } else {
                    _.postSlide(targetSlide);
                }
            }
            return;
        }

        if ( _.options.autoplay ) {
            clearInterval(_.autoPlayTimer);
        }

        if (targetSlide < 0) {
            if (_.slideCount % _.options.slidesToScroll !== 0) {
                animSlide = _.slideCount - (_.slideCount % _.options.slidesToScroll);
            } else {
                animSlide = _.slideCount + targetSlide;
            }
        } else if (targetSlide >= _.slideCount) {
            if (_.slideCount % _.options.slidesToScroll !== 0) {
                animSlide = 0;
            } else {
                animSlide = targetSlide - _.slideCount;
            }
        } else {
            animSlide = targetSlide;
        }

        _.animating = true;

        _.$slider.trigger('beforeChange', [_, _.currentSlide, animSlide]);

        oldSlide = _.currentSlide;
        _.currentSlide = animSlide;

        _.setSlideClasses(_.currentSlide);

        if ( _.options.asNavFor ) {

            navTarget = _.getNavTarget();
            navTarget = navTarget.slick('getSlick');

            if ( navTarget.slideCount <= navTarget.options.slidesToShow ) {
                navTarget.setSlideClasses(_.currentSlide);
            }

        }

        _.updateDots();
        _.updateArrows();

        if (_.options.fade === true) {
            if (dontAnimate !== true) {

                _.fadeSlideOut(oldSlide);

                _.fadeSlide(animSlide, function() {
                    _.postSlide(animSlide);
                });

            } else {
                _.postSlide(animSlide);
            }
            _.animateHeight();
            return;
        }

        if (dontAnimate !== true && _.slideCount > _.options.slidesToShow) {
            _.animateSlide(targetLeft, function() {
                _.postSlide(animSlide);
            });
        } else {
            _.postSlide(animSlide);
        }

    };

    Slick.prototype.startLoad = function() {

        var _ = this;

        if (_.options.arrows === true && _.slideCount > _.options.slidesToShow) {

            _.$prevArrow.hide();
            _.$nextArrow.hide();

        }

        if (_.options.dots === true && _.slideCount > _.options.slidesToShow) {

            _.$dots.hide();

        }

        _.$slider.addClass('slick-loading');

    };

    Slick.prototype.swipeDirection = function() {

        var xDist, yDist, r, swipeAngle, _ = this;

        xDist = _.touchObject.startX - _.touchObject.curX;
        yDist = _.touchObject.startY - _.touchObject.curY;
        r = Math.atan2(yDist, xDist);

        swipeAngle = Math.round(r * 180 / Math.PI);
        if (swipeAngle < 0) {
            swipeAngle = 360 - Math.abs(swipeAngle);
        }

        if ((swipeAngle <= 45) && (swipeAngle >= 0)) {
            return (_.options.rtl === false ? 'left' : 'right');
        }
        if ((swipeAngle <= 360) && (swipeAngle >= 315)) {
            return (_.options.rtl === false ? 'left' : 'right');
        }
        if ((swipeAngle >= 135) && (swipeAngle <= 225)) {
            return (_.options.rtl === false ? 'right' : 'left');
        }
        if (_.options.verticalSwiping === true) {
            if ((swipeAngle >= 35) && (swipeAngle <= 135)) {
                return 'down';
            } else {
                return 'up';
            }
        }

        return 'vertical';

    };

    Slick.prototype.swipeEnd = function(event) {

        var _ = this,
            slideCount,
            direction;

        _.dragging = false;
        _.swiping = false;

        if (_.scrolling) {
            _.scrolling = false;
            return false;
        }

        _.interrupted = false;
        _.shouldClick = ( _.touchObject.swipeLength > 10 ) ? false : true;

        if ( _.touchObject.curX === undefined ) {
            return false;
        }

        if ( _.touchObject.edgeHit === true ) {
            _.$slider.trigger('edge', [_, _.swipeDirection() ]);
        }

        if ( _.touchObject.swipeLength >= _.touchObject.minSwipe ) {

            direction = _.swipeDirection();

            switch ( direction ) {

                case 'left':
                case 'down':

                    slideCount =
                        _.options.swipeToSlide ?
                            _.checkNavigable( _.currentSlide + _.getSlideCount() ) :
                            _.currentSlide + _.getSlideCount();

                    _.currentDirection = 0;

                    break;

                case 'right':
                case 'up':

                    slideCount =
                        _.options.swipeToSlide ?
                            _.checkNavigable( _.currentSlide - _.getSlideCount() ) :
                            _.currentSlide - _.getSlideCount();

                    _.currentDirection = 1;

                    break;

                default:


            }

            if( direction != 'vertical' ) {

                _.slideHandler( slideCount );
                _.touchObject = {};
                _.$slider.trigger('swipe', [_, direction ]);

            }

        } else {

            if ( _.touchObject.startX !== _.touchObject.curX ) {

                _.slideHandler( _.currentSlide );
                _.touchObject = {};

            }

        }

    };

    Slick.prototype.swipeHandler = function(event) {

        var _ = this;

        if ((_.options.swipe === false) || ('ontouchend' in document && _.options.swipe === false)) {
            return;
        } else if (_.options.draggable === false && event.type.indexOf('mouse') !== -1) {
            return;
        }

        _.touchObject.fingerCount = event.originalEvent && event.originalEvent.touches !== undefined ?
            event.originalEvent.touches.length : 1;

        _.touchObject.minSwipe = _.listWidth / _.options
            .touchThreshold;

        if (_.options.verticalSwiping === true) {
            _.touchObject.minSwipe = _.listHeight / _.options
                .touchThreshold;
        }

        switch (event.data.action) {

            case 'start':
                _.swipeStart(event);
                break;

            case 'move':
                _.swipeMove(event);
                break;

            case 'end':
                _.swipeEnd(event);
                break;

        }

    };

    Slick.prototype.swipeMove = function(event) {

        var _ = this,
            edgeWasHit = false,
            curLeft, swipeDirection, swipeLength, positionOffset, touches, verticalSwipeLength;

        touches = event.originalEvent !== undefined ? event.originalEvent.touches : null;

        if (!_.dragging || _.scrolling || touches && touches.length !== 1) {
            return false;
        }

        curLeft = _.getLeft(_.currentSlide);

        _.touchObject.curX = touches !== undefined ? touches[0].pageX : event.clientX;
        _.touchObject.curY = touches !== undefined ? touches[0].pageY : event.clientY;

        _.touchObject.swipeLength = Math.round(Math.sqrt(
            Math.pow(_.touchObject.curX - _.touchObject.startX, 2)));

        verticalSwipeLength = Math.round(Math.sqrt(
            Math.pow(_.touchObject.curY - _.touchObject.startY, 2)));

        if (!_.options.verticalSwiping && !_.swiping && verticalSwipeLength > 4) {
            _.scrolling = true;
            return false;
        }

        if (_.options.verticalSwiping === true) {
            _.touchObject.swipeLength = verticalSwipeLength;
        }

        swipeDirection = _.swipeDirection();

        if (event.originalEvent !== undefined && _.touchObject.swipeLength > 4) {
            _.swiping = true;
            event.preventDefault();
        }

        positionOffset = (_.options.rtl === false ? 1 : -1) * (_.touchObject.curX > _.touchObject.startX ? 1 : -1);
        if (_.options.verticalSwiping === true) {
            positionOffset = _.touchObject.curY > _.touchObject.startY ? 1 : -1;
        }


        swipeLength = _.touchObject.swipeLength;

        _.touchObject.edgeHit = false;

        if (_.options.infinite === false) {
            if ((_.currentSlide === 0 && swipeDirection === 'right') || (_.currentSlide >= _.getDotCount() && swipeDirection === 'left')) {
                swipeLength = _.touchObject.swipeLength * _.options.edgeFriction;
                _.touchObject.edgeHit = true;
            }
        }

        if (_.options.vertical === false) {
            _.swipeLeft = curLeft + swipeLength * positionOffset;
        } else {
            _.swipeLeft = curLeft + (swipeLength * (_.$list.height() / _.listWidth)) * positionOffset;
        }
        if (_.options.verticalSwiping === true) {
            _.swipeLeft = curLeft + swipeLength * positionOffset;
        }

        if (_.options.fade === true || _.options.touchMove === false) {
            return false;
        }

        if (_.animating === true) {
            _.swipeLeft = null;
            return false;
        }

        _.setCSS(_.swipeLeft);

    };

    Slick.prototype.swipeStart = function(event) {

        var _ = this,
            touches;

        _.interrupted = true;

        if (_.touchObject.fingerCount !== 1 || _.slideCount <= _.options.slidesToShow) {
            _.touchObject = {};
            return false;
        }

        if (event.originalEvent !== undefined && event.originalEvent.touches !== undefined) {
            touches = event.originalEvent.touches[0];
        }

        _.touchObject.startX = _.touchObject.curX = touches !== undefined ? touches.pageX : event.clientX;
        _.touchObject.startY = _.touchObject.curY = touches !== undefined ? touches.pageY : event.clientY;

        _.dragging = true;

    };

    Slick.prototype.unfilterSlides = Slick.prototype.slickUnfilter = function() {

        var _ = this;

        if (_.$slidesCache !== null) {

            _.unload();

            _.$slideTrack.children(this.options.slide).detach();

            _.$slidesCache.appendTo(_.$slideTrack);

            _.reinit();

        }

    };

    Slick.prototype.unload = function() {

        var _ = this;

        $('.slick-cloned', _.$slider).remove();

        if (_.$dots) {
            _.$dots.remove();
        }

        if (_.$prevArrow && _.htmlExpr.test(_.options.prevArrow)) {
            _.$prevArrow.remove();
        }

        if (_.$nextArrow && _.htmlExpr.test(_.options.nextArrow)) {
            _.$nextArrow.remove();
        }

        _.$slides
            .removeClass('slick-slide slick-active slick-visible slick-current')
            .attr('aria-hidden', 'true')
            .css('width', '');

    };

    Slick.prototype.unslick = function(fromBreakpoint) {

        var _ = this;
        _.$slider.trigger('unslick', [_, fromBreakpoint]);
        _.destroy();

    };

    Slick.prototype.updateArrows = function() {

        var _ = this,
            centerOffset;

        centerOffset = Math.floor(_.options.slidesToShow / 2);

        if ( _.options.arrows === true &&
            _.slideCount > _.options.slidesToShow &&
            !_.options.infinite ) {

            _.$prevArrow.removeClass('slick-disabled').attr('aria-disabled', 'false');
            _.$nextArrow.removeClass('slick-disabled').attr('aria-disabled', 'false');

            if (_.currentSlide === 0) {

                _.$prevArrow.addClass('slick-disabled').attr('aria-disabled', 'true');
                _.$nextArrow.removeClass('slick-disabled').attr('aria-disabled', 'false');

            } else if (_.currentSlide >= _.slideCount - _.options.slidesToShow && _.options.centerMode === false) {

                _.$nextArrow.addClass('slick-disabled').attr('aria-disabled', 'true');
                _.$prevArrow.removeClass('slick-disabled').attr('aria-disabled', 'false');

            } else if (_.currentSlide >= _.slideCount - 1 && _.options.centerMode === true) {

                _.$nextArrow.addClass('slick-disabled').attr('aria-disabled', 'true');
                _.$prevArrow.removeClass('slick-disabled').attr('aria-disabled', 'false');

            }

        }

    };

    Slick.prototype.updateDots = function() {

        var _ = this;

        if (_.$dots !== null) {

            _.$dots
                .find('li')
                    .removeClass('slick-active')
                    .end();

            _.$dots
                .find('li')
                .eq(Math.floor(_.currentSlide / _.options.slidesToScroll))
                .addClass('slick-active');

        }

    };

    Slick.prototype.visibility = function() {

        var _ = this;

        if ( _.options.autoplay ) {

            if ( document[_.hidden] ) {

                _.interrupted = true;

            } else {

                _.interrupted = false;

            }

        }

    };

    $.fn.slick = function() {
        var _ = this,
            opt = arguments[0],
            args = Array.prototype.slice.call(arguments, 1),
            l = _.length,
            i,
            ret;
        for (i = 0; i < l; i++) {
            if (typeof opt == 'object' || typeof opt == 'undefined')
                _[i].slick = new Slick(_[i], opt);
            else
                ret = _[i].slick[opt].apply(_[i].slick, args);
            if (typeof ret != 'undefined') return ret;
        }
        return _;
    };

}));

// Sticky Plugin v1.0.4 for jQuery
// =============
// Author: Anthony Garand
// Improvements by German M. Bravo (Kronuz) and Ruud Kamphuis (ruudk)
// Improvements by Leonardo C. Daronco (daronco)
// Created: 02/14/2011
// Date: 07/20/2015
// Website: http://stickyjs.com/
// Description: Makes an element on the page stick on the screen as you scroll
//              It will only set the 'top' and 'position' of your element, you
//              might need to adjust the width in some cases.

(function (factory) {
    if (typeof define === 'function' && define.amd) {
        // AMD. Register as an anonymous module.
        define(['jquery'], factory);
    } else if (typeof module === 'object' && module.exports) {
        // Node/CommonJS
        module.exports = factory(require('jquery'));
    } else {
        // Browser globals
        factory(jQuery);
    }
}(function ($) {
    var slice = Array.prototype.slice; // save ref to original slice()
    var splice = Array.prototype.splice; // save ref to original slice()

  var defaults = {
      topSpacing: 0,
      bottomSpacing: 0,
      className: 'is-sticky',
      wrapperClassName: 'sticky-wrapper',
      center: false,
      getWidthFrom: '',
      widthFromWrapper: true, // works only when .getWidthFrom is empty
      responsiveWidth: false,
      zIndex: 'inherit'
    },
    $window = $(window),
    $document = $(document),
    sticked = [],
    windowHeight = $window.height(),
    scroller = function() {
      var scrollTop = $window.scrollTop(),
        documentHeight = $document.height(),
        dwh = documentHeight - windowHeight,
        extra = (scrollTop > dwh) ? dwh - scrollTop : 0;

      for (var i = 0, l = sticked.length; i < l; i++) {
        var s = sticked[i],
          elementTop = s.stickyWrapper.offset().top,
          etse = elementTop - s.topSpacing - extra;

        //update height in case of dynamic content
        s.stickyWrapper.css('height', s.stickyElement.outerHeight());

        if (scrollTop <= etse) {
          if (s.currentTop !== null) {
            s.stickyElement
              .css({
                'width': '',
                'position': '',
                'top': '',
                'z-index': ''
              });
            s.stickyElement.parent().removeClass(s.className);
            s.stickyElement.trigger('sticky-end', [s]);
            s.currentTop = null;
          }
        }
        else {
          var newTop = documentHeight - s.stickyElement.outerHeight()
            - s.topSpacing - s.bottomSpacing - scrollTop - extra;
          if (newTop < 0) {
            newTop = newTop + s.topSpacing;
          } else {
            newTop = s.topSpacing;
          }
          if (s.currentTop !== newTop) {
            var newWidth;
            if (s.getWidthFrom) {
                padding =  s.stickyElement.innerWidth() - s.stickyElement.width();
                newWidth = $(s.getWidthFrom).width() - padding || null;
            } else if (s.widthFromWrapper) {
                newWidth = s.stickyWrapper.width();
            }
            if (newWidth == null) {
                newWidth = s.stickyElement.width();
            }
            s.stickyElement
              .css('width', newWidth)
              .css('position', 'fixed')
              .css('top', newTop)
              .css('z-index', s.zIndex);

            s.stickyElement.parent().addClass(s.className);

            if (s.currentTop === null) {
              s.stickyElement.trigger('sticky-start', [s]);
            } else {
              // sticky is started but it have to be repositioned
              s.stickyElement.trigger('sticky-update', [s]);
            }

            if (s.currentTop === s.topSpacing && s.currentTop > newTop || s.currentTop === null && newTop < s.topSpacing) {
              // just reached bottom || just started to stick but bottom is already reached
              s.stickyElement.trigger('sticky-bottom-reached', [s]);
            } else if(s.currentTop !== null && newTop === s.topSpacing && s.currentTop < newTop) {
              // sticky is started && sticked at topSpacing && overflowing from top just finished
              s.stickyElement.trigger('sticky-bottom-unreached', [s]);
            }

            s.currentTop = newTop;
          }

          // Check if sticky has reached end of container and stop sticking
          var stickyWrapperContainer = s.stickyWrapper.parent();
          var unstick = (s.stickyElement.offset().top + s.stickyElement.outerHeight() >= stickyWrapperContainer.offset().top + stickyWrapperContainer.outerHeight()) && (s.stickyElement.offset().top <= s.topSpacing);

          if( unstick ) {
            s.stickyElement
              .css('position', 'absolute')
              .css('top', '')
              .css('bottom', 0)
              .css('z-index', '');
          } else {
            s.stickyElement
              .css('position', 'fixed')
              .css('top', newTop)
              .css('bottom', '')
              .css('z-index', s.zIndex);
          }
        }
      }
    },
    resizer = function() {
      windowHeight = $window.height();

      for (var i = 0, l = sticked.length; i < l; i++) {
        var s = sticked[i];
        var newWidth = null;
        if (s.getWidthFrom) {
            if (s.responsiveWidth) {
                newWidth = $(s.getWidthFrom).width();
            }
        } else if(s.widthFromWrapper) {
            newWidth = s.stickyWrapper.width();
        }
        if (newWidth != null) {
            s.stickyElement.css('width', newWidth);
        }
      }
    },
    methods = {
      init: function(options) {
        return this.each(function() {
          var o = $.extend({}, defaults, options);
          var stickyElement = $(this);

          var stickyId = stickyElement.attr('id');
          var wrapperId = stickyId ? stickyId + '-' + defaults.wrapperClassName : defaults.wrapperClassName;
          var wrapper = $('<div></div>')
            .attr('id', wrapperId)
            .addClass(o.wrapperClassName);

          stickyElement.wrapAll(function() {
            if ($(this).parent("#" + wrapperId).length == 0) {
                    return wrapper;
            }
});

          var stickyWrapper = stickyElement.parent();

          if (o.center) {
            stickyWrapper.css({width:stickyElement.outerWidth(),marginLeft:"auto",marginRight:"auto"});
          }

          if (stickyElement.css("float") === "right") {
            stickyElement.css({"float":"none"}).parent().css({"float":"right"});
          }

          o.stickyElement = stickyElement;
          o.stickyWrapper = stickyWrapper;
          o.currentTop    = null;

          sticked.push(o);

          methods.setWrapperHeight(this);
          methods.setupChangeListeners(this);
        });
      },

      setWrapperHeight: function(stickyElement) {
        var element = $(stickyElement);
        var stickyWrapper = element.parent();
        if (stickyWrapper) {
          stickyWrapper.css('height', element.outerHeight());
        }
      },

      setupChangeListeners: function(stickyElement) {
        if (window.MutationObserver) {
          var mutationObserver = new window.MutationObserver(function(mutations) {
            if (mutations[0].addedNodes.length || mutations[0].removedNodes.length) {
              methods.setWrapperHeight(stickyElement);
            }
          });
          mutationObserver.observe(stickyElement, {subtree: true, childList: true});
        } else {
          if (window.addEventListener) {
            stickyElement.addEventListener('DOMNodeInserted', function() {
              methods.setWrapperHeight(stickyElement);
            }, false);
            stickyElement.addEventListener('DOMNodeRemoved', function() {
              methods.setWrapperHeight(stickyElement);
            }, false);
          } else if (window.attachEvent) {
            stickyElement.attachEvent('onDOMNodeInserted', function() {
              methods.setWrapperHeight(stickyElement);
            });
            stickyElement.attachEvent('onDOMNodeRemoved', function() {
              methods.setWrapperHeight(stickyElement);
            });
          }
        }
      },
      update: scroller,
      unstick: function(options) {
        return this.each(function() {
          var that = this;
          var unstickyElement = $(that);

          var removeIdx = -1;
          var i = sticked.length;
          while (i-- > 0) {
            if (sticked[i].stickyElement.get(0) === that) {
                splice.call(sticked,i,1);
                removeIdx = i;
            }
          }
          if(removeIdx !== -1) {
            unstickyElement.unwrap();
            unstickyElement
              .css({
                'width': '',
                'position': '',
                'top': '',
                'float': '',
                'z-index': ''
              })
            ;
          }
        });
      }
    };

  // should be more efficient than using $window.scroll(scroller) and $window.resize(resizer):
  if (window.addEventListener) {
    window.addEventListener('scroll', scroller, false);
    window.addEventListener('resize', resizer, false);
  } else if (window.attachEvent) {
    window.attachEvent('onscroll', scroller);
    window.attachEvent('onresize', resizer);
  }

  $.fn.sticky = function(method) {
    if (methods[method]) {
      return methods[method].apply(this, slice.call(arguments, 1));
    } else if (typeof method === 'object' || !method ) {
      return methods.init.apply( this, arguments );
    } else {
      $.error('Method ' + method + ' does not exist on jQuery.sticky');
    }
  };

  $.fn.unstick = function(method) {
    if (methods[method]) {
      return methods[method].apply(this, slice.call(arguments, 1));
    } else if (typeof method === 'object' || !method ) {
      return methods.unstick.apply( this, arguments );
    } else {
      $.error('Method ' + method + ' does not exist on jQuery.sticky');
    }
  };
  $(function() {
    setTimeout(scroller, 0);
  });
}));
/*!
 * jQuery Validation Plugin v1.16.0
 *
 * http://jqueryvalidation.org/
 *
 * Copyright (c) 2016 JÃ¶rn Zaefferer
 * Released under the MIT license
 */
(function( factory ) {
  if ( typeof define === "function" && define.amd ) {
    define( ["jquery"], factory );
  } else if (typeof module === "object" && module.exports) {
    module.exports = factory( require( "jquery" ) );
  } else {
    factory( jQuery );
  }
}(function( $ ) {

$.extend( $.fn, {

  // http://jqueryvalidation.org/validate/
  validate: function( options ) {

    // If nothing is selected, return nothing; can't chain anyway
    if ( !this.length ) {
      if ( options && options.debug && window.console ) {
        console.warn( "Nothing selected, can't validate, returning nothing." );
      }
      return;
    }

    // Check if a validator for this form was already created
    var validator = $.data( this[ 0 ], "validator" );
    if ( validator ) {
      return validator;
    }

    // Add novalidate tag if HTML5.
    this.attr( "novalidate", "novalidate" );

    validator = new $.validator( options, this[ 0 ] );
    $.data( this[ 0 ], "validator", validator );

    if ( validator.settings.onsubmit ) {

      this.on( "click.validate", ":submit", function( event ) {
        if ( validator.settings.submitHandler ) {
          validator.submitButton = event.target;
        }

        // Allow suppressing validation by adding a cancel class to the submit button
        if ( $( this ).hasClass( "cancel" ) ) {
          validator.cancelSubmit = true;
        }

        // Allow suppressing validation by adding the html5 formnovalidate attribute to the submit button
        if ( $( this ).attr( "formnovalidate" ) !== undefined ) {
          validator.cancelSubmit = true;
        }
      } );

      // Validate the form on submit
      this.on( "submit.validate", function( event ) {
        if ( validator.settings.debug ) {

          // Prevent form submit to be able to see console output
          event.preventDefault();
        }
        function handle() {
          var hidden, result;
          if ( validator.settings.submitHandler ) {
            if ( validator.submitButton ) {

              // Insert a hidden input as a replacement for the missing submit button
              hidden = $( "<input type='hidden'/>" )
                .attr( "name", validator.submitButton.name )
                .val( $( validator.submitButton ).val() )
                .appendTo( validator.currentForm );
            }
            result = validator.settings.submitHandler.call( validator, validator.currentForm, event );
            if ( validator.submitButton ) {

              // And clean up afterwards; thanks to no-block-scope, hidden can be referenced
              hidden.remove();
            }
            if ( result !== undefined ) {
              return result;
            }
            return false;
          }
          return true;
        }

        // Prevent submit for invalid forms or custom submit handlers
        if ( validator.cancelSubmit ) {
          validator.cancelSubmit = false;
          return handle();
        }
        if ( validator.form() ) {
          if ( validator.pendingRequest ) {
            validator.formSubmitted = true;
            return false;
          }
          return handle();
        } else {
          validator.focusInvalid();
          return false;
        }
      } );
    }

    return validator;
  },

  // http://jqueryvalidation.org/valid/
  valid: function() {
    var valid, validator, errorList;

    if ( $( this[ 0 ] ).is( "form" ) ) {
      valid = this.validate().form();
    } else {
      errorList = [];
      valid = true;
      validator = $( this[ 0 ].form ).validate();
      this.each( function() {
        valid = validator.element( this ) && valid;
        if ( !valid ) {
          errorList = errorList.concat( validator.errorList );
        }
      } );
      validator.errorList = errorList;
    }
    return valid;
  },

  // http://jqueryvalidation.org/rules/
  rules: function( command, argument ) {
    var element = this[ 0 ],
      settings, staticRules, existingRules, data, param, filtered;

    // If nothing is selected, return empty object; can't chain anyway
    if ( element == null || element.form == null ) {
      return;
    }

    if ( command ) {
      settings = $.data( element.form, "validator" ).settings;
      staticRules = settings.rules;
      existingRules = $.validator.staticRules( element );
      switch ( command ) {
      case "add":
        $.extend( existingRules, $.validator.normalizeRule( argument ) );

        // Remove messages from rules, but allow them to be set separately
        delete existingRules.messages;
        staticRules[ element.name ] = existingRules;
        if ( argument.messages ) {
          settings.messages[ element.name ] = $.extend( settings.messages[ element.name ], argument.messages );
        }
        break;
      case "remove":
        if ( !argument ) {
          delete staticRules[ element.name ];
          return existingRules;
        }
        filtered = {};
        $.each( argument.split( /\s/ ), function( index, method ) {
          filtered[ method ] = existingRules[ method ];
          delete existingRules[ method ];
          if ( method === "required" ) {
            $( element ).removeAttr( "aria-required" );
          }
        } );
        return filtered;
      }
    }

    data = $.validator.normalizeRules(
    $.extend(
      {},
      $.validator.classRules( element ),
      $.validator.attributeRules( element ),
      $.validator.dataRules( element ),
      $.validator.staticRules( element )
    ), element );

    // Make sure required is at front
    if ( data.required ) {
      param = data.required;
      delete data.required;
      data = $.extend( { required: param }, data );
      $( element ).attr( "aria-required", "true" );
    }

    // Make sure remote is at back
    if ( data.remote ) {
      param = data.remote;
      delete data.remote;
      data = $.extend( data, { remote: param } );
    }

    return data;
  }
} );

// Custom selectors
$.extend( $.expr.pseudos || $.expr[ ":" ], {    // '|| $.expr[ ":" ]' here enables backwards compatibility to jQuery 1.7. Can be removed when dropping jQ 1.7.x support

  // http://jqueryvalidation.org/blank-selector/
  blank: function( a ) {
    return !$.trim( "" + $( a ).val() );
  },

  // http://jqueryvalidation.org/filled-selector/
  filled: function( a ) {
    var val = $( a ).val();
    return val !== null && !!$.trim( "" + val );
  },

  // http://jqueryvalidation.org/unchecked-selector/
  unchecked: function( a ) {
    return !$( a ).prop( "checked" );
  }
} );

// Constructor for validator
$.validator = function( options, form ) {
  this.settings = $.extend( true, {}, $.validator.defaults, options );
  this.currentForm = form;
  this.init();
};

// http://jqueryvalidation.org/jQuery.validator.format/
$.validator.format = function( source, params ) {
  if ( arguments.length === 1 ) {
    return function() {
      var args = $.makeArray( arguments );
      args.unshift( source );
      return $.validator.format.apply( this, args );
    };
  }
  if ( params === undefined ) {
    return source;
  }
  if ( arguments.length > 2 && params.constructor !== Array  ) {
    params = $.makeArray( arguments ).slice( 1 );
  }
  if ( params.constructor !== Array ) {
    params = [ params ];
  }
  $.each( params, function( i, n ) {
    source = source.replace( new RegExp( "\\{" + i + "\\}", "g" ), function() {
      return n;
    } );
  } );
  return source;
};

$.extend( $.validator, {

  defaults: {
    messages: {},
    groups: {},
    rules: {},
    errorClass: "error",
    pendingClass: "pending",
    validClass: "valid",
    errorElement: "label",
    focusCleanup: false,
    focusInvalid: true,
    errorContainer: $( [] ),
    errorLabelContainer: $( [] ),
    onsubmit: true,
    ignore: ":hidden",
    ignoreTitle: false,
    onfocusin: function( element ) {
      this.lastActive = element;

      // Hide error label and remove error class on focus if enabled
      if ( this.settings.focusCleanup ) {
        if ( this.settings.unhighlight ) {
          this.settings.unhighlight.call( this, element, this.settings.errorClass, this.settings.validClass );
        }
        this.hideThese( this.errorsFor( element ) );
      }
    },
    onfocusout: function( element ) {
      if ( !this.checkable( element ) && ( element.name in this.submitted || !this.optional( element ) ) ) {
        this.element( element );
      }
    },
    onkeyup: function( element, event ) {

      // Avoid revalidate the field when pressing one of the following keys
      // Shift       => 16
      // Ctrl        => 17
      // Alt         => 18
      // Caps lock   => 20
      // End         => 35
      // Home        => 36
      // Left arrow  => 37
      // Up arrow    => 38
      // Right arrow => 39
      // Down arrow  => 40
      // Insert      => 45
      // Num lock    => 144
      // AltGr key   => 225
      var excludedKeys = [
        16, 17, 18, 20, 35, 36, 37,
        38, 39, 40, 45, 144, 225
      ];

      if ( event.which === 9 && this.elementValue( element ) === "" || $.inArray( event.keyCode, excludedKeys ) !== -1 ) {
        return;
      } else if ( element.name in this.submitted || element.name in this.invalid ) {
        this.element( element );
      }
    },
    onclick: function( element ) {

      // Click on selects, radiobuttons and checkboxes
      if ( element.name in this.submitted ) {
        this.element( element );

      // Or option elements, check parent select in that case
      } else if ( element.parentNode.name in this.submitted ) {
        this.element( element.parentNode );
      }
    },
    highlight: function( element, errorClass, validClass ) {
      if ( element.type === "radio" ) {
        this.findByName( element.name ).addClass( errorClass ).removeClass( validClass );
      } else {
        $( element ).addClass( errorClass ).removeClass( validClass );
      }
    },
    unhighlight: function( element, errorClass, validClass ) {
      if ( element.type === "radio" ) {
        this.findByName( element.name ).removeClass( errorClass ).addClass( validClass );
      } else {
        $( element ).removeClass( errorClass ).addClass( validClass );
      }
    }
  },

  // http://jqueryvalidation.org/jQuery.validator.setDefaults/
  setDefaults: function( settings ) {
    $.extend( $.validator.defaults, settings );
  },

  messages: {
    required: "This field is required.",
    remote: "Please fix this field.",
    email: "Please enter a valid email address.",
    url: "Please enter a valid URL.",
    date: "Please enter a valid date.",
    dateISO: "Please enter a valid date (ISO).",
    number: "Please enter a valid number.",
    digits: "Please enter only digits.",
    equalTo: "Please enter the same value again.",
    maxlength: $.validator.format( "Please enter no more than {0} characters." ),
    minlength: $.validator.format( "Please enter at least {0} characters." ),
    rangelength: $.validator.format( "Please enter a value between {0} and {1} characters long." ),
    range: $.validator.format( "Please enter a value between {0} and {1}." ),
    max: $.validator.format( "Please enter a value less than or equal to {0}." ),
    min: $.validator.format( "Please enter a value greater than or equal to {0}." ),
    step: $.validator.format( "Please enter a multiple of {0}." )
  },

  autoCreateRanges: false,

  prototype: {

    init: function() {
      this.labelContainer = $( this.settings.errorLabelContainer );
      this.errorContext = this.labelContainer.length && this.labelContainer || $( this.currentForm );
      this.containers = $( this.settings.errorContainer ).add( this.settings.errorLabelContainer );
      this.submitted = {};
      this.valueCache = {};
      this.pendingRequest = 0;
      this.pending = {};
      this.invalid = {};
      this.reset();

      var groups = ( this.groups = {} ),
        rules;
      $.each( this.settings.groups, function( key, value ) {
        if ( typeof value === "string" ) {
          value = value.split( /\s/ );
        }
        $.each( value, function( index, name ) {
          groups[ name ] = key;
        } );
      } );
      rules = this.settings.rules;
      $.each( rules, function( key, value ) {
        rules[ key ] = $.validator.normalizeRule( value );
      } );

      function delegate( event ) {

        // Set form expando on contenteditable
        if ( !this.form && this.hasAttribute( "contenteditable" ) ) {
          this.form = $( this ).closest( "form" )[ 0 ];
        }

        var validator = $.data( this.form, "validator" ),
          eventType = "on" + event.type.replace( /^validate/, "" ),
          settings = validator.settings;
        if ( settings[ eventType ] && !$( this ).is( settings.ignore ) ) {
          settings[ eventType ].call( validator, this, event );
        }
      }

      $( this.currentForm )
        .on( "focusin.validate focusout.validate keyup.validate",
          ":text, [type='password'], [type='file'], select, textarea, [type='number'], [type='search'], " +
          "[type='tel'], [type='url'], [type='email'], [type='datetime'], [type='date'], [type='month'], " +
          "[type='week'], [type='time'], [type='datetime-local'], [type='range'], [type='color'], " +
          "[type='radio'], [type='checkbox'], [contenteditable], [type='button']", delegate )

        // Support: Chrome, oldIE
        // "select" is provided as event.target when clicking a option
        .on( "click.validate", "select, option, [type='radio'], [type='checkbox']", delegate );

      if ( this.settings.invalidHandler ) {
        $( this.currentForm ).on( "invalid-form.validate", this.settings.invalidHandler );
      }

      // Add aria-required to any Static/Data/Class required fields before first validation
      // Screen readers require this attribute to be present before the initial submission http://www.w3.org/TR/WCAG-TECHS/ARIA2.html
      $( this.currentForm ).find( "[required], [data-rule-required], .required" ).attr( "aria-required", "true" );
    },

    // http://jqueryvalidation.org/Validator.form/
    form: function() {
      this.checkForm();
      $.extend( this.submitted, this.errorMap );
      this.invalid = $.extend( {}, this.errorMap );
      if ( !this.valid() ) {
        $( this.currentForm ).triggerHandler( "invalid-form", [ this ] );
      }
      this.showErrors();
      return this.valid();
    },

    checkForm: function() {
      this.prepareForm();
      for ( var i = 0, elements = ( this.currentElements = this.elements() ); elements[ i ]; i++ ) {
        this.check( elements[ i ] );
      }
      return this.valid();
    },

    // http://jqueryvalidation.org/Validator.element/
    element: function( element ) {
      var cleanElement = this.clean( element ),
        checkElement = this.validationTargetFor( cleanElement ),
        v = this,
        result = true,
        rs, group;

      if ( checkElement === undefined ) {
        delete this.invalid[ cleanElement.name ];
      } else {
        this.prepareElement( checkElement );
        this.currentElements = $( checkElement );

        // If this element is grouped, then validate all group elements already
        // containing a value
        group = this.groups[ checkElement.name ];
        if ( group ) {
          $.each( this.groups, function( name, testgroup ) {
            if ( testgroup === group && name !== checkElement.name ) {
              cleanElement = v.validationTargetFor( v.clean( v.findByName( name ) ) );
              if ( cleanElement && cleanElement.name in v.invalid ) {
                v.currentElements.push( cleanElement );
                result = v.check( cleanElement ) && result;
              }
            }
          } );
        }

        rs = this.check( checkElement ) !== false;
        result = result && rs;
        if ( rs ) {
          this.invalid[ checkElement.name ] = false;
        } else {
          this.invalid[ checkElement.name ] = true;
        }

        if ( !this.numberOfInvalids() ) {

          // Hide error containers on last error
          this.toHide = this.toHide.add( this.containers );
        }
        this.showErrors();

        // Add aria-invalid status for screen readers
        $( element ).attr( "aria-invalid", !rs );
      }

      return result;
    },

    // http://jqueryvalidation.org/Validator.showErrors/
    showErrors: function( errors ) {
      if ( errors ) {
        var validator = this;

        // Add items to error list and map
        $.extend( this.errorMap, errors );
        this.errorList = $.map( this.errorMap, function( message, name ) {
          return {
            message: message,
            element: validator.findByName( name )[ 0 ]
          };
        } );

        // Remove items from success list
        this.successList = $.grep( this.successList, function( element ) {
          return !( element.name in errors );
        } );
      }
      if ( this.settings.showErrors ) {
        this.settings.showErrors.call( this, this.errorMap, this.errorList );
      } else {
        this.defaultShowErrors();
      }
    },

    // http://jqueryvalidation.org/Validator.resetForm/
    resetForm: function() {
      if ( $.fn.resetForm ) {
        $( this.currentForm ).resetForm();
      }
      this.invalid = {};
      this.submitted = {};
      this.prepareForm();
      this.hideErrors();
      var elements = this.elements()
        .removeData( "previousValue" )
        .removeAttr( "aria-invalid" );

      this.resetElements( elements );
    },

    resetElements: function( elements ) {
      var i;

      if ( this.settings.unhighlight ) {
        for ( i = 0; elements[ i ]; i++ ) {
          this.settings.unhighlight.call( this, elements[ i ],
            this.settings.errorClass, "" );
          this.findByName( elements[ i ].name ).removeClass( this.settings.validClass );
        }
      } else {
        elements
          .removeClass( this.settings.errorClass )
          .removeClass( this.settings.validClass );
      }
    },

    numberOfInvalids: function() {
      return this.objectLength( this.invalid );
    },

    objectLength: function( obj ) {
      /* jshint unused: false */
      var count = 0,
        i;
      for ( i in obj ) {
        if ( obj[ i ] ) {
          count++;
        }
      }
      return count;
    },

    hideErrors: function() {
      this.hideThese( this.toHide );
    },

    hideThese: function( errors ) {
      errors.not( this.containers ).text( "" );
      this.addWrapper( errors ).hide();
    },

    valid: function() {
      return this.size() === 0;
    },

    size: function() {
      return this.errorList.length;
    },

    focusInvalid: function() {
      if ( this.settings.focusInvalid ) {
        try {
          $( this.findLastActive() || this.errorList.length && this.errorList[ 0 ].element || [] )
          .filter( ":visible" )
          .focus()

          // Manually trigger focusin event; without it, focusin handler isn't called, findLastActive won't have anything to find
          .trigger( "focusin" );
        } catch ( e ) {

          // Ignore IE throwing errors when focusing hidden elements
        }
      }
    },

    findLastActive: function() {
      var lastActive = this.lastActive;
      return lastActive && $.grep( this.errorList, function( n ) {
        return n.element.name === lastActive.name;
      } ).length === 1 && lastActive;
    },

    elements: function() {
      var validator = this,
        rulesCache = {};

      // Select all valid inputs inside the form (no submit or reset buttons)
      return $( this.currentForm )
      .find( "input, select, textarea, [contenteditable]" )
      .not( ":submit, :reset, :image, :disabled" )
      .not( this.settings.ignore )
      .filter( function() {
        var name = this.name || $( this ).attr( "name" ); // For contenteditable
        if ( !name && validator.settings.debug && window.console ) {
          console.error( "%o has no name assigned", this );
        }

        // Set form expando on contenteditable
        if ( this.hasAttribute( "contenteditable" ) ) {
          this.form = $( this ).closest( "form" )[ 0 ];
        }

        // Select only the first element for each name, and only those with rules specified
        if ( name in rulesCache || !validator.objectLength( $( this ).rules() ) ) {
          return false;
        }

        rulesCache[ name ] = true;
        return true;
      } );
    },

    clean: function( selector ) {
      return $( selector )[ 0 ];
    },

    errors: function() {
      var errorClass = this.settings.errorClass.split( " " ).join( "." );
      return $( this.settings.errorElement + "." + errorClass, this.errorContext );
    },

    resetInternals: function() {
      this.successList = [];
      this.errorList = [];
      this.errorMap = {};
      this.toShow = $( [] );
      this.toHide = $( [] );
    },

    reset: function() {
      this.resetInternals();
      this.currentElements = $( [] );
    },

    prepareForm: function() {
      this.reset();
      this.toHide = this.errors().add( this.containers );
    },

    prepareElement: function( element ) {
      this.reset();
      this.toHide = this.errorsFor( element );
    },

    elementValue: function( element ) {
      var $element = $( element ),
        type = element.type,
        val, idx;

      if ( type === "radio" || type === "checkbox" ) {
        return this.findByName( element.name ).filter( ":checked" ).val();
      } else if ( type === "number" && typeof element.validity !== "undefined" ) {
        return element.validity.badInput ? "NaN" : $element.val();
      }

      if ( element.hasAttribute( "contenteditable" ) ) {
        val = $element.text();
      } else {
        val = $element.val();
      }

      if ( type === "file" ) {

        // Modern browser (chrome & safari)
        if ( val.substr( 0, 12 ) === "C:\\fakepath\\" ) {
          return val.substr( 12 );
        }

        // Legacy browsers
        // Unix-based path
        idx = val.lastIndexOf( "/" );
        if ( idx >= 0 ) {
          return val.substr( idx + 1 );
        }

        // Windows-based path
        idx = val.lastIndexOf( "\\" );
        if ( idx >= 0 ) {
          return val.substr( idx + 1 );
        }

        // Just the file name
        return val;
      }

      if ( typeof val === "string" ) {
        return val.replace( /\r/g, "" );
      }
      return val;
    },

    check: function( element ) {
      element = this.validationTargetFor( this.clean( element ) );

      var rules = $( element ).rules(),
        rulesCount = $.map( rules, function( n, i ) {
          return i;
        } ).length,
        dependencyMismatch = false,
        val = this.elementValue( element ),
        result, method, rule;

      // If a normalizer is defined for this element, then
      // call it to retreive the changed value instead
      // of using the real one.
      // Note that `this` in the normalizer is `element`.
      if ( typeof rules.normalizer === "function" ) {
        val = rules.normalizer.call( element, val );

        if ( typeof val !== "string" ) {
          throw new TypeError( "The normalizer should return a string value." );
        }

        // Delete the normalizer from rules to avoid treating
        // it as a pre-defined method.
        delete rules.normalizer;
      }

      for ( method in rules ) {
        rule = { method: method, parameters: rules[ method ] };
        try {
          result = $.validator.methods[ method ].call( this, val, element, rule.parameters );

          // If a method indicates that the field is optional and therefore valid,
          // don't mark it as valid when there are no other rules
          if ( result === "dependency-mismatch" && rulesCount === 1 ) {
            dependencyMismatch = true;
            continue;
          }
          dependencyMismatch = false;

          if ( result === "pending" ) {
            this.toHide = this.toHide.not( this.errorsFor( element ) );
            return;
          }

          if ( !result ) {
            this.formatAndAdd( element, rule );
            return false;
          }
        } catch ( e ) {
          if ( this.settings.debug && window.console ) {
            console.log( "Exception occurred when checking element " + element.id + ", check the '" + rule.method + "' method.", e );
          }
          if ( e instanceof TypeError ) {
            e.message += ".  Exception occurred when checking element " + element.id + ", check the '" + rule.method + "' method.";
          }

          throw e;
        }
      }
      if ( dependencyMismatch ) {
        return;
      }
      if ( this.objectLength( rules ) ) {
        this.successList.push( element );
      }
      return true;
    },

    // Return the custom message for the given element and validation method
    // specified in the element's HTML5 data attribute
    // return the generic message if present and no method specific message is present
    customDataMessage: function( element, method ) {
      return $( element ).data( "msg" + method.charAt( 0 ).toUpperCase() +
        method.substring( 1 ).toLowerCase() ) || $( element ).data( "msg" );
    },

    // Return the custom message for the given element name and validation method
    customMessage: function( name, method ) {
      var m = this.settings.messages[ name ];
      return m && ( m.constructor === String ? m : m[ method ] );
    },

    // Return the first defined argument, allowing empty strings
    findDefined: function() {
      for ( var i = 0; i < arguments.length; i++ ) {
        if ( arguments[ i ] !== undefined ) {
          return arguments[ i ];
        }
      }
      return undefined;
    },

    // The second parameter 'rule' used to be a string, and extended to an object literal
    // of the following form:
    // rule = {
    //     method: "method name",
    //     parameters: "the given method parameters"
    // }
    //
    // The old behavior still supported, kept to maintain backward compatibility with
    // old code, and will be removed in the next major release.
    defaultMessage: function( element, rule ) {
      if ( typeof rule === "string" ) {
        rule = { method: rule };
      }

      var message = this.findDefined(
          this.customMessage( element.name, rule.method ),
          this.customDataMessage( element, rule.method ),

          // 'title' is never undefined, so handle empty string as undefined
          !this.settings.ignoreTitle && element.title || undefined,
          $.validator.messages[ rule.method ],
          "<strong>Warning: No message defined for " + element.name + "</strong>"
        ),
        theregex = /\$?\{(\d+)\}/g;
      if ( typeof message === "function" ) {
        message = message.call( this, rule.parameters, element );
      } else if ( theregex.test( message ) ) {
        message = $.validator.format( message.replace( theregex, "{$1}" ), rule.parameters );
      }

      return message;
    },

    formatAndAdd: function( element, rule ) {
      var message = this.defaultMessage( element, rule );

      this.errorList.push( {
        message: message,
        element: element,
        method: rule.method
      } );

      this.errorMap[ element.name ] = message;
      this.submitted[ element.name ] = message;
    },

    addWrapper: function( toToggle ) {
      if ( this.settings.wrapper ) {
        toToggle = toToggle.add( toToggle.parent( this.settings.wrapper ) );
      }
      return toToggle;
    },

    defaultShowErrors: function() {
      var i, elements, error;
      for ( i = 0; this.errorList[ i ]; i++ ) {
        error = this.errorList[ i ];
        if ( this.settings.highlight ) {
          this.settings.highlight.call( this, error.element, this.settings.errorClass, this.settings.validClass );
        }
        this.showLabel( error.element, error.message );
      }
      if ( this.errorList.length ) {
        this.toShow = this.toShow.add( this.containers );
      }
      if ( this.settings.success ) {
        for ( i = 0; this.successList[ i ]; i++ ) {
          this.showLabel( this.successList[ i ] );
        }
      }
      if ( this.settings.unhighlight ) {
        for ( i = 0, elements = this.validElements(); elements[ i ]; i++ ) {
          this.settings.unhighlight.call( this, elements[ i ], this.settings.errorClass, this.settings.validClass );
        }
      }
      this.toHide = this.toHide.not( this.toShow );
      this.hideErrors();
      this.addWrapper( this.toShow ).show();
    },

    validElements: function() {
      return this.currentElements.not( this.invalidElements() );
    },

    invalidElements: function() {
      return $( this.errorList ).map( function() {
        return this.element;
      } );
    },

    showLabel: function( element, message ) {
      var place, group, errorID, v,
        error = this.errorsFor( element ),
        elementID = this.idOrName( element ),
        describedBy = $( element ).attr( "aria-describedby" );

      if ( error.length ) {

        // Refresh error/success class
        error.removeClass( this.settings.validClass ).addClass( this.settings.errorClass );

        // Replace message on existing label
        error.html( message );
      } else {

        // Create error element
        error = $( "<" + this.settings.errorElement + ">" )
          .attr( "id", elementID + "-error" )
          .addClass( this.settings.errorClass )
          .html( message || "" );

        // Maintain reference to the element to be placed into the DOM
        place = error;
        if ( this.settings.wrapper ) {

          // Make sure the element is visible, even in IE
          // actually showing the wrapped element is handled elsewhere
          place = error.hide().show().wrap( "<" + this.settings.wrapper + "/>" ).parent();
        }
        if ( this.labelContainer.length ) {
          this.labelContainer.append( place );
        } else if ( this.settings.errorPlacement ) {
          this.settings.errorPlacement.call( this, place, $( element ) );
        } else {
          place.insertAfter( element );
        }

        // Link error back to the element
        if ( error.is( "label" ) ) {

          // If the error is a label, then associate using 'for'
          error.attr( "for", elementID );

          // If the element is not a child of an associated label, then it's necessary
          // to explicitly apply aria-describedby
        } else if ( error.parents( "label[for='" + this.escapeCssMeta( elementID ) + "']" ).length === 0 ) {
          errorID = error.attr( "id" );

          // Respect existing non-error aria-describedby
          if ( !describedBy ) {
            describedBy = errorID;
          } else if ( !describedBy.match( new RegExp( "\\b" + this.escapeCssMeta( errorID ) + "\\b" ) ) ) {

            // Add to end of list if not already present
            describedBy += " " + errorID;
          }
          $( element ).attr( "aria-describedby", describedBy );

          // If this element is grouped, then assign to all elements in the same group
          group = this.groups[ element.name ];
          if ( group ) {
            v = this;
            $.each( v.groups, function( name, testgroup ) {
              if ( testgroup === group ) {
                $( "[name='" + v.escapeCssMeta( name ) + "']", v.currentForm )
                  .attr( "aria-describedby", error.attr( "id" ) );
              }
            } );
          }
        }
      }
      if ( !message && this.settings.success ) {
        error.text( "" );
        if ( typeof this.settings.success === "string" ) {
          error.addClass( this.settings.success );
        } else {
          this.settings.success( error, element );
        }
      }
      this.toShow = this.toShow.add( error );
    },

    errorsFor: function( element ) {
      var name = this.escapeCssMeta( this.idOrName( element ) ),
        describer = $( element ).attr( "aria-describedby" ),
        selector = "label[for='" + name + "'], label[for='" + name + "'] *";

      // 'aria-describedby' should directly reference the error element
      if ( describer ) {
        selector = selector + ", #" + this.escapeCssMeta( describer )
          .replace( /\s+/g, ", #" );
      }

      return this
        .errors()
        .filter( selector );
    },

    // See https://api.jquery.com/category/selectors/, for CSS
    // meta-characters that should be escaped in order to be used with JQuery
    // as a literal part of a name/id or any selector.
    escapeCssMeta: function( string ) {
      return string.replace( /([\\!"#$%&'()*+,./:;<=>?@\[\]^`{|}~])/g, "\\$1" );
    },

    idOrName: function( element ) {
      return this.groups[ element.name ] || ( this.checkable( element ) ? element.name : element.id || element.name );
    },

    validationTargetFor: function( element ) {

      // If radio/checkbox, validate first element in group instead
      if ( this.checkable( element ) ) {
        element = this.findByName( element.name );
      }

      // Always apply ignore filter
      return $( element ).not( this.settings.ignore )[ 0 ];
    },

    checkable: function( element ) {
      return ( /radio|checkbox/i ).test( element.type );
    },

    findByName: function( name ) {
      return $( this.currentForm ).find( "[name='" + this.escapeCssMeta( name ) + "']" );
    },

    getLength: function( value, element ) {
      switch ( element.nodeName.toLowerCase() ) {
      case "select":
        return $( "option:selected", element ).length;
      case "input":
        if ( this.checkable( element ) ) {
          return this.findByName( element.name ).filter( ":checked" ).length;
        }
      }
      return value.length;
    },

    depend: function( param, element ) {
      return this.dependTypes[ typeof param ] ? this.dependTypes[ typeof param ]( param, element ) : true;
    },

    dependTypes: {
      "boolean": function( param ) {
        return param;
      },
      "string": function( param, element ) {
        return !!$( param, element.form ).length;
      },
      "function": function( param, element ) {
        return param( element );
      }
    },

    optional: function( element ) {
      var val = this.elementValue( element );
      return !$.validator.methods.required.call( this, val, element ) && "dependency-mismatch";
    },

    startRequest: function( element ) {
      if ( !this.pending[ element.name ] ) {
        this.pendingRequest++;
        $( element ).addClass( this.settings.pendingClass );
        this.pending[ element.name ] = true;
      }
    },

    stopRequest: function( element, valid ) {
      this.pendingRequest--;

      // Sometimes synchronization fails, make sure pendingRequest is never < 0
      if ( this.pendingRequest < 0 ) {
        this.pendingRequest = 0;
      }
      delete this.pending[ element.name ];
      $( element ).removeClass( this.settings.pendingClass );
      if ( valid && this.pendingRequest === 0 && this.formSubmitted && this.form() ) {
        $( this.currentForm ).submit();
        this.formSubmitted = false;
      } else if ( !valid && this.pendingRequest === 0 && this.formSubmitted ) {
        $( this.currentForm ).triggerHandler( "invalid-form", [ this ] );
        this.formSubmitted = false;
      }
    },

    previousValue: function( element, method ) {
      method = typeof method === "string" && method || "remote";

      return $.data( element, "previousValue" ) || $.data( element, "previousValue", {
        old: null,
        valid: true,
        message: this.defaultMessage( element, { method: method } )
      } );
    },

    // Cleans up all forms and elements, removes validator-specific events
    destroy: function() {
      this.resetForm();

      $( this.currentForm )
        .off( ".validate" )
        .removeData( "validator" )
        .find( ".validate-equalTo-blur" )
          .off( ".validate-equalTo" )
          .removeClass( "validate-equalTo-blur" );
    }

  },

  classRuleSettings: {
    required: { required: true },
    email: { email: true },
    url: { url: true },
    date: { date: true },
    dateISO: { dateISO: true },
    number: { number: true },
    digits: { digits: true },
    creditcard: { creditcard: true }
  },

  addClassRules: function( className, rules ) {
    if ( className.constructor === String ) {
      this.classRuleSettings[ className ] = rules;
    } else {
      $.extend( this.classRuleSettings, className );
    }
  },

  classRules: function( element ) {
    var rules = {},
      classes = $( element ).attr( "class" );

    if ( classes ) {
      $.each( classes.split( " " ), function() {
        if ( this in $.validator.classRuleSettings ) {
          $.extend( rules, $.validator.classRuleSettings[ this ] );
        }
      } );
    }
    return rules;
  },

  normalizeAttributeRule: function( rules, type, method, value ) {

    // Convert the value to a number for number inputs, and for text for backwards compability
    // allows type="date" and others to be compared as strings
    if ( /min|max|step/.test( method ) && ( type === null || /number|range|text/.test( type ) ) ) {
      value = Number( value );

      // Support Opera Mini, which returns NaN for undefined minlength
      if ( isNaN( value ) ) {
        value = undefined;
      }
    }

    if ( value || value === 0 ) {
      rules[ method ] = value;
    } else if ( type === method && type !== "range" ) {

      // Exception: the jquery validate 'range' method
      // does not test for the html5 'range' type
      rules[ method ] = true;
    }
  },

  attributeRules: function( element ) {
    var rules = {},
      $element = $( element ),
      type = element.getAttribute( "type" ),
      method, value;

    for ( method in $.validator.methods ) {

      // Support for <input required> in both html5 and older browsers
      if ( method === "required" ) {
        value = element.getAttribute( method );

        // Some browsers return an empty string for the required attribute
        // and non-HTML5 browsers might have required="" markup
        if ( value === "" ) {
          value = true;
        }

        // Force non-HTML5 browsers to return bool
        value = !!value;
      } else {
        value = $element.attr( method );
      }

      this.normalizeAttributeRule( rules, type, method, value );
    }

    // 'maxlength' may be returned as -1, 2147483647 ( IE ) and 524288 ( safari ) for text inputs
    if ( rules.maxlength && /-1|2147483647|524288/.test( rules.maxlength ) ) {
      delete rules.maxlength;
    }

    return rules;
  },

  dataRules: function( element ) {
    var rules = {},
      $element = $( element ),
      type = element.getAttribute( "type" ),
      method, value;

    for ( method in $.validator.methods ) {
      value = $element.data( "rule" + method.charAt( 0 ).toUpperCase() + method.substring( 1 ).toLowerCase() );
      this.normalizeAttributeRule( rules, type, method, value );
    }
    return rules;
  },

  staticRules: function( element ) {
    var rules = {},
      validator = $.data( element.form, "validator" );

    if ( validator.settings.rules ) {
      rules = $.validator.normalizeRule( validator.settings.rules[ element.name ] ) || {};
    }
    return rules;
  },

  normalizeRules: function( rules, element ) {

    // Handle dependency check
    $.each( rules, function( prop, val ) {

      // Ignore rule when param is explicitly false, eg. required:false
      if ( val === false ) {
        delete rules[ prop ];
        return;
      }
      if ( val.param || val.depends ) {
        var keepRule = true;
        switch ( typeof val.depends ) {
        case "string":
          keepRule = !!$( val.depends, element.form ).length;
          break;
        case "function":
          keepRule = val.depends.call( element, element );
          break;
        }
        if ( keepRule ) {
          rules[ prop ] = val.param !== undefined ? val.param : true;
        } else {
          $.data( element.form, "validator" ).resetElements( $( element ) );
          delete rules[ prop ];
        }
      }
    } );

    // Evaluate parameters
    $.each( rules, function( rule, parameter ) {
      rules[ rule ] = $.isFunction( parameter ) && rule !== "normalizer" ? parameter( element ) : parameter;
    } );

    // Clean number parameters
    $.each( [ "minlength", "maxlength" ], function() {
      if ( rules[ this ] ) {
        rules[ this ] = Number( rules[ this ] );
      }
    } );
    $.each( [ "rangelength", "range" ], function() {
      var parts;
      if ( rules[ this ] ) {
        if ( $.isArray( rules[ this ] ) ) {
          rules[ this ] = [ Number( rules[ this ][ 0 ] ), Number( rules[ this ][ 1 ] ) ];
        } else if ( typeof rules[ this ] === "string" ) {
          parts = rules[ this ].replace( /[\[\]]/g, "" ).split( /[\s,]+/ );
          rules[ this ] = [ Number( parts[ 0 ] ), Number( parts[ 1 ] ) ];
        }
      }
    } );

    if ( $.validator.autoCreateRanges ) {

      // Auto-create ranges
      if ( rules.min != null && rules.max != null ) {
        rules.range = [ rules.min, rules.max ];
        delete rules.min;
        delete rules.max;
      }
      if ( rules.minlength != null && rules.maxlength != null ) {
        rules.rangelength = [ rules.minlength, rules.maxlength ];
        delete rules.minlength;
        delete rules.maxlength;
      }
    }

    return rules;
  },

  // Converts a simple string to a {string: true} rule, e.g., "required" to {required:true}
  normalizeRule: function( data ) {
    if ( typeof data === "string" ) {
      var transformed = {};
      $.each( data.split( /\s/ ), function() {
        transformed[ this ] = true;
      } );
      data = transformed;
    }
    return data;
  },

  // http://jqueryvalidation.org/jQuery.validator.addMethod/
  addMethod: function( name, method, message ) {
    $.validator.methods[ name ] = method;
    $.validator.messages[ name ] = message !== undefined ? message : $.validator.messages[ name ];
    if ( method.length < 3 ) {
      $.validator.addClassRules( name, $.validator.normalizeRule( name ) );
    }
  },

  // http://jqueryvalidation.org/jQuery.validator.methods/
  methods: {

    // http://jqueryvalidation.org/required-method/
    required: function( value, element, param ) {

      // Check if dependency is met
      if ( !this.depend( param, element ) ) {
        return "dependency-mismatch";
      }
      if ( element.nodeName.toLowerCase() === "select" ) {

        // Could be an array for select-multiple or a string, both are fine this way
        var val = $( element ).val();
        return val && val.length > 0;
      }
      if ( this.checkable( element ) ) {
        return this.getLength( value, element ) > 0;
      }
      return value.length > 0;
    },

    // http://jqueryvalidation.org/email-method/
    email: function( value, element ) {

      // From https://html.spec.whatwg.org/multipage/forms.html#valid-e-mail-address
      // Retrieved 2014-01-14
      // If you have a problem with this implementation, report a bug against the above spec
      // Or use custom methods to implement your own email validation
      return this.optional( element ) || /^[a-zA-Z0-9.!#$%&'*+\/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/.test( value );
    },

    // http://jqueryvalidation.org/url-method/
    url: function( value, element ) {

      // Copyright (c) 2010-2013 Diego Perini, MIT licensed
      // https://gist.github.com/dperini/729294
      // see also https://mathiasbynens.be/demo/url-regex
      // modified to allow protocol-relative URLs
      return this.optional( element ) || /^(?:(?:(?:https?|ftp):)?\/\/)(?:\S+(?::\S*)?@)?(?:(?!(?:10|127)(?:\.\d{1,3}){3})(?!(?:169\.254|192\.168)(?:\.\d{1,3}){2})(?!172\.(?:1[6-9]|2\d|3[0-1])(?:\.\d{1,3}){2})(?:[1-9]\d?|1\d\d|2[01]\d|22[0-3])(?:\.(?:1?\d{1,2}|2[0-4]\d|25[0-5])){2}(?:\.(?:[1-9]\d?|1\d\d|2[0-4]\d|25[0-4]))|(?:(?:[a-z\u00a1-\uffff0-9]-*)*[a-z\u00a1-\uffff0-9]+)(?:\.(?:[a-z\u00a1-\uffff0-9]-*)*[a-z\u00a1-\uffff0-9]+)*(?:\.(?:[a-z\u00a1-\uffff]{2,})).?)(?::\d{2,5})?(?:[/?#]\S*)?$/i.test( value );
    },

    // http://jqueryvalidation.org/date-method/
    date: function( value, element ) {
      return this.optional( element ) || !/Invalid|NaN/.test( new Date( value ).toString() );
    },

    // http://jqueryvalidation.org/dateISO-method/
    dateISO: function( value, element ) {
      return this.optional( element ) || /^\d{4}[\/\-](0?[1-9]|1[012])[\/\-](0?[1-9]|[12][0-9]|3[01])$/.test( value );
    },

    // http://jqueryvalidation.org/number-method/
    number: function( value, element ) {
      return this.optional( element ) || /^(?:-?\d+|-?\d{1,3}(?:,\d{3})+)?(?:\.\d+)?$/.test( value );
    },

    // http://jqueryvalidation.org/digits-method/
    digits: function( value, element ) {
      return this.optional( element ) || /^\d+$/.test( value );
    },

    // http://jqueryvalidation.org/minlength-method/
    minlength: function( value, element, param ) {
      var length = $.isArray( value ) ? value.length : this.getLength( value, element );
      return this.optional( element ) || length >= param;
    },

    // http://jqueryvalidation.org/maxlength-method/
    maxlength: function( value, element, param ) {
      var length = $.isArray( value ) ? value.length : this.getLength( value, element );
      return this.optional( element ) || length <= param;
    },

    // http://jqueryvalidation.org/rangelength-method/
    rangelength: function( value, element, param ) {
      var length = $.isArray( value ) ? value.length : this.getLength( value, element );
      return this.optional( element ) || ( length >= param[ 0 ] && length <= param[ 1 ] );
    },

    // http://jqueryvalidation.org/min-method/
    min: function( value, element, param ) {
      return this.optional( element ) || value >= param;
    },

    // http://jqueryvalidation.org/max-method/
    max: function( value, element, param ) {
      return this.optional( element ) || value <= param;
    },

    // http://jqueryvalidation.org/range-method/
    range: function( value, element, param ) {
      return this.optional( element ) || ( value >= param[ 0 ] && value <= param[ 1 ] );
    },

    // http://jqueryvalidation.org/step-method/
    step: function( value, element, param ) {
      var type = $( element ).attr( "type" ),
        errorMessage = "Step attribute on input type " + type + " is not supported.",
        supportedTypes = [ "text", "number", "range" ],
        re = new RegExp( "\\b" + type + "\\b" ),
        notSupported = type && !re.test( supportedTypes.join() ),
        decimalPlaces = function( num ) {
          var match = ( "" + num ).match( /(?:\.(\d+))?$/ );
          if ( !match ) {
            return 0;
          }

          // Number of digits right of decimal point.
          return match[ 1 ] ? match[ 1 ].length : 0;
        },
        toInt = function( num ) {
          return Math.round( num * Math.pow( 10, decimals ) );
        },
        valid = true,
        decimals;

      // Works only for text, number and range input types
      // TODO find a way to support input types date, datetime, datetime-local, month, time and week
      if ( notSupported ) {
        throw new Error( errorMessage );
      }

      decimals = decimalPlaces( param );

      // Value can't have too many decimals
      if ( decimalPlaces( value ) > decimals || toInt( value ) % toInt( param ) !== 0 ) {
        valid = false;
      }

      return this.optional( element ) || valid;
    },

    // http://jqueryvalidation.org/equalTo-method/
    equalTo: function( value, element, param ) {

      // Bind to the blur event of the target in order to revalidate whenever the target field is updated
      var target = $( param );
      if ( this.settings.onfocusout && target.not( ".validate-equalTo-blur" ).length ) {
        target.addClass( "validate-equalTo-blur" ).on( "blur.validate-equalTo", function() {
          $( element ).valid();
        } );
      }
      return value === target.val();
    },

    // http://jqueryvalidation.org/remote-method/
    remote: function( value, element, param, method ) {
      if ( this.optional( element ) ) {
        return "dependency-mismatch";
      }

      method = typeof method === "string" && method || "remote";

      var previous = this.previousValue( element, method ),
        validator, data, optionDataString;

      if ( !this.settings.messages[ element.name ] ) {
        this.settings.messages[ element.name ] = {};
      }
      previous.originalMessage = previous.originalMessage || this.settings.messages[ element.name ][ method ];
      this.settings.messages[ element.name ][ method ] = previous.message;

      param = typeof param === "string" && { url: param } || param;
      optionDataString = $.param( $.extend( { data: value }, param.data ) );
      if ( previous.old === optionDataString ) {
        return previous.valid;
      }

      previous.old = optionDataString;
      validator = this;
      this.startRequest( element );
      data = {};
      data[ element.name ] = value;
      $.ajax( $.extend( true, {
        mode: "abort",
        port: "validate" + element.name,
        dataType: "json",
        data: data,
        context: validator.currentForm,
        success: function( response ) {
          var valid = response === true || response === "true",
            errors, message, submitted;

          validator.settings.messages[ element.name ][ method ] = previous.originalMessage;
          if ( valid ) {
            submitted = validator.formSubmitted;
            validator.resetInternals();
            validator.toHide = validator.errorsFor( element );
            validator.formSubmitted = submitted;
            validator.successList.push( element );
            validator.invalid[ element.name ] = false;
            validator.showErrors();
          } else {
            errors = {};
            message = response || validator.defaultMessage( element, { method: method, parameters: value } );
            errors[ element.name ] = previous.message = message;
            validator.invalid[ element.name ] = true;
            validator.showErrors( errors );
          }
          previous.valid = valid;
          validator.stopRequest( element, valid );
        }
      }, param ) );
      return "pending";
    }
  }

} );

// Ajax mode: abort
// usage: $.ajax({ mode: "abort"[, port: "uniqueport"]});
// if mode:"abort" is used, the previous request on that port (port can be undefined) is aborted via XMLHttpRequest.abort()

var pendingRequests = {},
  ajax;

// Use a prefilter if available (1.5+)
if ( $.ajaxPrefilter ) {
  $.ajaxPrefilter( function( settings, _, xhr ) {
    var port = settings.port;
    if ( settings.mode === "abort" ) {
      if ( pendingRequests[ port ] ) {
        pendingRequests[ port ].abort();
      }
      pendingRequests[ port ] = xhr;
    }
  } );
} else {

  // Proxy ajax
  ajax = $.ajax;
  $.ajax = function( settings ) {
    var mode = ( "mode" in settings ? settings : $.ajaxSettings ).mode,
      port = ( "port" in settings ? settings : $.ajaxSettings ).port;
    if ( mode === "abort" ) {
      if ( pendingRequests[ port ] ) {
        pendingRequests[ port ].abort();
      }
      pendingRequests[ port ] = ajax.apply( this, arguments );
      return pendingRequests[ port ];
    }
    return ajax.apply( this, arguments );
  };
}
return $;
}));
/*!
 * jQuery Validation Plugin v1.16.0
 *
 * http://jqueryvalidation.org/
 *
 * Copyright (c) 2016 JÃ¶rn Zaefferer
 * Released under the MIT license
 */
(function( factory ) {
	if ( typeof define === "function" && define.amd ) {
		define( ["jquery", "./jquery.validate"], factory );
	} else if (typeof module === "object" && module.exports) {
		module.exports = factory( require( "jquery" ) );
	} else {
		factory( jQuery );
	}
}(function( $ ) {

( function() {

	function stripHtml( value ) {

		// Remove html tags and space chars
		return value.replace( /<.[^<>]*?>/g, " " ).replace( /&nbsp;|&#160;/gi, " " )

		// Remove punctuation
		.replace( /[.(),;:!?%#$'\"_+=\/\-âââ]*/g, "" );
	}

	$.validator.addMethod( "maxWords", function( value, element, params ) {
		return this.optional( element ) || stripHtml( value ).match( /\b\w+\b/g ).length <= params;
	}, $.validator.format( "Please enter {0} words or less." ) );

	$.validator.addMethod( "minWords", function( value, element, params ) {
		return this.optional( element ) || stripHtml( value ).match( /\b\w+\b/g ).length >= params;
	}, $.validator.format( "Please enter at least {0} words." ) );

	$.validator.addMethod( "rangeWords", function( value, element, params ) {
		var valueStripped = stripHtml( value ),
			regex = /\b\w+\b/g;
		return this.optional( element ) || valueStripped.match( regex ).length >= params[ 0 ] && valueStripped.match( regex ).length <= params[ 1 ];
	}, $.validator.format( "Please enter between {0} and {1} words." ) );

}() );

// Accept a value from a file input based on a required mimetype
$.validator.addMethod( "accept", function( value, element, param ) {

	// Split mime on commas in case we have multiple types we can accept
	var typeParam = typeof param === "string" ? param.replace( /\s/g, "" ) : "image/*",
		optionalValue = this.optional( element ),
		i, file, regex;

	// Element is optional
	if ( optionalValue ) {
		return optionalValue;
	}

	if ( $( element ).attr( "type" ) === "file" ) {

		// Escape string to be used in the regex
		// see: http://stackoverflow.com/questions/3446170/escape-string-for-use-in-javascript-regex
		// Escape also "/*" as "/.*" as a wildcard
		typeParam = typeParam
				.replace( /[\-\[\]\/\{\}\(\)\+\?\.\\\^\$\|]/g, "\\$&" )
				.replace( /,/g, "|" )
				.replace( /\/\*/g, "/.*" );

		// Check if the element has a FileList before checking each file
		if ( element.files && element.files.length ) {
			regex = new RegExp( ".?(" + typeParam + ")$", "i" );
			for ( i = 0; i < element.files.length; i++ ) {
				file = element.files[ i ];

				// Grab the mimetype from the loaded file, verify it matches
				if ( !file.type.match( regex ) ) {
					return false;
				}
			}
		}
	}

	// Either return true because we've validated each file, or because the
	// browser does not support element.files and the FileList feature
	return true;
}, $.validator.format( "Please enter a value with a valid mimetype." ) );

$.validator.addMethod( "alphanumeric", function( value, element ) {
	return this.optional( element ) || /^\w+$/i.test( value );
}, "Letters, numbers, and underscores only please" );

/*
 * Dutch bank account numbers (not 'giro' numbers) have 9 digits
 * and pass the '11 check'.
 * We accept the notation with spaces, as that is common.
 * acceptable: 123456789 or 12 34 56 789
 */
$.validator.addMethod( "bankaccountNL", function( value, element ) {
	if ( this.optional( element ) ) {
		return true;
	}
	if ( !( /^[0-9]{9}|([0-9]{2} ){3}[0-9]{3}$/.test( value ) ) ) {
		return false;
	}

	// Now '11 check'
	var account = value.replace( / /g, "" ), // Remove spaces
		sum = 0,
		len = account.length,
		pos, factor, digit;
	for ( pos = 0; pos < len; pos++ ) {
		factor = len - pos;
		digit = account.substring( pos, pos + 1 );
		sum = sum + factor * digit;
	}
	return sum % 11 === 0;
}, "Please specify a valid bank account number" );

$.validator.addMethod( "bankorgiroaccountNL", function( value, element ) {
	return this.optional( element ) ||
			( $.validator.methods.bankaccountNL.call( this, value, element ) ) ||
			( $.validator.methods.giroaccountNL.call( this, value, element ) );
}, "Please specify a valid bank or giro account number" );

/**
 * BIC is the business identifier code (ISO 9362). This BIC check is not a guarantee for authenticity.
 *
 * BIC pattern: BBBBCCLLbbb (8 or 11 characters long; bbb is optional)
 *
 * Validation is case-insensitive. Please make sure to normalize input yourself.
 *
 * BIC definition in detail:
 * - First 4 characters - bank code (only letters)
 * - Next 2 characters - ISO 3166-1 alpha-2 country code (only letters)
 * - Next 2 characters - location code (letters and digits)
 *   a. shall not start with '0' or '1'
 *   b. second character must be a letter ('O' is not allowed) or digit ('0' for test (therefore not allowed), '1' denoting passive participant, '2' typically reverse-billing)
 * - Last 3 characters - branch code, optional (shall not start with 'X' except in case of 'XXX' for primary office) (letters and digits)
 */
$.validator.addMethod( "bic", function( value, element ) {
    return this.optional( element ) || /^([A-Z]{6}[A-Z2-9][A-NP-Z1-9])(X{3}|[A-WY-Z0-9][A-Z0-9]{2})?$/.test( value.toUpperCase() );
}, "Please specify a valid BIC code" );

/*
 * CÃ³digo de identificaciÃ³n fiscal ( CIF ) is the tax identification code for Spanish legal entities
 * Further rules can be found in Spanish on http://es.wikipedia.org/wiki/C%C3%B3digo_de_identificaci%C3%B3n_fiscal
 *
 * Spanish CIF structure:
 *
 * [ T ][ P ][ P ][ N ][ N ][ N ][ N ][ N ][ C ]
 *
 * Where:
 *
 * T: 1 character. Kind of Organization Letter: [ABCDEFGHJKLMNPQRSUVW]
 * P: 2 characters. Province.
 * N: 5 characters. Secuencial Number within the province.
 * C: 1 character. Control Digit: [0-9A-J].
 *
 * [ T ]: Kind of Organizations. Possible values:
 *
 *   A. Corporations
 *   B. LLCs
 *   C. General partnerships
 *   D. Companies limited partnerships
 *   E. Communities of goods
 *   F. Cooperative Societies
 *   G. Associations
 *   H. Communities of homeowners in horizontal property regime
 *   J. Civil Societies
 *   K. Old format
 *   L. Old format
 *   M. Old format
 *   N. Nonresident entities
 *   P. Local authorities
 *   Q. Autonomous bodies, state or not, and the like, and congregations and religious institutions
 *   R. Congregations and religious institutions (since 2008 ORDER EHA/451/2008)
 *   S. Organs of State Administration and regions
 *   V. Agrarian Transformation
 *   W. Permanent establishments of non-resident in Spain
 *
 * [ C ]: Control Digit. It can be a number or a letter depending on T value:
 * [ T ]  -->  [ C ]
 * ------    ----------
 *   A         Number
 *   B         Number
 *   E         Number
 *   H         Number
 *   K         Letter
 *   P         Letter
 *   Q         Letter
 *   S         Letter
 *
 */
$.validator.addMethod( "cifES", function( value ) {
	"use strict";

	var cifRegEx = new RegExp( /^([ABCDEFGHJKLMNPQRSUVW])(\d{7})([0-9A-J])$/gi );
	var letter  = value.substring( 0, 1 ), // [ T ]
		number  = value.substring( 1, 8 ), // [ P ][ P ][ N ][ N ][ N ][ N ][ N ]
		control = value.substring( 8, 9 ), // [ C ]
		all_sum = 0,
		even_sum = 0,
		odd_sum = 0,
		i, n,
		control_digit,
		control_letter;

	function isOdd( n ) {
		return n % 2 === 0;
	}

	// Quick format test
	if ( value.length !== 9 || !cifRegEx.test( value ) ) {
		return false;
	}

	for ( i = 0; i < number.length; i++ ) {
		n = parseInt( number[ i ], 10 );

		// Odd positions
		if ( isOdd( i ) ) {

			// Odd positions are multiplied first.
			n *= 2;

			// If the multiplication is bigger than 10 we need to adjust
			odd_sum += n < 10 ? n : n - 9;

		// Even positions
		// Just sum them
		} else {
			even_sum += n;
		}
	}

	all_sum = even_sum + odd_sum;
	control_digit = ( 10 - ( all_sum ).toString().substr( -1 ) ).toString();
	control_digit = parseInt( control_digit, 10 ) > 9 ? "0" : control_digit;
	control_letter = "JABCDEFGHI".substr( control_digit, 1 ).toString();

	// Control must be a digit
	if ( letter.match( /[ABEH]/ ) ) {
		return control === control_digit;

	// Control must be a letter
	} else if ( letter.match( /[KPQS]/ ) ) {
		return control === control_letter;

	// Can be either
	} else {
		return control === control_digit || control === control_letter;
	}

	return false;

}, "Please specify a valid CIF number." );

/*
 * Brazillian CPF number (Cadastrado de Pessoas FÃ­sicas) is the equivalent of a Brazilian tax registration number.
 * CPF numbers have 11 digits in total: 9 numbers followed by 2 check numbers that are being used for validation.
 */
$.validator.addMethod( "cpfBR", function( value ) {

	// Removing special characters from value
	value = value.replace( /([~!@#$%^&*()_+=`{}\[\]\-|\\:;'<>,.\/? ])+/g, "" );

	// Checking value to have 11 digits only
	if ( value.length !== 11 ) {
		return false;
	}

	var sum = 0,
		firstCN, secondCN, checkResult, i;

	firstCN = parseInt( value.substring( 9, 10 ), 10 );
	secondCN = parseInt( value.substring( 10, 11 ), 10 );

	checkResult = function( sum, cn ) {
		var result = ( sum * 10 ) % 11;
		if ( ( result === 10 ) || ( result === 11 ) ) {
			result = 0;
		}
		return ( result === cn );
	};

	// Checking for dump data
	if ( value === "" ||
		value === "00000000000" ||
		value === "11111111111" ||
		value === "22222222222" ||
		value === "33333333333" ||
		value === "44444444444" ||
		value === "55555555555" ||
		value === "66666666666" ||
		value === "77777777777" ||
		value === "88888888888" ||
		value === "99999999999"
	) {
		return false;
	}

	// Step 1 - using first Check Number:
	for ( i = 1; i <= 9; i++ ) {
		sum = sum + parseInt( value.substring( i - 1, i ), 10 ) * ( 11 - i );
	}

	// If first Check Number (CN) is valid, move to Step 2 - using second Check Number:
	if ( checkResult( sum, firstCN ) ) {
		sum = 0;
		for ( i = 1; i <= 10; i++ ) {
			sum = sum + parseInt( value.substring( i - 1, i ), 10 ) * ( 12 - i );
		}
		return checkResult( sum, secondCN );
	}
	return false;

}, "Please specify a valid CPF number" );

// http://jqueryvalidation.org/creditcard-method/
// based on http://en.wikipedia.org/wiki/Luhn_algorithm
$.validator.addMethod( "creditcard", function( value, element ) {
	if ( this.optional( element ) ) {
		return "dependency-mismatch";
	}

	// Accept only spaces, digits and dashes
	if ( /[^0-9 \-]+/.test( value ) ) {
		return false;
	}

	var nCheck = 0,
		nDigit = 0,
		bEven = false,
		n, cDigit;

	value = value.replace( /\D/g, "" );

	// Basing min and max length on
	// http://developer.ean.com/general_info/Valid_Credit_Card_Types
	if ( value.length < 13 || value.length > 19 ) {
		return false;
	}

	for ( n = value.length - 1; n >= 0; n-- ) {
		cDigit = value.charAt( n );
		nDigit = parseInt( cDigit, 10 );
		if ( bEven ) {
			if ( ( nDigit *= 2 ) > 9 ) {
				nDigit -= 9;
			}
		}

		nCheck += nDigit;
		bEven = !bEven;
	}

	return ( nCheck % 10 ) === 0;
}, "Please enter a valid credit card number." );

/* NOTICE: Modified version of Castle.Components.Validator.CreditCardValidator
 * Redistributed under the the Apache License 2.0 at http://www.apache.org/licenses/LICENSE-2.0
 * Valid Types: mastercard, visa, amex, dinersclub, enroute, discover, jcb, unknown, all (overrides all other settings)
 */
$.validator.addMethod( "creditcardtypes", function( value, element, param ) {
	if ( /[^0-9\-]+/.test( value ) ) {
		return false;
	}

	value = value.replace( /\D/g, "" );

	var validTypes = 0x0000;

	if ( param.mastercard ) {
		validTypes |= 0x0001;
	}
	if ( param.visa ) {
		validTypes |= 0x0002;
	}
	if ( param.amex ) {
		validTypes |= 0x0004;
	}
	if ( param.dinersclub ) {
		validTypes |= 0x0008;
	}
	if ( param.enroute ) {
		validTypes |= 0x0010;
	}
	if ( param.discover ) {
		validTypes |= 0x0020;
	}
	if ( param.jcb ) {
		validTypes |= 0x0040;
	}
	if ( param.unknown ) {
		validTypes |= 0x0080;
	}
	if ( param.all ) {
		validTypes = 0x0001 | 0x0002 | 0x0004 | 0x0008 | 0x0010 | 0x0020 | 0x0040 | 0x0080;
	}
	if ( validTypes & 0x0001 && /^(5[12345])/.test( value ) ) { // Mastercard
		return value.length === 16;
	}
	if ( validTypes & 0x0002 && /^(4)/.test( value ) ) { // Visa
		return value.length === 16;
	}
	if ( validTypes & 0x0004 && /^(3[47])/.test( value ) ) { // Amex
		return value.length === 15;
	}
	if ( validTypes & 0x0008 && /^(3(0[012345]|[68]))/.test( value ) ) { // Dinersclub
		return value.length === 14;
	}
	if ( validTypes & 0x0010 && /^(2(014|149))/.test( value ) ) { // Enroute
		return value.length === 15;
	}
	if ( validTypes & 0x0020 && /^(6011)/.test( value ) ) { // Discover
		return value.length === 16;
	}
	if ( validTypes & 0x0040 && /^(3)/.test( value ) ) { // Jcb
		return value.length === 16;
	}
	if ( validTypes & 0x0040 && /^(2131|1800)/.test( value ) ) { // Jcb
		return value.length === 15;
	}
	if ( validTypes & 0x0080 ) { // Unknown
		return true;
	}
	return false;
}, "Please enter a valid credit card number." );

/**
 * Validates currencies with any given symbols by @jameslouiz
 * Symbols can be optional or required. Symbols required by default
 *
 * Usage examples:
 *  currency: ["Â£", false] - Use false for soft currency validation
 *  currency: ["$", false]
 *  currency: ["RM", false] - also works with text based symbols such as "RM" - Malaysia Ringgit etc
 *
 *  <input class="currencyInput" name="currencyInput">
 *
 * Soft symbol checking
 *  currencyInput: {
 *     currency: ["$", false]
 *  }
 *
 * Strict symbol checking (default)
 *  currencyInput: {
 *     currency: "$"
 *     //OR
 *     currency: ["$", true]
 *  }
 *
 * Multiple Symbols
 *  currencyInput: {
 *     currency: "$,Â£,Â¢"
 *  }
 */
$.validator.addMethod( "currency", function( value, element, param ) {
    var isParamString = typeof param === "string",
        symbol = isParamString ? param : param[ 0 ],
        soft = isParamString ? true : param[ 1 ],
        regex;

    symbol = symbol.replace( /,/g, "" );
    symbol = soft ? symbol + "]" : symbol + "]?";
    regex = "^[" + symbol + "([1-9]{1}[0-9]{0,2}(\\,[0-9]{3})*(\\.[0-9]{0,2})?|[1-9]{1}[0-9]{0,}(\\.[0-9]{0,2})?|0(\\.[0-9]{0,2})?|(\\.[0-9]{1,2})?)$";
    regex = new RegExp( regex );
    return this.optional( element ) || regex.test( value );

}, "Please specify a valid currency" );

$.validator.addMethod( "dateFA", function( value, element ) {
	return this.optional( element ) || /^[1-4]\d{3}\/((0?[1-6]\/((3[0-1])|([1-2][0-9])|(0?[1-9])))|((1[0-2]|(0?[7-9]))\/(30|([1-2][0-9])|(0?[1-9]))))$/.test( value );
}, $.validator.messages.date );

/**
 * Return true, if the value is a valid date, also making this formal check dd/mm/yyyy.
 *
 * @example $.validator.methods.date("01/01/1900")
 * @result true
 *
 * @example $.validator.methods.date("01/13/1990")
 * @result false
 *
 * @example $.validator.methods.date("01.01.1900")
 * @result false
 *
 * @example <input name="pippo" class="{dateITA:true}" />
 * @desc Declares an optional input element whose value must be a valid date.
 *
 * @name $.validator.methods.dateITA
 * @type Boolean
 * @cat Plugins/Validate/Methods
 */
$.validator.addMethod( "dateITA", function( value, element ) {
	var check = false,
		re = /^\d{1,2}\/\d{1,2}\/\d{4}$/,
		adata, gg, mm, aaaa, xdata;
	if ( re.test( value ) ) {
		adata = value.split( "/" );
		gg = parseInt( adata[ 0 ], 10 );
		mm = parseInt( adata[ 1 ], 10 );
		aaaa = parseInt( adata[ 2 ], 10 );
		xdata = new Date( Date.UTC( aaaa, mm - 1, gg, 12, 0, 0, 0 ) );
		if ( ( xdata.getUTCFullYear() === aaaa ) && ( xdata.getUTCMonth() === mm - 1 ) && ( xdata.getUTCDate() === gg ) ) {
			check = true;
		} else {
			check = false;
		}
	} else {
		check = false;
	}
	return this.optional( element ) || check;
}, $.validator.messages.date );

$.validator.addMethod( "dateNL", function( value, element ) {
	return this.optional( element ) || /^(0?[1-9]|[12]\d|3[01])[\.\/\-](0?[1-9]|1[012])[\.\/\-]([12]\d)?(\d\d)$/.test( value );
}, $.validator.messages.date );

// Older "accept" file extension method. Old docs: http://docs.jquery.com/Plugins/Validation/Methods/accept
$.validator.addMethod( "extension", function( value, element, param ) {
	param = typeof param === "string" ? param.replace( /,/g, "|" ) : "png|jpe?g|gif";
	return this.optional( element ) || value.match( new RegExp( "\\.(" + param + ")$", "i" ) );
}, $.validator.format( "Please enter a value with a valid extension." ) );

/**
 * Dutch giro account numbers (not bank numbers) have max 7 digits
 */
$.validator.addMethod( "giroaccountNL", function( value, element ) {
	return this.optional( element ) || /^[0-9]{1,7}$/.test( value );
}, "Please specify a valid giro account number" );

/**
 * IBAN is the international bank account number.
 * It has a country - specific format, that is checked here too
 *
 * Validation is case-insensitive. Please make sure to normalize input yourself.
 */
$.validator.addMethod( "iban", function( value, element ) {

	// Some quick simple tests to prevent needless work
	if ( this.optional( element ) ) {
		return true;
	}

	// Remove spaces and to upper case
	var iban = value.replace( / /g, "" ).toUpperCase(),
		ibancheckdigits = "",
		leadingZeroes = true,
		cRest = "",
		cOperator = "",
		countrycode, ibancheck, charAt, cChar, bbanpattern, bbancountrypatterns, ibanregexp, i, p;

	// Check for IBAN code length.
	// It contains:
	// country code ISO 3166-1 - two letters,
	// two check digits,
	// Basic Bank Account Number (BBAN) - up to 30 chars
	var minimalIBANlength = 5;
	if ( iban.length < minimalIBANlength ) {
		return false;
	}

	// Check the country code and find the country specific format
	countrycode = iban.substring( 0, 2 );
	bbancountrypatterns = {
		"AL": "\\d{8}[\\dA-Z]{16}",
		"AD": "\\d{8}[\\dA-Z]{12}",
		"AT": "\\d{16}",
		"AZ": "[\\dA-Z]{4}\\d{20}",
		"BE": "\\d{12}",
		"BH": "[A-Z]{4}[\\dA-Z]{14}",
		"BA": "\\d{16}",
		"BR": "\\d{23}[A-Z][\\dA-Z]",
		"BG": "[A-Z]{4}\\d{6}[\\dA-Z]{8}",
		"CR": "\\d{17}",
		"HR": "\\d{17}",
		"CY": "\\d{8}[\\dA-Z]{16}",
		"CZ": "\\d{20}",
		"DK": "\\d{14}",
		"DO": "[A-Z]{4}\\d{20}",
		"EE": "\\d{16}",
		"FO": "\\d{14}",
		"FI": "\\d{14}",
		"FR": "\\d{10}[\\dA-Z]{11}\\d{2}",
		"GE": "[\\dA-Z]{2}\\d{16}",
		"DE": "\\d{18}",
		"GI": "[A-Z]{4}[\\dA-Z]{15}",
		"GR": "\\d{7}[\\dA-Z]{16}",
		"GL": "\\d{14}",
		"GT": "[\\dA-Z]{4}[\\dA-Z]{20}",
		"HU": "\\d{24}",
		"IS": "\\d{22}",
		"IE": "[\\dA-Z]{4}\\d{14}",
		"IL": "\\d{19}",
		"IT": "[A-Z]\\d{10}[\\dA-Z]{12}",
		"KZ": "\\d{3}[\\dA-Z]{13}",
		"KW": "[A-Z]{4}[\\dA-Z]{22}",
		"LV": "[A-Z]{4}[\\dA-Z]{13}",
		"LB": "\\d{4}[\\dA-Z]{20}",
		"LI": "\\d{5}[\\dA-Z]{12}",
		"LT": "\\d{16}",
		"LU": "\\d{3}[\\dA-Z]{13}",
		"MK": "\\d{3}[\\dA-Z]{10}\\d{2}",
		"MT": "[A-Z]{4}\\d{5}[\\dA-Z]{18}",
		"MR": "\\d{23}",
		"MU": "[A-Z]{4}\\d{19}[A-Z]{3}",
		"MC": "\\d{10}[\\dA-Z]{11}\\d{2}",
		"MD": "[\\dA-Z]{2}\\d{18}",
		"ME": "\\d{18}",
		"NL": "[A-Z]{4}\\d{10}",
		"NO": "\\d{11}",
		"PK": "[\\dA-Z]{4}\\d{16}",
		"PS": "[\\dA-Z]{4}\\d{21}",
		"PL": "\\d{24}",
		"PT": "\\d{21}",
		"RO": "[A-Z]{4}[\\dA-Z]{16}",
		"SM": "[A-Z]\\d{10}[\\dA-Z]{12}",
		"SA": "\\d{2}[\\dA-Z]{18}",
		"RS": "\\d{18}",
		"SK": "\\d{20}",
		"SI": "\\d{15}",
		"ES": "\\d{20}",
		"SE": "\\d{20}",
		"CH": "\\d{5}[\\dA-Z]{12}",
		"TN": "\\d{20}",
		"TR": "\\d{5}[\\dA-Z]{17}",
		"AE": "\\d{3}\\d{16}",
		"GB": "[A-Z]{4}\\d{14}",
		"VG": "[\\dA-Z]{4}\\d{16}"
	};

	bbanpattern = bbancountrypatterns[ countrycode ];

	// As new countries will start using IBAN in the
	// future, we only check if the countrycode is known.
	// This prevents false negatives, while almost all
	// false positives introduced by this, will be caught
	// by the checksum validation below anyway.
	// Strict checking should return FALSE for unknown
	// countries.
	if ( typeof bbanpattern !== "undefined" ) {
		ibanregexp = new RegExp( "^[A-Z]{2}\\d{2}" + bbanpattern + "$", "" );
		if ( !( ibanregexp.test( iban ) ) ) {
			return false; // Invalid country specific format
		}
	}

	// Now check the checksum, first convert to digits
	ibancheck = iban.substring( 4, iban.length ) + iban.substring( 0, 4 );
	for ( i = 0; i < ibancheck.length; i++ ) {
		charAt = ibancheck.charAt( i );
		if ( charAt !== "0" ) {
			leadingZeroes = false;
		}
		if ( !leadingZeroes ) {
			ibancheckdigits += "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ".indexOf( charAt );
		}
	}

	// Calculate the result of: ibancheckdigits % 97
	for ( p = 0; p < ibancheckdigits.length; p++ ) {
		cChar = ibancheckdigits.charAt( p );
		cOperator = "" + cRest + "" + cChar;
		cRest = cOperator % 97;
	}
	return cRest === 1;
}, "Please specify a valid IBAN" );

$.validator.addMethod( "integer", function( value, element ) {
	return this.optional( element ) || /^-?\d+$/.test( value );
}, "A positive or negative non-decimal number please" );

$.validator.addMethod( "ipv4", function( value, element ) {
	return this.optional( element ) || /^(25[0-5]|2[0-4]\d|[01]?\d\d?)\.(25[0-5]|2[0-4]\d|[01]?\d\d?)\.(25[0-5]|2[0-4]\d|[01]?\d\d?)\.(25[0-5]|2[0-4]\d|[01]?\d\d?)$/i.test( value );
}, "Please enter a valid IP v4 address." );

$.validator.addMethod( "ipv6", function( value, element ) {
	return this.optional( element ) || /^((([0-9A-Fa-f]{1,4}:){7}[0-9A-Fa-f]{1,4})|(([0-9A-Fa-f]{1,4}:){6}:[0-9A-Fa-f]{1,4})|(([0-9A-Fa-f]{1,4}:){5}:([0-9A-Fa-f]{1,4}:)?[0-9A-Fa-f]{1,4})|(([0-9A-Fa-f]{1,4}:){4}:([0-9A-Fa-f]{1,4}:){0,2}[0-9A-Fa-f]{1,4})|(([0-9A-Fa-f]{1,4}:){3}:([0-9A-Fa-f]{1,4}:){0,3}[0-9A-Fa-f]{1,4})|(([0-9A-Fa-f]{1,4}:){2}:([0-9A-Fa-f]{1,4}:){0,4}[0-9A-Fa-f]{1,4})|(([0-9A-Fa-f]{1,4}:){6}((\b((25[0-5])|(1\d{2})|(2[0-4]\d)|(\d{1,2}))\b)\.){3}(\b((25[0-5])|(1\d{2})|(2[0-4]\d)|(\d{1,2}))\b))|(([0-9A-Fa-f]{1,4}:){0,5}:((\b((25[0-5])|(1\d{2})|(2[0-4]\d)|(\d{1,2}))\b)\.){3}(\b((25[0-5])|(1\d{2})|(2[0-4]\d)|(\d{1,2}))\b))|(::([0-9A-Fa-f]{1,4}:){0,5}((\b((25[0-5])|(1\d{2})|(2[0-4]\d)|(\d{1,2}))\b)\.){3}(\b((25[0-5])|(1\d{2})|(2[0-4]\d)|(\d{1,2}))\b))|([0-9A-Fa-f]{1,4}::([0-9A-Fa-f]{1,4}:){0,5}[0-9A-Fa-f]{1,4})|(::([0-9A-Fa-f]{1,4}:){0,6}[0-9A-Fa-f]{1,4})|(([0-9A-Fa-f]{1,4}:){1,7}:))$/i.test( value );
}, "Please enter a valid IP v6 address." );

$.validator.addMethod( "lettersonly", function( value, element ) {
	return this.optional( element ) || /^[a-z]+$/i.test( value );
}, "Letters only please" );

$.validator.addMethod( "letterswithbasicpunc", function( value, element ) {
	return this.optional( element ) || /^[a-z\-.,()'"\s]+$/i.test( value );
}, "Letters or punctuation only please" );

$.validator.addMethod( "mobileNL", function( value, element ) {
	return this.optional( element ) || /^((\+|00(\s|\s?\-\s?)?)31(\s|\s?\-\s?)?(\(0\)[\-\s]?)?|0)6((\s|\s?\-\s?)?[0-9]){8}$/.test( value );
}, "Please specify a valid mobile number" );

/* For UK phone functions, do the following server side processing:
 * Compare original input with this RegEx pattern:
 * ^\(?(?:(?:00\)?[\s\-]?\(?|\+)(44)\)?[\s\-]?\(?(?:0\)?[\s\-]?\(?)?|0)([1-9]\d{1,4}\)?[\s\d\-]+)$
 * Extract $1 and set $prefix to '+44<space>' if $1 is '44', otherwise set $prefix to '0'
 * Extract $2 and remove hyphens, spaces and parentheses. Phone number is combined $prefix and $2.
 * A number of very detailed GB telephone number RegEx patterns can also be found at:
 * http://www.aa-asterisk.org.uk/index.php/Regular_Expressions_for_Validating_and_Formatting_GB_Telephone_Numbers
 */
$.validator.addMethod( "mobileUK", function( phone_number, element ) {
	phone_number = phone_number.replace( /\(|\)|\s+|-/g, "" );
	return this.optional( element ) || phone_number.length > 9 &&
		phone_number.match( /^(?:(?:(?:00\s?|\+)44\s?|0)7(?:[1345789]\d{2}|624)\s?\d{3}\s?\d{3})$/ );
}, "Please specify a valid mobile number" );

/*
 * The NIE (NÃºmero de IdentificaciÃ³n de Extranjero) is a Spanish tax identification number assigned by the Spanish
 * authorities to any foreigner.
 *
 * The NIE is the equivalent of a Spaniards NÃºmero de IdentificaciÃ³n Fiscal (NIF) which serves as a fiscal
 * identification number. The CIF number (Certificado de IdentificaciÃ³n Fiscal) is equivalent to the NIF, but applies to
 * companies rather than individuals. The NIE consists of an 'X' or 'Y' followed by 7 or 8 digits then another letter.
 */
$.validator.addMethod( "nieES", function( value ) {
	"use strict";

	var nieRegEx = new RegExp( /^[MXYZ]{1}[0-9]{7,8}[TRWAGMYFPDXBNJZSQVHLCKET]{1}$/gi );
	var validChars = "TRWAGMYFPDXBNJZSQVHLCKET",
		letter = value.substr( value.length - 1 ).toUpperCase(),
		number;

	value = value.toString().toUpperCase();

	// Quick format test
	if ( value.length > 10 || value.length < 9 || !nieRegEx.test( value ) ) {
		return false;
	}

	// X means same number
	// Y means number + 10000000
	// Z means number + 20000000
	value = value.replace( /^[X]/, "0" )
		.replace( /^[Y]/, "1" )
		.replace( /^[Z]/, "2" );

	number = value.length === 9 ? value.substr( 0, 8 ) : value.substr( 0, 9 );

	return validChars.charAt( parseInt( number, 10 ) % 23 ) === letter;

}, "Please specify a valid NIE number." );

/*
 * The NÃºmero de IdentificaciÃ³n Fiscal ( NIF ) is the way tax identification used in Spain for individuals
 */
$.validator.addMethod( "nifES", function( value ) {
	"use strict";

	value = value.toUpperCase();

	// Basic format test
	if ( !value.match( "((^[A-Z]{1}[0-9]{7}[A-Z0-9]{1}$|^[T]{1}[A-Z0-9]{8}$)|^[0-9]{8}[A-Z]{1}$)" ) ) {
		return false;
	}

	// Test NIF
	if ( /^[0-9]{8}[A-Z]{1}$/.test( value ) ) {
		return ( "TRWAGMYFPDXBNJZSQVHLCKE".charAt( value.substring( 8, 0 ) % 23 ) === value.charAt( 8 ) );
	}

	// Test specials NIF (starts with K, L or M)
	if ( /^[KLM]{1}/.test( value ) ) {
		return ( value[ 8 ] === String.fromCharCode( 64 ) );
	}

	return false;

}, "Please specify a valid NIF number." );

$.validator.addMethod( "notEqualTo", function( value, element, param ) {
	return this.optional( element ) || !$.validator.methods.equalTo.call( this, value, element, param );
}, "Please enter a different value, values must not be the same." );

$.validator.addMethod( "nowhitespace", function( value, element ) {
	return this.optional( element ) || /^\S+$/i.test( value );
}, "No white space please" );

/**
* Return true if the field value matches the given format RegExp
*
* @example $.validator.methods.pattern("AR1004",element,/^AR\d{4}$/)
* @result true
*
* @example $.validator.methods.pattern("BR1004",element,/^AR\d{4}$/)
* @result false
*
* @name $.validator.methods.pattern
* @type Boolean
* @cat Plugins/Validate/Methods
*/
$.validator.addMethod( "pattern", function( value, element, param ) {
	if ( this.optional( element ) ) {
		return true;
	}
	if ( typeof param === "string" ) {
		param = new RegExp( "^(?:" + param + ")$" );
	}
	return param.test( value );
}, "Invalid format." );

/**
 * Dutch phone numbers have 10 digits (or 11 and start with +31).
 */
$.validator.addMethod( "phoneNL", function( value, element ) {
	return this.optional( element ) || /^((\+|00(\s|\s?\-\s?)?)31(\s|\s?\-\s?)?(\(0\)[\-\s]?)?|0)[1-9]((\s|\s?\-\s?)?[0-9]){8}$/.test( value );
}, "Please specify a valid phone number." );

/* For UK phone functions, do the following server side processing:
 * Compare original input with this RegEx pattern:
 * ^\(?(?:(?:00\)?[\s\-]?\(?|\+)(44)\)?[\s\-]?\(?(?:0\)?[\s\-]?\(?)?|0)([1-9]\d{1,4}\)?[\s\d\-]+)$
 * Extract $1 and set $prefix to '+44<space>' if $1 is '44', otherwise set $prefix to '0'
 * Extract $2 and remove hyphens, spaces and parentheses. Phone number is combined $prefix and $2.
 * A number of very detailed GB telephone number RegEx patterns can also be found at:
 * http://www.aa-asterisk.org.uk/index.php/Regular_Expressions_for_Validating_and_Formatting_GB_Telephone_Numbers
 */

// Matches UK landline + mobile, accepting only 01-3 for landline or 07 for mobile to exclude many premium numbers
$.validator.addMethod( "phonesUK", function( phone_number, element ) {
	phone_number = phone_number.replace( /\(|\)|\s+|-/g, "" );
	return this.optional( element ) || phone_number.length > 9 &&
		phone_number.match( /^(?:(?:(?:00\s?|\+)44\s?|0)(?:1\d{8,9}|[23]\d{9}|7(?:[1345789]\d{8}|624\d{6})))$/ );
}, "Please specify a valid uk phone number" );

/* For UK phone functions, do the following server side processing:
 * Compare original input with this RegEx pattern:
 * ^\(?(?:(?:00\)?[\s\-]?\(?|\+)(44)\)?[\s\-]?\(?(?:0\)?[\s\-]?\(?)?|0)([1-9]\d{1,4}\)?[\s\d\-]+)$
 * Extract $1 and set $prefix to '+44<space>' if $1 is '44', otherwise set $prefix to '0'
 * Extract $2 and remove hyphens, spaces and parentheses. Phone number is combined $prefix and $2.
 * A number of very detailed GB telephone number RegEx patterns can also be found at:
 * http://www.aa-asterisk.org.uk/index.php/Regular_Expressions_for_Validating_and_Formatting_GB_Telephone_Numbers
 */
$.validator.addMethod( "phoneUK", function( phone_number, element ) {
	phone_number = phone_number.replace( /\(|\)|\s+|-/g, "" );
	return this.optional( element ) || phone_number.length > 9 &&
		phone_number.match( /^(?:(?:(?:00\s?|\+)44\s?)|(?:\(?0))(?:\d{2}\)?\s?\d{4}\s?\d{4}|\d{3}\)?\s?\d{3}\s?\d{3,4}|\d{4}\)?\s?(?:\d{5}|\d{3}\s?\d{3})|\d{5}\)?\s?\d{4,5})$/ );
}, "Please specify a valid phone number" );

/**
 * Matches US phone number format
 *
 * where the area code may not start with 1 and the prefix may not start with 1
 * allows '-' or ' ' as a separator and allows parens around area code
 * some people may want to put a '1' in front of their number
 *
 * 1(212)-999-2345 or
 * 212 999 2344 or
 * 212-999-0983
 *
 * but not
 * 111-123-5434
 * and not
 * 212 123 4567
 */
$.validator.addMethod( "phoneUS", function( phone_number, element ) {
	phone_number = phone_number.replace( /\s+/g, "" );
	return this.optional( element ) || phone_number.length > 9 &&
		phone_number.match( /^(\+?1-?)?(\([2-9]([02-9]\d|1[02-9])\)|[2-9]([02-9]\d|1[02-9]))-?[2-9]([02-9]\d|1[02-9])-?\d{4}$/ );
}, "Please specify a valid phone number" );

/*
* Valida CEPs do brasileiros:
*
* Formatos aceitos:
* 99999-999
* 99.999-999
* 99999999
*/
$.validator.addMethod( "postalcodeBR", function( cep_value, element ) {
	return this.optional( element ) || /^\d{2}.\d{3}-\d{3}?$|^\d{5}-?\d{3}?$/.test( cep_value );
}, "Informe um CEP vÃ¡lido." );

/**
 * Matches a valid Canadian Postal Code
 *
 * @example jQuery.validator.methods.postalCodeCA( "H0H 0H0", element )
 * @result true
 *
 * @example jQuery.validator.methods.postalCodeCA( "H0H0H0", element )
 * @result false
 *
 * @name jQuery.validator.methods.postalCodeCA
 * @type Boolean
 * @cat Plugins/Validate/Methods
 */
$.validator.addMethod( "postalCodeCA", function( value, element ) {
	return this.optional( element ) || /^[ABCEGHJKLMNPRSTVXY]\d[ABCEGHJKLMNPRSTVWXYZ] *\d[ABCEGHJKLMNPRSTVWXYZ]\d$/i.test( value );
}, "Please specify a valid postal code" );

/* Matches Italian postcode (CAP) */
$.validator.addMethod( "postalcodeIT", function( value, element ) {
	return this.optional( element ) || /^\d{5}$/.test( value );
}, "Please specify a valid postal code" );

$.validator.addMethod( "postalcodeNL", function( value, element ) {
	return this.optional( element ) || /^[1-9][0-9]{3}\s?[a-zA-Z]{2}$/.test( value );
}, "Please specify a valid postal code" );

// Matches UK postcode. Does not match to UK Channel Islands that have their own postcodes (non standard UK)
$.validator.addMethod( "postcodeUK", function( value, element ) {
	return this.optional( element ) || /^((([A-PR-UWYZ][0-9])|([A-PR-UWYZ][0-9][0-9])|([A-PR-UWYZ][A-HK-Y][0-9])|([A-PR-UWYZ][A-HK-Y][0-9][0-9])|([A-PR-UWYZ][0-9][A-HJKSTUW])|([A-PR-UWYZ][A-HK-Y][0-9][ABEHMNPRVWXY]))\s?([0-9][ABD-HJLNP-UW-Z]{2})|(GIR)\s?(0AA))$/i.test( value );
}, "Please specify a valid UK postcode" );

/*
 * Lets you say "at least X inputs that match selector Y must be filled."
 *
 * The end result is that neither of these inputs:
 *
 *	<input class="productinfo" name="partnumber">
 *	<input class="productinfo" name="description">
 *
 *	...will validate unless at least one of them is filled.
 *
 * partnumber:	{require_from_group: [1,".productinfo"]},
 * description: {require_from_group: [1,".productinfo"]}
 *
 * options[0]: number of fields that must be filled in the group
 * options[1]: CSS selector that defines the group of conditionally required fields
 */
$.validator.addMethod( "require_from_group", function( value, element, options ) {
	var $fields = $( options[ 1 ], element.form ),
		$fieldsFirst = $fields.eq( 0 ),
		validator = $fieldsFirst.data( "valid_req_grp" ) ? $fieldsFirst.data( "valid_req_grp" ) : $.extend( {}, this ),
		isValid = $fields.filter( function() {
			return validator.elementValue( this );
		} ).length >= options[ 0 ];

	// Store the cloned validator for future validation
	$fieldsFirst.data( "valid_req_grp", validator );

	// If element isn't being validated, run each require_from_group field's validation rules
	if ( !$( element ).data( "being_validated" ) ) {
		$fields.data( "being_validated", true );
		$fields.each( function() {
			validator.element( this );
		} );
		$fields.data( "being_validated", false );
	}
	return isValid;
}, $.validator.format( "Please fill at least {0} of these fields." ) );

/*
 * Lets you say "either at least X inputs that match selector Y must be filled,
 * OR they must all be skipped (left blank)."
 *
 * The end result, is that none of these inputs:
 *
 *	<input class="productinfo" name="partnumber">
 *	<input class="productinfo" name="description">
 *	<input class="productinfo" name="color">
 *
 *	...will validate unless either at least two of them are filled,
 *	OR none of them are.
 *
 * partnumber:	{skip_or_fill_minimum: [2,".productinfo"]},
 * description: {skip_or_fill_minimum: [2,".productinfo"]},
 * color:		{skip_or_fill_minimum: [2,".productinfo"]}
 *
 * options[0]: number of fields that must be filled in the group
 * options[1]: CSS selector that defines the group of conditionally required fields
 *
 */
$.validator.addMethod( "skip_or_fill_minimum", function( value, element, options ) {
	var $fields = $( options[ 1 ], element.form ),
		$fieldsFirst = $fields.eq( 0 ),
		validator = $fieldsFirst.data( "valid_skip" ) ? $fieldsFirst.data( "valid_skip" ) : $.extend( {}, this ),
		numberFilled = $fields.filter( function() {
			return validator.elementValue( this );
		} ).length,
		isValid = numberFilled === 0 || numberFilled >= options[ 0 ];

	// Store the cloned validator for future validation
	$fieldsFirst.data( "valid_skip", validator );

	// If element isn't being validated, run each skip_or_fill_minimum field's validation rules
	if ( !$( element ).data( "being_validated" ) ) {
		$fields.data( "being_validated", true );
		$fields.each( function() {
			validator.element( this );
		} );
		$fields.data( "being_validated", false );
	}
	return isValid;
}, $.validator.format( "Please either skip these fields or fill at least {0} of them." ) );

/* Validates US States and/or Territories by @jdforsythe
 * Can be case insensitive or require capitalization - default is case insensitive
 * Can include US Territories or not - default does not
 * Can include US Military postal abbreviations (AA, AE, AP) - default does not
 *
 * Note: "States" always includes DC (District of Colombia)
 *
 * Usage examples:
 *
 *  This is the default - case insensitive, no territories, no military zones
 *  stateInput: {
 *     caseSensitive: false,
 *     includeTerritories: false,
 *     includeMilitary: false
 *  }
 *
 *  Only allow capital letters, no territories, no military zones
 *  stateInput: {
 *     caseSensitive: false
 *  }
 *
 *  Case insensitive, include territories but not military zones
 *  stateInput: {
 *     includeTerritories: true
 *  }
 *
 *  Only allow capital letters, include territories and military zones
 *  stateInput: {
 *     caseSensitive: true,
 *     includeTerritories: true,
 *     includeMilitary: true
 *  }
 *
 */
$.validator.addMethod( "stateUS", function( value, element, options ) {
	var isDefault = typeof options === "undefined",
		caseSensitive = ( isDefault || typeof options.caseSensitive === "undefined" ) ? false : options.caseSensitive,
		includeTerritories = ( isDefault || typeof options.includeTerritories === "undefined" ) ? false : options.includeTerritories,
		includeMilitary = ( isDefault || typeof options.includeMilitary === "undefined" ) ? false : options.includeMilitary,
		regex;

	if ( !includeTerritories && !includeMilitary ) {
		regex = "^(A[KLRZ]|C[AOT]|D[CE]|FL|GA|HI|I[ADLN]|K[SY]|LA|M[ADEINOST]|N[CDEHJMVY]|O[HKR]|PA|RI|S[CD]|T[NX]|UT|V[AT]|W[AIVY])$";
	} else if ( includeTerritories && includeMilitary ) {
		regex = "^(A[AEKLPRSZ]|C[AOT]|D[CE]|FL|G[AU]|HI|I[ADLN]|K[SY]|LA|M[ADEINOPST]|N[CDEHJMVY]|O[HKR]|P[AR]|RI|S[CD]|T[NX]|UT|V[AIT]|W[AIVY])$";
	} else if ( includeTerritories ) {
		regex = "^(A[KLRSZ]|C[AOT]|D[CE]|FL|G[AU]|HI|I[ADLN]|K[SY]|LA|M[ADEINOPST]|N[CDEHJMVY]|O[HKR]|P[AR]|RI|S[CD]|T[NX]|UT|V[AIT]|W[AIVY])$";
	} else {
		regex = "^(A[AEKLPRZ]|C[AOT]|D[CE]|FL|GA|HI|I[ADLN]|K[SY]|LA|M[ADEINOST]|N[CDEHJMVY]|O[HKR]|PA|RI|S[CD]|T[NX]|UT|V[AT]|W[AIVY])$";
	}

	regex = caseSensitive ? new RegExp( regex ) : new RegExp( regex, "i" );
	return this.optional( element ) || regex.test( value );
}, "Please specify a valid state" );

// TODO check if value starts with <, otherwise don't try stripping anything
$.validator.addMethod( "strippedminlength", function( value, element, param ) {
	return $( value ).text().length >= param;
}, $.validator.format( "Please enter at least {0} characters" ) );

$.validator.addMethod( "time", function( value, element ) {
	return this.optional( element ) || /^([01]\d|2[0-3]|[0-9])(:[0-5]\d){1,2}$/.test( value );
}, "Please enter a valid time, between 00:00 and 23:59" );

$.validator.addMethod( "time12h", function( value, element ) {
	return this.optional( element ) || /^((0?[1-9]|1[012])(:[0-5]\d){1,2}(\ ?[AP]M))$/i.test( value );
}, "Please enter a valid time in 12-hour am/pm format" );

// Same as url, but TLD is optional
$.validator.addMethod( "url2", function( value, element ) {
	return this.optional( element ) || /^(https?|ftp):\/\/(((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:)*@)?(((\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5]))|((([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.)*(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.?)(:\d*)?)(\/((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)+(\/(([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)*)*)?)?(\?((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)|[\uE000-\uF8FF]|\/|\?)*)?(#((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)|\/|\?)*)?$/i.test( value );
}, $.validator.messages.url );

/**
 * Return true, if the value is a valid vehicle identification number (VIN).
 *
 * Works with all kind of text inputs.
 *
 * @example <input type="text" size="20" name="VehicleID" class="{required:true,vinUS:true}" />
 * @desc Declares a required input element whose value must be a valid vehicle identification number.
 *
 * @name $.validator.methods.vinUS
 * @type Boolean
 * @cat Plugins/Validate/Methods
 */
$.validator.addMethod( "vinUS", function( v ) {
	if ( v.length !== 17 ) {
		return false;
	}

	var LL = [ "A", "B", "C", "D", "E", "F", "G", "H", "J", "K", "L", "M", "N", "P", "R", "S", "T", "U", "V", "W", "X", "Y", "Z" ],
		VL = [ 1, 2, 3, 4, 5, 6, 7, 8, 1, 2, 3, 4, 5, 7, 9, 2, 3, 4, 5, 6, 7, 8, 9 ],
		FL = [ 8, 7, 6, 5, 4, 3, 2, 10, 0, 9, 8, 7, 6, 5, 4, 3, 2 ],
		rs = 0,
		i, n, d, f, cd, cdv;

	for ( i = 0; i < 17; i++ ) {
		f = FL[ i ];
		d = v.slice( i, i + 1 );
		if ( i === 8 ) {
			cdv = d;
		}
		if ( !isNaN( d ) ) {
			d *= f;
		} else {
			for ( n = 0; n < LL.length; n++ ) {
				if ( d.toUpperCase() === LL[ n ] ) {
					d = VL[ n ];
					d *= f;
					if ( isNaN( cdv ) && n === 8 ) {
						cdv = LL[ n ];
					}
					break;
				}
			}
		}
		rs += d;
	}
	cd = rs % 11;
	if ( cd === 10 ) {
		cd = "X";
	}
	if ( cd === cdv ) {
		return true;
	}
	return false;
}, "The specified vehicle identification number (VIN) is invalid." );

$.validator.addMethod( "zipcodeUS", function( value, element ) {
	return this.optional( element ) || /^\d{5}(-\d{4})?$/.test( value );
}, "The specified US ZIP Code is invalid" );

$.validator.addMethod( "ziprange", function( value, element ) {
	return this.optional( element ) || /^90[2-5]\d\{2\}-\d{4}$/.test( value );
}, "Your ZIP-code must be in the range 902xx-xxxx to 905xx-xxxx" );
return $;
}));
/*!
 * Vue.js v2.5.13
 * (c) 2014-2017 Evan You
 * Released under the MIT License.
 */
!function(t,e){"object"==typeof exports&&"undefined"!=typeof module?module.exports=e():"function"==typeof define&&define.amd?define(e):t.Vue=e()}(this,function(){"use strict";function t(t){return void 0===t||null===t}function e(t){return void 0!==t&&null!==t}function n(t){return!0===t}function r(t){return"string"==typeof t||"number"==typeof t||"symbol"==typeof t||"boolean"==typeof t}function i(t){return null!==t&&"object"==typeof t}function o(t){return"[object Object]"===Nn.call(t)}function a(t){var e=parseFloat(String(t));return e>=0&&Math.floor(e)===e&&isFinite(t)}function s(t){return null==t?"":"object"==typeof t?JSON.stringify(t,null,2):String(t)}function c(t){var e=parseFloat(t);return isNaN(e)?t:e}function u(t,e){for(var n=Object.create(null),r=t.split(","),i=0;i<r.length;i++)n[r[i]]=!0;return e?function(t){return n[t.toLowerCase()]}:function(t){return n[t]}}function l(t,e){if(t.length){var n=t.indexOf(e);if(n>-1)return t.splice(n,1)}}function f(t,e){return Mn.call(t,e)}function p(t){var e=Object.create(null);return function(n){return e[n]||(e[n]=t(n))}}function d(t,e){function n(n){var r=arguments.length;return r?r>1?t.apply(e,arguments):t.call(e,n):t.call(e)}return n._length=t.length,n}function v(t,e){e=e||0;for(var n=t.length-e,r=new Array(n);n--;)r[n]=t[n+e];return r}function h(t,e){for(var n in e)t[n]=e[n];return t}function m(t){for(var e={},n=0;n<t.length;n++)t[n]&&h(e,t[n]);return e}function y(t,e,n){}function g(t,e){if(t===e)return!0;var n=i(t),r=i(e);if(!n||!r)return!n&&!r&&String(t)===String(e);try{var o=Array.isArray(t),a=Array.isArray(e);if(o&&a)return t.length===e.length&&t.every(function(t,n){return g(t,e[n])});if(o||a)return!1;var s=Object.keys(t),c=Object.keys(e);return s.length===c.length&&s.every(function(n){return g(t[n],e[n])})}catch(t){return!1}}function _(t,e){for(var n=0;n<t.length;n++)if(g(t[n],e))return n;return-1}function b(t){var e=!1;return function(){e||(e=!0,t.apply(this,arguments))}}function $(t){var e=(t+"").charCodeAt(0);return 36===e||95===e}function C(t,e,n,r){Object.defineProperty(t,e,{value:n,enumerable:!!r,writable:!0,configurable:!0})}function w(t){return"function"==typeof t&&/native code/.test(t.toString())}function x(t){return new mr(void 0,void 0,void 0,String(t))}function k(t,e){var n=t.componentOptions,r=new mr(t.tag,t.data,t.children,t.text,t.elm,t.context,n,t.asyncFactory);return r.ns=t.ns,r.isStatic=t.isStatic,r.key=t.key,r.isComment=t.isComment,r.fnContext=t.fnContext,r.fnOptions=t.fnOptions,r.fnScopeId=t.fnScopeId,r.isCloned=!0,e&&(t.children&&(r.children=A(t.children,!0)),n&&n.children&&(n.children=A(n.children,!0))),r}function A(t,e){for(var n=t.length,r=new Array(n),i=0;i<n;i++)r[i]=k(t[i],e);return r}function O(t,e,n){t.__proto__=e}function S(t,e,n){for(var r=0,i=n.length;r<i;r++){var o=n[r];C(t,o,e[o])}}function T(t,e){if(i(t)&&!(t instanceof mr)){var n;return f(t,"__ob__")&&t.__ob__ instanceof wr?n=t.__ob__:Cr.shouldConvert&&!ur()&&(Array.isArray(t)||o(t))&&Object.isExtensible(t)&&!t._isVue&&(n=new wr(t)),e&&n&&n.vmCount++,n}}function E(t,e,n,r,i){var o=new vr,a=Object.getOwnPropertyDescriptor(t,e);if(!a||!1!==a.configurable){var s=a&&a.get,c=a&&a.set,u=!i&&T(n);Object.defineProperty(t,e,{enumerable:!0,configurable:!0,get:function(){var e=s?s.call(t):n;return vr.target&&(o.depend(),u&&(u.dep.depend(),Array.isArray(e)&&I(e))),e},set:function(e){var r=s?s.call(t):n;e===r||e!=e&&r!=r||(c?c.call(t,e):n=e,u=!i&&T(e),o.notify())}})}}function j(t,e,n){if(Array.isArray(t)&&a(e))return t.length=Math.max(t.length,e),t.splice(e,1,n),n;if(e in t&&!(e in Object.prototype))return t[e]=n,n;var r=t.__ob__;return t._isVue||r&&r.vmCount?n:r?(E(r.value,e,n),r.dep.notify(),n):(t[e]=n,n)}function N(t,e){if(Array.isArray(t)&&a(e))t.splice(e,1);else{var n=t.__ob__;t._isVue||n&&n.vmCount||f(t,e)&&(delete t[e],n&&n.dep.notify())}}function I(t){for(var e=void 0,n=0,r=t.length;n<r;n++)(e=t[n])&&e.__ob__&&e.__ob__.dep.depend(),Array.isArray(e)&&I(e)}function L(t,e){if(!e)return t;for(var n,r,i,a=Object.keys(e),s=0;s<a.length;s++)r=t[n=a[s]],i=e[n],f(t,n)?o(r)&&o(i)&&L(r,i):j(t,n,i);return t}function M(t,e,n){return n?function(){var r="function"==typeof e?e.call(n,n):e,i="function"==typeof t?t.call(n,n):t;return r?L(r,i):i}:e?t?function(){return L("function"==typeof e?e.call(this,this):e,"function"==typeof t?t.call(this,this):t)}:e:t}function D(t,e){return e?t?t.concat(e):Array.isArray(e)?e:[e]:t}function P(t,e,n,r){var i=Object.create(t||null);return e?h(i,e):i}function F(t,e,n){function r(r){var i=xr[r]||Or;u[r]=i(t[r],e[r],n,r)}"function"==typeof e&&(e=e.options),function(t,e){var n=t.props;if(n){var r,i,a={};if(Array.isArray(n))for(r=n.length;r--;)"string"==typeof(i=n[r])&&(a[Pn(i)]={type:null});else if(o(n))for(var s in n)i=n[s],a[Pn(s)]=o(i)?i:{type:i};t.props=a}}(e),function(t,e){var n=t.inject;if(n){var r=t.inject={};if(Array.isArray(n))for(var i=0;i<n.length;i++)r[n[i]]={from:n[i]};else if(o(n))for(var a in n){var s=n[a];r[a]=o(s)?h({from:a},s):{from:s}}}}(e),function(t){var e=t.directives;if(e)for(var n in e){var r=e[n];"function"==typeof r&&(e[n]={bind:r,update:r})}}(e);var i=e.extends;if(i&&(t=F(t,i,n)),e.mixins)for(var a=0,s=e.mixins.length;a<s;a++)t=F(t,e.mixins[a],n);var c,u={};for(c in t)r(c);for(c in e)f(t,c)||r(c);return u}function R(t,e,n,r){if("string"==typeof n){var i=t[e];if(f(i,n))return i[n];var o=Pn(n);if(f(i,o))return i[o];var a=Fn(o);if(f(i,a))return i[a];return i[n]||i[o]||i[a]}}function H(t,e,n,r){var i=e[t],o=!f(n,t),a=n[t];if(U(Boolean,i.type)&&(o&&!f(i,"default")?a=!1:U(String,i.type)||""!==a&&a!==Hn(t)||(a=!0)),void 0===a){a=function(t,e,n){if(!f(e,"default"))return;var r=e.default;if(t&&t.$options.propsData&&void 0===t.$options.propsData[n]&&void 0!==t._props[n])return t._props[n];return"function"==typeof r&&"Function"!==B(e.type)?r.call(t):r}(r,i,t);var s=Cr.shouldConvert;Cr.shouldConvert=!0,T(a),Cr.shouldConvert=s}return a}function B(t){var e=t&&t.toString().match(/^\s*function (\w+)/);return e?e[1]:""}function U(t,e){if(!Array.isArray(e))return B(e)===B(t);for(var n=0,r=e.length;n<r;n++)if(B(e[n])===B(t))return!0;return!1}function V(t,e,n){if(e)for(var r=e;r=r.$parent;){var i=r.$options.errorCaptured;if(i)for(var o=0;o<i.length;o++)try{if(!1===i[o].call(r,t,e,n))return}catch(t){z(t,r,"errorCaptured hook")}}z(t,e,n)}function z(t,e,n){if(Jn.errorHandler)try{return Jn.errorHandler.call(null,t,e,n)}catch(t){K(t,null,"config.errorHandler")}K(t,e,n)}function K(t,e,n){if(!Gn&&!Zn||"undefined"==typeof console)throw t;console.error(t)}function J(){Tr=!1;var t=Sr.slice(0);Sr.length=0;for(var e=0;e<t.length;e++)t[e]()}function q(t,e){var n;if(Sr.push(function(){if(t)try{t.call(e)}catch(t){V(t,e,"nextTick")}else n&&n(e)}),Tr||(Tr=!0,Er?Ar():kr()),!t&&"undefined"!=typeof Promise)return new Promise(function(t){n=t})}function W(t){G(t,Mr),Mr.clear()}function G(t,e){var n,r,o=Array.isArray(t);if((o||i(t))&&!Object.isFrozen(t)){if(t.__ob__){var a=t.__ob__.dep.id;if(e.has(a))return;e.add(a)}if(o)for(n=t.length;n--;)G(t[n],e);else for(n=(r=Object.keys(t)).length;n--;)G(t[r[n]],e)}}function Z(t){function e(){var t=arguments,n=e.fns;if(!Array.isArray(n))return n.apply(null,arguments);for(var r=n.slice(),i=0;i<r.length;i++)r[i].apply(null,t)}return e.fns=t,e}function X(e,n,r,i,o){var a,s,c,u;for(a in e)s=e[a],c=n[a],u=Dr(a),t(s)||(t(c)?(t(s.fns)&&(s=e[a]=Z(s)),r(u.name,s,u.once,u.capture,u.passive,u.params)):s!==c&&(c.fns=s,e[a]=c));for(a in n)t(e[a])&&i((u=Dr(a)).name,n[a],u.capture)}function Y(r,i,o){function a(){o.apply(this,arguments),l(s.fns,a)}r instanceof mr&&(r=r.data.hook||(r.data.hook={}));var s,c=r[i];t(c)?s=Z([a]):e(c.fns)&&n(c.merged)?(s=c).fns.push(a):s=Z([c,a]),s.merged=!0,r[i]=s}function Q(t,n,r,i,o){if(e(n)){if(f(n,r))return t[r]=n[r],o||delete n[r],!0;if(f(n,i))return t[r]=n[i],o||delete n[i],!0}return!1}function tt(t){return e(t)&&e(t.text)&&function(t){return!1===t}(t.isComment)}function et(i,o){var a,s,c,u,l=[];for(a=0;a<i.length;a++)t(s=i[a])||"boolean"==typeof s||(u=l[c=l.length-1],Array.isArray(s)?s.length>0&&(tt((s=et(s,(o||"")+"_"+a))[0])&&tt(u)&&(l[c]=x(u.text+s[0].text),s.shift()),l.push.apply(l,s)):r(s)?tt(u)?l[c]=x(u.text+s):""!==s&&l.push(x(s)):tt(s)&&tt(u)?l[c]=x(u.text+s.text):(n(i._isVList)&&e(s.tag)&&t(s.key)&&e(o)&&(s.key="__vlist"+o+"_"+a+"__"),l.push(s)));return l}function nt(t,e){return(t.__esModule||fr&&"Module"===t[Symbol.toStringTag])&&(t=t.default),i(t)?e.extend(t):t}function rt(t){return t.isComment&&t.asyncFactory}function it(t){if(Array.isArray(t))for(var n=0;n<t.length;n++){var r=t[n];if(e(r)&&(e(r.componentOptions)||rt(r)))return r}}function ot(t,e,n){n?Lr.$once(t,e):Lr.$on(t,e)}function at(t,e){Lr.$off(t,e)}function st(t,e,n){Lr=t,X(e,n||{},ot,at),Lr=void 0}function ct(t,e){var n={};if(!t)return n;for(var r=0,i=t.length;r<i;r++){var o=t[r],a=o.data;if(a&&a.attrs&&a.attrs.slot&&delete a.attrs.slot,o.context!==e&&o.fnContext!==e||!a||null==a.slot)(n.default||(n.default=[])).push(o);else{var s=a.slot,c=n[s]||(n[s]=[]);"template"===o.tag?c.push.apply(c,o.children||[]):c.push(o)}}for(var u in n)n[u].every(ut)&&delete n[u];return n}function ut(t){return t.isComment&&!t.asyncFactory||" "===t.text}function lt(t,e){e=e||{};for(var n=0;n<t.length;n++)Array.isArray(t[n])?lt(t[n],e):e[t[n].key]=t[n].fn;return e}function ft(t){for(;t&&(t=t.$parent);)if(t._inactive)return!0;return!1}function pt(t,e){if(e){if(t._directInactive=!1,ft(t))return}else if(t._directInactive)return;if(t._inactive||null===t._inactive){t._inactive=!1;for(var n=0;n<t.$children.length;n++)pt(t.$children[n]);vt(t,"activated")}}function dt(t,e){if(!(e&&(t._directInactive=!0,ft(t))||t._inactive)){t._inactive=!0;for(var n=0;n<t.$children.length;n++)dt(t.$children[n]);vt(t,"deactivated")}}function vt(t,e){var n=t.$options[e];if(n)for(var r=0,i=n.length;r<i;r++)try{n[r].call(t)}catch(n){V(n,t,e+" hook")}t._hasHookEvent&&t.$emit("hook:"+e)}function ht(){Ur=!0;var t,e;for(Fr.sort(function(t,e){return t.id-e.id}),Vr=0;Vr<Fr.length;Vr++)e=(t=Fr[Vr]).id,Hr[e]=null,t.run();var n=Rr.slice(),r=Fr.slice();Vr=Fr.length=Rr.length=0,Hr={},Br=Ur=!1,function(t){for(var e=0;e<t.length;e++)t[e]._inactive=!0,pt(t[e],!0)}(n),function(t){var e=t.length;for(;e--;){var n=t[e],r=n.vm;r._watcher===n&&r._isMounted&&vt(r,"updated")}}(r),lr&&Jn.devtools&&lr.emit("flush")}function mt(t,e,n){Jr.get=function(){return this[e][n]},Jr.set=function(t){this[e][n]=t},Object.defineProperty(t,n,Jr)}function yt(t){t._watchers=[];var e=t.$options;e.props&&function(t,e){var n=t.$options.propsData||{},r=t._props={},i=t.$options._propKeys=[],o=!t.$parent;Cr.shouldConvert=o;var a=function(o){i.push(o);var a=H(o,e,n,t);E(r,o,a),o in t||mt(t,"_props",o)};for(var s in e)a(s);Cr.shouldConvert=!0}(t,e.props),e.methods&&function(t,e){t.$options.props;for(var n in e)t[n]=null==e[n]?y:d(e[n],t)}(t,e.methods),e.data?function(t){var e=t.$options.data;e=t._data="function"==typeof e?function(t,e){try{return t.call(e,e)}catch(t){return V(t,e,"data()"),{}}}(e,t):e||{},o(e)||(e={});var n=Object.keys(e),r=t.$options.props,i=(t.$options.methods,n.length);for(;i--;){var a=n[i];r&&f(r,a)||$(a)||mt(t,"_data",a)}T(e,!0)}(t):T(t._data={},!0),e.computed&&function(t,e){var n=t._computedWatchers=Object.create(null),r=ur();for(var i in e){var o=e[i],a="function"==typeof o?o:o.get;r||(n[i]=new Kr(t,a||y,y,qr)),i in t||gt(t,i,o)}}(t,e.computed),e.watch&&e.watch!==ir&&function(t,e){for(var n in e){var r=e[n];if(Array.isArray(r))for(var i=0;i<r.length;i++)bt(t,n,r[i]);else bt(t,n,r)}}(t,e.watch)}function gt(t,e,n){var r=!ur();"function"==typeof n?(Jr.get=r?_t(e):n,Jr.set=y):(Jr.get=n.get?r&&!1!==n.cache?_t(e):n.get:y,Jr.set=n.set?n.set:y),Object.defineProperty(t,e,Jr)}function _t(t){return function(){var e=this._computedWatchers&&this._computedWatchers[t];if(e)return e.dirty&&e.evaluate(),vr.target&&e.depend(),e.value}}function bt(t,e,n,r){return o(n)&&(r=n,n=n.handler),"string"==typeof n&&(n=t[n]),t.$watch(e,n,r)}function $t(t,e){if(t){for(var n=Object.create(null),r=fr?Reflect.ownKeys(t).filter(function(e){return Object.getOwnPropertyDescriptor(t,e).enumerable}):Object.keys(t),i=0;i<r.length;i++){for(var o=r[i],a=t[o].from,s=e;s;){if(s._provided&&a in s._provided){n[o]=s._provided[a];break}s=s.$parent}if(!s&&"default"in t[o]){var c=t[o].default;n[o]="function"==typeof c?c.call(e):c}}return n}}function Ct(t,n){var r,o,a,s,c;if(Array.isArray(t)||"string"==typeof t)for(r=new Array(t.length),o=0,a=t.length;o<a;o++)r[o]=n(t[o],o);else if("number"==typeof t)for(r=new Array(t),o=0;o<t;o++)r[o]=n(o+1,o);else if(i(t))for(s=Object.keys(t),r=new Array(s.length),o=0,a=s.length;o<a;o++)c=s[o],r[o]=n(t[c],c,o);return e(r)&&(r._isVList=!0),r}function wt(t,e,n,r){var i,o=this.$scopedSlots[t];if(o)n=n||{},r&&(n=h(h({},r),n)),i=o(n)||e;else{var a=this.$slots[t];a&&(a._rendered=!0),i=a||e}var s=n&&n.slot;return s?this.$createElement("template",{slot:s},i):i}function xt(t){return R(this.$options,"filters",t)||Un}function kt(t,e,n,r){var i=Jn.keyCodes[e]||n;return i?Array.isArray(i)?-1===i.indexOf(t):i!==t:r?Hn(r)!==e:void 0}function At(t,e,n,r,o){if(n)if(i(n)){Array.isArray(n)&&(n=m(n));var a,s=function(i){if("class"===i||"style"===i||Ln(i))a=t;else{var s=t.attrs&&t.attrs.type;a=r||Jn.mustUseProp(e,s,i)?t.domProps||(t.domProps={}):t.attrs||(t.attrs={})}if(!(i in a)&&(a[i]=n[i],o)){(t.on||(t.on={}))["update:"+i]=function(t){n[i]=t}}};for(var c in n)s(c)}else;return t}function Ot(t,e){var n=this._staticTrees||(this._staticTrees=[]),r=n[t];return r&&!e?Array.isArray(r)?A(r):k(r):(r=n[t]=this.$options.staticRenderFns[t].call(this._renderProxy,null,this),Tt(r,"__static__"+t,!1),r)}function St(t,e,n){return Tt(t,"__once__"+e+(n?"_"+n:""),!0),t}function Tt(t,e,n){if(Array.isArray(t))for(var r=0;r<t.length;r++)t[r]&&"string"!=typeof t[r]&&Et(t[r],e+"_"+r,n);else Et(t,e,n)}function Et(t,e,n){t.isStatic=!0,t.key=e,t.isOnce=n}function jt(t,e){if(e)if(o(e)){var n=t.on=t.on?h({},t.on):{};for(var r in e){var i=n[r],a=e[r];n[r]=i?[].concat(i,a):a}}else;return t}function Nt(t){t._o=St,t._n=c,t._s=s,t._l=Ct,t._t=wt,t._q=g,t._i=_,t._m=Ot,t._f=xt,t._k=kt,t._b=At,t._v=x,t._e=gr,t._u=lt,t._g=jt}function It(t,e,r,i,o){var a=o.options;this.data=t,this.props=e,this.children=r,this.parent=i,this.listeners=t.on||jn,this.injections=$t(a.inject,i),this.slots=function(){return ct(r,i)};var s=Object.create(i),c=n(a._compiled),u=!c;c&&(this.$options=a,this.$slots=this.slots(),this.$scopedSlots=t.scopedSlots||jn),a._scopeId?this._c=function(t,e,n,r){var o=Dt(s,t,e,n,r,u);return o&&(o.fnScopeId=a._scopeId,o.fnContext=i),o}:this._c=function(t,e,n,r){return Dt(s,t,e,n,r,u)}}function Lt(t,e){for(var n in e)t[Pn(n)]=e[n]}function Mt(r,o,a,s,c){if(!t(r)){var u=a.$options._base;if(i(r)&&(r=u.extend(r)),"function"==typeof r){var l;if(t(r.cid)&&(l=r,void 0===(r=function(r,o,a){if(n(r.error)&&e(r.errorComp))return r.errorComp;if(e(r.resolved))return r.resolved;if(n(r.loading)&&e(r.loadingComp))return r.loadingComp;if(!e(r.contexts)){var s=r.contexts=[a],c=!0,u=function(){for(var t=0,e=s.length;t<e;t++)s[t].$forceUpdate()},l=b(function(t){r.resolved=nt(t,o),c||u()}),f=b(function(t){e(r.errorComp)&&(r.error=!0,u())}),p=r(l,f);return i(p)&&("function"==typeof p.then?t(r.resolved)&&p.then(l,f):e(p.component)&&"function"==typeof p.component.then&&(p.component.then(l,f),e(p.error)&&(r.errorComp=nt(p.error,o)),e(p.loading)&&(r.loadingComp=nt(p.loading,o),0===p.delay?r.loading=!0:setTimeout(function(){t(r.resolved)&&t(r.error)&&(r.loading=!0,u())},p.delay||200)),e(p.timeout)&&setTimeout(function(){t(r.resolved)&&f(null)},p.timeout))),c=!1,r.loading?r.loadingComp:r.resolved}r.contexts.push(a)}(l,u,a))))return function(t,e,n,r,i){var o=gr();return o.asyncFactory=t,o.asyncMeta={data:e,context:n,children:r,tag:i},o}(l,o,a,s,c);o=o||{},Ft(r),e(o.model)&&function(t,n){var r=t.model&&t.model.prop||"value",i=t.model&&t.model.event||"input";(n.props||(n.props={}))[r]=n.model.value;var o=n.on||(n.on={});e(o[i])?o[i]=[n.model.callback].concat(o[i]):o[i]=n.model.callback}(r.options,o);var f=function(n,r,i){var o=r.options.props;if(!t(o)){var a={},s=n.attrs,c=n.props;if(e(s)||e(c))for(var u in o){var l=Hn(u);Q(a,c,u,l,!0)||Q(a,s,u,l,!1)}return a}}(o,r);if(n(r.options.functional))return function(t,n,r,i,o){var a=t.options,s={},c=a.props;if(e(c))for(var u in c)s[u]=H(u,c,n||jn);else e(r.attrs)&&Lt(s,r.attrs),e(r.props)&&Lt(s,r.props);var l=new It(r,s,o,i,t),f=a.render.call(null,l._c,l);return f instanceof mr&&(f.fnContext=i,f.fnOptions=a,r.slot&&((f.data||(f.data={})).slot=r.slot)),f}(r,f,o,a,s);var p=o.on;if(o.on=o.nativeOn,n(r.options.abstract)){var d=o.slot;o={},d&&(o.slot=d)}!function(t){t.hook||(t.hook={});for(var e=0;e<Gr.length;e++){var n=Gr[e],r=t.hook[n],i=Wr[n];t.hook[n]=r?function(t,e){return function(n,r,i,o){t(n,r,i,o),e(n,r,i,o)}}(i,r):i}}(o);var v=r.options.name||c;return new mr("vue-component-"+r.cid+(v?"-"+v:""),o,void 0,void 0,void 0,a,{Ctor:r,propsData:f,listeners:p,tag:c,children:s},l)}}}function Dt(t,i,o,a,s,c){return(Array.isArray(o)||r(o))&&(s=a,a=o,o=void 0),n(c)&&(s=Xr),function(t,n,i,o,a){if(e(i)&&e(i.__ob__))return gr();e(i)&&e(i.is)&&(n=i.is);if(!n)return gr();Array.isArray(o)&&"function"==typeof o[0]&&((i=i||{}).scopedSlots={default:o[0]},o.length=0);a===Xr?o=function(t){return r(t)?[x(t)]:Array.isArray(t)?et(t):void 0}(o):a===Zr&&(o=function(t){for(var e=0;e<t.length;e++)if(Array.isArray(t[e]))return Array.prototype.concat.apply([],t);return t}(o));var s,c;if("string"==typeof n){var u;c=t.$vnode&&t.$vnode.ns||Jn.getTagNamespace(n),s=Jn.isReservedTag(n)?new mr(Jn.parsePlatformTagName(n),i,o,void 0,void 0,t):e(u=R(t.$options,"components",n))?Mt(u,i,t,o,n):new mr(n,i,o,void 0,void 0,t)}else s=Mt(n,i,t,o);return e(s)?(c&&Pt(s,c),s):gr()}(t,i,o,a,s)}function Pt(r,i,o){if(r.ns=i,"foreignObject"===r.tag&&(i=void 0,o=!0),e(r.children))for(var a=0,s=r.children.length;a<s;a++){var c=r.children[a];e(c.tag)&&(t(c.ns)||n(o))&&Pt(c,i,o)}}function Ft(t){var e=t.options;if(t.super){var n=Ft(t.super);if(n!==t.superOptions){t.superOptions=n;var r=function(t){var e,n=t.options,r=t.extendOptions,i=t.sealedOptions;for(var o in n)n[o]!==i[o]&&(e||(e={}),e[o]=function(t,e,n){{if(Array.isArray(t)){var r=[];n=Array.isArray(n)?n:[n],e=Array.isArray(e)?e:[e];for(var i=0;i<t.length;i++)(e.indexOf(t[i])>=0||n.indexOf(t[i])<0)&&r.push(t[i]);return r}return t}}(n[o],r[o],i[o]));return e}(t);r&&h(t.extendOptions,r),(e=t.options=F(n,t.extendOptions)).name&&(e.components[e.name]=t)}}return e}function Rt(t){this._init(t)}function Ht(t){t.cid=0;var e=1;t.extend=function(t){t=t||{};var n=this,r=n.cid,i=t._Ctor||(t._Ctor={});if(i[r])return i[r];var o=t.name||n.options.name,a=function(t){this._init(t)};return a.prototype=Object.create(n.prototype),a.prototype.constructor=a,a.cid=e++,a.options=F(n.options,t),a.super=n,a.options.props&&function(t){var e=t.options.props;for(var n in e)mt(t.prototype,"_props",n)}(a),a.options.computed&&function(t){var e=t.options.computed;for(var n in e)gt(t.prototype,n,e[n])}(a),a.extend=n.extend,a.mixin=n.mixin,a.use=n.use,zn.forEach(function(t){a[t]=n[t]}),o&&(a.options.components[o]=a),a.superOptions=n.options,a.extendOptions=t,a.sealedOptions=h({},a.options),i[r]=a,a}}function Bt(t){return t&&(t.Ctor.options.name||t.tag)}function Ut(t,e){return Array.isArray(t)?t.indexOf(e)>-1:"string"==typeof t?t.split(",").indexOf(e)>-1:!!function(t){return"[object RegExp]"===Nn.call(t)}(t)&&t.test(e)}function Vt(t,e){var n=t.cache,r=t.keys,i=t._vnode;for(var o in n){var a=n[o];if(a){var s=Bt(a.componentOptions);s&&!e(s)&&zt(n,o,r,i)}}}function zt(t,e,n,r){var i=t[e];!i||r&&i.tag===r.tag||i.componentInstance.$destroy(),t[e]=null,l(n,e)}function Kt(t){for(var n=t.data,r=t,i=t;e(i.componentInstance);)(i=i.componentInstance._vnode)&&i.data&&(n=Jt(i.data,n));for(;e(r=r.parent);)r&&r.data&&(n=Jt(n,r.data));return function(t,n){if(e(t)||e(n))return qt(t,Wt(n));return""}(n.staticClass,n.class)}function Jt(t,n){return{staticClass:qt(t.staticClass,n.staticClass),class:e(t.class)?[t.class,n.class]:n.class}}function qt(t,e){return t?e?t+" "+e:t:e||""}function Wt(t){return Array.isArray(t)?function(t){for(var n,r="",i=0,o=t.length;i<o;i++)e(n=Wt(t[i]))&&""!==n&&(r&&(r+=" "),r+=n);return r}(t):i(t)?function(t){var e="";for(var n in t)t[n]&&(e&&(e+=" "),e+=n);return e}(t):"string"==typeof t?t:""}function Gt(t){return bi(t)?"svg":"math"===t?"math":void 0}function Zt(t){if("string"==typeof t){var e=document.querySelector(t);return e||document.createElement("div")}return t}function Xt(t,e){var n=t.data.ref;if(n){var r=t.context,i=t.componentInstance||t.elm,o=r.$refs;e?Array.isArray(o[n])?l(o[n],i):o[n]===i&&(o[n]=void 0):t.data.refInFor?Array.isArray(o[n])?o[n].indexOf(i)<0&&o[n].push(i):o[n]=[i]:o[n]=i}}function Yt(r,i){return r.key===i.key&&(r.tag===i.tag&&r.isComment===i.isComment&&e(r.data)===e(i.data)&&function(t,n){if("input"!==t.tag)return!0;var r,i=e(r=t.data)&&e(r=r.attrs)&&r.type,o=e(r=n.data)&&e(r=r.attrs)&&r.type;return i===o||wi(i)&&wi(o)}(r,i)||n(r.isAsyncPlaceholder)&&r.asyncFactory===i.asyncFactory&&t(i.asyncFactory.error))}function Qt(t,n,r){var i,o,a={};for(i=n;i<=r;++i)e(o=t[i].key)&&(a[o]=i);return a}function te(t,e){(t.data.directives||e.data.directives)&&function(t,e){var n,r,i,o=t===Ai,a=e===Ai,s=ee(t.data.directives,t.context),c=ee(e.data.directives,e.context),u=[],l=[];for(n in c)r=s[n],i=c[n],r?(i.oldValue=r.value,ne(i,"update",e,t),i.def&&i.def.componentUpdated&&l.push(i)):(ne(i,"bind",e,t),i.def&&i.def.inserted&&u.push(i));if(u.length){var f=function(){for(var n=0;n<u.length;n++)ne(u[n],"inserted",e,t)};o?Y(e,"insert",f):f()}l.length&&Y(e,"postpatch",function(){for(var n=0;n<l.length;n++)ne(l[n],"componentUpdated",e,t)});if(!o)for(n in s)c[n]||ne(s[n],"unbind",t,t,a)}(t,e)}function ee(t,e){var n=Object.create(null);if(!t)return n;var r,i;for(r=0;r<t.length;r++)(i=t[r]).modifiers||(i.modifiers=Ti),n[function(t){return t.rawName||t.name+"."+Object.keys(t.modifiers||{}).join(".")}(i)]=i,i.def=R(e.$options,"directives",i.name);return n}function ne(t,e,n,r,i){var o=t.def&&t.def[e];if(o)try{o(n.elm,t,n,r,i)}catch(r){V(r,n.context,"directive "+t.name+" "+e+" hook")}}function re(n,r){var i=r.componentOptions;if(!(e(i)&&!1===i.Ctor.options.inheritAttrs||t(n.data.attrs)&&t(r.data.attrs))){var o,a,s=r.elm,c=n.data.attrs||{},u=r.data.attrs||{};e(u.__ob__)&&(u=r.data.attrs=h({},u));for(o in u)a=u[o],c[o]!==a&&ie(s,o,a);(Qn||er)&&u.value!==c.value&&ie(s,"value",u.value);for(o in c)t(u[o])&&(hi(o)?s.removeAttributeNS(vi,mi(o)):pi(o)||s.removeAttribute(o))}}function ie(t,e,n){if(di(e))yi(n)?t.removeAttribute(e):(n="allowfullscreen"===e&&"EMBED"===t.tagName?"true":e,t.setAttribute(e,n));else if(pi(e))t.setAttribute(e,yi(n)||"false"===n?"false":"true");else if(hi(e))yi(n)?t.removeAttributeNS(vi,mi(e)):t.setAttributeNS(vi,e,n);else if(yi(n))t.removeAttribute(e);else{if(Qn&&!tr&&"TEXTAREA"===t.tagName&&"placeholder"===e&&!t.__ieph){var r=function(e){e.stopImmediatePropagation(),t.removeEventListener("input",r)};t.addEventListener("input",r),t.__ieph=!0}t.setAttribute(e,n)}}function oe(n,r){var i=r.elm,o=r.data,a=n.data;if(!(t(o.staticClass)&&t(o.class)&&(t(a)||t(a.staticClass)&&t(a.class)))){var s=Kt(r),c=i._transitionClasses;e(c)&&(s=qt(s,Wt(c))),s!==i._prevClass&&(i.setAttribute("class",s),i._prevClass=s)}}function ae(t){function e(){(a||(a=[])).push(t.slice(v,i).trim()),v=i+1}var n,r,i,o,a,s=!1,c=!1,u=!1,l=!1,f=0,p=0,d=0,v=0;for(i=0;i<t.length;i++)if(r=n,n=t.charCodeAt(i),s)39===n&&92!==r&&(s=!1);else if(c)34===n&&92!==r&&(c=!1);else if(u)96===n&&92!==r&&(u=!1);else if(l)47===n&&92!==r&&(l=!1);else if(124!==n||124===t.charCodeAt(i+1)||124===t.charCodeAt(i-1)||f||p||d){switch(n){case 34:c=!0;break;case 39:s=!0;break;case 96:u=!0;break;case 40:d++;break;case 41:d--;break;case 91:p++;break;case 93:p--;break;case 123:f++;break;case 125:f--}if(47===n){for(var h=i-1,m=void 0;h>=0&&" "===(m=t.charAt(h));h--);m&&Ii.test(m)||(l=!0)}}else void 0===o?(v=i+1,o=t.slice(0,i).trim()):e();if(void 0===o?o=t.slice(0,i).trim():0!==v&&e(),a)for(i=0;i<a.length;i++)o=function(t,e){var n=e.indexOf("(");{if(n<0)return'_f("'+e+'")('+t+")";var r=e.slice(0,n),i=e.slice(n+1);return'_f("'+r+'")('+t+","+i}}(o,a[i]);return o}function se(t){console.error("[Vue compiler]: "+t)}function ce(t,e){return t?t.map(function(t){return t[e]}).filter(function(t){return t}):[]}function ue(t,e,n){(t.props||(t.props=[])).push({name:e,value:n}),t.plain=!1}function le(t,e,n){(t.attrs||(t.attrs=[])).push({name:e,value:n}),t.plain=!1}function fe(t,e,n){t.attrsMap[e]=n,t.attrsList.push({name:e,value:n})}function pe(t,e,n,r,i,o){(t.directives||(t.directives=[])).push({name:e,rawName:n,value:r,arg:i,modifiers:o}),t.plain=!1}function de(t,e,n,r,i,o){(r=r||jn).capture&&(delete r.capture,e="!"+e),r.once&&(delete r.once,e="~"+e),r.passive&&(delete r.passive,e="&"+e),"click"===e&&(r.right?(e="contextmenu",delete r.right):r.middle&&(e="mouseup"));var a;r.native?(delete r.native,a=t.nativeEvents||(t.nativeEvents={})):a=t.events||(t.events={});var s={value:n};r!==jn&&(s.modifiers=r);var c=a[e];Array.isArray(c)?i?c.unshift(s):c.push(s):a[e]=c?i?[s,c]:[c,s]:s,t.plain=!1}function ve(t,e,n){var r=he(t,":"+e)||he(t,"v-bind:"+e);if(null!=r)return ae(r);if(!1!==n){var i=he(t,e);if(null!=i)return JSON.stringify(i)}}function he(t,e,n){var r;if(null!=(r=t.attrsMap[e]))for(var i=t.attrsList,o=0,a=i.length;o<a;o++)if(i[o].name===e){i.splice(o,1);break}return n&&delete t.attrsMap[e],r}function me(t,e,n){var r=n||{},i="$$v";r.trim&&(i="(typeof $$v === 'string'? $$v.trim(): $$v)"),r.number&&(i="_n("+i+")");var o=ye(e,i);t.model={value:"("+e+")",expression:'"'+e+'"',callback:"function ($$v) {"+o+"}"}}function ye(t,e){var n=function(t){if(ei=t.length,t.indexOf("[")<0||t.lastIndexOf("]")<ei-1)return(ii=t.lastIndexOf("."))>-1?{exp:t.slice(0,ii),key:'"'+t.slice(ii+1)+'"'}:{exp:t,key:null};ni=t,ii=oi=ai=0;for(;!_e();)be(ri=ge())?$e(ri):91===ri&&function(t){var e=1;oi=ii;for(;!_e();)if(t=ge(),be(t))$e(t);else if(91===t&&e++,93===t&&e--,0===e){ai=ii;break}}(ri);return{exp:t.slice(0,oi),key:t.slice(oi+1,ai)}}(t);return null===n.key?t+"="+e:"$set("+n.exp+", "+n.key+", "+e+")"}function ge(){return ni.charCodeAt(++ii)}function _e(){return ii>=ei}function be(t){return 34===t||39===t}function $e(t){for(var e=t;!_e()&&(t=ge())!==e;);}function Ce(t,e,n,r,i){e=function(t){return t._withTask||(t._withTask=function(){Er=!0;var e=t.apply(null,arguments);return Er=!1,e})}(e),n&&(e=function(t,e,n){var r=si;return function i(){null!==t.apply(null,arguments)&&we(e,i,n,r)}}(e,t,r)),si.addEventListener(t,e,or?{capture:r,passive:i}:r)}function we(t,e,n,r){(r||si).removeEventListener(t,e._withTask||e,n)}function xe(n,r){if(!t(n.data.on)||!t(r.data.on)){var i=r.data.on||{},o=n.data.on||{};si=r.elm,function(t){if(e(t[Li])){var n=Qn?"change":"input";t[n]=[].concat(t[Li],t[n]||[]),delete t[Li]}e(t[Mi])&&(t.change=[].concat(t[Mi],t.change||[]),delete t[Mi])}(i),X(i,o,Ce,we,r.context),si=void 0}}function ke(n,r){if(!t(n.data.domProps)||!t(r.data.domProps)){var i,o,a=r.elm,s=n.data.domProps||{},u=r.data.domProps||{};e(u.__ob__)&&(u=r.data.domProps=h({},u));for(i in s)t(u[i])&&(a[i]="");for(i in u){if(o=u[i],"textContent"===i||"innerHTML"===i){if(r.children&&(r.children.length=0),o===s[i])continue;1===a.childNodes.length&&a.removeChild(a.childNodes[0])}if("value"===i){a._value=o;var l=t(o)?"":String(o);(function(t,n){return!t.composing&&("OPTION"===t.tagName||function(t,e){var n=!0;try{n=document.activeElement!==t}catch(t){}return n&&t.value!==e}(t,n)||function(t,n){var r=t.value,i=t._vModifiers;if(e(i)){if(i.lazy)return!1;if(i.number)return c(r)!==c(n);if(i.trim)return r.trim()!==n.trim()}return r!==n}(t,n))})(a,l)&&(a.value=l)}else a[i]=o}}}function Ae(t){var e=Oe(t.style);return t.staticStyle?h(t.staticStyle,e):e}function Oe(t){return Array.isArray(t)?m(t):"string"==typeof t?Fi(t):t}function Se(n,r){var i=r.data,o=n.data;if(!(t(i.staticStyle)&&t(i.style)&&t(o.staticStyle)&&t(o.style))){var a,s,c=r.elm,u=o.staticStyle,l=o.normalizedStyle||o.style||{},f=u||l,p=Oe(r.data.style)||{};r.data.normalizedStyle=e(p.__ob__)?h({},p):p;var d=function(t,e){var n,r={};if(e)for(var i=t;i.componentInstance;)(i=i.componentInstance._vnode)&&i.data&&(n=Ae(i.data))&&h(r,n);(n=Ae(t.data))&&h(r,n);for(var o=t;o=o.parent;)o.data&&(n=Ae(o.data))&&h(r,n);return r}(r,!0);for(s in f)t(d[s])&&Bi(c,s,"");for(s in d)(a=d[s])!==f[s]&&Bi(c,s,null==a?"":a)}}function Te(t,e){if(e&&(e=e.trim()))if(t.classList)e.indexOf(" ")>-1?e.split(/\s+/).forEach(function(e){return t.classList.add(e)}):t.classList.add(e);else{var n=" "+(t.getAttribute("class")||"")+" ";n.indexOf(" "+e+" ")<0&&t.setAttribute("class",(n+e).trim())}}function Ee(t,e){if(e&&(e=e.trim()))if(t.classList)e.indexOf(" ")>-1?e.split(/\s+/).forEach(function(e){return t.classList.remove(e)}):t.classList.remove(e),t.classList.length||t.removeAttribute("class");else{for(var n=" "+(t.getAttribute("class")||"")+" ",r=" "+e+" ";n.indexOf(r)>=0;)n=n.replace(r," ");(n=n.trim())?t.setAttribute("class",n):t.removeAttribute("class")}}function je(t){if(t){if("object"==typeof t){var e={};return!1!==t.css&&h(e,Ki(t.name||"v")),h(e,t),e}return"string"==typeof t?Ki(t):void 0}}function Ne(t){Qi(function(){Qi(t)})}function Ie(t,e){var n=t._transitionClasses||(t._transitionClasses=[]);n.indexOf(e)<0&&(n.push(e),Te(t,e))}function Le(t,e){t._transitionClasses&&l(t._transitionClasses,e),Ee(t,e)}function Me(t,e,n){var r=De(t,e),i=r.type,o=r.timeout,a=r.propCount;if(!i)return n();var s=i===qi?Zi:Yi,c=0,u=function(){t.removeEventListener(s,l),n()},l=function(e){e.target===t&&++c>=a&&u()};setTimeout(function(){c<a&&u()},o+1),t.addEventListener(s,l)}function De(t,e){var n,r=window.getComputedStyle(t),i=r[Gi+"Delay"].split(", "),o=r[Gi+"Duration"].split(", "),a=Pe(i,o),s=r[Xi+"Delay"].split(", "),c=r[Xi+"Duration"].split(", "),u=Pe(s,c),l=0,f=0;e===qi?a>0&&(n=qi,l=a,f=o.length):e===Wi?u>0&&(n=Wi,l=u,f=c.length):f=(n=(l=Math.max(a,u))>0?a>u?qi:Wi:null)?n===qi?o.length:c.length:0;return{type:n,timeout:l,propCount:f,hasTransform:n===qi&&to.test(r[Gi+"Property"])}}function Pe(t,e){for(;t.length<e.length;)t=t.concat(t);return Math.max.apply(null,e.map(function(e,n){return Fe(e)+Fe(t[n])}))}function Fe(t){return 1e3*Number(t.slice(0,-1))}function Re(n,r){var o=n.elm;e(o._leaveCb)&&(o._leaveCb.cancelled=!0,o._leaveCb());var a=je(n.data.transition);if(!t(a)&&!e(o._enterCb)&&1===o.nodeType){for(var s=a.css,u=a.type,l=a.enterClass,f=a.enterToClass,p=a.enterActiveClass,d=a.appearClass,v=a.appearToClass,h=a.appearActiveClass,m=a.beforeEnter,y=a.enter,g=a.afterEnter,_=a.enterCancelled,$=a.beforeAppear,C=a.appear,w=a.afterAppear,x=a.appearCancelled,k=a.duration,A=Pr,O=Pr.$vnode;O&&O.parent;)A=(O=O.parent).context;var S=!A._isMounted||!n.isRootInsert;if(!S||C||""===C){var T=S&&d?d:l,E=S&&h?h:p,j=S&&v?v:f,N=S?$||m:m,I=S&&"function"==typeof C?C:y,L=S?w||g:g,M=S?x||_:_,D=c(i(k)?k.enter:k),P=!1!==s&&!tr,F=Ue(I),R=o._enterCb=b(function(){P&&(Le(o,j),Le(o,E)),R.cancelled?(P&&Le(o,T),M&&M(o)):L&&L(o),o._enterCb=null});n.data.show||Y(n,"insert",function(){var t=o.parentNode,e=t&&t._pending&&t._pending[n.key];e&&e.tag===n.tag&&e.elm._leaveCb&&e.elm._leaveCb(),I&&I(o,R)}),N&&N(o),P&&(Ie(o,T),Ie(o,E),Ne(function(){Ie(o,j),Le(o,T),R.cancelled||F||(Be(D)?setTimeout(R,D):Me(o,u,R))})),n.data.show&&(r&&r(),I&&I(o,R)),P||F||R()}}}function He(n,r){function o(){x.cancelled||(n.data.show||((a.parentNode._pending||(a.parentNode._pending={}))[n.key]=n),v&&v(a),$&&(Ie(a,f),Ie(a,d),Ne(function(){Ie(a,p),Le(a,f),x.cancelled||C||(Be(w)?setTimeout(x,w):Me(a,l,x))})),h&&h(a,x),$||C||x())}var a=n.elm;e(a._enterCb)&&(a._enterCb.cancelled=!0,a._enterCb());var s=je(n.data.transition);if(t(s)||1!==a.nodeType)return r();if(!e(a._leaveCb)){var u=s.css,l=s.type,f=s.leaveClass,p=s.leaveToClass,d=s.leaveActiveClass,v=s.beforeLeave,h=s.leave,m=s.afterLeave,y=s.leaveCancelled,g=s.delayLeave,_=s.duration,$=!1!==u&&!tr,C=Ue(h),w=c(i(_)?_.leave:_),x=a._leaveCb=b(function(){a.parentNode&&a.parentNode._pending&&(a.parentNode._pending[n.key]=null),$&&(Le(a,p),Le(a,d)),x.cancelled?($&&Le(a,f),y&&y(a)):(r(),m&&m(a)),a._leaveCb=null});g?g(o):o()}}function Be(t){return"number"==typeof t&&!isNaN(t)}function Ue(n){if(t(n))return!1;var r=n.fns;return e(r)?Ue(Array.isArray(r)?r[0]:r):(n._length||n.length)>1}function Ve(t,e){!0!==e.data.show&&Re(e)}function ze(t,e,n){Ke(t,e,n),(Qn||er)&&setTimeout(function(){Ke(t,e,n)},0)}function Ke(t,e,n){var r=e.value,i=t.multiple;if(!i||Array.isArray(r)){for(var o,a,s=0,c=t.options.length;s<c;s++)if(a=t.options[s],i)o=_(r,qe(a))>-1,a.selected!==o&&(a.selected=o);else if(g(qe(a),r))return void(t.selectedIndex!==s&&(t.selectedIndex=s));i||(t.selectedIndex=-1)}}function Je(t,e){return e.every(function(e){return!g(e,t)})}function qe(t){return"_value"in t?t._value:t.value}function We(t){t.target.composing=!0}function Ge(t){t.target.composing&&(t.target.composing=!1,Ze(t.target,"input"))}function Ze(t,e){var n=document.createEvent("HTMLEvents");n.initEvent(e,!0,!0),t.dispatchEvent(n)}function Xe(t){return!t.componentInstance||t.data&&t.data.transition?t:Xe(t.componentInstance._vnode)}function Ye(t){var e=t&&t.componentOptions;return e&&e.Ctor.options.abstract?Ye(it(e.children)):t}function Qe(t){var e={},n=t.$options;for(var r in n.propsData)e[r]=t[r];var i=n._parentListeners;for(var o in i)e[Pn(o)]=i[o];return e}function tn(t,e){if(/\d-keep-alive$/.test(e.tag))return t("keep-alive",{props:e.componentOptions.propsData})}function en(t){t.elm._moveCb&&t.elm._moveCb(),t.elm._enterCb&&t.elm._enterCb()}function nn(t){t.data.newPos=t.elm.getBoundingClientRect()}function rn(t){var e=t.data.pos,n=t.data.newPos,r=e.left-n.left,i=e.top-n.top;if(r||i){t.data.moved=!0;var o=t.elm.style;o.transform=o.WebkitTransform="translate("+r+"px,"+i+"px)",o.transitionDuration="0s"}}function on(t,e){var n=e?zo:Vo;return t.replace(n,function(t){return Uo[t]})}function an(t,e,n){return{type:1,tag:t,attrsList:e,attrsMap:function(t){for(var e={},n=0,r=t.length;n<r;n++)e[t[n].name]=t[n].value;return e}(e),parent:n,children:[]}}function sn(t,e){function n(t){t.pre&&(s=!1),Lo(t.tag)&&(c=!1);for(var n=0;n<Io.length;n++)Io[n](t,e)}To=e.warn||se,Lo=e.isPreTag||Bn,Mo=e.mustUseProp||Bn,Do=e.getTagNamespace||Bn,jo=ce(e.modules,"transformNode"),No=ce(e.modules,"preTransformNode"),Io=ce(e.modules,"postTransformNode"),Eo=e.delimiters;var r,i,o=[],a=!1!==e.preserveWhitespace,s=!1,c=!1;return function(t,e){function n(e){l+=e,t=t.substring(e)}function r(t,n,r){var i,s;if(null==n&&(n=l),null==r&&(r=l),t&&(s=t.toLowerCase()),t)for(i=a.length-1;i>=0&&a[i].lowerCasedTag!==s;i--);else i=0;if(i>=0){for(var c=a.length-1;c>=i;c--)e.end&&e.end(a[c].tag,n,r);a.length=i,o=i&&a[i-1].tag}else"br"===s?e.start&&e.start(t,[],!0,n,r):"p"===s&&(e.start&&e.start(t,[],!1,n,r),e.end&&e.end(t,n,r))}for(var i,o,a=[],s=e.expectHTML,c=e.isUnaryTag||Bn,u=e.canBeLeftOpenTag||Bn,l=0;t;){if(i=t,o&&Ho(o)){var f=0,p=o.toLowerCase(),d=Bo[p]||(Bo[p]=new RegExp("([\\s\\S]*?)(</"+p+"[^>]*>)","i")),v=t.replace(d,function(t,n,r){return f=r.length,Ho(p)||"noscript"===p||(n=n.replace(/<!--([\s\S]*?)-->/g,"$1").replace(/<!\[CDATA\[([\s\S]*?)]]>/g,"$1")),Jo(p,n)&&(n=n.slice(1)),e.chars&&e.chars(n),""});l+=t.length-v.length,t=v,r(p,l-f,l)}else{var h=t.indexOf("<");if(0===h){if(Ao.test(t)){var m=t.indexOf("--\x3e");if(m>=0){e.shouldKeepComment&&e.comment(t.substring(4,m)),n(m+3);continue}}if(Oo.test(t)){var y=t.indexOf("]>");if(y>=0){n(y+2);continue}}var g=t.match(ko);if(g){n(g[0].length);continue}var _=t.match(xo);if(_){var b=l;n(_[0].length),r(_[1],b,l);continue}var $=function(){var e=t.match(Co);if(e){var r={tagName:e[1],attrs:[],start:l};n(e[0].length);for(var i,o;!(i=t.match(wo))&&(o=t.match(_o));)n(o[0].length),r.attrs.push(o);if(i)return r.unarySlash=i[1],n(i[0].length),r.end=l,r}}();if($){!function(t){var n=t.tagName,i=t.unarySlash;s&&("p"===o&&go(n)&&r(o),u(n)&&o===n&&r(n));for(var l=c(n)||!!i,f=t.attrs.length,p=new Array(f),d=0;d<f;d++){var v=t.attrs[d];So&&-1===v[0].indexOf('""')&&(""===v[3]&&delete v[3],""===v[4]&&delete v[4],""===v[5]&&delete v[5]);var h=v[3]||v[4]||v[5]||"",m="a"===n&&"href"===v[1]?e.shouldDecodeNewlinesForHref:e.shouldDecodeNewlines;p[d]={name:v[1],value:on(h,m)}}l||(a.push({tag:n,lowerCasedTag:n.toLowerCase(),attrs:p}),o=n),e.start&&e.start(n,p,l,t.start,t.end)}($),Jo(o,t)&&n(1);continue}}var C=void 0,w=void 0,x=void 0;if(h>=0){for(w=t.slice(h);!(xo.test(w)||Co.test(w)||Ao.test(w)||Oo.test(w)||(x=w.indexOf("<",1))<0);)h+=x,w=t.slice(h);C=t.substring(0,h),n(h)}h<0&&(C=t,t=""),e.chars&&C&&e.chars(C)}if(t===i){e.chars&&e.chars(t);break}}r()}(t,{warn:To,expectHTML:e.expectHTML,isUnaryTag:e.isUnaryTag,canBeLeftOpenTag:e.canBeLeftOpenTag,shouldDecodeNewlines:e.shouldDecodeNewlines,shouldDecodeNewlinesForHref:e.shouldDecodeNewlinesForHref,shouldKeepComment:e.comments,start:function(t,a,u){var l=i&&i.ns||Do(t);Qn&&"svg"===l&&(a=function(t){for(var e=[],n=0;n<t.length;n++){var r=t[n];na.test(r.name)||(r.name=r.name.replace(ra,""),e.push(r))}return e}(a));var f=an(t,a,i);l&&(f.ns=l),function(t){return"style"===t.tag||"script"===t.tag&&(!t.attrsMap.type||"text/javascript"===t.attrsMap.type)}(f)&&!ur()&&(f.forbidden=!0);for(var p=0;p<No.length;p++)f=No[p](f,e)||f;if(s||(!function(t){null!=he(t,"v-pre")&&(t.pre=!0)}(f),f.pre&&(s=!0)),Lo(f.tag)&&(c=!0),s?function(t){var e=t.attrsList.length;if(e)for(var n=t.attrs=new Array(e),r=0;r<e;r++)n[r]={name:t.attrsList[r].name,value:JSON.stringify(t.attrsList[r].value)};else t.pre||(t.plain=!0)}(f):f.processed||(un(f),function(t){var e=he(t,"v-if");if(e)t.if=e,ln(t,{exp:e,block:t});else{null!=he(t,"v-else")&&(t.else=!0);var n=he(t,"v-else-if");n&&(t.elseif=n)}}(f),function(t){null!=he(t,"v-once")&&(t.once=!0)}(f),cn(f,e)),r?o.length||r.if&&(f.elseif||f.else)&&ln(r,{exp:f.elseif,block:f}):r=f,i&&!f.forbidden)if(f.elseif||f.else)!function(t,e){var n=function(t){var e=t.length;for(;e--;){if(1===t[e].type)return t[e];t.pop()}}(e.children);n&&n.if&&ln(n,{exp:t.elseif,block:t})}(f,i);else if(f.slotScope){i.plain=!1;var d=f.slotTarget||'"default"';(i.scopedSlots||(i.scopedSlots={}))[d]=f}else i.children.push(f),f.parent=i;u?n(f):(i=f,o.push(f))},end:function(){var t=o[o.length-1],e=t.children[t.children.length-1];e&&3===e.type&&" "===e.text&&!c&&t.children.pop(),o.length-=1,i=o[o.length-1],n(t)},chars:function(t){if(i&&(!Qn||"textarea"!==i.tag||i.attrsMap.placeholder!==t)){var e=i.children;if(t=c||t.trim()?function(t){return"script"===t.tag||"style"===t.tag}(i)?t:ea(t):a&&e.length?" ":""){var n;!s&&" "!==t&&(n=function(t,e){var n=e?fo(e):uo;if(n.test(t)){for(var r,i,o,a=[],s=[],c=n.lastIndex=0;r=n.exec(t);){(i=r.index)>c&&(s.push(o=t.slice(c,i)),a.push(JSON.stringify(o)));var u=ae(r[1].trim());a.push("_s("+u+")"),s.push({"@binding":u}),c=i+r[0].length}return c<t.length&&(s.push(o=t.slice(c)),a.push(JSON.stringify(o))),{expression:a.join("+"),tokens:s}}}(t,Eo))?e.push({type:2,expression:n.expression,tokens:n.tokens,text:t}):" "===t&&e.length&&" "===e[e.length-1].text||e.push({type:3,text:t})}}},comment:function(t){i.children.push({type:3,text:t,isComment:!0})}}),r}function cn(t,e){!function(t){var e=ve(t,"key");e&&(t.key=e)}(t),t.plain=!t.key&&!t.attrsList.length,function(t){var e=ve(t,"ref");e&&(t.ref=e,t.refInFor=function(t){var e=t;for(;e;){if(void 0!==e.for)return!0;e=e.parent}return!1}(t))}(t),function(t){if("slot"===t.tag)t.slotName=ve(t,"name");else{var e;"template"===t.tag?(e=he(t,"scope"),t.slotScope=e||he(t,"slot-scope")):(e=he(t,"slot-scope"))&&(t.slotScope=e);var n=ve(t,"slot");n&&(t.slotTarget='""'===n?'"default"':n,"template"===t.tag||t.slotScope||le(t,"slot",n))}}(t),function(t){var e;(e=ve(t,"is"))&&(t.component=e);null!=he(t,"inline-template")&&(t.inlineTemplate=!0)}(t);for(var n=0;n<jo.length;n++)t=jo[n](t,e)||t;!function(t){var e,n,r,i,o,a,s,c=t.attrsList;for(e=0,n=c.length;e<n;e++)if(r=i=c[e].name,o=c[e].value,Wo.test(r))if(t.hasBindings=!0,(a=function(t){var e=t.match(ta);if(e){var n={};return e.forEach(function(t){n[t.slice(1)]=!0}),n}}(r))&&(r=r.replace(ta,"")),Qo.test(r))r=r.replace(Qo,""),o=ae(o),s=!1,a&&(a.prop&&(s=!0,"innerHtml"===(r=Pn(r))&&(r="innerHTML")),a.camel&&(r=Pn(r)),a.sync&&de(t,"update:"+Pn(r),ye(o,"$event"))),s||!t.component&&Mo(t.tag,t.attrsMap.type,r)?ue(t,r,o):le(t,r,o);else if(qo.test(r))r=r.replace(qo,""),de(t,r,o,a,!1);else{var u=(r=r.replace(Wo,"")).match(Yo),l=u&&u[1];l&&(r=r.slice(0,-(l.length+1))),pe(t,r,i,o,l,a)}else le(t,r,JSON.stringify(o)),!t.component&&"muted"===r&&Mo(t.tag,t.attrsMap.type,r)&&ue(t,r,"true")}(t)}function un(t){var e;if(e=he(t,"v-for")){var n=function(t){var e=t.match(Go);if(!e)return;var n={};n.for=e[2].trim();var r=e[1].trim().replace(Xo,""),i=r.match(Zo);i?(n.alias=r.replace(Zo,""),n.iterator1=i[1].trim(),i[2]&&(n.iterator2=i[2].trim())):n.alias=r;return n}(e);n&&h(t,n)}}function ln(t,e){t.ifConditions||(t.ifConditions=[]),t.ifConditions.push(e)}function fn(t){return an(t.tag,t.attrsList.slice(),t.parent)}function pn(t){if(t.static=function(t){if(2===t.type)return!1;if(3===t.type)return!0;return!(!t.pre&&(t.hasBindings||t.if||t.for||In(t.tag)||!Fo(t.tag)||function(t){for(;t.parent;){if("template"!==(t=t.parent).tag)return!1;if(t.for)return!0}return!1}(t)||!Object.keys(t).every(Po)))}(t),1===t.type){if(!Fo(t.tag)&&"slot"!==t.tag&&null==t.attrsMap["inline-template"])return;for(var e=0,n=t.children.length;e<n;e++){var r=t.children[e];pn(r),r.static||(t.static=!1)}if(t.ifConditions)for(var i=1,o=t.ifConditions.length;i<o;i++){var a=t.ifConditions[i].block;pn(a),a.static||(t.static=!1)}}}function dn(t,e){if(1===t.type){if((t.static||t.once)&&(t.staticInFor=e),t.static&&t.children.length&&(1!==t.children.length||3!==t.children[0].type))return void(t.staticRoot=!0);if(t.staticRoot=!1,t.children)for(var n=0,r=t.children.length;n<r;n++)dn(t.children[n],e||!!t.for);if(t.ifConditions)for(var i=1,o=t.ifConditions.length;i<o;i++)dn(t.ifConditions[i].block,e)}}function vn(t,e,n){var r=e?"nativeOn:{":"on:{";for(var i in t)r+='"'+i+'":'+hn(i,t[i])+",";return r.slice(0,-1)+"}"}function hn(t,e){if(!e)return"function(){}";if(Array.isArray(e))return"["+e.map(function(e){return hn(t,e)}).join(",")+"]";var n=ca.test(e.value),r=sa.test(e.value);if(e.modifiers){var i="",o="",a=[];for(var s in e.modifiers)if(fa[s])o+=fa[s],ua[s]&&a.push(s);else if("exact"===s){var c=e.modifiers;o+=la(["ctrl","shift","alt","meta"].filter(function(t){return!c[t]}).map(function(t){return"$event."+t+"Key"}).join("||"))}else a.push(s);a.length&&(i+=function(t){return"if(!('button' in $event)&&"+t.map(mn).join("&&")+")return null;"}(a)),o&&(i+=o);return"function($event){"+i+(n?e.value+"($event)":r?"("+e.value+")($event)":e.value)+"}"}return n||r?e.value:"function($event){"+e.value+"}"}function mn(t){var e=parseInt(t,10);if(e)return"$event.keyCode!=="+e;var n=ua[t];return"_k($event.keyCode,"+JSON.stringify(t)+","+JSON.stringify(n)+",$event.key)"}function yn(t,e){var n=new da(e);return{render:"with(this){return "+(t?gn(t,n):'_c("div")')+"}",staticRenderFns:n.staticRenderFns}}function gn(t,e){if(t.staticRoot&&!t.staticProcessed)return _n(t,e);if(t.once&&!t.onceProcessed)return bn(t,e);if(t.for&&!t.forProcessed)return function(t,e,n,r){var i=t.for,o=t.alias,a=t.iterator1?","+t.iterator1:"",s=t.iterator2?","+t.iterator2:"";return t.forProcessed=!0,(r||"_l")+"(("+i+"),function("+o+a+s+"){return "+(n||gn)(t,e)+"})"}(t,e);if(t.if&&!t.ifProcessed)return $n(t,e);if("template"!==t.tag||t.slotTarget){if("slot"===t.tag)return function(t,e){var n=t.slotName||'"default"',r=kn(t,e),i="_t("+n+(r?","+r:""),o=t.attrs&&"{"+t.attrs.map(function(t){return Pn(t.name)+":"+t.value}).join(",")+"}",a=t.attrsMap["v-bind"];!o&&!a||r||(i+=",null");o&&(i+=","+o);a&&(i+=(o?"":",null")+","+a);return i+")"}(t,e);var n;if(t.component)n=function(t,e,n){var r=e.inlineTemplate?null:kn(e,n,!0);return"_c("+t+","+wn(e,n)+(r?","+r:"")+")"}(t.component,t,e);else{var r=t.plain?void 0:wn(t,e),i=t.inlineTemplate?null:kn(t,e,!0);n="_c('"+t.tag+"'"+(r?","+r:"")+(i?","+i:"")+")"}for(var o=0;o<e.transforms.length;o++)n=e.transforms[o](t,n);return n}return kn(t,e)||"void 0"}function _n(t,e){return t.staticProcessed=!0,e.staticRenderFns.push("with(this){return "+gn(t,e)+"}"),"_m("+(e.staticRenderFns.length-1)+(t.staticInFor?",true":"")+")"}function bn(t,e){if(t.onceProcessed=!0,t.if&&!t.ifProcessed)return $n(t,e);if(t.staticInFor){for(var n="",r=t.parent;r;){if(r.for){n=r.key;break}r=r.parent}return n?"_o("+gn(t,e)+","+e.onceId+++","+n+")":gn(t,e)}return _n(t,e)}function $n(t,e,n,r){return t.ifProcessed=!0,Cn(t.ifConditions.slice(),e,n,r)}function Cn(t,e,n,r){function i(t){return n?n(t,e):t.once?bn(t,e):gn(t,e)}if(!t.length)return r||"_e()";var o=t.shift();return o.exp?"("+o.exp+")?"+i(o.block)+":"+Cn(t,e,n,r):""+i(o.block)}function wn(t,e){var n="{",r=function(t,e){var n=t.directives;if(!n)return;var r,i,o,a,s="directives:[",c=!1;for(r=0,i=n.length;r<i;r++){o=n[r],a=!0;var u=e.directives[o.name];u&&(a=!!u(t,o,e.warn)),a&&(c=!0,s+='{name:"'+o.name+'",rawName:"'+o.rawName+'"'+(o.value?",value:("+o.value+"),expression:"+JSON.stringify(o.value):"")+(o.arg?',arg:"'+o.arg+'"':"")+(o.modifiers?",modifiers:"+JSON.stringify(o.modifiers):"")+"},")}if(c)return s.slice(0,-1)+"]"}(t,e);r&&(n+=r+","),t.key&&(n+="key:"+t.key+","),t.ref&&(n+="ref:"+t.ref+","),t.refInFor&&(n+="refInFor:true,"),t.pre&&(n+="pre:true,"),t.component&&(n+='tag:"'+t.tag+'",');for(var i=0;i<e.dataGenFns.length;i++)n+=e.dataGenFns[i](t);if(t.attrs&&(n+="attrs:{"+On(t.attrs)+"},"),t.props&&(n+="domProps:{"+On(t.props)+"},"),t.events&&(n+=vn(t.events,!1,e.warn)+","),t.nativeEvents&&(n+=vn(t.nativeEvents,!0,e.warn)+","),t.slotTarget&&!t.slotScope&&(n+="slot:"+t.slotTarget+","),t.scopedSlots&&(n+=function(t,e){return"scopedSlots:_u(["+Object.keys(t).map(function(n){return xn(n,t[n],e)}).join(",")+"])"}(t.scopedSlots,e)+","),t.model&&(n+="model:{value:"+t.model.value+",callback:"+t.model.callback+",expression:"+t.model.expression+"},"),t.inlineTemplate){var o=function(t,e){var n=t.children[0];if(1===n.type){var r=yn(n,e.options);return"inlineTemplate:{render:function(){"+r.render+"},staticRenderFns:["+r.staticRenderFns.map(function(t){return"function(){"+t+"}"}).join(",")+"]}"}}(t,e);o&&(n+=o+",")}return n=n.replace(/,$/,"")+"}",t.wrapData&&(n=t.wrapData(n)),t.wrapListeners&&(n=t.wrapListeners(n)),n}function xn(t,e,n){if(e.for&&!e.forProcessed)return function(t,e,n){var r=e.for,i=e.alias,o=e.iterator1?","+e.iterator1:"",a=e.iterator2?","+e.iterator2:"";return e.forProcessed=!0,"_l(("+r+"),function("+i+o+a+"){return "+xn(t,e,n)+"})"}(t,e,n);return"{key:"+t+",fn:"+("function("+String(e.slotScope)+"){return "+("template"===e.tag?e.if?e.if+"?"+(kn(e,n)||"undefined")+":undefined":kn(e,n)||"undefined":gn(e,n))+"}")+"}"}function kn(t,e,n,r,i){var o=t.children;if(o.length){var a=o[0];if(1===o.length&&a.for&&"template"!==a.tag&&"slot"!==a.tag)return(r||gn)(a,e);var s=n?function(t,e){for(var n=0,r=0;r<t.length;r++){var i=t[r];if(1===i.type){if(An(i)||i.ifConditions&&i.ifConditions.some(function(t){return An(t.block)})){n=2;break}(e(i)||i.ifConditions&&i.ifConditions.some(function(t){return e(t.block)}))&&(n=1)}}return n}(o,e.maybeComponent):0,c=i||function(t,e){if(1===t.type)return gn(t,e);return 3===t.type&&t.isComment?function(t){return"_e("+JSON.stringify(t.text)+")"}(t):function(t){return"_v("+(2===t.type?t.expression:Sn(JSON.stringify(t.text)))+")"}(t)};return"["+o.map(function(t){return c(t,e)}).join(",")+"]"+(s?","+s:"")}}function An(t){return void 0!==t.for||"template"===t.tag||"slot"===t.tag}function On(t){for(var e="",n=0;n<t.length;n++){var r=t[n];e+='"'+r.name+'":'+Sn(r.value)+","}return e.slice(0,-1)}function Sn(t){return t.replace(/\u2028/g,"\\u2028").replace(/\u2029/g,"\\u2029")}function Tn(t,e){try{return new Function(t)}catch(n){return e.push({err:n,code:t}),y}}function En(t){return Ro=Ro||document.createElement("div"),Ro.innerHTML=t?'<a href="\n"/>':'<div a="\n"/>',Ro.innerHTML.indexOf("&#10;")>0}var jn=Object.freeze({}),Nn=Object.prototype.toString,In=u("slot,component",!0),Ln=u("key,ref,slot,slot-scope,is"),Mn=Object.prototype.hasOwnProperty,Dn=/-(\w)/g,Pn=p(function(t){return t.replace(Dn,function(t,e){return e?e.toUpperCase():""})}),Fn=p(function(t){return t.charAt(0).toUpperCase()+t.slice(1)}),Rn=/\B([A-Z])/g,Hn=p(function(t){return t.replace(Rn,"-$1").toLowerCase()}),Bn=function(t,e,n){return!1},Un=function(t){return t},Vn="data-server-rendered",zn=["component","directive","filter"],Kn=["beforeCreate","created","beforeMount","mounted","beforeUpdate","updated","beforeDestroy","destroyed","activated","deactivated","errorCaptured"],Jn={optionMergeStrategies:Object.create(null),silent:!1,productionTip:!1,devtools:!1,performance:!1,errorHandler:null,warnHandler:null,ignoredElements:[],keyCodes:Object.create(null),isReservedTag:Bn,isReservedAttr:Bn,isUnknownElement:Bn,getTagNamespace:y,parsePlatformTagName:Un,mustUseProp:Bn,_lifecycleHooks:Kn},qn=/[^\w.$]/,Wn="__proto__"in{},Gn="undefined"!=typeof window,Zn="undefined"!=typeof WXEnvironment&&!!WXEnvironment.platform,Xn=Zn&&WXEnvironment.platform.toLowerCase(),Yn=Gn&&window.navigator.userAgent.toLowerCase(),Qn=Yn&&/msie|trident/.test(Yn),tr=Yn&&Yn.indexOf("msie 9.0")>0,er=Yn&&Yn.indexOf("edge/")>0,nr=Yn&&Yn.indexOf("android")>0||"android"===Xn,rr=Yn&&/iphone|ipad|ipod|ios/.test(Yn)||"ios"===Xn,ir=(Yn&&/chrome\/\d+/.test(Yn),{}.watch),or=!1;if(Gn)try{var ar={};Object.defineProperty(ar,"passive",{get:function(){or=!0}}),window.addEventListener("test-passive",null,ar)}catch(t){}var sr,cr,ur=function(){return void 0===sr&&(sr=!Gn&&"undefined"!=typeof global&&"server"===global.process.env.VUE_ENV),sr},lr=Gn&&window.__VUE_DEVTOOLS_GLOBAL_HOOK__,fr="undefined"!=typeof Symbol&&w(Symbol)&&"undefined"!=typeof Reflect&&w(Reflect.ownKeys);cr="undefined"!=typeof Set&&w(Set)?Set:function(){function t(){this.set=Object.create(null)}return t.prototype.has=function(t){return!0===this.set[t]},t.prototype.add=function(t){this.set[t]=!0},t.prototype.clear=function(){this.set=Object.create(null)},t}();var pr=y,dr=0,vr=function(){this.id=dr++,this.subs=[]};vr.prototype.addSub=function(t){this.subs.push(t)},vr.prototype.removeSub=function(t){l(this.subs,t)},vr.prototype.depend=function(){vr.target&&vr.target.addDep(this)},vr.prototype.notify=function(){for(var t=this.subs.slice(),e=0,n=t.length;e<n;e++)t[e].update()},vr.target=null;var hr=[],mr=function(t,e,n,r,i,o,a,s){this.tag=t,this.data=e,this.children=n,this.text=r,this.elm=i,this.ns=void 0,this.context=o,this.fnContext=void 0,this.fnOptions=void 0,this.fnScopeId=void 0,this.key=e&&e.key,this.componentOptions=a,this.componentInstance=void 0,this.parent=void 0,this.raw=!1,this.isStatic=!1,this.isRootInsert=!0,this.isComment=!1,this.isCloned=!1,this.isOnce=!1,this.asyncFactory=s,this.asyncMeta=void 0,this.isAsyncPlaceholder=!1},yr={child:{configurable:!0}};yr.child.get=function(){return this.componentInstance},Object.defineProperties(mr.prototype,yr);var gr=function(t){void 0===t&&(t="");var e=new mr;return e.text=t,e.isComment=!0,e},_r=Array.prototype,br=Object.create(_r);["push","pop","shift","unshift","splice","sort","reverse"].forEach(function(t){var e=_r[t];C(br,t,function(){for(var n=[],r=arguments.length;r--;)n[r]=arguments[r];var i,o=e.apply(this,n),a=this.__ob__;switch(t){case"push":case"unshift":i=n;break;case"splice":i=n.slice(2)}return i&&a.observeArray(i),a.dep.notify(),o})});var $r=Object.getOwnPropertyNames(br),Cr={shouldConvert:!0},wr=function(t){if(this.value=t,this.dep=new vr,this.vmCount=0,C(t,"__ob__",this),Array.isArray(t)){(Wn?O:S)(t,br,$r),this.observeArray(t)}else this.walk(t)};wr.prototype.walk=function(t){for(var e=Object.keys(t),n=0;n<e.length;n++)E(t,e[n],t[e[n]])},wr.prototype.observeArray=function(t){for(var e=0,n=t.length;e<n;e++)T(t[e])};var xr=Jn.optionMergeStrategies;xr.data=function(t,e,n){return n?M(t,e,n):e&&"function"!=typeof e?t:M(t,e)},Kn.forEach(function(t){xr[t]=D}),zn.forEach(function(t){xr[t+"s"]=P}),xr.watch=function(t,e,n,r){if(t===ir&&(t=void 0),e===ir&&(e=void 0),!e)return Object.create(t||null);if(!t)return e;var i={};h(i,t);for(var o in e){var a=i[o],s=e[o];a&&!Array.isArray(a)&&(a=[a]),i[o]=a?a.concat(s):Array.isArray(s)?s:[s]}return i},xr.props=xr.methods=xr.inject=xr.computed=function(t,e,n,r){if(!t)return e;var i=Object.create(null);return h(i,t),e&&h(i,e),i},xr.provide=M;var kr,Ar,Or=function(t,e){return void 0===e?t:e},Sr=[],Tr=!1,Er=!1;if("undefined"!=typeof setImmediate&&w(setImmediate))Ar=function(){setImmediate(J)};else if("undefined"==typeof MessageChannel||!w(MessageChannel)&&"[object MessageChannelConstructor]"!==MessageChannel.toString())Ar=function(){setTimeout(J,0)};else{var jr=new MessageChannel,Nr=jr.port2;jr.port1.onmessage=J,Ar=function(){Nr.postMessage(1)}}if("undefined"!=typeof Promise&&w(Promise)){var Ir=Promise.resolve();kr=function(){Ir.then(J),rr&&setTimeout(y)}}else kr=Ar;var Lr,Mr=new cr,Dr=p(function(t){var e="&"===t.charAt(0),n="~"===(t=e?t.slice(1):t).charAt(0),r="!"===(t=n?t.slice(1):t).charAt(0);return t=r?t.slice(1):t,{name:t,once:n,capture:r,passive:e}}),Pr=null,Fr=[],Rr=[],Hr={},Br=!1,Ur=!1,Vr=0,zr=0,Kr=function(t,e,n,r,i){this.vm=t,i&&(t._watcher=this),t._watchers.push(this),r?(this.deep=!!r.deep,this.user=!!r.user,this.lazy=!!r.lazy,this.sync=!!r.sync):this.deep=this.user=this.lazy=this.sync=!1,this.cb=n,this.id=++zr,this.active=!0,this.dirty=this.lazy,this.deps=[],this.newDeps=[],this.depIds=new cr,this.newDepIds=new cr,this.expression="","function"==typeof e?this.getter=e:(this.getter=function(t){if(!qn.test(t)){var e=t.split(".");return function(t){for(var n=0;n<e.length;n++){if(!t)return;t=t[e[n]]}return t}}}(e),this.getter||(this.getter=function(){})),this.value=this.lazy?void 0:this.get()};Kr.prototype.get=function(){!function(t){vr.target&&hr.push(vr.target),vr.target=t}(this);var t,e=this.vm;try{t=this.getter.call(e,e)}catch(t){if(!this.user)throw t;V(t,e,'getter for watcher "'+this.expression+'"')}finally{this.deep&&W(t),vr.target=hr.pop(),this.cleanupDeps()}return t},Kr.prototype.addDep=function(t){var e=t.id;this.newDepIds.has(e)||(this.newDepIds.add(e),this.newDeps.push(t),this.depIds.has(e)||t.addSub(this))},Kr.prototype.cleanupDeps=function(){for(var t=this.deps.length;t--;){var e=this.deps[t];this.newDepIds.has(e.id)||e.removeSub(this)}var n=this.depIds;this.depIds=this.newDepIds,this.newDepIds=n,this.newDepIds.clear(),n=this.deps,this.deps=this.newDeps,this.newDeps=n,this.newDeps.length=0},Kr.prototype.update=function(){this.lazy?this.dirty=!0:this.sync?this.run():function(t){var e=t.id;if(null==Hr[e]){if(Hr[e]=!0,Ur){for(var n=Fr.length-1;n>Vr&&Fr[n].id>t.id;)n--;Fr.splice(n+1,0,t)}else Fr.push(t);Br||(Br=!0,q(ht))}}(this)},Kr.prototype.run=function(){if(this.active){var t=this.get();if(t!==this.value||i(t)||this.deep){var e=this.value;if(this.value=t,this.user)try{this.cb.call(this.vm,t,e)}catch(t){V(t,this.vm,'callback for watcher "'+this.expression+'"')}else this.cb.call(this.vm,t,e)}}},Kr.prototype.evaluate=function(){this.value=this.get(),this.dirty=!1},Kr.prototype.depend=function(){for(var t=this.deps.length;t--;)this.deps[t].depend()},Kr.prototype.teardown=function(){if(this.active){this.vm._isBeingDestroyed||l(this.vm._watchers,this);for(var t=this.deps.length;t--;)this.deps[t].removeSub(this);this.active=!1}};var Jr={enumerable:!0,configurable:!0,get:y,set:y},qr={lazy:!0};Nt(It.prototype);var Wr={init:function(t,n,r,i){if(!t.componentInstance||t.componentInstance._isDestroyed){(t.componentInstance=function(t,n,r,i){var o={_isComponent:!0,parent:n,_parentVnode:t,_parentElm:r||null,_refElm:i||null},a=t.data.inlineTemplate;return e(a)&&(o.render=a.render,o.staticRenderFns=a.staticRenderFns),new t.componentOptions.Ctor(o)}(t,Pr,r,i)).$mount(n?t.elm:void 0,n)}else if(t.data.keepAlive){var o=t;Wr.prepatch(o,o)}},prepatch:function(t,e){var n=e.componentOptions;!function(t,e,n,r,i){var o=!!(i||t.$options._renderChildren||r.data.scopedSlots||t.$scopedSlots!==jn);if(t.$options._parentVnode=r,t.$vnode=r,t._vnode&&(t._vnode.parent=r),t.$options._renderChildren=i,t.$attrs=r.data&&r.data.attrs||jn,t.$listeners=n||jn,e&&t.$options.props){Cr.shouldConvert=!1;for(var a=t._props,s=t.$options._propKeys||[],c=0;c<s.length;c++){var u=s[c];a[u]=H(u,t.$options.props,e,t)}Cr.shouldConvert=!0,t.$options.propsData=e}if(n){var l=t.$options._parentListeners;t.$options._parentListeners=n,st(t,n,l)}o&&(t.$slots=ct(i,r.context),t.$forceUpdate())}(e.componentInstance=t.componentInstance,n.propsData,n.listeners,e,n.children)},insert:function(t){var e=t.context,n=t.componentInstance;n._isMounted||(n._isMounted=!0,vt(n,"mounted")),t.data.keepAlive&&(e._isMounted?function(t){t._inactive=!1,Rr.push(t)}(n):pt(n,!0))},destroy:function(t){var e=t.componentInstance;e._isDestroyed||(t.data.keepAlive?dt(e,!0):e.$destroy())}},Gr=Object.keys(Wr),Zr=1,Xr=2,Yr=0;!function(t){t.prototype._init=function(t){this._uid=Yr++,this._isVue=!0,t&&t._isComponent?function(t,e){var n=t.$options=Object.create(t.constructor.options),r=e._parentVnode;n.parent=e.parent,n._parentVnode=r,n._parentElm=e._parentElm,n._refElm=e._refElm;var i=r.componentOptions;n.propsData=i.propsData,n._parentListeners=i.listeners,n._renderChildren=i.children,n._componentTag=i.tag,e.render&&(n.render=e.render,n.staticRenderFns=e.staticRenderFns)}(this,t):this.$options=F(Ft(this.constructor),t||{},this),this._renderProxy=this,this._self=this,function(t){var e=t.$options,n=e.parent;if(n&&!e.abstract){for(;n.$options.abstract&&n.$parent;)n=n.$parent;n.$children.push(t)}t.$parent=n,t.$root=n?n.$root:t,t.$children=[],t.$refs={},t._watcher=null,t._inactive=null,t._directInactive=!1,t._isMounted=!1,t._isDestroyed=!1,t._isBeingDestroyed=!1}(this),function(t){t._events=Object.create(null),t._hasHookEvent=!1;var e=t.$options._parentListeners;e&&st(t,e)}(this),function(t){t._vnode=null,t._staticTrees=null;var e=t.$options,n=t.$vnode=e._parentVnode,r=n&&n.context;t.$slots=ct(e._renderChildren,r),t.$scopedSlots=jn,t._c=function(e,n,r,i){return Dt(t,e,n,r,i,!1)},t.$createElement=function(e,n,r,i){return Dt(t,e,n,r,i,!0)};var i=n&&n.data;E(t,"$attrs",i&&i.attrs||jn,0,!0),E(t,"$listeners",e._parentListeners||jn,0,!0)}(this),vt(this,"beforeCreate"),function(t){var e=$t(t.$options.inject,t);e&&(Cr.shouldConvert=!1,Object.keys(e).forEach(function(n){E(t,n,e[n])}),Cr.shouldConvert=!0)}(this),yt(this),function(t){var e=t.$options.provide;e&&(t._provided="function"==typeof e?e.call(t):e)}(this),vt(this,"created"),this.$options.el&&this.$mount(this.$options.el)}}(Rt),function(t){var e={};e.get=function(){return this._data};var n={};n.get=function(){return this._props},Object.defineProperty(t.prototype,"$data",e),Object.defineProperty(t.prototype,"$props",n),t.prototype.$set=j,t.prototype.$delete=N,t.prototype.$watch=function(t,e,n){if(o(e))return bt(this,t,e,n);(n=n||{}).user=!0;var r=new Kr(this,t,e,n);return n.immediate&&e.call(this,r.value),function(){r.teardown()}}}(Rt),function(t){var e=/^hook:/;t.prototype.$on=function(t,n){if(Array.isArray(t))for(var r=0,i=t.length;r<i;r++)this.$on(t[r],n);else(this._events[t]||(this._events[t]=[])).push(n),e.test(t)&&(this._hasHookEvent=!0);return this},t.prototype.$once=function(t,e){function n(){r.$off(t,n),e.apply(r,arguments)}var r=this;return n.fn=e,r.$on(t,n),r},t.prototype.$off=function(t,e){if(!arguments.length)return this._events=Object.create(null),this;if(Array.isArray(t)){for(var n=0,r=t.length;n<r;n++)this.$off(t[n],e);return this}var i=this._events[t];if(!i)return this;if(!e)return this._events[t]=null,this;if(e)for(var o,a=i.length;a--;)if((o=i[a])===e||o.fn===e){i.splice(a,1);break}return this},t.prototype.$emit=function(t){var e=this,n=e._events[t];if(n){n=n.length>1?v(n):n;for(var r=v(arguments,1),i=0,o=n.length;i<o;i++)try{n[i].apply(e,r)}catch(n){V(n,e,'event handler for "'+t+'"')}}return e}}(Rt),function(t){t.prototype._update=function(t,e){this._isMounted&&vt(this,"beforeUpdate");var n=this.$el,r=this._vnode,i=Pr;Pr=this,this._vnode=t,r?this.$el=this.__patch__(r,t):(this.$el=this.__patch__(this.$el,t,e,!1,this.$options._parentElm,this.$options._refElm),this.$options._parentElm=this.$options._refElm=null),Pr=i,n&&(n.__vue__=null),this.$el&&(this.$el.__vue__=this),this.$vnode&&this.$parent&&this.$vnode===this.$parent._vnode&&(this.$parent.$el=this.$el)},t.prototype.$forceUpdate=function(){this._watcher&&this._watcher.update()},t.prototype.$destroy=function(){if(!this._isBeingDestroyed){vt(this,"beforeDestroy"),this._isBeingDestroyed=!0;var t=this.$parent;!t||t._isBeingDestroyed||this.$options.abstract||l(t.$children,this),this._watcher&&this._watcher.teardown();for(var e=this._watchers.length;e--;)this._watchers[e].teardown();this._data.__ob__&&this._data.__ob__.vmCount--,this._isDestroyed=!0,this.__patch__(this._vnode,null),vt(this,"destroyed"),this.$off(),this.$el&&(this.$el.__vue__=null),this.$vnode&&(this.$vnode.parent=null)}}}(Rt),function(t){Nt(t.prototype),t.prototype.$nextTick=function(t){return q(t,this)},t.prototype._render=function(){var t=this,e=t.$options,n=e.render,r=e._parentVnode;if(t._isMounted)for(var i in t.$slots){var o=t.$slots[i];(o._rendered||o[0]&&o[0].elm)&&(t.$slots[i]=A(o,!0))}t.$scopedSlots=r&&r.data.scopedSlots||jn,t.$vnode=r;var a;try{a=n.call(t._renderProxy,t.$createElement)}catch(e){V(e,t,"render"),a=t._vnode}return a instanceof mr||(a=gr()),a.parent=r,a}}(Rt);var Qr=[String,RegExp,Array],ti={KeepAlive:{name:"keep-alive",abstract:!0,props:{include:Qr,exclude:Qr,max:[String,Number]},created:function(){this.cache=Object.create(null),this.keys=[]},destroyed:function(){for(var t in this.cache)zt(this.cache,t,this.keys)},watch:{include:function(t){Vt(this,function(e){return Ut(t,e)})},exclude:function(t){Vt(this,function(e){return!Ut(t,e)})}},render:function(){var t=this.$slots.default,e=it(t),n=e&&e.componentOptions;if(n){var r=Bt(n),i=this.include,o=this.exclude;if(i&&(!r||!Ut(i,r))||o&&r&&Ut(o,r))return e;var a=this.cache,s=this.keys,c=null==e.key?n.Ctor.cid+(n.tag?"::"+n.tag:""):e.key;a[c]?(e.componentInstance=a[c].componentInstance,l(s,c),s.push(c)):(a[c]=e,s.push(c),this.max&&s.length>parseInt(this.max)&&zt(a,s[0],s,this._vnode)),e.data.keepAlive=!0}return e||t&&t[0]}}};!function(t){var e={};e.get=function(){return Jn},Object.defineProperty(t,"config",e),t.util={warn:pr,extend:h,mergeOptions:F,defineReactive:E},t.set=j,t.delete=N,t.nextTick=q,t.options=Object.create(null),zn.forEach(function(e){t.options[e+"s"]=Object.create(null)}),t.options._base=t,h(t.options.components,ti),function(t){t.use=function(t){var e=this._installedPlugins||(this._installedPlugins=[]);if(e.indexOf(t)>-1)return this;var n=v(arguments,1);return n.unshift(this),"function"==typeof t.install?t.install.apply(t,n):"function"==typeof t&&t.apply(null,n),e.push(t),this}}(t),function(t){t.mixin=function(t){return this.options=F(this.options,t),this}}(t),Ht(t),function(t){zn.forEach(function(e){t[e]=function(t,n){return n?("component"===e&&o(n)&&(n.name=n.name||t,n=this.options._base.extend(n)),"directive"===e&&"function"==typeof n&&(n={bind:n,update:n}),this.options[e+"s"][t]=n,n):this.options[e+"s"][t]}})}(t)}(Rt),Object.defineProperty(Rt.prototype,"$isServer",{get:ur}),Object.defineProperty(Rt.prototype,"$ssrContext",{get:function(){return this.$vnode&&this.$vnode.ssrContext}}),Rt.version="2.5.13";var ei,ni,ri,ii,oi,ai,si,ci,ui=u("style,class"),li=u("input,textarea,option,select,progress"),fi=function(t,e,n){return"value"===n&&li(t)&&"button"!==e||"selected"===n&&"option"===t||"checked"===n&&"input"===t||"muted"===n&&"video"===t},pi=u("contenteditable,draggable,spellcheck"),di=u("allowfullscreen,async,autofocus,autoplay,checked,compact,controls,declare,default,defaultchecked,defaultmuted,defaultselected,defer,disabled,enabled,formnovalidate,hidden,indeterminate,inert,ismap,itemscope,loop,multiple,muted,nohref,noresize,noshade,novalidate,nowrap,open,pauseonexit,readonly,required,reversed,scoped,seamless,selected,sortable,translate,truespeed,typemustmatch,visible"),vi="http://www.w3.org/1999/xlink",hi=function(t){return":"===t.charAt(5)&&"xlink"===t.slice(0,5)},mi=function(t){return hi(t)?t.slice(6,t.length):""},yi=function(t){return null==t||!1===t},gi={svg:"http://www.w3.org/2000/svg",math:"http://www.w3.org/1998/Math/MathML"},_i=u("html,body,base,head,link,meta,style,title,address,article,aside,footer,header,h1,h2,h3,h4,h5,h6,hgroup,nav,section,div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,rtc,ruby,s,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,output,progress,select,textarea,details,dialog,menu,menuitem,summary,content,element,shadow,template,blockquote,iframe,tfoot"),bi=u("svg,animate,circle,clippath,cursor,defs,desc,ellipse,filter,font-face,foreignObject,g,glyph,image,line,marker,mask,missing-glyph,path,pattern,polygon,polyline,rect,switch,symbol,text,textpath,tspan,use,view",!0),$i=function(t){return _i(t)||bi(t)},Ci=Object.create(null),wi=u("text,number,password,search,email,tel,url"),xi=Object.freeze({createElement:function(t,e){var n=document.createElement(t);return"select"!==t?n:(e.data&&e.data.attrs&&void 0!==e.data.attrs.multiple&&n.setAttribute("multiple","multiple"),n)},createElementNS:function(t,e){return document.createElementNS(gi[t],e)},createTextNode:function(t){return document.createTextNode(t)},createComment:function(t){return document.createComment(t)},insertBefore:function(t,e,n){t.insertBefore(e,n)},removeChild:function(t,e){t.removeChild(e)},appendChild:function(t,e){t.appendChild(e)},parentNode:function(t){return t.parentNode},nextSibling:function(t){return t.nextSibling},tagName:function(t){return t.tagName},setTextContent:function(t,e){t.textContent=e},setAttribute:function(t,e,n){t.setAttribute(e,n)}}),ki={create:function(t,e){Xt(e)},update:function(t,e){t.data.ref!==e.data.ref&&(Xt(t,!0),Xt(e))},destroy:function(t){Xt(t,!0)}},Ai=new mr("",{},[]),Oi=["create","activate","update","remove","destroy"],Si={create:te,update:te,destroy:function(t){te(t,Ai)}},Ti=Object.create(null),Ei=[ki,Si],ji={create:re,update:re},Ni={create:oe,update:oe},Ii=/[\w).+\-_$\]]/,Li="__r",Mi="__c",Di={create:xe,update:xe},Pi={create:ke,update:ke},Fi=p(function(t){var e={},n=/:(.+)/;return t.split(/;(?![^(]*\))/g).forEach(function(t){if(t){var r=t.split(n);r.length>1&&(e[r[0].trim()]=r[1].trim())}}),e}),Ri=/^--/,Hi=/\s*!important$/,Bi=function(t,e,n){if(Ri.test(e))t.style.setProperty(e,n);else if(Hi.test(n))t.style.setProperty(e,n.replace(Hi,""),"important");else{var r=Vi(e);if(Array.isArray(n))for(var i=0,o=n.length;i<o;i++)t.style[r]=n[i];else t.style[r]=n}},Ui=["Webkit","Moz","ms"],Vi=p(function(t){if(ci=ci||document.createElement("div").style,"filter"!==(t=Pn(t))&&t in ci)return t;for(var e=t.charAt(0).toUpperCase()+t.slice(1),n=0;n<Ui.length;n++){var r=Ui[n]+e;if(r in ci)return r}}),zi={create:Se,update:Se},Ki=p(function(t){return{enterClass:t+"-enter",enterToClass:t+"-enter-to",enterActiveClass:t+"-enter-active",leaveClass:t+"-leave",leaveToClass:t+"-leave-to",leaveActiveClass:t+"-leave-active"}}),Ji=Gn&&!tr,qi="transition",Wi="animation",Gi="transition",Zi="transitionend",Xi="animation",Yi="animationend";Ji&&(void 0===window.ontransitionend&&void 0!==window.onwebkittransitionend&&(Gi="WebkitTransition",Zi="webkitTransitionEnd"),void 0===window.onanimationend&&void 0!==window.onwebkitanimationend&&(Xi="WebkitAnimation",Yi="webkitAnimationEnd"));var Qi=Gn?window.requestAnimationFrame?window.requestAnimationFrame.bind(window):setTimeout:function(t){return t()},to=/\b(transform|all)(,|$)/,eo=function(i){function o(t){var n=A.parentNode(t);e(n)&&A.removeChild(n,t)}function a(t,r,i,o,a){if(t.isRootInsert=!a,!function(t,r,i,o){var a=t.data;if(e(a)){var u=e(t.componentInstance)&&a.keepAlive;if(e(a=a.hook)&&e(a=a.init)&&a(t,!1,i,o),e(t.componentInstance))return s(t,r),n(u)&&function(t,n,r,i){for(var o,a=t;a.componentInstance;)if(a=a.componentInstance._vnode,e(o=a.data)&&e(o=o.transition)){for(o=0;o<x.activate.length;++o)x.activate[o](Ai,a);n.push(a);break}c(r,t.elm,i)}(t,r,i,o),!0}}(t,r,i,o)){var u=t.data,f=t.children,v=t.tag;e(v)?(t.elm=t.ns?A.createElementNS(t.ns,v):A.createElement(v,t),d(t),l(t,f,r),e(u)&&p(t,r),c(i,t.elm,o)):n(t.isComment)?(t.elm=A.createComment(t.text),c(i,t.elm,o)):(t.elm=A.createTextNode(t.text),c(i,t.elm,o))}}function s(t,n){e(t.data.pendingInsert)&&(n.push.apply(n,t.data.pendingInsert),t.data.pendingInsert=null),t.elm=t.componentInstance.$el,f(t)?(p(t,n),d(t)):(Xt(t),n.push(t))}function c(t,n,r){e(t)&&(e(r)?r.parentNode===t&&A.insertBefore(t,n,r):A.appendChild(t,n))}function l(t,e,n){if(Array.isArray(e))for(var i=0;i<e.length;++i)a(e[i],n,t.elm,null,!0);else r(t.text)&&A.appendChild(t.elm,A.createTextNode(String(t.text)))}function f(t){for(;t.componentInstance;)t=t.componentInstance._vnode;return e(t.tag)}function p(t,n){for(var r=0;r<x.create.length;++r)x.create[r](Ai,t);e(C=t.data.hook)&&(e(C.create)&&C.create(Ai,t),e(C.insert)&&n.push(t))}function d(t){var n;if(e(n=t.fnScopeId))A.setAttribute(t.elm,n,"");else for(var r=t;r;)e(n=r.context)&&e(n=n.$options._scopeId)&&A.setAttribute(t.elm,n,""),r=r.parent;e(n=Pr)&&n!==t.context&&n!==t.fnContext&&e(n=n.$options._scopeId)&&A.setAttribute(t.elm,n,"")}function v(t,e,n,r,i,o){for(;r<=i;++r)a(n[r],o,t,e)}function h(t){var n,r,i=t.data;if(e(i))for(e(n=i.hook)&&e(n=n.destroy)&&n(t),n=0;n<x.destroy.length;++n)x.destroy[n](t);if(e(n=t.children))for(r=0;r<t.children.length;++r)h(t.children[r])}function m(t,n,r,i){for(;r<=i;++r){var a=n[r];e(a)&&(e(a.tag)?(y(a),h(a)):o(a.elm))}}function y(t,n){if(e(n)||e(t.data)){var r,i=x.remove.length+1;for(e(n)?n.listeners+=i:n=function(t,e){function n(){0==--n.listeners&&o(t)}return n.listeners=e,n}(t.elm,i),e(r=t.componentInstance)&&e(r=r._vnode)&&e(r.data)&&y(r,n),r=0;r<x.remove.length;++r)x.remove[r](t,n);e(r=t.data.hook)&&e(r=r.remove)?r(t,n):n()}else o(t.elm)}function g(n,r,i,o,s){for(var c,u,l,f=0,p=0,d=r.length-1,h=r[0],y=r[d],g=i.length-1,b=i[0],$=i[g],C=!s;f<=d&&p<=g;)t(h)?h=r[++f]:t(y)?y=r[--d]:Yt(h,b)?(_(h,b,o),h=r[++f],b=i[++p]):Yt(y,$)?(_(y,$,o),y=r[--d],$=i[--g]):Yt(h,$)?(_(h,$,o),C&&A.insertBefore(n,h.elm,A.nextSibling(y.elm)),h=r[++f],$=i[--g]):Yt(y,b)?(_(y,b,o),C&&A.insertBefore(n,y.elm,h.elm),y=r[--d],b=i[++p]):(t(c)&&(c=Qt(r,f,d)),t(u=e(b.key)?c[b.key]:function(t,n,r,i){for(var o=r;o<i;o++){var a=n[o];if(e(a)&&Yt(t,a))return o}}(b,r,f,d))?a(b,o,n,h.elm):Yt(l=r[u],b)?(_(l,b,o),r[u]=void 0,C&&A.insertBefore(n,l.elm,h.elm)):a(b,o,n,h.elm),b=i[++p]);f>d?v(n,t(i[g+1])?null:i[g+1].elm,i,p,g,o):p>g&&m(0,r,f,d)}function _(r,i,o,a){if(r!==i){var s=i.elm=r.elm;if(n(r.isAsyncPlaceholder))e(i.asyncFactory.resolved)?$(r.elm,i,o):i.isAsyncPlaceholder=!0;else if(n(i.isStatic)&&n(r.isStatic)&&i.key===r.key&&(n(i.isCloned)||n(i.isOnce)))i.componentInstance=r.componentInstance;else{var c,u=i.data;e(u)&&e(c=u.hook)&&e(c=c.prepatch)&&c(r,i);var l=r.children,p=i.children;if(e(u)&&f(i)){for(c=0;c<x.update.length;++c)x.update[c](r,i);e(c=u.hook)&&e(c=c.update)&&c(r,i)}t(i.text)?e(l)&&e(p)?l!==p&&g(s,l,p,o,a):e(p)?(e(r.text)&&A.setTextContent(s,""),v(s,null,p,0,p.length-1,o)):e(l)?m(0,l,0,l.length-1):e(r.text)&&A.setTextContent(s,""):r.text!==i.text&&A.setTextContent(s,i.text),e(u)&&e(c=u.hook)&&e(c=c.postpatch)&&c(r,i)}}}function b(t,r,i){if(n(i)&&e(t.parent))t.parent.data.pendingInsert=r;else for(var o=0;o<r.length;++o)r[o].data.hook.insert(r[o])}function $(t,r,i,o){var a,c=r.tag,u=r.data,f=r.children;if(o=o||u&&u.pre,r.elm=t,n(r.isComment)&&e(r.asyncFactory))return r.isAsyncPlaceholder=!0,!0;if(e(u)&&(e(a=u.hook)&&e(a=a.init)&&a(r,!0),e(a=r.componentInstance)))return s(r,i),!0;if(e(c)){if(e(f))if(t.hasChildNodes())if(e(a=u)&&e(a=a.domProps)&&e(a=a.innerHTML)){if(a!==t.innerHTML)return!1}else{for(var d=!0,v=t.firstChild,h=0;h<f.length;h++){if(!v||!$(v,f[h],i,o)){d=!1;break}v=v.nextSibling}if(!d||v)return!1}else l(r,f,i);if(e(u)){var m=!1;for(var y in u)if(!O(y)){m=!0,p(r,i);break}!m&&u.class&&W(u.class)}}else t.data!==r.text&&(t.data=r.text);return!0}var C,w,x={},k=i.modules,A=i.nodeOps;for(C=0;C<Oi.length;++C)for(x[Oi[C]]=[],w=0;w<k.length;++w)e(k[w][Oi[C]])&&x[Oi[C]].push(k[w][Oi[C]]);var O=u("attrs,class,staticClass,staticStyle,key");return function(r,i,o,s,c,u){if(!t(i)){var l=!1,p=[];if(t(r))l=!0,a(i,p,c,u);else{var d=e(r.nodeType);if(!d&&Yt(r,i))_(r,i,p,s);else{if(d){if(1===r.nodeType&&r.hasAttribute(Vn)&&(r.removeAttribute(Vn),o=!0),n(o)&&$(r,i,p))return b(i,p,!0),r;r=function(t){return new mr(A.tagName(t).toLowerCase(),{},[],void 0,t)}(r)}var v=r.elm,y=A.parentNode(v);if(a(i,p,v._leaveCb?null:y,A.nextSibling(v)),e(i.parent))for(var g=i.parent,C=f(i);g;){for(var w=0;w<x.destroy.length;++w)x.destroy[w](g);if(g.elm=i.elm,C){for(var k=0;k<x.create.length;++k)x.create[k](Ai,g);var O=g.data.hook.insert;if(O.merged)for(var S=1;S<O.fns.length;S++)O.fns[S]()}else Xt(g);g=g.parent}e(y)?m(0,[r],0,0):e(r.tag)&&h(r)}}return b(i,p,l),i.elm}e(r)&&h(r)}}({nodeOps:xi,modules:[ji,Ni,Di,Pi,zi,Gn?{create:Ve,activate:Ve,remove:function(t,e){!0!==t.data.show?He(t,e):e()}}:{}].concat(Ei)});tr&&document.addEventListener("selectionchange",function(){var t=document.activeElement;t&&t.vmodel&&Ze(t,"input")});var no={inserted:function(t,e,n,r){"select"===n.tag?(r.elm&&!r.elm._vOptions?Y(n,"postpatch",function(){no.componentUpdated(t,e,n)}):ze(t,e,n.context),t._vOptions=[].map.call(t.options,qe)):("textarea"===n.tag||wi(t.type))&&(t._vModifiers=e.modifiers,e.modifiers.lazy||(t.addEventListener("change",Ge),nr||(t.addEventListener("compositionstart",We),t.addEventListener("compositionend",Ge)),tr&&(t.vmodel=!0)))},componentUpdated:function(t,e,n){if("select"===n.tag){ze(t,e,n.context);var r=t._vOptions,i=t._vOptions=[].map.call(t.options,qe);if(i.some(function(t,e){return!g(t,r[e])})){(t.multiple?e.value.some(function(t){return Je(t,i)}):e.value!==e.oldValue&&Je(e.value,i))&&Ze(t,"change")}}}},ro={model:no,show:{bind:function(t,e,n){var r=e.value,i=(n=Xe(n)).data&&n.data.transition,o=t.__vOriginalDisplay="none"===t.style.display?"":t.style.display;r&&i?(n.data.show=!0,Re(n,function(){t.style.display=o})):t.style.display=r?o:"none"},update:function(t,e,n){var r=e.value;if(r!==e.oldValue){(n=Xe(n)).data&&n.data.transition?(n.data.show=!0,r?Re(n,function(){t.style.display=t.__vOriginalDisplay}):He(n,function(){t.style.display="none"})):t.style.display=r?t.__vOriginalDisplay:"none"}},unbind:function(t,e,n,r,i){i||(t.style.display=t.__vOriginalDisplay)}}},io={name:String,appear:Boolean,css:Boolean,mode:String,type:String,enterClass:String,leaveClass:String,enterToClass:String,leaveToClass:String,enterActiveClass:String,leaveActiveClass:String,appearClass:String,appearActiveClass:String,appearToClass:String,duration:[Number,String,Object]},oo={name:"transition",props:io,abstract:!0,render:function(t){var e=this,n=this.$slots.default;if(n&&(n=n.filter(function(t){return t.tag||rt(t)})).length){var i=this.mode,o=n[0];if(function(t){for(;t=t.parent;)if(t.data.transition)return!0}(this.$vnode))return o;var a=Ye(o);if(!a)return o;if(this._leaving)return tn(t,o);var s="__transition-"+this._uid+"-";a.key=null==a.key?a.isComment?s+"comment":s+a.tag:r(a.key)?0===String(a.key).indexOf(s)?a.key:s+a.key:a.key;var c=(a.data||(a.data={})).transition=Qe(this),u=this._vnode,l=Ye(u);if(a.data.directives&&a.data.directives.some(function(t){return"show"===t.name})&&(a.data.show=!0),l&&l.data&&!function(t,e){return e.key===t.key&&e.tag===t.tag}(a,l)&&!rt(l)&&(!l.componentInstance||!l.componentInstance._vnode.isComment)){var f=l.data.transition=h({},c);if("out-in"===i)return this._leaving=!0,Y(f,"afterLeave",function(){e._leaving=!1,e.$forceUpdate()}),tn(t,o);if("in-out"===i){if(rt(a))return u;var p,d=function(){p()};Y(c,"afterEnter",d),Y(c,"enterCancelled",d),Y(f,"delayLeave",function(t){p=t})}}return o}}},ao=h({tag:String,moveClass:String},io);delete ao.mode;var so={Transition:oo,TransitionGroup:{props:ao,render:function(t){for(var e=this.tag||this.$vnode.data.tag||"span",n=Object.create(null),r=this.prevChildren=this.children,i=this.$slots.default||[],o=this.children=[],a=Qe(this),s=0;s<i.length;s++){var c=i[s];c.tag&&null!=c.key&&0!==String(c.key).indexOf("__vlist")&&(o.push(c),n[c.key]=c,(c.data||(c.data={})).transition=a)}if(r){for(var u=[],l=[],f=0;f<r.length;f++){var p=r[f];p.data.transition=a,p.data.pos=p.elm.getBoundingClientRect(),n[p.key]?u.push(p):l.push(p)}this.kept=t(e,null,u),this.removed=l}return t(e,null,o)},beforeUpdate:function(){this.__patch__(this._vnode,this.kept,!1,!0),this._vnode=this.kept},updated:function(){var t=this.prevChildren,e=this.moveClass||(this.name||"v")+"-move";t.length&&this.hasMove(t[0].elm,e)&&(t.forEach(en),t.forEach(nn),t.forEach(rn),this._reflow=document.body.offsetHeight,t.forEach(function(t){if(t.data.moved){var n=t.elm,r=n.style;Ie(n,e),r.transform=r.WebkitTransform=r.transitionDuration="",n.addEventListener(Zi,n._moveCb=function t(r){r&&!/transform$/.test(r.propertyName)||(n.removeEventListener(Zi,t),n._moveCb=null,Le(n,e))})}}))},methods:{hasMove:function(t,e){if(!Ji)return!1;if(this._hasMove)return this._hasMove;var n=t.cloneNode();t._transitionClasses&&t._transitionClasses.forEach(function(t){Ee(n,t)}),Te(n,e),n.style.display="none",this.$el.appendChild(n);var r=De(n);return this.$el.removeChild(n),this._hasMove=r.hasTransform}}}};Rt.config.mustUseProp=fi,Rt.config.isReservedTag=$i,Rt.config.isReservedAttr=ui,Rt.config.getTagNamespace=Gt,Rt.config.isUnknownElement=function(t){if(!Gn)return!0;if($i(t))return!1;if(t=t.toLowerCase(),null!=Ci[t])return Ci[t];var e=document.createElement(t);return t.indexOf("-")>-1?Ci[t]=e.constructor===window.HTMLUnknownElement||e.constructor===window.HTMLElement:Ci[t]=/HTMLUnknownElement/.test(e.toString())},h(Rt.options.directives,ro),h(Rt.options.components,so),Rt.prototype.__patch__=Gn?eo:y,Rt.prototype.$mount=function(t,e){return t=t&&Gn?Zt(t):void 0,function(t,e,n){t.$el=e,t.$options.render||(t.$options.render=gr),vt(t,"beforeMount");var r;return r=function(){t._update(t._render(),n)},new Kr(t,r,y,null,!0),n=!1,null==t.$vnode&&(t._isMounted=!0,vt(t,"mounted")),t}(this,t,e)},Rt.nextTick(function(){Jn.devtools&&lr&&lr.emit("init",Rt)},0);var co,uo=/\{\{((?:.|\n)+?)\}\}/g,lo=/[-.*+?^${}()|[\]\/\\]/g,fo=p(function(t){var e=t[0].replace(lo,"\\$&"),n=t[1].replace(lo,"\\$&");return new RegExp(e+"((?:.|\\n)+?)"+n,"g")}),po={staticKeys:["staticClass"],transformNode:function(t,e){e.warn;var n=he(t,"class");n&&(t.staticClass=JSON.stringify(n));var r=ve(t,"class",!1);r&&(t.classBinding=r)},genData:function(t){var e="";return t.staticClass&&(e+="staticClass:"+t.staticClass+","),t.classBinding&&(e+="class:"+t.classBinding+","),e}},vo={staticKeys:["staticStyle"],transformNode:function(t,e){e.warn;var n=he(t,"style");n&&(t.staticStyle=JSON.stringify(Fi(n)));var r=ve(t,"style",!1);r&&(t.styleBinding=r)},genData:function(t){var e="";return t.staticStyle&&(e+="staticStyle:"+t.staticStyle+","),t.styleBinding&&(e+="style:("+t.styleBinding+"),"),e}},ho=function(t){return co=co||document.createElement("div"),co.innerHTML=t,co.textContent},mo=u("area,base,br,col,embed,frame,hr,img,input,isindex,keygen,link,meta,param,source,track,wbr"),yo=u("colgroup,dd,dt,li,options,p,td,tfoot,th,thead,tr,source"),go=u("address,article,aside,base,blockquote,body,caption,col,colgroup,dd,details,dialog,div,dl,dt,fieldset,figcaption,figure,footer,form,h1,h2,h3,h4,h5,h6,head,header,hgroup,hr,html,legend,li,menuitem,meta,optgroup,option,param,rp,rt,source,style,summary,tbody,td,tfoot,th,thead,title,tr,track"),_o=/^\s*([^\s"'<>\/=]+)(?:\s*(=)\s*(?:"([^"]*)"+|'([^']*)'+|([^\s"'=<>`]+)))?/,bo="[a-zA-Z_][\\w\\-\\.]*",$o="((?:"+bo+"\\:)?"+bo+")",Co=new RegExp("^<"+$o),wo=/^\s*(\/?)>/,xo=new RegExp("^<\\/"+$o+"[^>]*>"),ko=/^<!DOCTYPE [^>]+>/i,Ao=/^<!--/,Oo=/^<!\[/,So=!1;"x".replace(/x(.)?/g,function(t,e){So=""===e});var To,Eo,jo,No,Io,Lo,Mo,Do,Po,Fo,Ro,Ho=u("script,style,textarea",!0),Bo={},Uo={"&lt;":"<","&gt;":">","&quot;":'"',"&amp;":"&","&#10;":"\n","&#9;":"\t"},Vo=/&(?:lt|gt|quot|amp);/g,zo=/&(?:lt|gt|quot|amp|#10|#9);/g,Ko=u("pre,textarea",!0),Jo=function(t,e){return t&&Ko(t)&&"\n"===e[0]},qo=/^@|^v-on:/,Wo=/^v-|^@|^:/,Go=/(.*?)\s+(?:in|of)\s+(.*)/,Zo=/,([^,\}\]]*)(?:,([^,\}\]]*))?$/,Xo=/^\(|\)$/g,Yo=/:(.*)$/,Qo=/^:|^v-bind:/,ta=/\.[^.]+/g,ea=p(ho),na=/^xmlns:NS\d+/,ra=/^NS\d+:/,ia=[po,vo,{preTransformNode:function(t,e){if("input"===t.tag){var n=t.attrsMap;if(n["v-model"]&&(n["v-bind:type"]||n[":type"])){var r=ve(t,"type"),i=he(t,"v-if",!0),o=i?"&&("+i+")":"",a=null!=he(t,"v-else",!0),s=he(t,"v-else-if",!0),c=fn(t);un(c),fe(c,"type","checkbox"),cn(c,e),c.processed=!0,c.if="("+r+")==='checkbox'"+o,ln(c,{exp:c.if,block:c});var u=fn(t);he(u,"v-for",!0),fe(u,"type","radio"),cn(u,e),ln(c,{exp:"("+r+")==='radio'"+o,block:u});var l=fn(t);return he(l,"v-for",!0),fe(l,":type",r),cn(l,e),ln(c,{exp:i,block:l}),a?c.else=!0:s&&(c.elseif=s),c}}}}],oa={expectHTML:!0,modules:ia,directives:{model:function(t,e,n){var r=e.value,i=e.modifiers,o=t.tag,a=t.attrsMap.type;if(t.component)return me(t,r,i),!1;if("select"===o)!function(t,e,n){var r='var $$selectedVal = Array.prototype.filter.call($event.target.options,function(o){return o.selected}).map(function(o){var val = "_value" in o ? o._value : o.value;return '+(n&&n.number?"_n(val)":"val")+"});";r=r+" "+ye(e,"$event.target.multiple ? $$selectedVal : $$selectedVal[0]"),de(t,"change",r,null,!0)}(t,r,i);else if("input"===o&&"checkbox"===a)!function(t,e,n){var r=n&&n.number,i=ve(t,"value")||"null",o=ve(t,"true-value")||"true",a=ve(t,"false-value")||"false";ue(t,"checked","Array.isArray("+e+")?_i("+e+","+i+")>-1"+("true"===o?":("+e+")":":_q("+e+","+o+")")),de(t,"change","var $$a="+e+",$$el=$event.target,$$c=$$el.checked?("+o+"):("+a+");if(Array.isArray($$a)){var $$v="+(r?"_n("+i+")":i)+",$$i=_i($$a,$$v);if($$el.checked){$$i<0&&("+e+"=$$a.concat([$$v]))}else{$$i>-1&&("+e+"=$$a.slice(0,$$i).concat($$a.slice($$i+1)))}}else{"+ye(e,"$$c")+"}",null,!0)}(t,r,i);else if("input"===o&&"radio"===a)!function(t,e,n){var r=n&&n.number,i=ve(t,"value")||"null";ue(t,"checked","_q("+e+","+(i=r?"_n("+i+")":i)+")"),de(t,"change",ye(e,i),null,!0)}(t,r,i);else if("input"===o||"textarea"===o)!function(t,e,n){var r=t.attrsMap.type,i=n||{},o=i.lazy,a=i.number,s=i.trim,c=!o&&"range"!==r,u=o?"change":"range"===r?Li:"input",l="$event.target.value";s&&(l="$event.target.value.trim()"),a&&(l="_n("+l+")");var f=ye(e,l);c&&(f="if($event.target.composing)return;"+f),ue(t,"value","("+e+")"),de(t,u,f,null,!0),(s||a)&&de(t,"blur","$forceUpdate()")}(t,r,i);else if(!Jn.isReservedTag(o))return me(t,r,i),!1;return!0},text:function(t,e){e.value&&ue(t,"textContent","_s("+e.value+")")},html:function(t,e){e.value&&ue(t,"innerHTML","_s("+e.value+")")}},isPreTag:function(t){return"pre"===t},isUnaryTag:mo,mustUseProp:fi,canBeLeftOpenTag:yo,isReservedTag:$i,getTagNamespace:Gt,staticKeys:function(t){return t.reduce(function(t,e){return t.concat(e.staticKeys||[])},[]).join(",")}(ia)},aa=p(function(t){return u("type,tag,attrsList,attrsMap,plain,parent,children,attrs"+(t?","+t:""))}),sa=/^\s*([\w$_]+|\([^)]*?\))\s*=>|^function\s*\(/,ca=/^\s*[A-Za-z_$][\w$]*(?:\.[A-Za-z_$][\w$]*|\['.*?']|\[".*?"]|\[\d+]|\[[A-Za-z_$][\w$]*])*\s*$/,ua={esc:27,tab:9,enter:13,space:32,up:38,left:37,right:39,down:40,delete:[8,46]},la=function(t){return"if("+t+")return null;"},fa={stop:"$event.stopPropagation();",prevent:"$event.preventDefault();",self:la("$event.target !== $event.currentTarget"),ctrl:la("!$event.ctrlKey"),shift:la("!$event.shiftKey"),alt:la("!$event.altKey"),meta:la("!$event.metaKey"),left:la("'button' in $event && $event.button !== 0"),middle:la("'button' in $event && $event.button !== 1"),right:la("'button' in $event && $event.button !== 2")},pa={on:function(t,e){t.wrapListeners=function(t){return"_g("+t+","+e.value+")"}},bind:function(t,e){t.wrapData=function(n){return"_b("+n+",'"+t.tag+"',"+e.value+","+(e.modifiers&&e.modifiers.prop?"true":"false")+(e.modifiers&&e.modifiers.sync?",true":"")+")"}},cloak:y},da=function(t){this.options=t,this.warn=t.warn||se,this.transforms=ce(t.modules,"transformCode"),this.dataGenFns=ce(t.modules,"genData"),this.directives=h(h({},pa),t.directives);var e=t.isReservedTag||Bn;this.maybeComponent=function(t){return!e(t.tag)},this.onceId=0,this.staticRenderFns=[]},va=(new RegExp("\\b"+"do,if,for,let,new,try,var,case,else,with,await,break,catch,class,const,super,throw,while,yield,delete,export,import,return,switch,default,extends,finally,continue,debugger,function,arguments".split(",").join("\\b|\\b")+"\\b"),new RegExp("\\b"+"delete,typeof,void".split(",").join("\\s*\\([^\\)]*\\)|\\b")+"\\s*\\([^\\)]*\\)"),function(t){return function(e){function n(n,r){var i=Object.create(e),o=[],a=[];if(i.warn=function(t,e){(e?a:o).push(t)},r){r.modules&&(i.modules=(e.modules||[]).concat(r.modules)),r.directives&&(i.directives=h(Object.create(e.directives||null),r.directives));for(var s in r)"modules"!==s&&"directives"!==s&&(i[s]=r[s])}var c=t(n,i);return c.errors=o,c.tips=a,c}return{compile:n,compileToFunctions:function(t){var e=Object.create(null);return function(n,r,i){(r=h({},r)).warn,delete r.warn;var o=r.delimiters?String(r.delimiters)+n:n;if(e[o])return e[o];var a=t(n,r),s={},c=[];return s.render=Tn(a.render,c),s.staticRenderFns=a.staticRenderFns.map(function(t){return Tn(t,c)}),e[o]=s}}(n)}}}(function(t,e){var n=sn(t.trim(),e);!1!==e.optimize&&function(t,e){t&&(Po=aa(e.staticKeys||""),Fo=e.isReservedTag||Bn,pn(t),dn(t,!1))}(n,e);var r=yn(n,e);return{ast:n,render:r.render,staticRenderFns:r.staticRenderFns}})(oa).compileToFunctions),ha=!!Gn&&En(!1),ma=!!Gn&&En(!0),ya=p(function(t){var e=Zt(t);return e&&e.innerHTML}),ga=Rt.prototype.$mount;return Rt.prototype.$mount=function(t,e){if((t=t&&Zt(t))===document.body||t===document.documentElement)return this;var n=this.$options;if(!n.render){var r=n.template;if(r)if("string"==typeof r)"#"===r.charAt(0)&&(r=ya(r));else{if(!r.nodeType)return this;r=r.innerHTML}else t&&(r=function(t){if(t.outerHTML)return t.outerHTML;var e=document.createElement("div");return e.appendChild(t.cloneNode(!0)),e.innerHTML}(t));if(r){var i=va(r,{shouldDecodeNewlines:ha,shouldDecodeNewlinesForHref:ma,delimiters:n.delimiters,comments:n.comments},this),o=i.render,a=i.staticRenderFns;n.render=o,n.staticRenderFns=a}}return ga.call(this,t,e)},Rt.compile=va,Rt});
/*! @preserve This js file is bundled through automated tasks, view the repo for the real source */
(function ($$1) {
  'use strict';

  /**
   * --------------------------------------------------------------------------
   * Bootstrap (v4.0.0-alpha.6): util.js
   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
   * --------------------------------------------------------------------------
   */

  var Util = (function ($) {


    /**
     * ------------------------------------------------------------------------
     * Private TransitionEnd Helpers
     * ------------------------------------------------------------------------
     */

    var transition = false;

    var MAX_UID = 1000000;

    var TransitionEndEvent = {
      WebkitTransition : 'webkitTransitionEnd',
      MozTransition    : 'transitionend',
      OTransition      : 'oTransitionEnd otransitionend',
      transition       : 'transitionend'
    };

    // shoutout AngusCroll (https://goo.gl/pxwQGp)
    function toType(obj) {
      return {}.toString.call(obj).match(/\s([a-zA-Z]+)/)[1].toLowerCase()
    }

    function isElement(obj) {
      return (obj[0] || obj).nodeType
    }

    function getSpecialTransitionEndEvent() {
      return {
        bindType: transition.end,
        delegateType: transition.end,
        handle: function handle(event) {
          if ($(event.target).is(this)) {
            return event.handleObj.handler.apply(this, arguments) // eslint-disable-line prefer-rest-params
          }
          return undefined
        }
      }
    }

    function transitionEndTest() {
      if (window.QUnit) {
        return false
      }

      var el = document.createElement('bootstrap');

      for (var name in TransitionEndEvent) {
        if (el.style[name] !== undefined) {
          return {
            end: TransitionEndEvent[name]
          }
        }
      }

      return false
    }

    function transitionEndEmulator(duration) {
      var this$1 = this;

      var called = false;

      $(this).one(Util.TRANSITION_END, function () {
        called = true;
      });

      setTimeout(function () {
        if (!called) {
          Util.triggerTransitionEnd(this$1);
        }
      }, duration);

      return this
    }

    function setTransitionEndSupport() {
      transition = transitionEndTest();

      $.fn.emulateTransitionEnd = transitionEndEmulator;

      if (Util.supportsTransitionEnd()) {
        $.event.special[Util.TRANSITION_END] = getSpecialTransitionEndEvent();
      }
    }


    /**
     * --------------------------------------------------------------------------
     * Public Util Api
     * --------------------------------------------------------------------------
     */

    var Util = {

      TRANSITION_END: 'bsTransitionEnd',

      getUID: function getUID(prefix) {
        do {
          // eslint-disable-next-line no-bitwise
          prefix += ~~(Math.random() * MAX_UID); // "~~" acts like a faster Math.floor() here
        } while (document.getElementById(prefix))
        return prefix
      },

      getSelectorFromElement: function getSelectorFromElement(element) {
        var selector = element.getAttribute('data-target');

        if (!selector) {
          selector = element.getAttribute('href') || '';
          selector = /^#[a-z]/i.test(selector) ? selector : null;
        }

        return selector
      },

      reflow: function reflow(element) {
        return element.offsetHeight
      },

      triggerTransitionEnd: function triggerTransitionEnd(element) {
        $(element).trigger(transition.end);
      },

      supportsTransitionEnd: function supportsTransitionEnd() {
        return Boolean(transition)
      },

      typeCheckConfig: function typeCheckConfig(componentName, config, configTypes) {
        for (var property in configTypes) {
          if (configTypes.hasOwnProperty(property)) {
            var expectedTypes = configTypes[property];
            var value         = config[property];
            var valueType     = value && isElement(value) ?
                                  'element' : toType(value);

            if (!new RegExp(expectedTypes).test(valueType)) {
              throw new Error(
                (componentName.toUpperCase()) + ": " +
                "Option \"" + property + "\" provided type \"" + valueType + "\" " +
                "but expected type \"" + expectedTypes + "\".")
            }
          }
        }
      }
    };

    setTransitionEndSupport();

    return Util

  })(jQuery);

  /**
   * --------------------------------------------------------------------------
   * Bootstrap (v4.0.0-alpha.6): collapse.js
   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
   * --------------------------------------------------------------------------
   */

  var Collapse = (function ($) {


    /**
     * ------------------------------------------------------------------------
     * Constants
     * ------------------------------------------------------------------------
     */

    var NAME                = 'collapse';
    var VERSION             = '4.0.0-alpha.6';
    var DATA_KEY            = 'bs.collapse';
    var EVENT_KEY           = "." + DATA_KEY;
    var DATA_API_KEY        = '.data-api';
    var JQUERY_NO_CONFLICT  = $.fn[NAME];
    var TRANSITION_DURATION = 600;

    var Default = {
      toggle : true,
      parent : ''
    };

    var DefaultType = {
      toggle : 'boolean',
      parent : 'string'
    };

    var Event = {
      SHOW           : ("show" + EVENT_KEY),
      SHOWN          : ("shown" + EVENT_KEY),
      HIDE           : ("hide" + EVENT_KEY),
      HIDDEN         : ("hidden" + EVENT_KEY),
      CLICK_DATA_API : ("click" + EVENT_KEY + DATA_API_KEY)
    };

    var ClassName = {
      SHOW       : 'show',
      COLLAPSE   : 'collapse',
      COLLAPSING : 'collapsing',
      COLLAPSED  : 'collapsed'
    };

    var Dimension = {
      WIDTH  : 'width',
      HEIGHT : 'height'
    };

    var Selector = {
      ACTIVES     : '.card > .show, .card > .collapsing',
      DATA_TOGGLE : '[data-toggle="collapse"]'
    };


    /**
     * ------------------------------------------------------------------------
     * Class Definition
     * ------------------------------------------------------------------------
     */

    var Collapse = function Collapse(element, config) {
      this._isTransitioning = false;
      this._element       = element;
      this._config        = this._getConfig(config);
      this._triggerArray  = $.makeArray($(
        "[data-toggle=\"collapse\"][href=\"#" + (element.id) + "\"]," +
        "[data-toggle=\"collapse\"][data-target=\"#" + (element.id) + "\"]"
      ));

      this._parent = this._config.parent ? this._getParent() : null;

      if (!this._config.parent) {
        this._addAriaAndCollapsedClass(this._element, this._triggerArray);
      }

      if (this._config.toggle) {
        this.toggle();
      }
    };

    var staticAccessors = { VERSION: { configurable: true },Default: { configurable: true } };


    // getters

    staticAccessors.VERSION.get = function () {
      return VERSION
    };

    staticAccessors.Default.get = function () {
      return Default
    };


    // public

    Collapse.prototype.toggle = function toggle () {
      if ($(this._element).hasClass(ClassName.SHOW)) {
        this.hide();
      } else {
        this.show();
      }
    };

    Collapse.prototype.show = function show () {
        var this$1 = this;

      if (this._isTransitioning) {
        throw new Error('Collapse is transitioning')
      }

      if ($(this._element).hasClass(ClassName.SHOW)) {
        return
      }

      var actives;
      var activesData;

      if (this._parent) {
        actives = $.makeArray($(this._parent).find(Selector.ACTIVES));
        if (!actives.length) {
          actives = null;
        }
      }

      if (actives) {
        activesData = $(actives).data(DATA_KEY);
        if (activesData && activesData._isTransitioning) {
          return
        }
      }

      var startEvent = $.Event(Event.SHOW);
      $(this._element).trigger(startEvent);
      if (startEvent.isDefaultPrevented()) {
        return
      }

      if (actives) {
        Collapse._jQueryInterface.call($(actives), 'hide');
        if (!activesData) {
          $(actives).data(DATA_KEY, null);
        }
      }

      var dimension = this._getDimension();

      $(this._element)
        .removeClass(ClassName.COLLAPSE)
        .addClass(ClassName.COLLAPSING);

      this._element.style[dimension] = 0;
      this._element.setAttribute('aria-expanded', true);

      if (this._triggerArray.length) {
        $(this._triggerArray)
          .removeClass(ClassName.COLLAPSED)
          .attr('aria-expanded', true);
      }

      this.setTransitioning(true);

      var complete = function () {
        $(this$1._element)
          .removeClass(ClassName.COLLAPSING)
          .addClass(ClassName.COLLAPSE)
          .addClass(ClassName.SHOW);

        this$1._element.style[dimension] = '';

        this$1.setTransitioning(false);

        $(this$1._element).trigger(Event.SHOWN);
      };

      if (!Util.supportsTransitionEnd()) {
        complete();
        return
      }

      var capitalizedDimension = dimension[0].toUpperCase() + dimension.slice(1);
      var scrollSize         = "scroll" + capitalizedDimension;

      $(this._element)
        .one(Util.TRANSITION_END, complete)
        .emulateTransitionEnd(TRANSITION_DURATION);

      this._element.style[dimension] = (this._element[scrollSize]) + "px";
    };

    Collapse.prototype.hide = function hide () {
        var this$1 = this;

      if (this._isTransitioning) {
        throw new Error('Collapse is transitioning')
      }

      if (!$(this._element).hasClass(ClassName.SHOW)) {
        return
      }

      var startEvent = $.Event(Event.HIDE);
      $(this._element).trigger(startEvent);
      if (startEvent.isDefaultPrevented()) {
        return
      }

      var dimension     = this._getDimension();
      var offsetDimension = dimension === Dimension.WIDTH ?
        'offsetWidth' : 'offsetHeight';

      this._element.style[dimension] = (this._element[offsetDimension]) + "px";

      Util.reflow(this._element);

      $(this._element)
        .addClass(ClassName.COLLAPSING)
        .removeClass(ClassName.COLLAPSE)
        .removeClass(ClassName.SHOW);

      this._element.setAttribute('aria-expanded', false);

      if (this._triggerArray.length) {
        $(this._triggerArray)
          .addClass(ClassName.COLLAPSED)
          .attr('aria-expanded', false);
      }

      this.setTransitioning(true);

      var complete = function () {
        this$1.setTransitioning(false);
        $(this$1._element)
          .removeClass(ClassName.COLLAPSING)
          .addClass(ClassName.COLLAPSE)
          .trigger(Event.HIDDEN);
      };

      this._element.style[dimension] = '';

      if (!Util.supportsTransitionEnd()) {
        complete();
        return
      }

      $(this._element)
        .one(Util.TRANSITION_END, complete)
        .emulateTransitionEnd(TRANSITION_DURATION);
    };

    Collapse.prototype.setTransitioning = function setTransitioning (isTransitioning) {
      this._isTransitioning = isTransitioning;
    };

    Collapse.prototype.dispose = function dispose () {
      $.removeData(this._element, DATA_KEY);

      this._config        = null;
      this._parent        = null;
      this._element       = null;
      this._triggerArray  = null;
      this._isTransitioning = null;
    };


    // private

    Collapse.prototype._getConfig = function _getConfig (config) {
      config = $.extend({}, Default, config);
      config.toggle = Boolean(config.toggle); // coerce string values
      Util.typeCheckConfig(NAME, config, DefaultType);
      return config
    };

    Collapse.prototype._getDimension = function _getDimension () {
      var hasWidth = $(this._element).hasClass(Dimension.WIDTH);
      return hasWidth ? Dimension.WIDTH : Dimension.HEIGHT
    };

    Collapse.prototype._getParent = function _getParent () {
        var this$1 = this;

      var parent = $(this._config.parent)[0];
      var selector =
        "[data-toggle=\"collapse\"][data-parent=\"" + (this._config.parent) + "\"]";

      $(parent).find(selector).each(function (i, element) {
        this$1._addAriaAndCollapsedClass(
          Collapse._getTargetFromElement(element),
          [element]
        );
      });

      return parent
    };

    Collapse.prototype._addAriaAndCollapsedClass = function _addAriaAndCollapsedClass (element, triggerArray) {
      if (element) {
        var isOpen = $(element).hasClass(ClassName.SHOW);
        element.setAttribute('aria-expanded', isOpen);

        if (triggerArray.length) {
          $(triggerArray)
            .toggleClass(ClassName.COLLAPSED, !isOpen)
            .attr('aria-expanded', isOpen);
        }
      }
    };


    // static

    Collapse._getTargetFromElement = function _getTargetFromElement (element) {
      var selector = Util.getSelectorFromElement(element);
      return selector ? $(selector)[0] : null
    };

    Collapse._jQueryInterface = function _jQueryInterface (config) {
      return this.each(function () {
        var $this = $(this);
        var data    = $this.data(DATA_KEY);
        var _config = $.extend(
          {},
          Default,
          $this.data(),
          typeof config === 'object' && config
        );

        if (!data && _config.toggle && /show|hide/.test(config)) {
          _config.toggle = false;
        }

        if (!data) {
          data = new Collapse(this, _config);
          $this.data(DATA_KEY, data);
        }

        if (typeof config === 'string') {
          if (data[config] === undefined) {
            throw new Error(("No method named \"" + config + "\""))
          }
          data[config]();
        }
      })
    };

    Object.defineProperties( Collapse, staticAccessors );


    /**
     * ------------------------------------------------------------------------
     * Data Api implementation
     * ------------------------------------------------------------------------
     */

    $(document).on(Event.CLICK_DATA_API, Selector.DATA_TOGGLE, function (event) {
      event.preventDefault();

      var target = Collapse._getTargetFromElement(this);
      var data   = $(target).data(DATA_KEY);
      var config = data ? 'toggle' : $(this).data();

      Collapse._jQueryInterface.call($(target), config);
    });


    /**
     * ------------------------------------------------------------------------
     * jQuery
     * ------------------------------------------------------------------------
     */

    $.fn[NAME]             = Collapse._jQueryInterface;
    $.fn[NAME].Constructor = Collapse;
    $.fn[NAME].noConflict  = function () {
      $.fn[NAME] = JQUERY_NO_CONFLICT;
      return Collapse._jQueryInterface
    };

    return Collapse

  })(jQuery);

  /**
   * --------------------------------------------------------------------------
   * Bootstrap (v4.0.0-alpha.6): alert.js
   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
   * --------------------------------------------------------------------------
   */

  var Alert = (function ($) {


    /**
     * ------------------------------------------------------------------------
     * Constants
     * ------------------------------------------------------------------------
     */

    var NAME                = 'alert';
    var VERSION             = '4.0.0-alpha.6';
    var DATA_KEY            = 'bs.alert';
    var EVENT_KEY           = "." + DATA_KEY;
    var DATA_API_KEY        = '.data-api';
    var JQUERY_NO_CONFLICT  = $.fn[NAME];
    var TRANSITION_DURATION = 150;

    var Selector = {
      DISMISS : '[data-dismiss="alert"]'
    };

    var Event = {
      CLOSE          : ("close" + EVENT_KEY),
      CLOSED         : ("closed" + EVENT_KEY),
      CLICK_DATA_API : ("click" + EVENT_KEY + DATA_API_KEY)
    };

    var ClassName = {
      ALERT : 'alert',
      FADE  : 'fade',
      SHOW  : 'show'
    };


    /**
     * ------------------------------------------------------------------------
     * Class Definition
     * ------------------------------------------------------------------------
     */

    var Alert = function Alert(element) {
      this._element = element;
    };

    var staticAccessors = { VERSION: { configurable: true } };


    // getters

    staticAccessors.VERSION.get = function () {
      return VERSION
    };


    // public

    Alert.prototype.close = function close (element) {
      element = element || this._element;

      var rootElement = this._getRootElement(element);
      var customEvent = this._triggerCloseEvent(rootElement);

      if (customEvent.isDefaultPrevented()) {
        return
      }

      this._removeElement(rootElement);
    };

    Alert.prototype.dispose = function dispose () {
      $.removeData(this._element, DATA_KEY);
      this._element = null;
    };


    // private

    Alert.prototype._getRootElement = function _getRootElement (element) {
      var selector = Util.getSelectorFromElement(element);
      var parent   = false;

      if (selector) {
        parent = $(selector)[0];
      }

      if (!parent) {
        parent = $(element).closest(("." + (ClassName.ALERT)))[0];
      }

      return parent
    };

    Alert.prototype._triggerCloseEvent = function _triggerCloseEvent (element) {
      var closeEvent = $.Event(Event.CLOSE);

      $(element).trigger(closeEvent);
      return closeEvent
    };

    Alert.prototype._removeElement = function _removeElement (element) {
        var this$1 = this;

      $(element).removeClass(ClassName.SHOW);

      if (!Util.supportsTransitionEnd() ||
          !$(element).hasClass(ClassName.FADE)) {
        this._destroyElement(element);
        return
      }

      $(element)
        .one(Util.TRANSITION_END, function (event) { return this$1._destroyElement(element, event); })
        .emulateTransitionEnd(TRANSITION_DURATION);
    };

    Alert.prototype._destroyElement = function _destroyElement (element) {
      $(element)
        .detach()
        .trigger(Event.CLOSED)
        .remove();
    };


    // static

    Alert._jQueryInterface = function _jQueryInterface (config) {
      return this.each(function () {
        var $element = $(this);
        var data     = $element.data(DATA_KEY);

        if (!data) {
          data = new Alert(this);
          $element.data(DATA_KEY, data);
        }

        if (config === 'close') {
          data[config](this);
        }
      })
    };

    Alert._handleDismiss = function _handleDismiss (alertInstance) {
      return function (event) {
        if (event) {
          event.preventDefault();
        }

        alertInstance.close(this);
      }
    };

    Object.defineProperties( Alert, staticAccessors );


    /**
     * ------------------------------------------------------------------------
     * Data Api implementation
     * ------------------------------------------------------------------------
     */

    $(document).on(
      Event.CLICK_DATA_API,
      Selector.DISMISS,
      Alert._handleDismiss(new Alert())
    );


    /**
     * ------------------------------------------------------------------------
     * jQuery
     * ------------------------------------------------------------------------
     */

    $.fn[NAME]             = Alert._jQueryInterface;
    $.fn[NAME].Constructor = Alert;
    $.fn[NAME].noConflict  = function () {
      $.fn[NAME] = JQUERY_NO_CONFLICT;
      return Alert._jQueryInterface
    };

    return Alert

  })(jQuery);

  /**
   * --------------------------------------------------------------------------
   * Bootstrap (v4.0.0-alpha.6): modal.js
   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
   * --------------------------------------------------------------------------
   */

  var Modal = (function ($) {


    /**
     * ------------------------------------------------------------------------
     * Constants
     * ------------------------------------------------------------------------
     */

    var NAME                         = 'modal';
    var VERSION                      = '4.0.0-alpha.6';
    var DATA_KEY                     = 'bs.modal';
    var EVENT_KEY                    = "." + DATA_KEY;
    var DATA_API_KEY                 = '.data-api';
    var JQUERY_NO_CONFLICT           = $.fn[NAME];
    var TRANSITION_DURATION          = 300;
    var BACKDROP_TRANSITION_DURATION = 150;
    var ESCAPE_KEYCODE               = 27; // KeyboardEvent.which value for Escape (Esc) key

    var Default = {
      backdrop : true,
      keyboard : true,
      focus    : true,
      show     : true
    };

    var DefaultType = {
      backdrop : '(boolean|string)',
      keyboard : 'boolean',
      focus    : 'boolean',
      show     : 'boolean'
    };

    var Event = {
      HIDE              : ("hide" + EVENT_KEY),
      HIDDEN            : ("hidden" + EVENT_KEY),
      SHOW              : ("show" + EVENT_KEY),
      SHOWN             : ("shown" + EVENT_KEY),
      FOCUSIN           : ("focusin" + EVENT_KEY),
      RESIZE            : ("resize" + EVENT_KEY),
      CLICK_DISMISS     : ("click.dismiss" + EVENT_KEY),
      KEYDOWN_DISMISS   : ("keydown.dismiss" + EVENT_KEY),
      MOUSEUP_DISMISS   : ("mouseup.dismiss" + EVENT_KEY),
      MOUSEDOWN_DISMISS : ("mousedown.dismiss" + EVENT_KEY),
      CLICK_DATA_API    : ("click" + EVENT_KEY + DATA_API_KEY)
    };

    var ClassName = {
      SCROLLBAR_MEASURER : 'modal-scrollbar-measure',
      BACKDROP           : 'modal-backdrop',
      OPEN               : 'modal-open',
      FADE               : 'fade',
      SHOW               : 'show'
    };

    var Selector = {
      DIALOG             : '.modal-dialog',
      DATA_TOGGLE        : '[data-toggle="modal"]',
      DATA_DISMISS       : '[data-dismiss="modal"]',
      FIXED_CONTENT      : '.fixed-top, .fixed-bottom, .is-fixed, .sticky-top'
    };


    /**
     * ------------------------------------------------------------------------
     * Class Definition
     * ------------------------------------------------------------------------
     */

    var Modal = function Modal(element, config) {
      this._config            = this._getConfig(config);
      this._element           = element;
      this._dialog            = $(element).find(Selector.DIALOG)[0];
      this._backdrop          = null;
      this._isShown           = false;
      this._isBodyOverflowing = false;
      this._ignoreBackdropClick = false;
      this._isTransitioning   = false;
      this._originalBodyPadding = 0;
      this._scrollbarWidth    = 0;
    };

    var staticAccessors = { VERSION: { configurable: true },Default: { configurable: true } };


    // getters

    staticAccessors.VERSION.get = function () {
      return VERSION
    };

    staticAccessors.Default.get = function () {
      return Default
    };


    // public

    Modal.prototype.toggle = function toggle (relatedTarget) {
      return this._isShown ? this.hide() : this.show(relatedTarget)
    };

    Modal.prototype.show = function show (relatedTarget) {
        var this$1 = this;

      if (this._isTransitioning) {
        throw new Error('Modal is transitioning')
      }

      if (Util.supportsTransitionEnd() &&
        $(this._element).hasClass(ClassName.FADE)) {
        this._isTransitioning = true;
      }
      var showEvent = $.Event(Event.SHOW, {
        relatedTarget: relatedTarget
      });

      $(this._element).trigger(showEvent);

      if (this._isShown || showEvent.isDefaultPrevented()) {
        return
      }

      this._isShown = true;

      this._checkScrollbar();
      this._setScrollbar();

      $(document.body).addClass(ClassName.OPEN);

      this._setEscapeEvent();
      this._setResizeEvent();

      $(this._element).on(
        Event.CLICK_DISMISS,
        Selector.DATA_DISMISS,
        function (event) { return this$1.hide(event); }
      );

      $(this._dialog).on(Event.MOUSEDOWN_DISMISS, function () {
        $(this$1._element).one(Event.MOUSEUP_DISMISS, function (event) {
          if ($(event.target).is(this$1._element)) {
            this$1._ignoreBackdropClick = true;
          }
        });
      });

      this._showBackdrop(function () { return this$1._showElement(relatedTarget); });
    };

    Modal.prototype.hide = function hide (event) {
        var this$1 = this;

      if (event) {
        event.preventDefault();
      }

      if (this._isTransitioning) {
        throw new Error('Modal is transitioning')
      }

      var transition = Util.supportsTransitionEnd() &&
        $(this._element).hasClass(ClassName.FADE);
      if (transition) {
        this._isTransitioning = true;
      }

      var hideEvent = $.Event(Event.HIDE);
      $(this._element).trigger(hideEvent);

      if (!this._isShown || hideEvent.isDefaultPrevented()) {
        return
      }

      this._isShown = false;

      this._setEscapeEvent();
      this._setResizeEvent();

      $(document).off(Event.FOCUSIN);

      $(this._element).removeClass(ClassName.SHOW);

      $(this._element).off(Event.CLICK_DISMISS);
      $(this._dialog).off(Event.MOUSEDOWN_DISMISS);

      if (transition) {
        $(this._element)
          .one(Util.TRANSITION_END, function (event) { return this$1._hideModal(event); })
          .emulateTransitionEnd(TRANSITION_DURATION);
      } else {
        this._hideModal();
      }
    };

    Modal.prototype.dispose = function dispose () {
      $.removeData(this._element, DATA_KEY);

      $(window, document, this._element, this._backdrop).off(EVENT_KEY);

      this._config            = null;
      this._element           = null;
      this._dialog            = null;
      this._backdrop          = null;
      this._isShown           = null;
      this._isBodyOverflowing = null;
      this._ignoreBackdropClick = null;
      this._originalBodyPadding = null;
      this._scrollbarWidth    = null;
    };


    // private

    Modal.prototype._getConfig = function _getConfig (config) {
      config = $.extend({}, Default, config);
      Util.typeCheckConfig(NAME, config, DefaultType);
      return config
    };

    Modal.prototype._showElement = function _showElement (relatedTarget) {
        var this$1 = this;

      var transition = Util.supportsTransitionEnd() &&
        $(this._element).hasClass(ClassName.FADE);

      if (!this._element.parentNode ||
         this._element.parentNode.nodeType !== Node.ELEMENT_NODE) {
        // don't move modals dom position
        document.body.appendChild(this._element);
      }

      this._element.style.display = 'block';
      this._element.removeAttribute('aria-hidden');
      this._element.scrollTop = 0;

      if (transition) {
        Util.reflow(this._element);
      }

      $(this._element).addClass(ClassName.SHOW);

      if (this._config.focus) {
        this._enforceFocus();
      }

      var shownEvent = $.Event(Event.SHOWN, {
        relatedTarget: relatedTarget
      });

      var transitionComplete = function () {
        if (this$1._config.focus) {
          this$1._element.focus();
        }
        this$1._isTransitioning = false;
        $(this$1._element).trigger(shownEvent);
      };

      if (transition) {
        $(this._dialog)
          .one(Util.TRANSITION_END, transitionComplete)
          .emulateTransitionEnd(TRANSITION_DURATION);
      } else {
        transitionComplete();
      }
    };

    Modal.prototype._enforceFocus = function _enforceFocus () {
        var this$1 = this;

      $(document)
        .off(Event.FOCUSIN) // guard against infinite focus loop
        .on(Event.FOCUSIN, function (event) {
          if (document !== event.target &&
              this$1._element !== event.target &&
              !$(this$1._element).has(event.target).length) {
            this$1._element.focus();
          }
        });
    };

    Modal.prototype._setEscapeEvent = function _setEscapeEvent () {
        var this$1 = this;

      if (this._isShown && this._config.keyboard) {
        $(this._element).on(Event.KEYDOWN_DISMISS, function (event) {
          if (event.which === ESCAPE_KEYCODE) {
            this$1.hide();
          }
        });

      } else if (!this._isShown) {
        $(this._element).off(Event.KEYDOWN_DISMISS);
      }
    };

    Modal.prototype._setResizeEvent = function _setResizeEvent () {
        var this$1 = this;

      if (this._isShown) {
        $(window).on(Event.RESIZE, function (event) { return this$1._handleUpdate(event); });
      } else {
        $(window).off(Event.RESIZE);
      }
    };

    Modal.prototype._hideModal = function _hideModal () {
        var this$1 = this;

      this._element.style.display = 'none';
      this._element.setAttribute('aria-hidden', 'true');
      this._isTransitioning = false;
      this._showBackdrop(function () {
        $(document.body).removeClass(ClassName.OPEN);
        this$1._resetAdjustments();
        this$1._resetScrollbar();
        $(this$1._element).trigger(Event.HIDDEN);
      });
    };

    Modal.prototype._removeBackdrop = function _removeBackdrop () {
      if (this._backdrop) {
        $(this._backdrop).remove();
        this._backdrop = null;
      }
    };

    Modal.prototype._showBackdrop = function _showBackdrop (callback) {
        var this$1 = this;

      var animate = $(this._element).hasClass(ClassName.FADE) ?
        ClassName.FADE : '';

      if (this._isShown && this._config.backdrop) {
        var doAnimate = Util.supportsTransitionEnd() && animate;

        this._backdrop = document.createElement('div');
        this._backdrop.className = ClassName.BACKDROP;

        if (animate) {
          $(this._backdrop).addClass(animate);
        }

        $(this._backdrop).appendTo(document.body);

        $(this._element).on(Event.CLICK_DISMISS, function (event) {
          if (this$1._ignoreBackdropClick) {
            this$1._ignoreBackdropClick = false;
            return
          }
          if (event.target !== event.currentTarget) {
            return
          }
          if (this$1._config.backdrop === 'static') {
            this$1._element.focus();
          } else {
            this$1.hide();
          }
        });

        if (doAnimate) {
          Util.reflow(this._backdrop);
        }

        $(this._backdrop).addClass(ClassName.SHOW);

        if (!callback) {
          return
        }

        if (!doAnimate) {
          callback();
          return
        }

        $(this._backdrop)
          .one(Util.TRANSITION_END, callback)
          .emulateTransitionEnd(BACKDROP_TRANSITION_DURATION);

      } else if (!this._isShown && this._backdrop) {
        $(this._backdrop).removeClass(ClassName.SHOW);

        var callbackRemove = function () {
          this$1._removeBackdrop();
          if (callback) {
            callback();
          }
        };

        if (Util.supportsTransitionEnd() &&
           $(this._element).hasClass(ClassName.FADE)) {
          $(this._backdrop)
            .one(Util.TRANSITION_END, callbackRemove)
            .emulateTransitionEnd(BACKDROP_TRANSITION_DURATION);
        } else {
          callbackRemove();
        }

      } else if (callback) {
        callback();
      }
    };


    // ----------------------------------------------------------------------
    // the following methods are used to handle overflowing modals
    // todo (fat): these should probably be refactored out of modal.js
    // ----------------------------------------------------------------------

    Modal.prototype._handleUpdate = function _handleUpdate () {
      this._adjustDialog();
    };

    Modal.prototype._adjustDialog = function _adjustDialog () {
      var isModalOverflowing =
        this._element.scrollHeight > document.documentElement.clientHeight;

      if (!this._isBodyOverflowing && isModalOverflowing) {
        this._element.style.paddingLeft = (this._scrollbarWidth) + "px";
      }

      if (this._isBodyOverflowing && !isModalOverflowing) {
        this._element.style.paddingRight = (this._scrollbarWidth) + "px";
      }
    };

    Modal.prototype._resetAdjustments = function _resetAdjustments () {
      this._element.style.paddingLeft = '';
      this._element.style.paddingRight = '';
    };

    Modal.prototype._checkScrollbar = function _checkScrollbar () {
      this._isBodyOverflowing = document.body.clientWidth < window.innerWidth;
      this._scrollbarWidth = this._getScrollbarWidth();
    };

    Modal.prototype._setScrollbar = function _setScrollbar () {
      var bodyPadding = parseInt(
        $(Selector.FIXED_CONTENT).css('padding-right') || 0,
        10
      );

      this._originalBodyPadding = document.body.style.paddingRight || '';

      if (this._isBodyOverflowing) {
        document.body.style.paddingRight =
          (bodyPadding + this._scrollbarWidth) + "px";
      }
    };

    Modal.prototype._resetScrollbar = function _resetScrollbar () {
      document.body.style.paddingRight = this._originalBodyPadding;
    };

    Modal.prototype._getScrollbarWidth = function _getScrollbarWidth () { // thx d.walsh
      var scrollDiv = document.createElement('div');
      scrollDiv.className = ClassName.SCROLLBAR_MEASURER;
      document.body.appendChild(scrollDiv);
      var scrollbarWidth = scrollDiv.offsetWidth - scrollDiv.clientWidth;
      document.body.removeChild(scrollDiv);
      return scrollbarWidth
    };


    // static

    Modal._jQueryInterface = function _jQueryInterface (config, relatedTarget) {
      return this.each(function () {
        var data    = $(this).data(DATA_KEY);
        var _config = $.extend(
          {},
          Modal.Default,
          $(this).data(),
          typeof config === 'object' && config
        );

        if (!data) {
          data = new Modal(this, _config);
          $(this).data(DATA_KEY, data);
        }

        if (typeof config === 'string') {
          if (data[config] === undefined) {
            throw new Error(("No method named \"" + config + "\""))
          }
          data[config](relatedTarget);
        } else if (_config.show) {
          data.show(relatedTarget);
        }
      })
    };

    Object.defineProperties( Modal, staticAccessors );


    /**
     * ------------------------------------------------------------------------
     * Data Api implementation
     * ------------------------------------------------------------------------
     */

    $(document).on(Event.CLICK_DATA_API, Selector.DATA_TOGGLE, function (event) {
      var this$1 = this;

      var target;
      var selector = Util.getSelectorFromElement(this);

      if (selector) {
        target = $(selector)[0];
      }

      var config = $(target).data(DATA_KEY) ?
        'toggle' : $.extend({}, $(target).data(), $(this).data());

      if (this.tagName === 'A' || this.tagName === 'AREA') {
        event.preventDefault();
      }

      var $target = $(target).one(Event.SHOW, function (showEvent) {
        if (showEvent.isDefaultPrevented()) {
          // only register focus restorer if modal will actually get shown
          return
        }

        $target.one(Event.HIDDEN, function () {
          if ($(this$1).is(':visible')) {
            this$1.focus();
          }
        });
      });

      Modal._jQueryInterface.call($(target), config, this);
    });


    /**
     * ------------------------------------------------------------------------
     * jQuery
     * ------------------------------------------------------------------------
     */

    $.fn[NAME]             = Modal._jQueryInterface;
    $.fn[NAME].Constructor = Modal;
    $.fn[NAME].noConflict  = function () {
      $.fn[NAME] = JQUERY_NO_CONFLICT;
      return Modal._jQueryInterface
    };

    return Modal

  })(jQuery);

  /* global Tether */

  /**
   * --------------------------------------------------------------------------
   * Bootstrap (v4.0.0-alpha.6): tooltip.js
   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
   * --------------------------------------------------------------------------
   */

  var Tooltip = (function ($) {

    /**
     * Check for Tether dependency
     * Tether - http://tether.io/
     */
    if (typeof Tether === 'undefined') {
      throw new Error('Bootstrap tooltips require Tether (http://tether.io/)')
    }


    /**
     * ------------------------------------------------------------------------
     * Constants
     * ------------------------------------------------------------------------
     */

    var NAME                = 'tooltip';
    var VERSION             = '4.0.0-alpha.6';
    var DATA_KEY            = 'bs.tooltip';
    var EVENT_KEY           = "." + DATA_KEY;
    var JQUERY_NO_CONFLICT  = $.fn[NAME];
    var TRANSITION_DURATION = 150;
    var CLASS_PREFIX        = 'bs-tether';

    var Default = {
      animation   : true,
      template    : '<div class="tooltip" role="tooltip">'
                  + '<div class="tooltip-inner"></div></div>',
      trigger     : 'hover focus',
      title       : '',
      delay       : 0,
      html        : false,
      selector    : false,
      placement   : 'top',
      offset      : '0 0',
      constraints : [],
      container   : false
    };

    var DefaultType = {
      animation   : 'boolean',
      template    : 'string',
      title       : '(string|element|function)',
      trigger     : 'string',
      delay       : '(number|object)',
      html        : 'boolean',
      selector    : '(string|boolean)',
      placement   : '(string|function)',
      offset      : 'string',
      constraints : 'array',
      container   : '(string|element|boolean)'
    };

    var AttachmentMap = {
      TOP    : 'bottom center',
      RIGHT  : 'middle left',
      BOTTOM : 'top center',
      LEFT   : 'middle right'
    };

    var HoverState = {
      SHOW : 'show',
      OUT  : 'out'
    };

    var Event = {
      HIDE       : ("hide" + EVENT_KEY),
      HIDDEN     : ("hidden" + EVENT_KEY),
      SHOW       : ("show" + EVENT_KEY),
      SHOWN      : ("shown" + EVENT_KEY),
      INSERTED   : ("inserted" + EVENT_KEY),
      CLICK      : ("click" + EVENT_KEY),
      FOCUSIN    : ("focusin" + EVENT_KEY),
      FOCUSOUT   : ("focusout" + EVENT_KEY),
      MOUSEENTER : ("mouseenter" + EVENT_KEY),
      MOUSELEAVE : ("mouseleave" + EVENT_KEY)
    };

    var ClassName = {
      FADE : 'fade',
      SHOW : 'show'
    };

    var Selector = {
      TOOLTIP       : '.tooltip',
      TOOLTIP_INNER : '.tooltip-inner'
    };

    var TetherClass = {
      element : false,
      enabled : false
    };

    var Trigger = {
      HOVER  : 'hover',
      FOCUS  : 'focus',
      CLICK  : 'click',
      MANUAL : 'manual'
    };


    /**
     * ------------------------------------------------------------------------
     * Class Definition
     * ------------------------------------------------------------------------
     */

    var Tooltip = function Tooltip(element, config) {

      // private
      this._isEnabled      = true;
      this._timeout        = 0;
      this._hoverState     = '';
      this._activeTrigger  = {};
      this._isTransitioning= false;
      this._tether         = null;

      // protected
      this.element = element;
      this.config= this._getConfig(config);
      this.tip   = null;

      this._setListeners();

    };

    var staticAccessors = { VERSION: { configurable: true },Default: { configurable: true },NAME: { configurable: true },DATA_KEY: { configurable: true },Event: { configurable: true },EVENT_KEY: { configurable: true },DefaultType: { configurable: true } };


    // getters

    staticAccessors.VERSION.get = function () {
      return VERSION
    };

    staticAccessors.Default.get = function () {
      return Default
    };

    staticAccessors.NAME.get = function () {
      return NAME
    };

    staticAccessors.DATA_KEY.get = function () {
      return DATA_KEY
    };

    staticAccessors.Event.get = function () {
      return Event
    };

    staticAccessors.EVENT_KEY.get = function () {
      return EVENT_KEY
    };

    staticAccessors.DefaultType.get = function () {
      return DefaultType
    };


    // public

    Tooltip.prototype.enable = function enable () {
      this._isEnabled = true;
    };

    Tooltip.prototype.disable = function disable () {
      this._isEnabled = false;
    };

    Tooltip.prototype.toggleEnabled = function toggleEnabled () {
      this._isEnabled = !this._isEnabled;
    };

    Tooltip.prototype.toggle = function toggle (event) {
      if (event) {
        var dataKey = this.constructor.DATA_KEY;
        var context = $(event.currentTarget).data(dataKey);

        if (!context) {
          context = new this.constructor(
            event.currentTarget,
            this._getDelegateConfig()
          );
          $(event.currentTarget).data(dataKey, context);
        }

        context._activeTrigger.click = !context._activeTrigger.click;

        if (context._isWithActiveTrigger()) {
          context._enter(null, context);
        } else {
          context._leave(null, context);
        }

      } else {

        if ($(this.getTipElement()).hasClass(ClassName.SHOW)) {
          this._leave(null, this);
          return
        }

        this._enter(null, this);
      }
    };

    Tooltip.prototype.dispose = function dispose () {
      clearTimeout(this._timeout);

      this.cleanupTether();

      $.removeData(this.element, this.constructor.DATA_KEY);

      $(this.element).off(this.constructor.EVENT_KEY);
      $(this.element).closest('.modal').off('hide.bs.modal');

      if (this.tip) {
        $(this.tip).remove();
      }

      this._isEnabled   = null;
      this._timeout     = null;
      this._hoverState  = null;
      this._activeTrigger = null;
      this._tether      = null;

      this.element = null;
      this.config= null;
      this.tip   = null;
    };

    Tooltip.prototype.show = function show () {
        var this$1 = this;

      if ($(this.element).css('display') === 'none') {
        throw new Error('Please use show on visible elements')
      }

      var showEvent = $.Event(this.constructor.Event.SHOW);
      if (this.isWithContent() && this._isEnabled) {
        if (this._isTransitioning) {
          throw new Error('Tooltip is transitioning')
        }
        $(this.element).trigger(showEvent);

        var isInTheDom = $.contains(
          this.element.ownerDocument.documentElement,
          this.element
        );

        if (showEvent.isDefaultPrevented() || !isInTheDom) {
          return
        }

        var tip = this.getTipElement();
        var tipId = Util.getUID(this.constructor.NAME);

        tip.setAttribute('id', tipId);
        this.element.setAttribute('aria-describedby', tipId);

        this.setContent();

        if (this.config.animation) {
          $(tip).addClass(ClassName.FADE);
        }

        var placement= typeof this.config.placement === 'function' ?
          this.config.placement.call(this, tip, this.element) :
          this.config.placement;

        var attachment = this._getAttachment(placement);

        var container = this.config.container === false ? document.body : $(this.config.container);

        $(tip)
          .data(this.constructor.DATA_KEY, this)
          .appendTo(container);

        $(this.element).trigger(this.constructor.Event.INSERTED);

        this._tether = new Tether({
          attachment: attachment,
          element       : tip,
          target        : this.element,
          classes       : TetherClass,
          classPrefix   : CLASS_PREFIX,
          offset        : this.config.offset,
          constraints   : this.config.constraints,
          addTargetClasses: false
        });

        Util.reflow(tip);
        this._tether.position();

        $(tip).addClass(ClassName.SHOW);

        var complete = function () {
          var prevHoverState = this$1._hoverState;
          this$1._hoverState = null;
          this$1._isTransitioning = false;

          $(this$1.element).trigger(this$1.constructor.Event.SHOWN);

          if (prevHoverState === HoverState.OUT) {
            this$1._leave(null, this$1);
          }
        };

        if (Util.supportsTransitionEnd() && $(this.tip).hasClass(ClassName.FADE)) {
          this._isTransitioning = true;
          $(this.tip)
            .one(Util.TRANSITION_END, complete)
            .emulateTransitionEnd(Tooltip._TRANSITION_DURATION);
          return
        }

        complete();
      }
    };

    Tooltip.prototype.hide = function hide (callback) {
        var this$1 = this;

      var tip     = this.getTipElement();
      var hideEvent = $.Event(this.constructor.Event.HIDE);
      if (this._isTransitioning) {
        throw new Error('Tooltip is transitioning')
      }
      var complete= function () {
        if (this$1._hoverState !== HoverState.SHOW && tip.parentNode) {
          tip.parentNode.removeChild(tip);
        }

        this$1.element.removeAttribute('aria-describedby');
        $(this$1.element).trigger(this$1.constructor.Event.HIDDEN);
        this$1._isTransitioning = false;
        this$1.cleanupTether();

        if (callback) {
          callback();
        }
      };

      $(this.element).trigger(hideEvent);

      if (hideEvent.isDefaultPrevented()) {
        return
      }

      $(tip).removeClass(ClassName.SHOW);

      this._activeTrigger[Trigger.CLICK] = false;
      this._activeTrigger[Trigger.FOCUS] = false;
      this._activeTrigger[Trigger.HOVER] = false;

      if (Util.supportsTransitionEnd() &&
          $(this.tip).hasClass(ClassName.FADE)) {
        this._isTransitioning = true;
        $(tip)
          .one(Util.TRANSITION_END, complete)
          .emulateTransitionEnd(TRANSITION_DURATION);

      } else {
        complete();
      }

      this._hoverState = '';
    };


    // protected

    Tooltip.prototype.isWithContent = function isWithContent () {
      return Boolean(this.getTitle())
    };

    Tooltip.prototype.getTipElement = function getTipElement () {
      return this.tip = this.tip || $(this.config.template)[0]
    };

    Tooltip.prototype.setContent = function setContent () {
      var $tip = $(this.getTipElement());

      this.setElementContent($tip.find(Selector.TOOLTIP_INNER), this.getTitle());

      $tip.removeClass(((ClassName.FADE) + " " + (ClassName.SHOW)));

      this.cleanupTether();
    };

    Tooltip.prototype.setElementContent = function setElementContent ($element, content) {
      var html = this.config.html;
      if (typeof content === 'object' && (content.nodeType || content.jquery)) {
        // content is a DOM node or a jQuery
        if (html) {
          if (!$(content).parent().is($element)) {
            $element.empty().append(content);
          }
        } else {
          $element.text($(content).text());
        }
      } else {
        $element[html ? 'html' : 'text'](content);
      }
    };

    Tooltip.prototype.getTitle = function getTitle () {
      var title = this.element.getAttribute('data-original-title');

      if (!title) {
        title = typeof this.config.title === 'function' ?
          this.config.title.call(this.element) :
          this.config.title;
      }

      return title
    };

    Tooltip.prototype.cleanupTether = function cleanupTether () {
      if (this._tether) {
        this._tether.destroy();
      }
    };


    // private

    Tooltip.prototype._getAttachment = function _getAttachment (placement) {
      return AttachmentMap[placement.toUpperCase()]
    };

    Tooltip.prototype._setListeners = function _setListeners () {
        var this$1 = this;

      var triggers = this.config.trigger.split(' ');

      triggers.forEach(function (trigger) {
        if (trigger === 'click') {
          $(this$1.element).on(
            this$1.constructor.Event.CLICK,
            this$1.config.selector,
            function (event) { return this$1.toggle(event); }
          );

        } else if (trigger !== Trigger.MANUAL) {
          var eventIn= trigger === Trigger.HOVER ?
            this$1.constructor.Event.MOUSEENTER :
            this$1.constructor.Event.FOCUSIN;
          var eventOut = trigger === Trigger.HOVER ?
            this$1.constructor.Event.MOUSELEAVE :
            this$1.constructor.Event.FOCUSOUT;

          $(this$1.element)
            .on(
              eventIn,
              this$1.config.selector,
              function (event) { return this$1._enter(event); }
            )
            .on(
              eventOut,
              this$1.config.selector,
              function (event) { return this$1._leave(event); }
            );
        }

        $(this$1.element).closest('.modal').on(
          'hide.bs.modal',
          function () { return this$1.hide(); }
        );
      });

      if (this.config.selector) {
        this.config = $.extend({}, this.config, {
          trigger: 'manual',
          selector : ''
        });
      } else {
        this._fixTitle();
      }
    };

    Tooltip.prototype._fixTitle = function _fixTitle () {
      var titleType = typeof this.element.getAttribute('data-original-title');
      if (this.element.getAttribute('title') ||
         titleType !== 'string') {
        this.element.setAttribute(
          'data-original-title',
          this.element.getAttribute('title') || ''
        );
        this.element.setAttribute('title', '');
      }
    };

    Tooltip.prototype._enter = function _enter (event, context) {
      var dataKey = this.constructor.DATA_KEY;

      context = context || $(event.currentTarget).data(dataKey);

      if (!context) {
        context = new this.constructor(
          event.currentTarget,
          this._getDelegateConfig()
        );
        $(event.currentTarget).data(dataKey, context);
      }

      if (event) {
        context._activeTrigger[
          event.type === 'focusin' ? Trigger.FOCUS : Trigger.HOVER
        ] = true;
      }

      if ($(context.getTipElement()).hasClass(ClassName.SHOW) ||
         context._hoverState === HoverState.SHOW) {
        context._hoverState = HoverState.SHOW;
        return
      }

      clearTimeout(context._timeout);

      context._hoverState = HoverState.SHOW;

      if (!context.config.delay || !context.config.delay.show) {
        context.show();
        return
      }

      context._timeout = setTimeout(function () {
        if (context._hoverState === HoverState.SHOW) {
          context.show();
        }
      }, context.config.delay.show);
    };

    Tooltip.prototype._leave = function _leave (event, context) {
      var dataKey = this.constructor.DATA_KEY;

      context = context || $(event.currentTarget).data(dataKey);

      if (!context) {
        context = new this.constructor(
          event.currentTarget,
          this._getDelegateConfig()
        );
        $(event.currentTarget).data(dataKey, context);
      }

      if (event) {
        context._activeTrigger[
          event.type === 'focusout' ? Trigger.FOCUS : Trigger.HOVER
        ] = false;
      }

      if (context._isWithActiveTrigger()) {
        return
      }

      clearTimeout(context._timeout);

      context._hoverState = HoverState.OUT;

      if (!context.config.delay || !context.config.delay.hide) {
        context.hide();
        return
      }

      context._timeout = setTimeout(function () {
        if (context._hoverState === HoverState.OUT) {
          context.hide();
        }
      }, context.config.delay.hide);
    };

    Tooltip.prototype._isWithActiveTrigger = function _isWithActiveTrigger () {
        var this$1 = this;

      for (var trigger in this$1._activeTrigger) {
        if (this$1._activeTrigger[trigger]) {
          return true
        }
      }

      return false
    };

    Tooltip.prototype._getConfig = function _getConfig (config) {
      config = $.extend(
        {},
        this.constructor.Default,
        $(this.element).data(),
        config
      );

      if (config.delay && typeof config.delay === 'number') {
        config.delay = {
          show : config.delay,
          hide : config.delay
        };
      }

      Util.typeCheckConfig(
        NAME,
        config,
        this.constructor.DefaultType
      );

      return config
    };

    Tooltip.prototype._getDelegateConfig = function _getDelegateConfig () {
        var this$1 = this;

      var config = {};

      if (this.config) {
        for (var key in this$1.config) {
          if (this$1.constructor.Default[key] !== this$1.config[key]) {
            config[key] = this$1.config[key];
          }
        }
      }

      return config
    };


    // static

    Tooltip._jQueryInterface = function _jQueryInterface (config) {
      return this.each(function () {
        var data    = $(this).data(DATA_KEY);
        var _config = typeof config === 'object' && config;

        if (!data && /dispose|hide/.test(config)) {
          return
        }

        if (!data) {
          data = new Tooltip(this, _config);
          $(this).data(DATA_KEY, data);
        }

        if (typeof config === 'string') {
          if (data[config] === undefined) {
            throw new Error(("No method named \"" + config + "\""))
          }
          data[config]();
        }
      })
    };

    Object.defineProperties( Tooltip, staticAccessors );


    /**
     * ------------------------------------------------------------------------
     * jQuery
     * ------------------------------------------------------------------------
     */

    $.fn[NAME]             = Tooltip._jQueryInterface;
    $.fn[NAME].Constructor = Tooltip;
    $.fn[NAME].noConflict  = function () {
      $.fn[NAME] = JQUERY_NO_CONFLICT;
      return Tooltip._jQueryInterface
    };

    return Tooltip

  })(jQuery);

  /**
   * --------------------------------------------------------------------------
   * Bootstrap (v4.0.0-alpha.6): dropdown.js
   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
   * --------------------------------------------------------------------------
   */

  var Dropdown = (function ($) {


    /**
     * ------------------------------------------------------------------------
     * Constants
     * ------------------------------------------------------------------------
     */

    var NAME                     = 'dropdown';
    var VERSION                  = '4.0.0-alpha.6';
    var DATA_KEY                 = 'bs.dropdown';
    var EVENT_KEY                = "." + DATA_KEY;
    var DATA_API_KEY             = '.data-api';
    var JQUERY_NO_CONFLICT       = $.fn[NAME];
    var ESCAPE_KEYCODE           = 27; // KeyboardEvent.which value for Escape (Esc) key
    var ARROW_UP_KEYCODE         = 38; // KeyboardEvent.which value for up arrow key
    var ARROW_DOWN_KEYCODE       = 40; // KeyboardEvent.which value for down arrow key
    var RIGHT_MOUSE_BUTTON_WHICH = 3; // MouseEvent.which value for the right button (assuming a right-handed mouse)

    var Event = {
      HIDE             : ("hide" + EVENT_KEY),
      HIDDEN           : ("hidden" + EVENT_KEY),
      SHOW             : ("show" + EVENT_KEY),
      SHOWN            : ("shown" + EVENT_KEY),
      CLICK            : ("click" + EVENT_KEY),
      CLICK_DATA_API   : ("click" + EVENT_KEY + DATA_API_KEY),
      FOCUSIN_DATA_API : ("focusin" + EVENT_KEY + DATA_API_KEY),
      KEYDOWN_DATA_API : ("keydown" + EVENT_KEY + DATA_API_KEY)
    };

    var ClassName = {
      BACKDROP : 'dropdown-backdrop',
      DISABLED : 'disabled',
      SHOW     : 'show'
    };

    var Selector = {
      BACKDROP      : '.dropdown-backdrop',
      DATA_TOGGLE   : '[data-toggle="dropdown"]',
      FORM_CHILD    : '.dropdown form',
      ROLE_MENU     : '[role="menu"]',
      ROLE_LISTBOX  : '[role="listbox"]',
      NAVBAR_NAV    : '.navbar-nav',
      VISIBLE_ITEMS : '[role="menu"] li:not(.disabled) a, '
                    + '[role="listbox"] li:not(.disabled) a'
    };


    /**
     * ------------------------------------------------------------------------
     * Class Definition
     * ------------------------------------------------------------------------
     */

    var Dropdown = function Dropdown(element) {
      this._element = element;

      this._addEventListeners();
    };

    var staticAccessors = { VERSION: { configurable: true } };


    // getters

    staticAccessors.VERSION.get = function () {
      return VERSION
    };


    // public

    Dropdown.prototype.toggle = function toggle () {
      if (this.disabled || $(this).hasClass(ClassName.DISABLED)) {
        return false
      }

      var parent = Dropdown._getParentFromElement(this);
      var isActive = $(parent).hasClass(ClassName.SHOW);

      Dropdown._clearMenus();

      if (isActive) {
        return false
      }

      if ('ontouchstart' in document.documentElement &&
         !$(parent).closest(Selector.NAVBAR_NAV).length) {

        // if mobile we use a backdrop because click events don't delegate
        var dropdown   = document.createElement('div');
        dropdown.className = ClassName.BACKDROP;
        $(dropdown).insertBefore(this);
        $(dropdown).on('click', Dropdown._clearMenus);
      }

      var relatedTarget = {
        relatedTarget : this
      };
      var showEvent   = $.Event(Event.SHOW, relatedTarget);

      $(parent).trigger(showEvent);

      if (showEvent.isDefaultPrevented()) {
        return false
      }

      this.focus();
      this.setAttribute('aria-expanded', true);

      $(parent).toggleClass(ClassName.SHOW);
      $(parent).trigger($.Event(Event.SHOWN, relatedTarget));

      return false
    };

    Dropdown.prototype.dispose = function dispose () {
      $.removeData(this._element, DATA_KEY);
      $(this._element).off(EVENT_KEY);
      this._element = null;
    };


    // private

    Dropdown.prototype._addEventListeners = function _addEventListeners () {
      $(this._element).on(Event.CLICK, this.toggle);
    };


    // static

    Dropdown._jQueryInterface = function _jQueryInterface (config) {
      return this.each(function () {
        var data = $(this).data(DATA_KEY);

        if (!data) {
          data = new Dropdown(this);
          $(this).data(DATA_KEY, data);
        }

        if (typeof config === 'string') {
          if (data[config] === undefined) {
            throw new Error(("No method named \"" + config + "\""))
          }
          data[config].call(this);
        }
      })
    };

    Dropdown._clearMenus = function _clearMenus (event) {
      if (event && event.which === RIGHT_MOUSE_BUTTON_WHICH) {
        return
      }

      var backdrop = $(Selector.BACKDROP)[0];
      if (backdrop) {
        backdrop.parentNode.removeChild(backdrop);
      }

      var toggles = $.makeArray($(Selector.DATA_TOGGLE));

      for (var i = 0; i < toggles.length; i++) {
        var parent      = Dropdown._getParentFromElement(toggles[i]);
        var relatedTarget = {
          relatedTarget : toggles[i]
        };

        if (!$(parent).hasClass(ClassName.SHOW)) {
          continue
        }

        if (event && (event.type === 'click' &&
            /input|textarea/i.test(event.target.tagName) || event.type === 'focusin')
            && $.contains(parent, event.target)) {
          continue
        }

        var hideEvent = $.Event(Event.HIDE, relatedTarget);
        $(parent).trigger(hideEvent);
        if (hideEvent.isDefaultPrevented()) {
          continue
        }

        toggles[i].setAttribute('aria-expanded', 'false');

        $(parent)
          .removeClass(ClassName.SHOW)
          .trigger($.Event(Event.HIDDEN, relatedTarget));
      }
    };

    Dropdown._getParentFromElement = function _getParentFromElement (element) {
      var parent;
      var selector = Util.getSelectorFromElement(element);

      if (selector) {
        parent = $(selector)[0];
      }

      return parent || element.parentNode
    };

    Dropdown._dataApiKeydownHandler = function _dataApiKeydownHandler (event) {
      if (!/(38|40|27|32)/.test(event.which) ||
         /input|textarea/i.test(event.target.tagName)) {
        return
      }

      event.preventDefault();
      event.stopPropagation();

      if (this.disabled || $(this).hasClass(ClassName.DISABLED)) {
        return
      }

      var parent = Dropdown._getParentFromElement(this);
      var isActive = $(parent).hasClass(ClassName.SHOW);

      if (!isActive && event.which !== ESCAPE_KEYCODE ||
           isActive && event.which === ESCAPE_KEYCODE) {

        if (event.which === ESCAPE_KEYCODE) {
          var toggle = $(parent).find(Selector.DATA_TOGGLE)[0];
          $(toggle).trigger('focus');
        }

        $(this).trigger('click');
        return
      }

      var items = $(parent).find(Selector.VISIBLE_ITEMS).get();

      if (!items.length) {
        return
      }

      var index = items.indexOf(event.target);

      if (event.which === ARROW_UP_KEYCODE && index > 0) { // up
        index--;
      }

      if (event.which === ARROW_DOWN_KEYCODE && index < items.length - 1) { // down
        index++;
      }

      if (index < 0) {
        index = 0;
      }

      items[index].focus();
    };

    Object.defineProperties( Dropdown, staticAccessors );


    /**
     * ------------------------------------------------------------------------
     * Data Api implementation
     * ------------------------------------------------------------------------
     */

    $(document)
      .on(Event.KEYDOWN_DATA_API, Selector.DATA_TOGGLE,  Dropdown._dataApiKeydownHandler)
      .on(Event.KEYDOWN_DATA_API, Selector.ROLE_MENU,    Dropdown._dataApiKeydownHandler)
      .on(Event.KEYDOWN_DATA_API, Selector.ROLE_LISTBOX, Dropdown._dataApiKeydownHandler)
      .on(((Event.CLICK_DATA_API) + " " + (Event.FOCUSIN_DATA_API)), Dropdown._clearMenus)
      .on(Event.CLICK_DATA_API, Selector.DATA_TOGGLE, Dropdown.prototype.toggle)
      .on(Event.CLICK_DATA_API, Selector.FORM_CHILD, function (e) {
        e.stopPropagation();
      });


    /**
     * ------------------------------------------------------------------------
     * jQuery
     * ------------------------------------------------------------------------
     */

    $.fn[NAME]             = Dropdown._jQueryInterface;
    $.fn[NAME].Constructor = Dropdown;
    $.fn[NAME].noConflict  = function () {
      $.fn[NAME] = JQUERY_NO_CONFLICT;
      return Dropdown._jQueryInterface
    };

    return Dropdown

  })(jQuery);

  // allow this to be set from outside of this script, e.g. from the backend
  var api = window['hellospecial'] || {
    'opts': {
      'demo': false
    }
  };

  var api$1 = window['hellospecial'] = api;

  /**
   * Get lang code from url
   *
   * @return {String}
   */
  function getLangFromUrl () {
    var urlParts = location.href.split('/');
    var langMap = window.i18n;

    for (var i = 0; i < urlParts.length; i++) {
      var urlPart = urlParts[i];
      if (langMap[urlPart] && urlPart !== 'current') {
        return urlPart;
      }
    }
    return 'en'; // default language
  }

  /**
   * Get i18n string by its id
   *
   * @param  {String}  id
   * @param  {?String} givenLang
   * @param  {?String} fallback
   * @return {String}
   */
  function getI18n (id, givenLang, fallback) {
    var i18n = window.i18n;
    var lang = givenLang || i18n['current'] || getLangFromUrl();
    var langStrings = i18n[lang];
    return langStrings[id] || fallback || '';
  }

  api$1['getI18n'] = getI18n;

  /**
   * Anatomy of a state object
   *
   * (values preceded by a question mark are optional)
  ```
  {
    id: {string},            // All lowercase, no whitespaces. This is used in the css as well. e.g. ''eenmaal'',
    idx: {Number},           // The index of the state in the states succession. e.g. `1`
    text: {string},          // The displayed text for the state. E.g. `'Eenmaal...'`,
    duration: {?Number},     // Dynamically set by the Item class, it can have a default value though
    isLast: {?boolean},      // Set it to true if you want to indicate that this state is the last. Otherwise
                             // the last is always considered `'verkocht'`
    expirations: {Array<
        Object<
          percent: {Number}, // Number that indicates at which point in time
                             // (expressed in percentage) this expiration breakpoint is triggered
          name: {string}     // All lowercase, no whitespaces. This is used in the css as well. e.g. `'blink'`,
          >
      >}
    [{
      percent: 70,
      name: 'blink'
    }]
  }
  ```
  */

  /**
   * The `text` is displayed in the status bar.
   *
   * The `duration` is set dynamically, it's here just for reference.
   *
   * The `expirations` values available are for now:
   * 'blink, close, hurry, final'; to each of them correspond
   * some variations and animation applied through css. Each expiration must
   * declare a `percent` property that indicates the percentage at which point
   * in time trigger the expiration animation (or whatever),
   * e.g. a `percent` value of `50` would trigger at the 14th second for a
   * state that lasts 28s
   */
  var defaultStates = [
    {
      id: 'eenmaal',
      idx: 0,
      text: getI18n('eenmaal'),
      duration: null,
      expirations: [{
        percent: 70,
        name: 'blink'
      }]
    }, {
      id: 'andermaal',
      idx: 1,
      text: getI18n('andermaal'),
      duration: null,
      expirations: [{
        percent: 50,
        name: 'hurry'
      }, {
        percent: 70,
        name: 'blink'
      }, {
        percent: 90,
        name: 'final'
      }]
    }, {
      id: 'geboden',
      idx: 2,
      text: getI18n('geboden'),
      duration: null,
      expirations: [{
        percent: 50,
        name: 'hurry'
      }, {
        percent: 70,
        name: 'blink'
      }, {
        percent: 90,
        name: 'final'
      }]
    }, {
      id: 'geboden-timeless',
      idx: 3,
      text: getI18n('geboden-timeless'),
      duration: null
    }, {
      id: 'verkocht',
      idx: 4,
      text: getI18n('verkocht'),
      duration: null
    }, {
      id: 'bieden',
      idx: 5,
      text: getI18n('bieden'),
      duration: null,
      expirations: [{
        percent: 70,
        name: 'blink'
      }]
    }, {
      id: 'winnen',
      idx: 6,
      text: getI18n('winnen'),
      duration: null,
      expirations: [{
        percent: 50,
        name: 'hurry'
      }, {
        percent: 70,
        name: 'blink'
      }]
    }, {
      id: 'geladen',
      idx: 7,
      text: getI18n('geladen'),
      duration: null,
      expirations: [{
        percent: 70,
        name: 'blink'
      }]
    }, {
      id: 'gesloten',
      idx: 8,
      text: getI18n('gesloten'),
      duration: null,
      expirations: [{
        percent: 70,
        name: 'blink'
      }]
    }, {
      id: 'controleren',
      idx: 9,
      text: getI18n('controleren'),
      duration: null
    }, {
      id: 'uitverkocht',
      idx: 10,
      text: getI18n('uitverkocht'),
      duration: null
    } ];

  // export to public API
  api$1['defaultStates'] = defaultStates;

  var defaultColors = {
    'eenmaal': ['#6DBF52', '#BCD53A'],
    'andermaal': ['#EC282E', '#F58639'],
    'geboden': ['#8756A3', '#BC91C0'],
    'geboden-timeless': ['#6b4482', '#a871ad'],
    'verkocht': ['#B2B2B2', '#E6E7E6'],
    'bieden': ['#0B72BA', '#4A9DD6'],
    'winnen': ['#ad005d', 'deeppink'],
    'geladen': ['#a38d8d', '#e2bab7'],
    'gesloten': ['#9d8f8f', '#d7bfbd'],
    'controleren': ['#979090', '#cec4c1']
  };

  // export to public API
  api$1['defaultColors'] = defaultColors;

  /*!
   * Heavily inspired by
   *
   * SVG Pie Timer 0.9.1 | Anders Grimsrud, grint.no | MIT License | github.com/agrimsrud/svgPieTimer.js
   */
  var SvgPieTimer = function SvgPieTimer (props) {
    var self = this;
    this._element = props.element;
    this._size = 40;
    this._startFrom = props.startFrom ? props.startFrom * 1000: 0; // startFrom is given in seconds
    this._duration = props.duration ? props.duration * 1000 : 1000; // duration is given in seconds
    this._actualDuration = this._duration - this._startFrom;
    var n = props.loops;

    if (this.req) {
      this.stop();
    }

    // This part might be confusing:
    // If n==0, do infinite loops
    // In other cases where n is set, do n loops
    // If n is not set, do 1 loop
    // Do it this way to prevent mixing n==0 and !n
    n = (n === 0) ? 0 : n ? n : 1;

    var end = Date.now() + this._actualDuration * n;
    var totaldur = this._actualDuration * n;

    // Date.now fix by Ari Fuchs, afuchs.tumblr.com/post/23550124774/date-now-in-ie8
    Date.now = Date.now || function() { return +new Date(); };

    // Animate frame by frame
    (function frame() {
      var current = Date.now();
      var remaining = end - current;

      // Now set rotation rate
      // E.g. 50% of first loop returns 1.5
      // E.g. 75% of sixth loop returns 6.75
      // Has to return >0 for SVG to be drawn correctly
      // If you need the current loop, use Math.floor(rate)
      var rate = n + 1 - remaining / self._duration;
      // total rate for a full cycle is 0 to 2
      rate = rate;// + ((self._startFrom * 2) / self._duration);

      // As requestAnimationFrame will draw whenever capable,
      // the animation might end before it reaches 100%.
      // Let's simulate completeness on the last visual
      // frame of the loop, regardless of actual progress
      // console.log(current)
      if (remaining < 60) {
        // 1.0 might break, set to slightly lower than 1
        // Update: Set to slightly lower than n instead
        self._draw(n - 0.0001);
        // Stop animating when we reach n loops (if n is set)
        if(remaining < totaldur && n) {
          return;
        }
      }
      // To reverse, uncomment this line
      // rate = 360 - rate;

      // draw
      self._draw(rate);
      // request next frame
      self.req = requestAnimationFrame(frame);
    }());
  };

  /**
   * Draw SVG path
   *
   * x on the right side is positive, y on the bottom side is positive,
   * on the other sides they are negative
   * @param{Number} rate
   */
  SvgPieTimer.prototype._draw = function _draw (rate) {
    var angle = 360 * rate;
    angle %= 360;
    // if (angle >= 359.9) {
    // console.log(angle)
    // }

    var rad = (angle * Math.PI / 180);
    var mid = (angle > 180) ? 1 : 0;
    var x = Math.sin(rad) * this._size;
    var y = Math.cos(rad) * -this._size;
    var shape = "M 0 0 v -" + (this._size) + " A " + (this._size) + " " + (this._size) + " 1 " + mid + " 1 " + x + " " + y + " z";

    this._element.setAttribute('d', shape);
  };

  /**
   * Stop the animation cancel the request animation frame
   */
  SvgPieTimer.prototype.stop = function stop () {
    window.cancelAnimationFrame(this._req);
  };

  /**
   * Destroy the animation
   * @return {[type]} [description]
   */
  SvgPieTimer.prototype.destroy = function destroy () {
    this.stop();
  };

  // Example use of the API
  // (function (window, document, $, api) {
  //   var myDOMorJquery = $('.hsItem')[0];

  //   var myItem = new api.Item({
  //     id: 10,
  //     elem: myDOMorJquery,
  //     // state: 3,
  //     onState: function (item) {
  //       console.log('onState ' + item.state.id, item);
  //     },
  //     onEnd: function (item) {
  //       console.log('Auction ends! onEnd', item);
  //     },
  //     onBid: function (item) {
  //       console.log('Bid! on item', item);
  //     }
  //   });
  //   myItem.setState(0, 15);
  //   // myItem.destroy();
  // })(window, document, jQuery, window.hellospecial);

  // (function(window, document, $, api) {
  //   // calling the contructor or the setState method return the item instance
  //   var myItem = new hellospecial.Item({
  //     id: 12,
  //     elem: $('.hsItem')[0] // the item element in the category page
  //   }).setState('geboden', 11);
  //   // grab the state in a variable to use closure
  //   var myState = myItem.state;

  //   // fake async loading of ajax content
  //   setTimeout(function () {
  //     var myItemPopup = new hellospecial.Item({
  //       id: 12,
  //       elem: $('.hsItem')[1] // the item element in the popup
  //     });
  //     myItemPopup.resumeState(myState);
  //   }, 3000);

  //   // fake async something elese
  //   setTimeout(function () {
  //     var myAsyncItem = new hellospecial.Item({
  //       id: 12,
  //       elem: $('.hsItem')[2] // another item element
  //     });
  //     myAsyncItem.resumeState(myState);
  //   }, 5000);
  // })(window, document, jQuery, window['hellospecial']);

  /**
   * The Item class default options
   * @type {Object}
   */
  var defaultOpts = {
    /** @type {Array} Default states */
    states: defaultStates,
    /** @type {string} attribute name */
    attrState: 'data-state',
    /** @type {string} attribute name */
    attrExpiration: 'data-expiration',
    /** @type {function(Item)} Callback at the end of each state */
    onState: function () {},
    /** @type {function(Item, Number)} Callback each second of a state progression */
    // onSecond: function () {},
    /** @type {function(Item)} Callback at the end of the last state */
    onEnd: function () {},
    /** @type {function(Item)} Callback at bid click */
    onBid: function () {},
  };

  /**
   * The Item class needs to be initialized on document ready with an id and a
   * container element
   */
  var Item = function Item (opts) {
    if (typeof opts.id === undefined) {
      throw new Error('`elem` property is required when instantiate a new Item');
      return;
    }
    if (typeof opts.id === undefined) {
      throw new Error('`id` property is required when instantiate a new Item');
      return;
    }

    /** @type {Object} Item given opts */
    this.opts = $.extend({}, defaultOpts, opts);

    /** @deprecated@type {HTMLelement} Basic DOM container for the item */
    this.container = opts.elem.jquery ? opts.elem[0] : opts.elem;

    /** @type {jQuery} Basic DOM container for the item (jQuery wrap) */
    this.$container = opts.elem.jquery ? opts.elem : $(opts.elem);

    /** @type {string} Item id */
    this.id = opts.id || this.$container.attr('id');

    /** @type {Array} Contains the possible states for the item, as an array */
    this.states = this.opts.states;

    /** @type {Object} Contains the possible states for the item, as an object (indexed by id) */
    this.statesMap = this._getObjFromArray(this.opts.states, 'id');

    /** @type {function()} Holds the intervalled reference for one cycle */
    this._cycle = null;

    /** @type {Number} ID of one of the four states */
    this._initialStateId = opts.state || this.$container.attr(this.opts.attrState);

    /** @type {Array<SvgPieTimer>} One animation per svg element */
    this._animations = [];

    // set DOM related stuff
    this._bindUI();

    // if (this._initialStateId) {
    // this.setState(this._initialStateId);
    // }

    // console.log('Item->constructor()', this);

    return this;
  };

  /**
   * Init
   */
  Item.prototype._bindUI = function _bindUI () {

    /** @type {jQuery} The 'Bied' buttons */
    this.__$bid = this.$container.find('[data-bid]');

    /** @type {jQuery} */
    this.__$price = this.$container.find('[data-price]');

    /** @type {jQuery} */
    this.__$bidder = this.$container.find('[data-bidder]');

    /** @type {Array<jQuery>} */
    this.__$stateSvgs = this.$container.find('[data-state-svg]');

    /** @type {Array<jQuery>} */
    this.__$stateMsgs = this.$container.find('[data-state-msg]');

    /** @type {Array<jQuery>} */
    this.__$stops1 = this.$container.find('.stop1');

    /** @type {Array<jQuery>} */
    this.__$stops2 = this.$container.find('.stop2');

    // bind click button
    this.__$bid.on('click', this.onBid.bind(this));
  };

  /**
   * Add new state
   * @param {State} stateObject
   */
  Item.prototype.addState = function addState (stateObject) {
    var stateId = stateObject.id;
    this.statesMap[stateId] = stateObject;

    // here we could or should or push the new state
    // at the specified index in the array but I don't really
    // see the point of this at this stage. We use state ids
    // now anyway to change the item style through css
    this.states.push(stateObject);

    return stateObject;
  };

  /**
   * Set state updating UI and running the animation
   *
   * It just updates the state animation/color and text msg,
   * e.g. 'bidding, going once, going twice, sold', it also adds an attr
   * on the item container so that we can tweak the style of item
   * differently for each state.
   *
   * @param {?Number|String|State} givenState The state index `0,1,2,3`,
   *                                        or id (e.g. 'verkocht') or
   *                                        new custom object (see the
   *                                        state.defaults.js to see the
   *                                        anatomy of a state object)
   * @param {?Number}             durationThe duration in seconds
   * @param {?Number}             startFrom The resuming point in seconds
   * @return {Item}                         The item instance
   */
  Item.prototype.setState = function setState (givenState, duration, startFrom) {
      var this$1 = this;

    // set current state
    if ($.isPlainObject(givenState)) {
      // if we are resuming just assign the given state
      if ((givenState.second && givenState.second > 0) || startFrom) {
        this.state = givenState;
      } else {
        // either by using the given object
        this.state = this.addState(givenState);
      }
    }
    else if (this.states[givenState]) {
      // or by grabbing the state with its idx value
      this.state = this.states[givenState];
    }
    else if (this.statesMap[givenState]) {
      // or by grabbing the state with its idx value
      this.state = this.statesMap[givenState];
    }
    else {
      // or by grabbing the state with the initial state id value
      this.state = this.statesMap[this._initialStateId];
    }
    if (!this.state) {
      return;
    }
    // set current state second
    this.state.second = startFrom || 0;

    // set current state duration
    if (duration) {
      this.state.duration = duration;
    }
    // set cycle duration
    this._cycleDuration = this.state.duration - this.state.second;

    // display state message
    if (this.__$stateMsgs && this.__$stateMsgs.length) {
      for (var i = 0; i < this.__$stateMsgs.length; i++) {
        this$1.__$stateMsgs[i].textContent = this$1.state.text;
      }
    }

    // display state style through css
    this.$container.attr(this.opts.attrState, this.state.id);

    var palette = defaultColors[this.state.id];
    if (palette) {
      if (this.__$stops1 && this.__$stops1.length) {
        for (var j = 0; j < this.__$stops1.length; j++) {
          this$1.__$stops1[j].setAttribute('stop-color', palette[0]);
        }
      }
      if (this.__$stops2 && this.__$stops2.length) {
        for (var k = 0; k < this.__$stops2.length; k++) {
          this$1.__$stops2[k].setAttribute('stop-color', palette[1]);
        }
      }
    }

    // ... and fires the animation
    this._runAnimation();
    // start the timer...
    this._startCycle();

    // callback
    this.opts.onState(this);
    // callback on last state ('verkocht')
    if (this.state.id === 'verkocht' || this.state.isLast) {
      this.opts.onEnd(this);
    }

    return this;
  };

  /**
   * Resume state
   * @param{State} state The state object
   * @return {Item}      The item instance
   */
  Item.prototype.resumeState = function resumeState (state) {
    // create a new state object to don't interfere with other items
    // states
    var newState = $.extend({}, state);
    this.setState(newState, null, state.second);
    return this;
  };

  /**
   * Set data
   *
   * @param{Object} data Data from server that need to update the UI
   */
  Item.prototype.setData = function setData (data) {
    if (data['current_price']) {
      this.__$price.text(data['current_price']);
    }
    if (data['highest_bidder']) {
      this.__$bidder.text(data['highest_bidder']);
    }
  };

  /**
   * User has clicked bid
   */
  Item.prototype.onBid = function onBid () {
    this.opts.onBid(this.item);
    // console.log('bid! newSeconds:', newSeconds);
  };

  /**
   * Destroy item instance
   */
  Item.prototype.destroy = function destroy () {
      var this$1 = this;

    if (this._animations && this._animations.length) {
      for (var i = 0; i < this._animations.length; i++) {
        this$1._animations[i].destroy();
      }
    }
    this._clearCycle();
  };

  /**
   * Start single cycle timer
   */
  Item.prototype._clearCycle = function _clearCycle () {
    if (this._cycle) {
      window.clearInterval(this._cycle);
      this._cycle = null;
    }
  };

  /**
   * Start single cycle timer
   */
  Item.prototype._startCycle = function _startCycle () {
    this._clearCycle();
    this._cycle = window.setInterval(this._onCycleTick.bind(this), 1000);
  };

  /**
   * On second tick, it runs every second using `setInterval`, it
   * coordinates the animation states.
   */
  Item.prototype._onCycleTick = function _onCycleTick () {
    // maybe trigger expiration behaviour
    this._maybeTriggerExpiration();

    // increment second
    this.state.second++;

    // api callback
    // this.opts.onSecond(this.state.second, this.state, this);

    if (this.state.second >= this.state.duration) {
      this._clearCycle();
    }
  };

  /**
   * Set expiration attribute to trigger further animations through css
   *
   * @param {string} The expiration name to set on the attribute
   */
  Item.prototype._updateUiExpiration = function _updateUiExpiration (name) {
    this.$container.attr(this.opts.attrExpiration, name);
  };

  /**
   * Loop through the expiration breakpoints of the given state
   * and check if the current second has past the expiration breakpoint
   * (which is defined in percentage because the state duration is dynamic,
   * so we need to calculate the breakpoint in seconds).
   */
  Item.prototype._maybeTriggerExpiration = function _maybeTriggerExpiration () {
      var this$1 = this;

    var expirations = this.state.expirations;
    if (!expirations) {
      return;
    }

    // expirations array must be set in order from lower to higher percentage
    for (var i = expirations.length; i--;) {
      var expiration = expirations[i];
      var secondBreakpoint = (this$1.state.duration / 100) * expiration.percent;

      if (this$1.state.second > secondBreakpoint) {
        this$1._updateUiExpiration(expiration.name);
        return;
      }
    }
    // otherwise reset the expiration attribute
    this._updateUiExpiration('');
  };

  /**
   * It makes one full loop with the given duration or by reading the current
   * state duration
   */
  Item.prototype._runAnimation = function _runAnimation () {
      var this$1 = this;

    if (this._animations && this._animations.length) {
      for (var i = 0; i < this._animations.length; i++) {
        this$1._animations[i].destroy();
      }
    }

    // init animations
    this._animations = [];
    if (this.__$stateSvgs && this.__$stateSvgs.length) {
      for (var j = 0; j < this.__$stateSvgs.length; j++) {
        // console.log('run for ', this.__$stateSvgs[i])
        this$1._animations.push(new SvgPieTimer({
          element: this$1.__$stateSvgs[j],
          duration: this$1.state.duration, // seconds
          startFrom: this$1.state.second // seconds
        }));
      }
    }
  };

  /**
   * Get object from array
   *
   * @param{Array} array
   * @param{string} value
   * @return {Object}     The lookup object
   */
  Item.prototype._getObjFromArray = function _getObjFromArray (array, value) {
    var lookupObject = {};
    for (var i = 0, l = array.length; i < l; i++) {
      lookupObject[array[i][value]] = array[i];
    }
    return lookupObject;
  };

  // export to public API
  api$1['Item'] = Item;

  var Demo = function Demo () {
    var host = window.location.host;
    if (host === 'kuus.github.io' || host.split(':')[0] === 'localhost') {
      this.init();
    }
  };

  /**
   * Init
   */
  Demo.prototype.init = function init () {
    /** @type {Number} @@demoonly Max seconds for total loop of four state */
    this._loopMaxSeconds = 12;

    $$1(document).ready(this.$onReady.bind(this));
  };

  /**
   * On document ready
   */
  Demo.prototype.$onReady = function $onReady () {
    // this.initModals();
    this.initItems();
    this.checkout();
  };

  /**
   * Initialize items
   */
  Demo.prototype.initItems = function initItems () {
      var this$1 = this;

    $$1('.hsItem').each(function (index, element) {
      var initialState = undefined;
      if ($$1(element).hasClass('appItemDetail')) {
        initialState = 'geboden';
      }
      var item = new Item({
        id: index,
        elem: element,
        // state: 3,
        onState: this$1._setNextState.bind(this$1),
        // onEnd: this._onEnd.bind(this),
      });
      item.setState(initialState, this$1._getAverageStateDuration(item));
    });
  };

  /**
   * Get average state duration
   *
   * Durations are calculated dynamically dividing equally the max time by the
   * number of states
   *
   * @param{Item} item
   * @return {Number} Duration in seconds
   */
  Demo.prototype._getAverageStateDuration = function _getAverageStateDuration (item) {
    return this._loopMaxSeconds / item.states.length;
  };

  /**
   * Set next state
   *
   * @param{Item} item
   */
  Demo.prototype._setNextState = function _setNextState (item) {
      var this$1 = this;

    setTimeout(function () {
      // console.log('item.id', item.state.id, 'idx', item.state.idx)
      if (item.state.idx === item.states.length - 1) {
        item.setState(0, this$1._getAverageStateDuration(item));
      } else {
        item.setState(item.state.idx + 1, this$1._getAverageStateDuration(item));
      }
    }, this._getAverageStateDuration(item) * 1000);
  };

  /**
   * Initialize various modals, e.g. winning bet modal
   */
  Demo.prototype.initModals = function initModals () {
    // $('#hsWinModal').modal('show');
    $$1('#appPayreminderModal').modal('show');
  };

  /**
   * Checkout fake behaviour
   */
  Demo.prototype.checkout = function checkout () {
    // breaadcrumbs
    $$1('.hsCheckout__breadcrumb').on('click', function (e) {
      var checkout = window.hellospecial.checkout;
      var el = e.target.parentNode;
      if (el) {
        var step = $$1(el).index();
        if (step === 1) {
          if (checkout.isFormValid()) {
            checkout.goToStep(step);
          }
        } else {
          checkout.goToStep(step);
        }
        e.stopPropagation();
        return false;
      }
    });

    // to step2
    $$1('.hsCheckout__tostep2').on('click', function (e) {
      e.preventDefault();
      var checkout = window.hellospecial.checkout;
      if (checkout.isFormValid()) {
        checkout.goToStep(1);
      }
    });
  };

  var demo = new Demo();

  // export to public API
  api$1['demo'] = demo;

  var ABtest = function ABtest () {
    // bootstrap
    this.$onInit();
    $$1(document).ready(this.$onReady.bind(this));
  };

  /**
   * Init
   */
  ABtest.prototype.$onInit = function $onInit () {
    // console.log('app.js initialized');
    this.tests = {
      'Standoutregistration': {},
    };
  };

  /**
   * On document ready
   */
  ABtest.prototype.$onReady = function $onReady () {
    // this.ABtest01();
  };

  /**
   * Run test
   * @param{String} id
   */
  ABtest.prototype.run = function run (id) {
    if (this.tests[id]) {
      this['test' + id]();
    } else {
      console.error(("ABtest with id " + id + " does not exists"));
    }
  };

  /**
   * Test 01: ABtest--standoutregistration
   */
  ABtest.prototype.testStandoutregistration = function testStandoutregistration () {
    var $homepageCard = $$1('#homepageRegisterCard');
    var $body = $$1('body');
    if (!$homepageCard.length) {
      return;
    }
    $body.addClass('ABtest--standoutregistration');
    // on click anywhere remove the class
    document.body.addEventListener('click', function () {
      $body.removeClass('ABtest--standoutregistration');
    }, true);
  };

  // export to public API
  api$1['ABtest'] = new ABtest();

  var CookieAnnouncement = function CookieAnnouncement () {
    // bootstrap
    this.$onInit();
    $$1(document).ready(this.$onReady.bind(this));
  };

  /**
   * Init
   */
  CookieAnnouncement.prototype.$onInit = function $onInit () {
    // console.log('app.js initialized');
  };

  /**
   * On document ready
   */
  CookieAnnouncement.prototype.$onReady = function $onReady () {
      var this$1 = this;

    var $container = $$1('#js-cookieannouncement');
    var $dismissTriggers = $$1('.js-cookieannouncement-dismiss');

    if (!$container.length) {
      return;
    }

    var cookieValue = this._readCookie('cookieannouncement');

    if (cookieValue !== 'shown') {
      setTimeout(function () {
        $container.addClass('in');
      }, 500);

      $dismissTriggers.on('click', function () {
        $container.removeClass('in');
        this$1._createCookie('cookieannouncement', 'shown', 365);
      });
    }
  };

  /**
   * Create cookie
   * @see https://stackoverflow.com/a/24103596/1938970
   *
   * @param{String} name
   * @param{Mixed}value
   * @param{Number} days
   */
  CookieAnnouncement.prototype._createCookie = function _createCookie (name, value, days) {
    var expires = "";
    if (days) {
        var date = new Date();
        date.setTime(date.getTime() + (days*24*60*60*1000));
        expires = "; expires=" + date.toUTCString();
    }
    document.cookie = name + "=" + value + expires + "; path=/";
  };

  /**
   * Read cookie
   * @see https://stackoverflow.com/a/24103596/1938970
   *
   * @param{String} name
   * @return {?String}
   */
  CookieAnnouncement.prototype._readCookie = function _readCookie (name) {
    var nameEQ = name + "=";
    var ca = document.cookie.split(';');
    for(var i=0;i < ca.length;i++) {
        var c = ca[i];
        while (c.charAt(0)==' ') { c = c.substring(1,c.length); }
        if (c.indexOf(nameEQ) == 0) { return c.substring(nameEQ.length,c.length); }
    }
    return null;
  };

  CookieAnnouncement.prototype._eraseCookie = function _eraseCookie (name) {
    this._createCookie(name,"",-1);
  };

  new CookieAnnouncement();

  var Nask = function Nask () {
    this.$onInit();

    // bootstrap
    $$1(document).ready(this.$onReady.bind(this));
  };

  /**
   * Init
   */
  Nask.prototype.$onInit = function $onInit () {
    // try to immediately hide the container to don't cause a flash of "unstyled" content
    try {
      var containers = document.getElementsByClassName('nask');
      for (var i = 0; i < containers.length; i++) {
        containers[i].style.opacity = 0;
      }
    } catch(e) {}

    this._browser = this._getBrowser();
    this._mobileOS = this._getMobileOS();
    this._permission = this._getPermission();

    // console.log(`Nask->$onInit: mobile os is ${this._mobileOS} browser detected is ${this._browser}, permission is ${this._permission}`);
  };

  /**
   * On document ready
   */
  Nask.prototype.$onReady = function $onReady () {
    var $container = $$1('.nask');

    if (!$container.length) {
      return;
    }

    this.__$container = $container;

    var view = this._getViewName();
    this.setView(view);

    if (view === 'request' || view === 'request-mobile') {
      this.ask();
    }

    this.setEnv(this._getEnvName());

    this.__$container.addClass('nask--ready').css('opacity', 1);

    // @@disabled for now, because it wouldn't work anyway...
    // @see https://stackoverflow.com/a/31868708/1938970
    // $container.find('.nask__askbutton').click(() => {
    // this.ask()
    // });
  };

  /**
   * Get browser
   *
   * based on @link https://stackoverflow.com/a/9851769/1938970
   *
   * @return {String}
   */
  Nask.prototype._getBrowser = function _getBrowser () {
    // Opera 8.0+
    if ((!!window.opr && !!opr.addons) || !!window.opera || navigator.userAgent.indexOf(' OPR/') >= 0) {
      return 'opera';
    }

    // Firefox 1.0+
    if (typeof InstallTrigger !== 'undefined') {
      return 'firefox';
    }

    // Safari 3.0+ "[object HTMLElementConstructor]"
    if (/constructor/i.test(window.HTMLElement) || (function (p) { return p.toString() === "[object SafariRemoteNotification]"; })(!window['safari'] || (typeof safari !== 'undefined' && safari.pushNotification))) {
      return 'safari';
    }

    // Internet Explorer 6-11
    if (/*@cc_on!@*/false || !!document.documentMode) {
      return 'ie';
    }

    // Edge 20+
    if (!!window.StyleMedia) {
      return 'edge';
    }

    // Chrome 1+
    if (!!window.chrome && !!window.chrome.webstore) {
      return 'chrome';
    }
  };

  /**
   * Determine the mobile operating system.
   * This function returns one of 'ios', 'Android', 'Windows Phone', or false.
   *
   * @link https://stackoverflow.com/a/21742107/1938970
   *
   * @returns {String|boolean} 'windows|android|ios|false'
   */
  Nask.prototype._getMobileOS = function _getMobileOS () {
    var userAgent = navigator.userAgent || navigator.vendor || window.opera;

    // Windows Phone must come first because its UA also contains "Android"
    if (/windows phone/i.test(userAgent)) {
      return 'windows';
    }

    if (/android/i.test(userAgent)) {
      return 'android';
    }

    // iOS detection from: http://stackoverflow.com/a/9039885/177710
    if (/iPad|iPhone|iPod/.test(userAgent) && !window.MSStream) {
      return 'ios';
    }

    return false;
  };

  /**
   * Get notifications permissions
   *
   * @return {String} 'denied|granted|default|unsupported'
   */
  Nask.prototype._getPermission = function _getPermission () {
    if (window.Notification && window.Notification.permission) {
      return window.Notification.permission;
    }
    return 'unsupported';
  };

  /**
   * Get view name
   *
   * Views:
   * 'granted': Notification are granted already, we don't ask anything
   * 'request': On Android notifications are denied by the user, we ask to enable them
   * 'request-mobile': On Android notifications are denied by the user, we ask to enable them
   * 'allowing': On desktop notifications are denied by the user, the allow box is opened
   * 'allowing-mobile': On Android notifications are denied by the user, the allow box is opened
   * 'thanks': On desktop notification permission has just been granted by the user
   * 'thanks-mobile': On Android notification permission has just been granted by the user
   * 'other': Desktop browser other than Chrome. Firefox, Opera, no notifications system
   * 'other-mobile': Mobile browser other than Android, no notifications system
   *
   * @param{?String} viewFamily
   * @return {String}
   */
   Nask.prototype._getViewName = function _getViewName (viewFamily) {
    if (viewFamily === 'allowing') {
      return this._mobileOS ? 'allowing-mobile' : 'allowing';
    }
    else if (viewFamily === 'thanks') {
      return this._mobileOS ? 'thanks-mobile' : 'thanks';
    }

    // if (['chrome', 'firefox', 'opera'].indexOf(this._browser) === -1) {
    // }

    if (this._permission === 'unsupported') {
      return this._mobileOS ? 'other-mobile' : 'other';
    }
    else if (this._permission === 'default') {
      return this._mobileOS ? 'request-mobile' : 'request';
    }
    else if (this._permission === 'denied') {
      return this._mobileOS ? 'request-mobile' : 'request';
    }
    else if (this._permission === 'granted') {
      return 'granted';
    }

    return 'none';
  };

  /**
   * Get env name
   *
   * @return {String}
   */
  Nask.prototype._getEnvName = function _getEnvName () {
    return this._mobileOS === 'android' ? 'android' : this._browser;
  };

  /**
   * Set view on the UI
   *
   * @public
   * @param {String} view
   */
  Nask.prototype.setView = function setView (view) {
    this.__$container.attr('data-nask-view-is', view);
    console.log(("Nask: set view name to \"" + view + "\""));
    return this;
  };

  /**
   * Set environment on the UI
   *
   * @public
   * @param {String} env
   */
  Nask.prototype.setEnv = function setEnv (env) {
    this.__$container.attr('data-nask-env-is', env);
    console.log(("Nask: set env to \"" + env + "\""));
    return this;
  };

  /**
   * Ask for permission
   *
   * @param {?Function} callback
   * @public
   *
   * @return {this}
   */
  Nask.prototype.ask = function ask (callback) {
      var this$1 = this;

    if (this._permission === 'unsupported') {
      console.log("Nask: Notification are not supported");
      return;
    }
    console.log("Nask: asking for permission");

    this.setView(this._getViewName('allowing'));

    Notification.requestPermission(function (permission) {
      if (callback) {
        callback(permission);
      }

      if (permission === 'granted') {
        // const notification = new Notification('Thanks');
        this$1.setView(this$1._getViewName('thanks'));
      }
      else if (permission === 'denied') {
        this$1.setView(this$1._getViewName('request'));
      }
    });

    return this;
  };

  // export to public API
  api$1['nask'] = new Nask();

  var Faq = function Faq () {

    // bootstrap
    this.$onInit();
    $(document).ready(this.$onReady.bind(this));
  };

  /**
   * Init
   */
  Faq.prototype.$onInit = function $onInit () {
  };

  /**
   * On document ready
   */
  Faq.prototype.$onReady = function $onReady () {
    if (!$('#hsFaq').length) {
      return;
    }

    var $expandables = $('.expandable__body');
    var $noResults = $('.hsFaq__noresults');
    var highlightOpts = { className: 'hsFaq__mark' };

    $expandables.collapse({
      toggle: false
    });

    $('#hsFaq_filterList').liveFilter('#hsFaq_filterInput', '.expandable', {
      after: function (contains, containsNot) {
        var query = this.value;

        if (!contains.length) {
          $expandables.parent().parent().prev().hide();
          $noResults.show();
        } else {
          $noResults.hide();
          $expandables.parent().parent().prev().show();
        }

        if (!query) {
          // contains.collapse('hide').unhighlight(highlightOpts);
          // containsNot.collapse('hide').unhighlight(highlightOpts);
          $expandables.collapse('hide').unhighlight(highlightOpts);
        } else {
          try {
            contains.find('.expandable__body').collapse('show')
              .unhighlight(highlightOpts)
              .highlight(query, highlightOpts);

            containsNot.find('.expandable__body').collapse('hide')
              .unhighlight(highlightOpts);
          } catch (e) {}
        }
      }
    });

    $('.hsFaq__search').on('submit', this._onSearchSubmit);
    $('#hsFaq_filterSubmit').on('click', this._onSearchSubmit);
  };

  /**
   * On search submit
   *
   * @param{Object} e Event
   */
  Faq.prototype._onSearchSubmit = function _onSearchSubmit (e) {
    e.preventDefault();
    if ($(window).width() < 600) {
      // $('html, body').animate({
      // scrollTop: $('.hsFaq__mark').first().offset().top - 70
      // }, 300);
      $('html, body').scrollTop($('.hsFaq__mark').first().offset().top - 70);
    }
  };

  new Faq();

  // import 'slick-carousel/slick/slick.js';
  // import 'sticky-kit/dist/sticky-kit';
  // import 'sticky-js/dist/sticky.min';

  var ItemDetail = function ItemDetail () {
    this.$onInit();
    $$1(document).ready(this.$onReady.bind(this));
  };

  /**
   * Init
   */
  ItemDetail.prototype.$onInit = function $onInit () {
  };

  /**
   * On document ready
   */
  ItemDetail.prototype.$onReady = function $onReady () {
    this.__$thumbs = $$1('#appItemDetail__thumbs');
    this.__$slider = $$1('#appItemDetail__slider');
    this.__$sticky = $$1('#appItemDetail__main-sticky');

    if (this.__$slider.length && this.__$thumbs.length) {
      this._initSliderThumbs();
      this._initSlider();
      $$1(window).on('resize', this._onResizeSliders.bind(this));
    }

    if (this.__$sticky.length) {
      // this.__$sticky.stick_in_parent();
      this._initSticky();
      $$1(window).on('resize', this._onResizeSticky.bind(this));
    }
  };

  /**
   * On resize slides behaviours
   */
  ItemDetail.prototype._onResizeSliders = function _onResizeSliders () {
    // no slider if there is only one image
    if (this.__$slider.find('img').length === 1) {
      this.__$slider.slick('unslick');
      this.__$thumbs.slick('unslick');
    } else {

    }
  };

  /**
   * On resize sticky behavious
   */
  ItemDetail.prototype._onResizeSticky = function _onResizeSticky () {
    var screenLgVersion = $$1(window).width() >= 992; // @@ref $grid-breakpoints: lg,

    if (this._stickyInitialised && screenLgVersion) {
      this.__$sticky.unstick();
      this._stickyInitialised = false;
    } else {
      this._initSticky();
    }
  };

  /**
   * Init sticky
   */
  ItemDetail.prototype._initSticky = function _initSticky () {
    if (this._stickyInitialised) {
      return;
    }
    this.__$sticky.sticky({
      responsiveWidth: true,
      className: 'is-sticky'
    });
    // this._sticky = new Sticky('#appItemDetail__main-sticky');
    this._stickyInitialised = true;
  };

  /**
   * Init slider thumbnails
   */
  ItemDetail.prototype._initSliderThumbs = function _initSliderThumbs () {
    if (!this.__$thumbs.length || this._sliderThumbsInitialised) {
      return;
    }

    this.__$thumbs.slick({
      vertical: true,
      // verticalSwiping: true,
      // centerMode: screenLgVersion,
      slidesToShow: 8,
      slidesToScroll: 1,
      asNavFor: this.__$slider,
      focusOnSelect: true,
      arrows: false,
      // infinite: false,
      responsive: [{
        breakpoint: 992, // @@ref $grid-breakpoints: lg
        settings: {
          vertical: false,
          slidesToShow: 5,
        }
      }]
    });

    this._sliderThumbsInitialised = true;

    // remove active class from all thumbnail slides
    this.__$thumbs.find('.slick-slide').removeClass('slick-active');

    // set active class to first thumbnail slides
    this.__$thumbs.find('.slick-slide').eq(0).addClass('slick-active');
  };

  /**
   * Init slider
   */
  ItemDetail.prototype._initSlider = function _initSlider () {
      var this$1 = this;

    if (!this.__$slider.length || !this.__$thumbs.length || this._sliderInitialised) {
      return;
    }

    this.__$slider.slick({
      slidesToShow: 1,
      slidesToScroll: 1,
      dots: false,
      arrows: true,
      asNavFor: this.__$thumbs
    });

    this._sliderInitialised = true;

    // on before slide change match active thumbnail to current slide
    this.__$slider.on('beforeChange', function (event, slick, currentSlide, nextSlide) {
      this$1.__$thumbs.find('.slick-slide').removeClass('slick-active');
      this$1.__$thumbs.find('.slick-slide').eq(nextSlide).addClass('slick-active');
    });
  };

  /**
   * Reinit UI
   */
  ItemDetail.prototype.reinitUI = function reinitUI () {
    this._initSlider();
    this._initSliderThumbs();
    this._initSticky();
  };

  // export to public API
  api$1['itemDetail'] = new ItemDetail();

  var p = navigator.platform;

  var browsers = {
    'safari': Object.prototype.toString.call(window.HTMLElement).indexOf('Constructor') > 0,
    // 'chrome': !!window.chrome && !opera,
    'ie': /*@cc_on!@*/false || !!document.documentMode,
    // 'mac': p.toUpperCase().indexOf('MAC') >= 0,
    // 'macLike': p.match(/(Mac|iPhone|iPod|iPad)/i) ? true : false,
    'ios': p.match(/(iPhone|iPod|iPad)/i) ? true : false,
    // 'windows': p.toUpperCase().indexOf('WIN')!==-1,
    // 'linux': p.toUpperCase().indexOf('LINUX')!==-1,
    // 'android': /Android/i.test(a),
    // 'blackBerry': /BlackBerry/i.test(a),
    // 'ios': /iPhone|iPad|iPod/i.test(a),
  };

  $$1(document).ready(function () {
    var $html = $$1('html');
    for (name in browsers) {
      var isIt = !!browsers[name];
      // browsers[browser];
      $html.toggleClass(name, isIt);
    }
  });

  /**
    * vee-validate v2.0.1
    * (c) 2018 Abdelrahman Awad
    * @license MIT
    */
  // 

  /**
   * Gets the data attribute. the name must be kebab-case.
   */
  var getDataAttribute = function (el, name) { return el.getAttribute(("data-vv-" + name)); };

  /**
   * Checks if the value is either null or undefined.
   */
  var isNullOrUndefined = function (value) {
    return value === null || value === undefined;
  };

  /**
   * Sets the data attribute.
   */
  var setDataAttribute = function (el, name, value) { return el.setAttribute(("data-vv-" + name), value); };

  /**
   * Creates a proxy object if available in the environment.
   */
  var createProxy = function (target, handler) {
    /* istanbul ignore next */
    if (typeof Proxy === 'undefined') {
      return target;
    }

    return new Proxy(target, handler);
  };

  /**
   * Creates the default flags object.
   */
  var createFlags = function () { return ({
    untouched: true,
    touched: false,
    dirty: false,
    pristine: true,
    valid: null,
    invalid: null,
    validated: false,
    pending: false,
    required: false
  }); };

  /**
   * Shallow object comparison.
   */
  var isEqual = function (lhs, rhs) {
    if (lhs instanceof RegExp && rhs instanceof RegExp) {
      return isEqual(lhs.source, rhs.source) && isEqual(lhs.flags, rhs.flags);
    }

    if (Array.isArray(lhs) && Array.isArray(rhs)) {
      if (lhs.length !== rhs.length) { return false; }

      for (var i = 0; i < lhs.length; i++) {
        if (!isEqual(lhs[i], rhs[i])) {
          return false;
        }
      }

      return true;
    }

    // if both are objects, compare each key recursively.
    if (isObject(lhs) && isObject(rhs)) {
      return Object.keys(lhs).every(function (key) {
        return isEqual(lhs[key], rhs[key]);
      }) && Object.keys(rhs).every(function (key) {
        return isEqual(lhs[key], rhs[key]);
      });
    }

    return lhs === rhs;
  };

  /**
   * Determines the input field scope.
   */
  var getScope = function (el) {
    var scope = getDataAttribute(el, 'scope');
    if (isNullOrUndefined(scope) && el.form) {
      scope = getDataAttribute(el.form, 'scope');
    }

    return !isNullOrUndefined(scope) ? scope : null;
  };

  /**
   * Gets the value in an object safely.
   */
  var getPath = function (path, target, def) {
    if ( def === void 0 ) { def = undefined; }

    if (!path || !target) { return def; }

    var value = target;
    path.split('.').every(function (prop) {
      if (! Object.prototype.hasOwnProperty.call(value, prop) && value[prop] === undefined) {
        value = def;

        return false;
      }

      value = value[prop];

      return true;
    });

    return value;
  };

  /**
   * Checks if path exists within an object.
   */
  var hasPath = function (path, target) {
    var obj = target;
    return path.split('.').every(function (prop) {
      if (! Object.prototype.hasOwnProperty.call(obj, prop)) {
        return false;
      }

      obj = obj[prop];

      return true;
    });
  };

  /**
   * Parses a rule string expression.
   */
  var parseRule = function (rule) {
    var params = [];
    var name = rule.split(':')[0];

    if (~rule.indexOf(':')) {
      params = rule.split(':').slice(1).join(':').split(',');
    }

    return { name: name, params: params };
  };

  /**
   * Debounces a function.
   */
  var debounce = function (fn, wait, immediate) {
    if ( wait === void 0 ) { wait = 0; }
    if ( immediate === void 0 ) { immediate = false; }

    if (wait === 0) {
      return fn;
    }

    var timeout;

    return function () {
      var arguments$1 = arguments;

      var args = [], len = arguments.length;
      while ( len-- ) { args[ len ] = arguments$1[ len ]; }

      var later = function () {
        timeout = null;
        if (!immediate) { fn.apply(void 0, args); }
      };
      /* istanbul ignore next */
      var callNow = immediate && !timeout;
      clearTimeout(timeout);
      timeout = setTimeout(later, wait);
      /* istanbul ignore next */
      if (callNow) { fn.apply(void 0, args); }
    };
  };

  /**
   * Normalizes the given rules expression.
   */
  var normalizeRules = function (rules) {
    // if falsy value return an empty object.
    if (!rules) {
      return {};
    }

    if (isObject(rules)) {
      // $FlowFixMe
      return Object.keys(rules).reduce(function (prev, curr) {
        var params = [];
        // $FlowFixMe
        if (rules[curr] === true) {
          params = [];
        } else if (Array.isArray(rules[curr])) {
          params = rules[curr];
        } else {
          params = [rules[curr]];
        }

        // $FlowFixMe
        if (rules[curr] !== false) {
          prev[curr] = params;
        }

        return prev;
      }, {});
    }

    if (typeof rules !== 'string') {
      warn('rules must be either a string or an object.');
      return {};
    }

    return rules.split('|').reduce(function (prev, rule) {
      var parsedRule = parseRule(rule);
      if (!parsedRule.name) {
        return prev;
      }

      prev[parsedRule.name] = parsedRule.params;
      return prev;
    }, {});
  };

  /**
   * Emits a warning to the console.
   */
  var warn = function (message) {
    console.warn(("[vee-validate] " + message)); // eslint-disable-line
  };

  /**
   * Creates a branded error object.
   */
  var createError = function (message) { return new Error(("[vee-validate] " + message)); };

  /**
   * Checks if the value is an object.
   */
  var isObject = function (obj) { return obj !== null && obj && typeof obj === 'object' && ! Array.isArray(obj); };

  /**
   * Checks if a function is callable.
   */
  var isCallable = function (func) { return typeof func === 'function'; };

  /**
   * Check if element has the css class on it.
   */
  var hasClass = function (el, className) {
    if (el.classList) {
      return el.classList.contains(className);
    }

    return !!el.className.match(new RegExp(("(\\s|^)" + className + "(\\s|$)")));
  };

  /**
   * Adds the provided css className to the element.
   */
  var addClass = function (el, className) {
    if (el.classList) {
      el.classList.add(className);
      return;
    }

    if (!hasClass(el, className)) {
      el.className += " " + className;
    }
  };

  /**
   * Remove the provided css className from the element.
   */
  var removeClass = function (el, className) {
    if (el.classList) {
      el.classList.remove(className);
      return;
    }

    if (hasClass(el, className)) {
      var reg = new RegExp(("(\\s|^)" + className + "(\\s|$)"));
      el.className = el.className.replace(reg, ' ');
    }
  };

  /**
   * Adds or removes a class name on the input depending on the status flag.
   */
  var toggleClass = function (el, className, status) {
    if (!el || !className) { return; }

    if (status) {
      return addClass(el, className);
    }

    removeClass(el, className);
  };

  /**
   * Converts an array-like object to array, provides a simple polyfill for Array.from
   */
  var toArray = function (arrayLike) {
    if (isCallable(Array.from)) {
      return Array.from(arrayLike);
    }

    var array = [];
    var length = arrayLike.length;
    for (var i = 0; i < length; i++) {
      array.push(arrayLike[i]);
    }

    return array;
  };

  /**
   * Assign polyfill from the mdn.
   */
  var assign = function (target) {
    var arguments$1 = arguments;

    var others = [], len = arguments.length - 1;
    while ( len-- > 0 ) { others[ len ] = arguments$1[ len + 1 ]; }

    /* istanbul ignore else */
    if (isCallable(Object.assign)) {
      return Object.assign.apply(Object, [ target ].concat( others ));
    }

    /* istanbul ignore next */
    if (target == null) {
      throw new TypeError('Cannot convert undefined or null to object');
    }

    /* istanbul ignore next */
    var to = Object(target);
    /* istanbul ignore next */
    others.forEach(function (arg) {
      // Skip over if undefined or null
      if (arg != null) {
        Object.keys(arg).forEach(function (key) {
          to[key] = arg[key];
        });
      }
    });
    /* istanbul ignore next */
    return to;
  };

  var id = 0;
  var idTemplate = '{id}';

  /**
   * Generates a unique id.
   */
  var uniqId = function () {
    // handle too many uses of uniqId, although unlikely.
    if (id >= 9999) {
      id = 0;
      // shift the template.
      idTemplate = idTemplate.replace('{id}', '_{id}');
    }

    id++;
    var newId = idTemplate.replace('{id}', String(id));

    return newId;
  };

  /**
   * finds the first element that satisfies the predicate callback, polyfills array.find
   */
  var find = function (arrayLike, predicate) {
    var array = Array.isArray(arrayLike) ? arrayLike : toArray(arrayLike);
    for (var i = 0; i < array.length; i++) {
      if (predicate(array[i])) {
        return array[i];
      }
    }

    return undefined;
  };

  /**
   * Returns a suitable event name for the input element.
   */
  var getInputEventName = function (el) {
    if (el && (el.tagName === 'SELECT' || ~['radio', 'checkbox', 'file'].indexOf(el.type))) {
      return 'change';
    }

    return 'input';
  };

  var isBuiltInComponent = function (vnode) {
    if (!vnode) {
      return false;
    }

    var tag = vnode.componentOptions.tag;

    return /keep-alive|transition|transition-group/.test(tag);
  };

  var makeEventsArray = function (events) {
    return (typeof events === 'string' && events.length) ? events.split('|') : [];
  };

  var makeDelayObject = function (events, delay, delayConfig) {
    if (typeof delay === 'number') {
      return events.reduce(function (prev, e) {
        prev[e] = delay;
        return prev;
      }, {});
    }

    return events.reduce(function (prev, e) {
      if (typeof delay === 'object' && e in delay) {
        prev[e] = delay[e];
        return prev;
      }

      if (typeof delayConfig === 'number') {
        prev[e] = delayConfig;
        return prev;
      }

      prev[e] = (delayConfig && delayConfig[e]) || 0;

      return prev;
    }, {});
  };

  var deepParseInt = function (input) {
    if (typeof input === 'number') { return input; }

    if (typeof input === 'string') { return parseInt(input); }

    var map = {};
    for (var element in input) {
      map[element] = parseInt(input[element]);
    }

    return map;
  };

  var merge = function (target, source) {
    if (! (isObject(target) && isObject(source))) {
      return target;
    }

    Object.keys(source).forEach(function (key) {
      if (isObject(source[key])) {
        if (! target[key]) {
          assign(target, ( obj = {}, obj[key] = {}, obj ));
          var obj;
        }

        merge(target[key], source[key]);
        return;
      }

      assign(target, ( obj$1 = {}, obj$1[key] = source[key], obj$1 ));
      var obj$1;
    });

    return target;
  };

  // 

  var ErrorBag = function ErrorBag () {
    this.items = [];
  };

  /**
   * Adds an error to the internal array.
   */
  ErrorBag.prototype.add = function add (error) {
    // handle old signature.
    if (arguments.length > 1) {
      error = {
        field: arguments[0],
        msg: arguments[1],
        rule: arguments[2],
        scope: !isNullOrUndefined(arguments[3]) ? arguments[3] : null,
        regenerate: null
      };
    }

    error.scope = !isNullOrUndefined(error.scope) ? error.scope : null;
    this.items.push(error);
  };

  /**
   * Regenrates error messages if they have a generator function.
   */
  ErrorBag.prototype.regenerate = function regenerate () {
    this.items.forEach(function (i) {
      i.msg = isCallable(i.regenerate) ? i.regenerate() : i.msg;
    });
  };

  /**
   * Updates a field error with the new field scope.
   */
  ErrorBag.prototype.update = function update (id, error) {
    var item = find(this.items, function (i) { return i.id === id; });
    if (!item) {
      return;
    }

    var idx = this.items.indexOf(item);
    this.items.splice(idx, 1);
    item.scope = error.scope;
    this.items.push(item);
  };

  /**
   * Gets all error messages from the internal array.
   */
  ErrorBag.prototype.all = function all (scope) {
    if (isNullOrUndefined(scope)) {
      return this.items.map(function (e) { return e.msg; });
    }

    return this.items.filter(function (e) { return e.scope === scope; }).map(function (e) { return e.msg; });
  };

  /**
   * Checks if there are any errors in the internal array.
   */
  ErrorBag.prototype.any = function any (scope) {
    if (isNullOrUndefined(scope)) {
      return !!this.items.length;
    }

    return !!this.items.filter(function (e) { return e.scope === scope; }).length;
  };

  /**
   * Removes all items from the internal array.
   */
  ErrorBag.prototype.clear = function clear (scope) {
      var this$1 = this;

    if (isNullOrUndefined(scope)) {
      scope = null;
    }

    for (var i = 0; i < this.items.length; ++i) {
      if (this$1.items[i].scope === scope) {
        this$1.items.splice(i, 1);
        --i;
      }
    }
  };

  /**
   * Collects errors into groups or for a specific field.
   */
  ErrorBag.prototype.collect = function collect (field, scope, map) {
      if ( map === void 0 ) { map = true; }

    if (!field) {
      var collection = {};
      this.items.forEach(function (e) {
        if (! collection[e.field]) {
          collection[e.field] = [];
        }

        collection[e.field].push(map ? e.msg : e);
      });

      return collection;
    }

    field = !isNullOrUndefined(field) ? String(field) : field;
    if (isNullOrUndefined(scope)) {
      return this.items.filter(function (e) { return e.field === field; }).map(function (e) { return (map ? e.msg : e); });
    }

    return this.items.filter(function (e) { return e.field === field && e.scope === scope; })
      .map(function (e) { return (map ? e.msg : e); });
  };
  /**
   * Gets the internal array length.
   */
  ErrorBag.prototype.count = function count () {
    return this.items.length;
  };

  /**
   * Finds and fetches the first error message for the specified field id.
   */
  ErrorBag.prototype.firstById = function firstById (id) {
    var error = find(this.items, function (i) { return i.id === id; });

    return error ? error.msg : null;
  };

  /**
   * Gets the first error message for a specific field.
   */
  ErrorBag.prototype.first = function first (field, scope) {
      var this$1 = this;
      if ( scope === void 0 ) { scope = null; }

    field = !isNullOrUndefined(field) ? String(field) : field;
    var selector = this._selector(field);
    var scoped = this._scope(field);

    if (scoped) {
      var result = this.first(scoped.name, scoped.scope);
      // if such result exist, return it. otherwise it could be a field.
      // with dot in its name.
      if (result) {
        return result;
      }
    }

    if (selector) {
      return this.firstByRule(selector.name, selector.rule, scope);
    }

    for (var i = 0; i < this.items.length; ++i) {
      if (this$1.items[i].field === field && (this$1.items[i].scope === scope)) {
        return this$1.items[i].msg;
      }
    }

    return null;
  };

  /**
   * Returns the first error rule for the specified field
   */
  ErrorBag.prototype.firstRule = function firstRule (field, scope) {
    var errors = this.collect(field, scope, false);

    return (errors.length && errors[0].rule) || null;
  };

  /**
   * Checks if the internal array has at least one error for the specified field.
   */
  ErrorBag.prototype.has = function has (field, scope) {
      if ( scope === void 0 ) { scope = null; }

    return !!this.first(field, scope);
  };

  /**
   * Gets the first error message for a specific field and a rule.
   */
  ErrorBag.prototype.firstByRule = function firstByRule (name, rule, scope) {
      if ( scope === void 0 ) { scope = null; }

    var error = this.collect(name, scope, false).filter(function (e) { return e.rule === rule; })[0];

    return (error && error.msg) || null;
  };

  /**
   * Gets the first error message for a specific field that not match the rule.
   */
  ErrorBag.prototype.firstNot = function firstNot (name, rule, scope) {
      if ( rule === void 0 ) { rule = 'required'; }
      if ( scope === void 0 ) { scope = null; }

    var error = this.collect(name, scope, false).filter(function (e) { return e.rule !== rule; })[0];

    return (error && error.msg) || null;
  };

  /**
   * Removes errors by matching against the id.
   */
  ErrorBag.prototype.removeById = function removeById (id) {
      var this$1 = this;

    for (var i = 0; i < this.items.length; ++i) {
      if (this$1.items[i].id === id) {
        this$1.items.splice(i, 1);
        --i;
      }
    }
  };

  /**
   * Removes all error messages associated with a specific field.
   */
  ErrorBag.prototype.remove = function remove (field, scope, id) {
      var this$1 = this;

    field = !isNullOrUndefined(field) ? String(field) : field;
    var removeCondition = function (e) {
      if (e.id && id) {
        return e.id === id;
      }

      if (!isNullOrUndefined(scope)) {
        return e.field === field && e.scope === scope;
      }

      return e.field === field && e.scope === null;
    };

    for (var i = 0; i < this.items.length; ++i) {
      if (removeCondition(this$1.items[i])) {
        this$1.items.splice(i, 1);
        --i;
      }
    }
  };

  /**
   * Get the field attributes if there's a rule selector.
   */
  ErrorBag.prototype._selector = function _selector (field) {
    if (field.indexOf(':') > -1) {
      var ref = field.split(':');
        var name = ref[0];
        var rule = ref[1];

      return { name: name, rule: rule };
    }

    return null;
  };

  /**
   * Get the field scope if specified using dot notation.
   */
  ErrorBag.prototype._scope = function _scope (field) {
    if (field.indexOf('.') > -1) {
      var ref = field.split('.');
        var scope = ref[0];
        var name = ref.slice(1);

      return { name: name.join('.'), scope: scope };
    }

    return null;
  };

  // 

  var LOCALE = 'en';

  var Dictionary = function Dictionary (dictionary) {
    if ( dictionary === void 0 ) { dictionary = {}; }

    this.container = {};
    this.merge(dictionary);
  };

  var prototypeAccessors$2 = { locale: {} };

  prototypeAccessors$2.locale.get = function () {
    return LOCALE;
  };

  prototypeAccessors$2.locale.set = function (value) {
    LOCALE = value || 'en';
  };

  Dictionary.prototype.hasLocale = function hasLocale (locale) {
    return !!this.container[locale];
  };

  Dictionary.prototype.setDateFormat = function setDateFormat (locale, format) {
    if (!this.container[locale]) {
      this.container[locale] = {};
    }

    this.container[locale].dateFormat = format;
  };

  Dictionary.prototype.getDateFormat = function getDateFormat (locale) {
    if (!this.container[locale] || !this.container[locale].dateFormat) {
      return null;
    }

    return this.container[locale].dateFormat;
  };

  Dictionary.prototype.getMessage = function getMessage (locale, key, data) {
    var message = null;
    if (!this.hasMessage(locale, key)) {
      message = this._getDefaultMessage(locale);
    } else {
      message = this.container[locale].messages[key];
    }

    return isCallable(message) ? message.apply(void 0, data) : message;
  };

  /**
   * Gets a specific message for field. falls back to the rule message.
   */
  Dictionary.prototype.getFieldMessage = function getFieldMessage (locale, field, key, data) {
    if (!this.hasLocale(locale)) {
      return this.getMessage(locale, key, data);
    }

    var dict = this.container[locale].custom && this.container[locale].custom[field];
    if (!dict || !dict[key]) {
      return this.getMessage(locale, key, data);
    }

    var message = dict[key];
    return isCallable(message) ? message.apply(void 0, data) : message;
  };

  Dictionary.prototype._getDefaultMessage = function _getDefaultMessage (locale) {
    if (this.hasMessage(locale, '_default')) {
      return this.container[locale].messages._default;
    }

    return this.container.en.messages._default;
  };

  Dictionary.prototype.getAttribute = function getAttribute (locale, key, fallback) {
      if ( fallback === void 0 ) { fallback = ''; }

    if (!this.hasAttribute(locale, key)) {
      return fallback;
    }

    return this.container[locale].attributes[key];
  };

  Dictionary.prototype.hasMessage = function hasMessage (locale, key) {
    return !! (
      this.hasLocale(locale) &&
            this.container[locale].messages &&
            this.container[locale].messages[key]
    );
  };

  Dictionary.prototype.hasAttribute = function hasAttribute (locale, key) {
    return !! (
      this.hasLocale(locale) &&
            this.container[locale].attributes &&
            this.container[locale].attributes[key]
    );
  };

  Dictionary.prototype.merge = function merge$1 (dictionary) {
    merge(this.container, dictionary);
  };

  Dictionary.prototype.setMessage = function setMessage (locale, key, message) {
    if (! this.hasLocale(locale)) {
      this.container[locale] = {
        messages: {},
        attributes: {}
      };
    }

    this.container[locale].messages[key] = message;
  };

  Dictionary.prototype.setAttribute = function setAttribute (locale, key, attribute) {
    if (! this.hasLocale(locale)) {
      this.container[locale] = {
        messages: {},
        attributes: {}
      };
    }

    this.container[locale].attributes[key] = attribute;
  };

  Object.defineProperties( Dictionary.prototype, prototypeAccessors$2 );

  // 

  var normalizeValue = function (value) {
    if (isObject(value)) {
      return Object.keys(value).reduce(function (prev, key) {
        prev[key] = normalizeValue(value[key]);

        return prev;
      }, {});
    }

    if (isCallable(value)) {
      return value('{0}', ['{1}', '{2}', '{3}']);
    }

    return value;
  };

  var normalizeFormat = function (locale) {
    // normalize messages
    var messages = normalizeValue(locale.messages);
    var custom = normalizeValue(locale.custom);

    return {
      messages: messages,
      custom: custom,
      attributes: locale.attributes,
      dateFormat: locale.dateFormat
    };
  };

  var I18nDictionary = function I18nDictionary (i18n, rootKey) {
    this.i18n = i18n;
    this.rootKey = rootKey;
  };

  var prototypeAccessors$3 = { locale: {} };

  prototypeAccessors$3.locale.get = function () {
    return this.i18n.locale;
  };

  prototypeAccessors$3.locale.set = function (value) {
    warn('Cannot set locale from the validator when using vue-i18n, use i18n.locale setter instead');
  };

  I18nDictionary.prototype.getDateFormat = function getDateFormat (locale) {
    return this.i18n.getDateTimeFormat(locale || this.locale);
  };

  I18nDictionary.prototype.setDateFormat = function setDateFormat (locale, value) {
    this.i18n.setDateTimeFormat(locale || this.locale, value);
  };

  I18nDictionary.prototype.getMessage = function getMessage (locale, key, data) {
    var path = (this.rootKey) + ".messages." + key;
    if (!this.i18n.te(path)) {
      return this.i18n.t(((this.rootKey) + ".messages._default"), locale, data);
    }

    return this.i18n.t(path, locale, data);
  };

  I18nDictionary.prototype.getAttribute = function getAttribute (locale, key, fallback) {
      if ( fallback === void 0 ) { fallback = ''; }

    var path = (this.rootKey) + ".attributes." + key;
    if (!this.i18n.te(path)) {
      return fallback;
    }

    return this.i18n.t(path, locale);
  };

  I18nDictionary.prototype.getFieldMessage = function getFieldMessage (locale, field, key, data) {
    var path = (this.rootKey) + ".custom." + field + "." + key;
    if (this.i18n.te(path)) {
      return this.i18n.t(path);
    }

    return this.getMessage(locale, key, data);
  };

  I18nDictionary.prototype.merge = function merge$1 (dictionary) {
      var this$1 = this;

    Object.keys(dictionary).forEach(function (localeKey) {
      // i18n doesn't deep merge
      // first clone the existing locale (avoid mutations to locale)
      var clone = merge({}, getPath((localeKey + "." + (this$1.rootKey)), this$1.i18n.messages, {}));
      // Merge cloned locale with new one
      var locale = merge(clone, normalizeFormat(dictionary[localeKey]));
      this$1.i18n.mergeLocaleMessage(localeKey, ( obj = {}, obj[this$1.rootKey] = locale, obj ));
        var obj;
      if (locale.dateFormat) {
        this$1.i18n.setDateTimeFormat(localeKey, locale.dateFormat);
      }
    });
  };

  I18nDictionary.prototype.setMessage = function setMessage (locale, key, value) {
    this.merge(( obj$1 = {}, obj$1[locale] = {
        messages: ( obj = {}, obj[key] = value, obj )
      }, obj$1 ));
      var obj;
      var obj$1;
  };

  I18nDictionary.prototype.setAttribute = function setAttribute (locale, key, value) {
    this.merge(( obj$1 = {}, obj$1[locale] = {
        attributes: ( obj = {}, obj[key] = value, obj )
      }, obj$1 ));
      var obj;
      var obj$1;
  };

  Object.defineProperties( I18nDictionary.prototype, prototypeAccessors$3 );

  // 

  var defaultConfig = {
    locale: 'en',
    delay: 0,
    errorBagName: 'errors',
    dictionary: null,
    strict: true,
    fieldsBagName: 'fields',
    classes: false,
    classNames: null,
    events: 'input|blur',
    inject: true,
    fastExit: true,
    aria: true,
    validity: false,
    i18n: null,
    i18nRootKey: 'validation'
  };

  var currentConfig = assign({}, defaultConfig);
  var dependencies = {
    dictionary: new Dictionary({
      en: {
        messages: {},
        attributes: {},
        custom: {}
      }
    })
  };

  var Config = function Config () {};

  var staticAccessors$1 = { default: {},current: {} };

  staticAccessors$1.default.get = function () {
    return defaultConfig;
  };

  staticAccessors$1.current.get = function () {
    return currentConfig;
  };

  Config.dependency = function dependency (key) {
    return dependencies[key];
  };

  /**
   * Merges the config with a new one.
   */
  Config.merge = function merge$$1 (config) {
    currentConfig = assign({}, currentConfig, config);
    if (currentConfig.i18n) {
      Config.register('dictionary', new I18nDictionary(currentConfig.i18n, currentConfig.i18nRootKey));
    }
  };

  /**
   * Registers a dependency.
   */
  Config.register = function register (key, value) {
    dependencies[key] = value;
  };

  /**
   * Resolves the working config from a Vue instance.
   */
  Config.resolve = function resolve (context) {
    var selfConfig = getPath('$options.$_veeValidate', context, {});

    return assign({}, Config.current, selfConfig);
  };

  Object.defineProperties( Config, staticAccessors$1 );

  /**
   * Generates the options required to construct a field.
   */
  var Generator = function Generator () {};

  Generator.generate = function generate (el, binding, vnode) {
    var model = Generator.resolveModel(binding, vnode);
    var options = Config.resolve(vnode.context);

    return {
      name: Generator.resolveName(el, vnode),
      el: el,
      listen: !binding.modifiers.disable,
      scope: Generator.resolveScope(el, binding, vnode),
      vm: Generator.makeVM(vnode.context),
      expression: binding.value,
      component: vnode.child,
      classes: options.classes,
      classNames: options.classNames,
      getter: Generator.resolveGetter(el, vnode, model),
      events: Generator.resolveEvents(el, vnode) || options.events,
      model: model,
      delay: Generator.resolveDelay(el, vnode, options),
      rules: Generator.resolveRules(el, binding),
      initial: !!binding.modifiers.initial,
      validity: options.validity,
      aria: options.aria,
      initialValue: Generator.resolveInitialValue(vnode)
    };
  };

  Generator.getCtorConfig = function getCtorConfig (vnode) {
    if (!vnode.child) { return null; }

    var config = getPath('child.$options.$_veeValidate', vnode);

    return config;
  };

  /**
   * Resolves the rules defined on an element.
   */
  Generator.resolveRules = function resolveRules (el, binding) {
    if (!binding.value && (!binding || !binding.expression)) {
      return getDataAttribute(el, 'rules');
    }

    if (~['string', 'object'].indexOf(typeof binding.value.rules)) {
      return binding.value.rules;
    }

    return binding.value;
  };

  /**
   * @param {*} vnode
   */
  Generator.resolveInitialValue = function resolveInitialValue (vnode) {
    var model = vnode.data.model || find(vnode.data.directives, function (d) { return d.name === 'model'; });

    return model && model.value;
  };

  /**
   * Creates a non-circular partial VM instance from a Vue instance.
   * @param {*} vm
   */
  Generator.makeVM = function makeVM (vm) {
    return {
      get $el () {
        return vm.$el;
      },
      get $refs () {
        return vm.$refs;
      },
      $watch: vm.$watch ? vm.$watch.bind(vm) : function () {},
      $validator: vm.$validator ? {
        errors: vm.$validator.errors,
        validate: vm.$validator.validate.bind(vm.$validator),
        update: vm.$validator.update.bind(vm.$validator)
      } : null
    };
  };

  /**
   * Resolves the delay value.
   * @param {*} el
   * @param {*} vnode
   * @param {Object} options
   */
  Generator.resolveDelay = function resolveDelay (el, vnode, options) {
    var delay = getDataAttribute(el, 'delay');
    var globalDelay = (options && 'delay' in options) ? options.delay : 0;

    if (!delay && vnode.child && vnode.child.$attrs) {
      delay = vnode.child.$attrs['data-vv-delay'];
    }

    if (!isObject(globalDelay)) {
      return deepParseInt(delay || globalDelay);
    }

    globalDelay.input = delay || 0;

    return deepParseInt(globalDelay);
  };

  /**
   * Resolves the events to validate in response to.
   * @param {*} el
   * @param {*} vnode
   */
  Generator.resolveEvents = function resolveEvents (el, vnode) {
    var events = getDataAttribute(el, 'validate-on');

    if (!events && vnode.child && vnode.child.$attrs) {
      events = vnode.child.$attrs['data-vv-validate-on'];
    }

    if (!events && vnode.child) {
      var config = Generator.getCtorConfig(vnode);
      events = config && config.events;
    }

    return events;
  };

  /**
   * Resolves the scope for the field.
   * @param {*} el
   * @param {*} binding
   */
  Generator.resolveScope = function resolveScope (el, binding, vnode) {
      if ( vnode === void 0 ) { vnode = {}; }

    var scope = null;
    if (vnode.child && isNullOrUndefined(scope)) {
      scope = vnode.child.$attrs && vnode.child.$attrs['data-vv-scope'];
    }

    return !isNullOrUndefined(scope) ? scope : getScope(el);
  };

  /**
   * Checks if the node directives contains a v-model or a specified arg.
   * Args take priority over models.
   *
   * @return {Object}
   */
  Generator.resolveModel = function resolveModel (binding, vnode) {
    if (binding.arg) {
      return binding.arg;
    }

    var model = vnode.data.model || find(vnode.data.directives, function (d) { return d.name === 'model'; });
    if (!model) {
      return null;
    }

    var watchable = /^[a-z_]+[0-9]*(\w*\.[a-z_]\w*)*$/i.test(model.expression) && hasPath(model.expression, vnode.context);
    if (!watchable) {
      return null;
    }

    return model.expression;
  };

  /**
     * Resolves the field name to trigger validations.
     * @return {String} The field name.
     */
  Generator.resolveName = function resolveName (el, vnode) {
    var name = getDataAttribute(el, 'name');

    if (!name && !vnode.child) {
      return el.name;
    }

    if (!name && vnode.child && vnode.child.$attrs) {
      name = vnode.child.$attrs['data-vv-name'] || vnode.child.$attrs['name'];
    }

    if (!name && vnode.child) {
      var config = Generator.getCtorConfig(vnode);
      if (config && isCallable(config.name)) {
        var boundGetter = config.name.bind(vnode.child);

        return boundGetter();
      }

      return vnode.child.name;
    }

    return name;
  };

  /**
   * Returns a value getter input type.
   */
  Generator.resolveGetter = function resolveGetter (el, vnode, model) {
    if (model) {
      return function () {
        return getPath(model, vnode.context);
      };
    }

    if (vnode.child) {
      var path = getDataAttribute(el, 'value-path') || (vnode.child.$attrs && vnode.child.$attrs['data-vv-value-path']);
      if (path) {
        return function () {
          return getPath(path, vnode.child);
        };
      }

      var config = Generator.getCtorConfig(vnode);
      if (config && isCallable(config.value)) {
        var boundGetter = config.value.bind(vnode.child);

        return function () {
          return boundGetter();
        };
      }

      return function () {
        return vnode.child.value;
      };
    }

    switch (el.type) {
    case 'checkbox': return function () {
      var els = document.querySelectorAll(("input[name=\"" + (el.name) + "\"]"));

      els = toArray(els).filter(function (el) { return el.checked; });
      if (!els.length) { return undefined; }

      return els.map(function (checkbox) { return checkbox.value; });
    };
    case 'radio': return function () {
      var els = document.querySelectorAll(("input[name=\"" + (el.name) + "\"]"));
      var elm = find(els, function (el) { return el.checked; });

      return elm && elm.value;
    };
    case 'file': return function (context) {
      return toArray(el.files);
    };
    case 'select-multiple': return function () {
      return toArray(el.options).filter(function (opt) { return opt.selected; }).map(function (opt) { return opt.value; });
    };
    default: return function () {
      return el && el.value;
    };
    }
  };

  // 

  var DEFAULT_OPTIONS = {
    targetOf: null,
    initial: false,
    scope: null,
    listen: true,
    name: null,
    rules: {},
    vm: null,
    classes: false,
    validity: true,
    aria: true,
    events: 'input|blur',
    delay: 0,
    classNames: {
      touched: 'touched', // the control has been blurred
      untouched: 'untouched', // the control hasn't been blurred
      valid: 'valid', // model is valid
      invalid: 'invalid', // model is invalid
      pristine: 'pristine', // control has not been interacted with
      dirty: 'dirty' // control has been interacted with
    }
  };

  var Field = function Field (el, options) {
    if ( options === void 0 ) { options = {}; }

    this.id = uniqId();
    this.el = el;
    this.updated = false;
    this.dependencies = [];
    this.watchers = [];
    this.events = [];
    this.delay = 0;
    this.rules = {};
    this._cacheId(options);
    this.classNames = assign({}, DEFAULT_OPTIONS.classNames);
    options = assign({}, DEFAULT_OPTIONS, options);
    this._delay = !isNullOrUndefined(options.delay) ? options.delay : 0; // cache initial delay
    this.validity = options.validity;
    this.aria = options.aria;
    this.flags = createFlags();
    this.vm = options.vm;
    this.component = options.component;
    this.ctorConfig = this.component ? getPath('$options.$_veeValidate', this.component) : undefined;
    this.update(options);
    this.updated = false;
  };

  var prototypeAccessors$1 = { validator: {},isRequired: {},isDisabled: {},alias: {},value: {},rejectsFalse: {} };

  prototypeAccessors$1.validator.get = function () {
    if (!this.vm || !this.vm.$validator) {
      warn('No validator instance detected.');
      return { validate: function () {} };
    }

    return this.vm.$validator;
  };

  prototypeAccessors$1.isRequired.get = function () {
    return !!this.rules.required;
  };

  prototypeAccessors$1.isDisabled.get = function () {
    return !!(this.component && this.component.disabled) || !!(this.el && this.el.disabled);
  };

  /**
   * Gets the display name (user-friendly name).
   */
  prototypeAccessors$1.alias.get = function () {
    if (this._alias) {
      return this._alias;
    }

    var alias = null;
    if (this.el) {
      alias = getDataAttribute(this.el, 'as');
    }

    if (!alias && this.component) {
      return this.component.$attrs && this.component.$attrs['data-vv-as'];
    }

    return alias;
  };

  /**
   * Gets the input value.
   */

  prototypeAccessors$1.value.get = function () {
    if (!isCallable(this.getter)) {
      return undefined;
    }

    return this.getter();
  };

  /**
   * If the field rejects false as a valid value for the required rule.
   */

  prototypeAccessors$1.rejectsFalse.get = function () {
    if (this.component && this.ctorConfig) {
      return !!this.ctorConfig.rejectsFalse;
    }

    if (!this.el) {
      return false;
    }

    return this.el.type === 'checkbox';
  };

  /**
   * Determines if the instance matches the options provided.
   */
  Field.prototype.matches = function matches (options) {
    if (options.id) {
      return this.id === options.id;
    }

    if (options.name === undefined && options.scope === undefined) {
      return true;
    }

    if (options.scope === undefined) {
      return this.name === options.name;
    }

    if (options.name === undefined) {
      return this.scope === options.scope;
    }

    return options.name === this.name && options.scope === this.scope;
  };

  /**
   * Caches the field id.
   */
  Field.prototype._cacheId = function _cacheId (options) {
    if (this.el && !options.targetOf) {
      setDataAttribute(this.el, 'id', this.id); // cache field id if it is independent and has a root element.
    }
  };

  /**
   * Updates the field with changed data.
   */
  Field.prototype.update = function update (options) {
    this.targetOf = options.targetOf || null;
    this.initial = options.initial || this.initial || false;

    // update errors scope if the field scope was changed.
    if (!isNullOrUndefined(options.scope) && options.scope !== this.scope && isCallable(this.validator.update)) {
      this.validator.update(this.id, { scope: options.scope });
    }
    this.scope = !isNullOrUndefined(options.scope) ? options.scope
      : !isNullOrUndefined(this.scope) ? this.scope : null;
    this.name = (!isNullOrUndefined(options.name) ? String(options.name) : options.name) || this.name || null;
    this.rules = options.rules !== undefined ? normalizeRules(options.rules) : this.rules;
    this.model = options.model || this.model;
    this.listen = options.listen !== undefined ? options.listen : this.listen;
    this.classes = (options.classes || this.classes || false) && !this.component;
    this.classNames = isObject(options.classNames) ? merge(this.classNames, options.classNames) : this.classNames;
    this.getter = isCallable(options.getter) ? options.getter : this.getter;
    this._alias = options.alias || this._alias;
    this.events = (options.events) ? makeEventsArray(options.events) : this.events;
    this.delay = (options.delay) ? makeDelayObject(this.events, options.delay, this._delay) : makeDelayObject(this.events, this.delay, this._delay);
    this.updateDependencies();
    this.addActionListeners();

    // update required flag flags
    if (options.rules !== undefined) {
      this.flags.required = this.isRequired;
    }

    // validate if it was validated before and field was updated and there was a rules mutation.
    if (this.flags.validated && options.rules !== undefined && this.updated) {
      this.validator.validate(("#" + (this.id)));
    }

    this.updated = true;
    this.addValueListeners();

    // no need to continue.
    if (!this.el) {
      return;
    }

    this.updateClasses();
    this.updateAriaAttrs();
  };

  /**
   * Resets field flags and errors.
   */
  Field.prototype.reset = function reset () {
      var this$1 = this;

    var defaults = createFlags();
    Object.keys(this.flags).filter(function (flag) { return flag !== 'required'; }).forEach(function (flag) {
      this$1.flags[flag] = defaults[flag];
    });

    this.addActionListeners();
    this.updateClasses();
    this.updateAriaAttrs();
    this.updateCustomValidity();
  };

  /**
   * Sets the flags and their negated counterparts, and updates the classes and re-adds action listeners.
   */
  Field.prototype.setFlags = function setFlags (flags) {
      var this$1 = this;

    var negated = {
      pristine: 'dirty',
      dirty: 'pristine',
      valid: 'invalid',
      invalid: 'valid',
      touched: 'untouched',
      untouched: 'touched'
    };

    Object.keys(flags).forEach(function (flag) {
      this$1.flags[flag] = flags[flag];
      // if it has a negation and was not specified, set it as well.
      if (negated[flag] && flags[negated[flag]] === undefined) {
        this$1.flags[negated[flag]] = !flags[flag];
      }
    });

    if (
      flags.untouched !== undefined ||
      flags.touched !== undefined ||
      flags.dirty !== undefined ||
      flags.pristine !== undefined
    ) {
      this.addActionListeners();
    }
    this.updateClasses();
    this.updateAriaAttrs();
    this.updateCustomValidity();
  };

  /**
   * Determines if the field requires references to target fields.
  */
  Field.prototype.updateDependencies = function updateDependencies () {
      var this$1 = this;

    // reset dependencies.
    this.dependencies.forEach(function (d) { return d.field.destroy(); });
    this.dependencies = [];

    // we get the selectors for each field.
    var fields = Object.keys(this.rules).reduce(function (prev, r) {
      if (Validator.isTargetRule(r)) {
        var selector = this$1.rules[r][0];
        if (r === 'confirmed' && !selector) {
          selector = (this$1.name) + "_confirmation";
        }

        prev.push({ selector: selector, name: r });
      }

      return prev;
    }, []);

    if (!fields.length || !this.vm || !this.vm.$el) { return; }

    // must be contained within the same component, so we use the vm root element constrain our dom search.
    fields.forEach(function (ref) {
        var selector = ref.selector;
        var name = ref.name;

      var el = null;
      // vue ref selector.
      if (selector[0] === '$') {
        el = this$1.vm.$refs[selector.slice(1)];
      } else {
        try {
          // try query selector
          el = this$1.vm.$el.querySelector(selector);
        } catch (err) {
          el = null;
        }
      }

      if (!el) {
        try {
          el = this$1.vm.$el.querySelector(("input[name=\"" + selector + "\"]"));
        } catch (err) {
          el = null;
        }
      }

      if (!el) {
        return;
      }

      var options = {
        vm: this$1.vm,
        classes: this$1.classes,
        classNames: this$1.classNames,
        delay: this$1.delay,
        scope: this$1.scope,
        events: this$1.events.join('|'),
        initial: this$1.initial,
        targetOf: this$1.id
      };

      // probably a component.
      if (isCallable(el.$watch)) {
        options.component = el;
        options.el = el.$el;
        options.getter = Generator.resolveGetter(el.$el, { child: el });
      } else {
        options.el = el;
        options.getter = Generator.resolveGetter(el, {});
      }

      this$1.dependencies.push({ name: name, field: new Field(options.el, options) });
    });
  };

  /**
   * Removes listeners.
   */
  Field.prototype.unwatch = function unwatch (tag) {
      if ( tag === void 0 ) { tag = null; }

    if (!tag) {
      this.watchers.forEach(function (w) { return w.unwatch(); });
      this.watchers = [];
      return;
    }

    this.watchers.filter(function (w) { return tag.test(w.tag); }).forEach(function (w) { return w.unwatch(); });
    this.watchers = this.watchers.filter(function (w) { return !tag.test(w.tag); });
  };

  /**
   * Updates the element classes depending on each field flag status.
   */
  Field.prototype.updateClasses = function updateClasses () {
    if (!this.classes || this.isDisabled) { return; }

    toggleClass(this.el, this.classNames.dirty, this.flags.dirty);
    toggleClass(this.el, this.classNames.pristine, this.flags.pristine);
    toggleClass(this.el, this.classNames.touched, this.flags.touched);
    toggleClass(this.el, this.classNames.untouched, this.flags.untouched);
    // make sure we don't set any classes if the state is undetermined.
    if (!isNullOrUndefined(this.flags.valid) && this.flags.validated) {
      toggleClass(this.el, this.classNames.valid, this.flags.valid);
    }

    if (!isNullOrUndefined(this.flags.invalid) && this.flags.validated) {
      toggleClass(this.el, this.classNames.invalid, this.flags.invalid);
    }
  };

  /**
   * Adds the listeners required for automatic classes and some flags.
   */
  Field.prototype.addActionListeners = function addActionListeners () {
      var this$1 = this;

    // remove previous listeners.
    this.unwatch(/class/);

    var onBlur = function () {
      this$1.flags.touched = true;
      this$1.flags.untouched = false;
      if (this$1.classes) {
        toggleClass(this$1.el, this$1.classNames.touched, true);
        toggleClass(this$1.el, this$1.classNames.untouched, false);
      }

      // only needed once.
      this$1.unwatch(/^class_blur$/);
    };

    var inputEvent = getInputEventName(this.el);
    var onInput = function () {
      this$1.flags.dirty = true;
      this$1.flags.pristine = false;
      if (this$1.classes) {
        toggleClass(this$1.el, this$1.classNames.pristine, false);
        toggleClass(this$1.el, this$1.classNames.dirty, true);
      }

      // only needed once.
      this$1.unwatch(/^class_input$/);
    };

    if (this.component && isCallable(this.component.$once)) {
      this.component.$once('input', onInput);
      this.component.$once('blur', onBlur);
      this.watchers.push({
        tag: 'class_input',
        unwatch: function () {
          this$1.component.$off('input', onInput);
        }
      });
      this.watchers.push({
        tag: 'class_blur',
        unwatch: function () {
          this$1.component.$off('blur', onBlur);
        }
      });
      return;
    }

    if (!this.el) { return; }

    this.el.addEventListener(inputEvent, onInput);
    // Checkboxes and radio buttons on Mac don't emit blur naturally, so we listen on click instead.
    var blurEvent = ['radio', 'checkbox'].indexOf(this.el.type) === -1 ? 'blur' : 'click';
    this.el.addEventListener(blurEvent, onBlur);
    this.watchers.push({
      tag: 'class_input',
      unwatch: function () {
        this$1.el.removeEventListener(inputEvent, onInput);
      }
    });

    this.watchers.push({
      tag: 'class_blur',
      unwatch: function () {
        this$1.el.removeEventListener(blurEvent, onBlur);
      }
    });
  };

  /**
   * Adds the listeners required for validation.
   */
  Field.prototype.addValueListeners = function addValueListeners () {
      var this$1 = this;

    this.unwatch(/^input_.+/);
    if (!this.listen) { return; }

    var fn = this.targetOf ? function () {
      this$1.validator.validate(("#" + (this$1.targetOf)));
    } : function () {
        var arguments$1 = arguments;

        var args = [], len = arguments.length;
        while ( len-- ) { args[ len ] = arguments$1[ len ]; }

      // if its a DOM event, resolve the value, otherwise use the first parameter as the value.
      if (args.length === 0 || (isCallable(Event) && args[0] instanceof Event) || (args[0] && args[0].srcElement)) {
        args[0] = this$1.value;
      }
      this$1.validator.validate(("#" + (this$1.id)), args[0]);
    };

    var inputEvent = getInputEventName(this.el);
    // replace input event with suitable one.
    var events = this.events.map(function (e) {
      return e === 'input' ? inputEvent : e;
    });

    // if there is a watchable model and an on input validation is requested.
    if (this.model && events.indexOf(inputEvent) !== -1) {
      var debouncedFn = debounce(fn, this.delay[inputEvent]);
      var unwatch = this.vm.$watch(this.model, function () {
          var arguments$1 = arguments;

          var args = [], len = arguments.length;
          while ( len-- ) { args[ len ] = arguments$1[ len ]; }

        this$1.flags.pending = true;
        debouncedFn.apply(void 0, args);
      });
      this.watchers.push({
        tag: 'input_model',
        unwatch: unwatch
      });
      // filter out input event as it is already handled by the watcher API.
      events = events.filter(function (e) { return e !== inputEvent; });
    }

    // Add events.
    events.forEach(function (e) {
      var debouncedFn = debounce(fn, this$1.delay[e]);
      var validate = function () {
          var arguments$1 = arguments;

          var args = [], len = arguments.length;
          while ( len-- ) { args[ len ] = arguments$1[ len ]; }

        this$1.flags.pending = true;
        debouncedFn.apply(void 0, args);
      };

      this$1._addComponentEventListener(e, validate);
      this$1._addHTMLEventListener(e, validate);
    });
  };

  Field.prototype._addComponentEventListener = function _addComponentEventListener (evt, validate) {
      var this$1 = this;

    if (!this.component) { return; }

    this.component.$on(evt, validate);
    this.watchers.push({
      tag: 'input_vue',
      unwatch: function () {
        this$1.component.$off(evt, validate);
      }
    });
  };

  Field.prototype._addHTMLEventListener = function _addHTMLEventListener (evt, validate) {
      var this$1 = this;

    if (!this.el) { return; }

    if (~['radio', 'checkbox'].indexOf(this.el.type)) {
      var els = document.querySelectorAll(("input[name=\"" + (this.el.name) + "\"]"));
      toArray(els).forEach(function (el) {
        el.addEventListener(evt, validate);
        this$1.watchers.push({
          tag: 'input_native',
          unwatch: function () {
            el.removeEventListener(evt, validate);
          }
        });
      });

      return;
    }

    this.el.addEventListener(evt, validate);
    this.watchers.push({
      tag: 'input_native',
      unwatch: function () {
        this$1.el.removeEventListener(evt, validate);
      }
    });
  };

  /**
   * Updates aria attributes on the element.
   */
  Field.prototype.updateAriaAttrs = function updateAriaAttrs () {
    if (!this.aria || !this.el || !isCallable(this.el.setAttribute)) { return; }

    this.el.setAttribute('aria-required', this.isRequired ? 'true' : 'false');
    this.el.setAttribute('aria-invalid', this.flags.invalid ? 'true' : 'false');
  };

  /**
   * Updates the custom validity for the field.
   */
  Field.prototype.updateCustomValidity = function updateCustomValidity () {
    if (!this.validity || !this.el || !isCallable(this.el.setCustomValidity)) { return; }

    this.el.setCustomValidity(this.flags.valid ? '' : (this.validator.errors.firstById(this.id) || ''));
  };

  /**
   * Removes all listeners.
   */
  Field.prototype.destroy = function destroy () {
    this.unwatch();
    this.dependencies.forEach(function (d) { return d.field.destroy(); });
    this.dependencies = [];
  };

  Object.defineProperties( Field.prototype, prototypeAccessors$1 );

  // 

  var FieldBag = function FieldBag () {
    this.items = [];
  };

  var prototypeAccessors$4 = { length: {} };

  /**
   * Gets the current items length.
   */

  prototypeAccessors$4.length.get = function () {
    return this.items.length;
  };

  /**
   * Finds the first field that matches the provided matcher object.
   */
  FieldBag.prototype.find = function find$1 (matcher) {
    return find(this.items, function (item) { return item.matches(matcher); });
  };

  /**
   * Filters the items down to the matched fields.
   */
  FieldBag.prototype.filter = function filter (matcher) {
    // multiple matchers to be tried.
    if (Array.isArray(matcher)) {
      return this.items.filter(function (item) { return matcher.some(function (m) { return item.matches(m); }); });
    }

    return this.items.filter(function (item) { return item.matches(matcher); });
  };

  /**
   * Maps the field items using the mapping function.
   */
  FieldBag.prototype.map = function map (mapper) {
    return this.items.map(mapper);
  };

  /**
   * Finds and removes the first field that matches the provided matcher object, returns the removed item.
   */
  FieldBag.prototype.remove = function remove (matcher) {
    var item = null;
    if (matcher instanceof Field) {
      item = matcher;
    } else {
      item = this.find(matcher);
    }

    if (!item) { return null; }

    var index = this.items.indexOf(item);
    this.items.splice(index, 1);

    return item;
  };

  /**
   * Adds a field item to the list.
   */
  FieldBag.prototype.push = function push (item) {
    if (! (item instanceof Field)) {
      throw createError('FieldBag only accepts instances of Field that has an id defined.');
    }

    if (!item.id) {
      throw createError('Field id must be defined.');
    }

    if (this.find({ id: item.id })) {
      throw createError(("Field with id " + (item.id) + " is already added."));
    }

    this.items.push(item);
  };

  Object.defineProperties( FieldBag.prototype, prototypeAccessors$4 );

  // 

  var RULES = {};
  var STRICT_MODE = true;
  var TARGET_RULES = ['confirmed', 'after', 'before'];
  var ERRORS = []; // HOLD errors references to trigger regeneration.

  var Validator = function Validator (validations, options) {
    var this$1 = this;
    if ( options === void 0 ) { options = { vm: null, fastExit: true }; }

    this.strict = STRICT_MODE;
    this.errors = new ErrorBag();
    ERRORS.push(this.errors);
    this.fields = new FieldBag();
    this.flags = {};
    this._createFields(validations);
    this.paused = false;
    this.fastExit = options.fastExit || false;
    this.ownerId = options.vm && options.vm._uid;
    // create it statically since we don't need constant access to the vm.
    this.reset = options.vm && isCallable(options.vm.$nextTick) ? function (matcher) {
      return new Promise(function (resolve) {
        options.vm.$nextTick(function () {
          options.vm.$nextTick(function () {
            resolve(this$1._reset(matcher));
          });
        });
      });
    } : this._reset;
  };

  var prototypeAccessors = { dictionary: {},locale: {},rules: {} };
  var staticAccessors = { dictionary: {},locale: {},rules: {} };

  /**
   * Getter for the dictionary.
   */
  prototypeAccessors.dictionary.get = function () {
    return Config.dependency('dictionary');
  };

  /**
   * Static Getter for the dictionary.
   */
  staticAccessors.dictionary.get = function () {
    return Config.dependency('dictionary');
  };

  /**
   * Getter for the current locale.
   */
  prototypeAccessors.locale.get = function () {
    return this.dictionary.locale;
  };

  /**
   * Setter for the validator locale.
   */
  prototypeAccessors.locale.set = function (value) {
    Validator.locale = value;
  };

  /**
  * Static getter for the validator locale.
  */
  staticAccessors.locale.get = function () {
    return Validator.dictionary.locale;
  };

  /**
   * Static setter for the validator locale.
   */
  staticAccessors.locale.set = function (value) {
    var hasChanged = value !== Validator.dictionary.locale;
    Validator.dictionary.locale = value;
    if (hasChanged) {
      Validator.regenerate();
    }
  };

  /**
   * Getter for the rules object.
   */
  prototypeAccessors.rules.get = function () {
    return RULES;
  };

  /**
   * Static Getter for the rules object.
   */
  staticAccessors.rules.get = function () {
    return RULES;
  };

  /**
   * Static constructor.
   */
  Validator.create = function create (validations, options) {
    return new Validator(validations, options);
  };

  /**
   * Adds a custom validator to the list of validation rules.
   */
  Validator.extend = function extend (name, validator, options) {
      if ( options === void 0 ) { options = {}; }

    Validator._guardExtend(name, validator);
    Validator._merge(name, validator);
    if (options && options.hasTarget) {
      TARGET_RULES.push(name);
    }
  };

  /**
   * Regenerates error messages across all validators.
   */
  Validator.regenerate = function regenerate () {
    ERRORS.forEach(function (errorBag) { return errorBag.regenerate(); });
  };

  /**
   * Removes a rule from the list of validators.
   */
  Validator.remove = function remove (name) {
    delete RULES[name];
    var idx = TARGET_RULES.indexOf(name);
    if (idx === -1) { return; }

    TARGET_RULES.splice(idx, 1);
  };

  /**
   * Checks if the given rule name is a rule that targets other fields.
   */
  Validator.isTargetRule = function isTargetRule (name) {
    return TARGET_RULES.indexOf(name) !== -1;
  };

  /**
   * Sets the operating mode for all newly created validators.
   * strictMode = true: Values without a rule are invalid and cause failure.
   * strictMode = false: Values without a rule are valid and are skipped.
   */
  Validator.setStrictMode = function setStrictMode (strictMode) {
      if ( strictMode === void 0 ) { strictMode = true; }

    STRICT_MODE = strictMode;
  };

  /**
   * Adds and sets the current locale for the validator.
   */
  Validator.prototype.localize = function localize (lang, dictionary) {
    Validator.localize(lang, dictionary);
  };

  /**
   * Adds and sets the current locale for the validator.
   */
  Validator.localize = function localize (lang, dictionary) {
    if (isObject(lang)) {
      Validator.dictionary.merge(lang);
      return;
    }

    // merge the dictionary.
    if (dictionary) {
      var locale = lang || dictionary.name;
      dictionary = assign({}, dictionary);
      Validator.dictionary.merge(( obj = {}, obj[locale] = dictionary, obj ));
        var obj;
    }

    if (lang) {
      // set the locale.
      Validator.locale = lang;
    }
  };

  /**
   * Registers a field to be validated.
   */
  Validator.prototype.attach = function attach (field) {
    // deprecate: handle old signature.
    if (arguments.length > 1) {
      warn('This signature of the attach method has been deprecated, please consult the docs.');
      field = assign({}, {
        name: arguments[0],
        rules: arguments[1]
      }, arguments[2] || { vm: { $validator: this } });
    }

    // fixes initial value detection with v-model and select elements.
    var value = field.initialValue;
    if (!(field instanceof Field)) {
      field = new Field(field.el || null, field);
    }

    this.fields.push(field);

    // validate the field initially
    if (field.initial) {
      this.validate(("#" + (field.id)), value || field.value);
    } else {
      this._validate(field, value || field.value, true).then(function (result) {
        field.flags.valid = result.valid;
        field.flags.invalid = !result.valid;
      });
    }

    this._addFlag(field, field.scope);
    return field;
  };

  /**
   * Sets the flags on a field.
   */
  Validator.prototype.flag = function flag (name, flags) {
    var field = this._resolveField(name);
    if (! field || !flags) {
      return;
    }

    field.setFlags(flags);
  };

  /**
   * Removes a field from the validator.
   */
  Validator.prototype.detach = function detach (name, scope) {
    var field = name instanceof Field ? name : this._resolveField(name, scope);
    if (!field) { return; }

    field.destroy();
    this.errors.remove(field.name, field.scope, field.id);
    this.fields.remove(field);
    var flags = this.flags;
    if (!isNullOrUndefined(field.scope) && flags[("$" + (field.scope))]) {
      delete flags[("$" + (field.scope))][field.name];
    } else if (isNullOrUndefined(field.scope)) {
      delete flags[field.name];
    }

    this.flags = assign({}, flags);
  };

  /**
   * Adds a custom validator to the list of validation rules.
   */
  Validator.prototype.extend = function extend (name, validator, options) {
      if ( options === void 0 ) { options = {}; }

    Validator.extend(name, validator, options);
  };

  /**
   * Updates a field, updating both errors and flags.
   */
  Validator.prototype.update = function update (id, ref) {
      var scope = ref.scope;

    var field = this._resolveField(("#" + id));
    if (!field) { return; }

    // remove old scope.
    this.errors.update(id, { scope: scope });
    if (!isNullOrUndefined(field.scope) && this.flags[("$" + (field.scope))]) {
      delete this.flags[("$" + (field.scope))][field.name];
    } else if (isNullOrUndefined(field.scope)) {
      delete this.flags[field.name];
    }

    this._addFlag(field, scope);
  };

  /**
   * Removes a rule from the list of validators.
   */
  Validator.prototype.remove = function remove (name) {
    Validator.remove(name);
  };

  /**
   * Validates a value against a registered field validations.
   */
  Validator.prototype.validate = function validate (name, value, scope) {
      var this$1 = this;
      if ( scope === void 0 ) { scope = null; }

    if (this.paused) { return Promise.resolve(true); }

    // overload to validate all.
    if (arguments.length === 0) {
      return this.validateScopes();
    }

    // overload to validate scope-less fields.
    if (arguments.length === 1 && arguments[0] === '*') {
      return this.validateAll();
    }

    // overload to validate a scope.
    if (arguments.length === 1 && typeof arguments[0] === 'string' && /^(.+)\.\*$/.test(arguments[0])) {
      var matched = arguments[0].match(/^(.+)\.\*$/)[1];
      return this.validateAll(matched);
    }

    var field = this._resolveField(name, scope);
    if (!field) {
      return this._handleFieldNotFound(name, scope);
    }

    field.flags.pending = true;
    if (arguments.length === 1) {
      value = field.value;
    }

    var silentRun = field.isDisabled;

    return this._validate(field, value, silentRun).then(function (result) {
      this$1.errors.remove(field.name, field.scope, field.id);
      if (silentRun) {
        return Promise.resolve(true);
      } else if (result.errors) {
        result.errors.forEach(function (e) { return this$1.errors.add(e); });
      }

      field.setFlags({
        pending: false,
        valid: result.valid,
        validated: true
      });

      return result.valid;
    });
  };

  /**
   * Pauses the validator.
   */
  Validator.prototype.pause = function pause () {
    this.paused = true;

    return this;
  };

  /**
   * Resumes the validator.
   */
  Validator.prototype.resume = function resume () {
    this.paused = false;

    return this;
  };

  /**
   * Validates each value against the corresponding field validations.
   */
  Validator.prototype.validateAll = function validateAll (values) {
      var arguments$1 = arguments;
      var this$1 = this;

    if (this.paused) { return Promise.resolve(true); }

    var matcher = null;
    var providedValues = false;

    if (typeof values === 'string') {
      matcher = { scope: values };
    } else if (isObject(values)) {
      matcher = Object.keys(values).map(function (key) {
        return { name: key, scope: arguments$1[1] || null };
      });
      providedValues = true;
    } else if (arguments.length === 0) {
      matcher = { scope: null }; // global scope.
    } else if (Array.isArray(values)) {
      matcher = values.map(function (key) {
        return { name: key, scope: arguments$1[1] || null };
      });
    }

    var promises = this.fields.filter(matcher).map(function (field) { return this$1.validate(
      ("#" + (field.id)),
      providedValues ? values[field.name] : field.value
    ); });

    return Promise.all(promises).then(function (results) { return results.every(function (t) { return t; }); });
  };

  /**
   * Validates all scopes.
   */
  Validator.prototype.validateScopes = function validateScopes () {
      var this$1 = this;

    if (this.paused) { return Promise.resolve(true); }

    var promises = this.fields.map(function (field) { return this$1.validate(
      ("#" + (field.id)),
      field.value
    ); });

    return Promise.all(promises).then(function (results) { return results.every(function (t) { return t; }); });
  };

  /**
   * Perform cleanup.
   */
  Validator.prototype.destroy = function destroy () {
    // Remove ErrorBag instance.
    var idx = ERRORS.indexOf(this.errors);
    if (idx === -1) { return; }

    ERRORS.splice(idx, 1);
  };

  /**
   * Creates the fields to be validated.
   */
  Validator.prototype._createFields = function _createFields (validations) {
      var this$1 = this;

    if (!validations) { return; }

    Object.keys(validations).forEach(function (field) {
      var options = assign({}, { name: field, rules: validations[field] });
      this$1.attach(options);
    });
  };

  /**
   * Date rules need the existence of a format, so date_format must be supplied.
   */
  Validator.prototype._getDateFormat = function _getDateFormat (validations) {
    var format = null;
    if (validations.date_format && Array.isArray(validations.date_format)) {
      format = validations.date_format[0];
    }

    return format || this.dictionary.getDateFormat(this.locale);
  };

  /**
   * Checks if the passed rule is a date rule.
   */
  Validator.prototype._isADateRule = function _isADateRule (rule) {
    return !! ~['after', 'before', 'date_between', 'date_format'].indexOf(rule);
  };

  /**
   * Formats an error message for field and a rule.
   */
  Validator.prototype._formatErrorMessage = function _formatErrorMessage (field, rule, data, targetName) {
      if ( data === void 0 ) { data = {}; }
      if ( targetName === void 0 ) { targetName = null; }

    var name = this._getFieldDisplayName(field);
    var params = this._getLocalizedParams(rule, targetName);

    return this.dictionary.getFieldMessage(this.locale, field.name, rule.name, [name, params, data]);
  };

  /**
   * Translates the parameters passed to the rule (mainly for target fields).
   */
  Validator.prototype._getLocalizedParams = function _getLocalizedParams (rule, targetName) {
      if ( targetName === void 0 ) { targetName = null; }

    if (~TARGET_RULES.indexOf(rule.name) && rule.params && rule.params[0]) {
      var localizedName = targetName || this.dictionary.getAttribute(this.locale, rule.params[0], rule.params[0]);
      return [localizedName].concat(rule.params.slice(1));
    }

    return rule.params;
  };

  /**
   * Resolves an appropriate display name, first checking 'data-as' or the registered 'prettyName'
   */
  Validator.prototype._getFieldDisplayName = function _getFieldDisplayName (field) {
    return field.alias || this.dictionary.getAttribute(this.locale, field.name, field.name);
  };

  /**
   * Adds a field flags to the flags collection.
   */
  Validator.prototype._addFlag = function _addFlag (field, scope) {
      if ( scope === void 0 ) { scope = null; }

    if (isNullOrUndefined(scope)) {
      this.flags = assign({}, this.flags, ( obj = {}, obj[("" + (field.name))] = field.flags, obj ));
        var obj;
      return;
    }

    var scopeObj = assign({}, this.flags[("$" + scope)] || {}, ( obj$1 = {}, obj$1[("" + (field.name))] = field.flags, obj$1 ));
      var obj$1;
    this.flags = assign({}, this.flags, ( obj$2 = {}, obj$2[("$" + scope)] = scopeObj, obj$2 ));
      var obj$2;
  };

  /**
   * Resets fields that matches the matcher options or all fields if not specified.
   */
  Validator.prototype._reset = function _reset (matcher) {
      var this$1 = this;

    return new Promise(function (resolve) {
      if (matcher) {
        this$1.fields.filter(matcher).forEach(function (field) {
          field.reset(); // reset field flags.
          this$1.errors.remove(field.name, field.scope, field.id);
        });

        return resolve();
      }

      this$1.fields.items.forEach(function (i) { return i.reset(); });
      this$1.errors.clear();
      resolve();
    });
  };

  /**
   * Tests a single input value against a rule.
   */
  Validator.prototype._test = function _test (field, value, rule) {
      var this$1 = this;

    var validator = RULES[rule.name];
    var params = Array.isArray(rule.params) ? toArray(rule.params) : [];
    var targetName = null;
    if (!validator || typeof validator !== 'function') {
      throw createError(("No such validator '" + (rule.name) + "' exists."));
    }

    // has field dependencies.
    if (TARGET_RULES.indexOf(rule.name) !== -1) {
      var target = find(field.dependencies, function (d) { return d.name === rule.name; });
      if (target) {
        targetName = target.field.alias;
        params = [target.field.value].concat(params.slice(1));
      }
    } else if (rule.name === 'required' && field.rejectsFalse) {
      // invalidate false if no args were specified and the field rejects false by default.
      params = params.length ? params : [true];
    }

    if (this._isADateRule(rule.name)) {
      var dateFormat = this._getDateFormat(field.rules);
      if (rule.name !== 'date_format') {
        params.push(dateFormat);
      }
    }

    var result = validator(value, params);

    // If it is a promise.
    if (isCallable(result.then)) {
      return result.then(function (values) {
        var allValid = true;
        var data = {};
        if (Array.isArray(values)) {
          allValid = values.every(function (t) { return (isObject(t) ? t.valid : t); });
        } else { // Is a single object/boolean.
          allValid = isObject(values) ? values.valid : values;
          data = values.data;
        }

        return {
          valid: allValid,
          error: allValid ? undefined : this$1._createFieldError(field, rule, data, targetName)
        };
      });
    }

    if (!isObject(result)) {
      result = { valid: result, data: {} };
    }

    return {
      valid: result.valid,
      error: result.valid ? undefined : this._createFieldError(field, rule, result.data, targetName)
    };
  };

  /**
   * Merges a validator object into the RULES and Messages.
   */
  Validator._merge = function _merge (name, validator) {
    if (isCallable(validator)) {
      RULES[name] = validator;
      return;
    }

    RULES[name] = validator.validate;
    if (validator.getMessage) {
      Validator.dictionary.setMessage(this.locale, name, validator.getMessage);
    }
  };

  /**
   * Guards from extension violations.
   */
  Validator._guardExtend = function _guardExtend (name, validator) {
    if (isCallable(validator)) {
      return;
    }

    if (!isCallable(validator.validate)) {
      throw createError(
        ("Extension Error: The validator '" + name + "' must be a function or have a 'validate' method.")
      );
    }

    if (!isCallable(validator.getMessage) && typeof validator.getMessage !== 'string') {
      throw createError(
        ("Extension Error: The validator '" + name + "' object must have a 'getMessage' method or string.")
      );
    }
  };

  /**
   * Creates a Field Error Object.
   */
  Validator.prototype._createFieldError = function _createFieldError (field, rule, data, targetName) {
      var this$1 = this;

    return {
      id: field.id,
      field: field.name,
      msg: this._formatErrorMessage(field, rule, data, targetName),
      rule: rule.name,
      scope: field.scope,
      regenerate: function () {
        return this$1._formatErrorMessage(field, rule, data, targetName);
      }
    };
  };

  /**
   * Tries different strategies to find a field.
   */
  Validator.prototype._resolveField = function _resolveField (name, scope) {
    if (!isNullOrUndefined(scope)) {
      return this.fields.find({ name: name, scope: scope });
    }

    if (name[0] === '#') {
      return this.fields.find({ id: name.slice(1) });
    }

    if (name.indexOf('.') > -1) {
      var ref = name.split('.');
        var fieldScope = ref[0];
        var fieldName = ref.slice(1);
      var field = this.fields.find({ name: fieldName.join('.'), scope: fieldScope });
      if (field) {
        return field;
      }
    }

    return this.fields.find({ name: name, scope: null });
  };

  /**
   * Handles when a field is not found depending on the strict flag.
   */
  Validator.prototype._handleFieldNotFound = function _handleFieldNotFound (name, scope) {
    if (!this.strict) { return Promise.resolve(true); }

    var fullName = isNullOrUndefined(scope) ? name : ("" + (!isNullOrUndefined(scope) ? scope + '.' : '') + name);
    throw createError(
      ("Validating a non-existent field: \"" + fullName + "\". Use \"attach()\" first.")
    );
  };

  /**
   * Starts the validation process.
   */
  Validator.prototype._validate = function _validate (field, value, silent) {
      var this$1 = this;
      if ( silent === void 0 ) { silent = false; }

    if (!field.isRequired && (isNullOrUndefined(value) || value === '')) {
      return Promise.resolve({ valid: true });
    }

    var promises = [];
    var errors = [];
    var isExitEarly = false;
    // use of '.some()' is to break iteration in middle by returning true
    Object.keys(field.rules).some(function (rule) {
      var result = this$1._test(field, value, { name: rule, params: field.rules[rule] });
      if (isCallable(result.then)) {
        promises.push(result);
      } else if (this$1.fastExit && !result.valid) {
        errors.push(result.error);
        isExitEarly = true;
      } else {
        // promisify the result.
        promises.push(new Promise(function (resolve) {
          resolve(result);
        }));
      }

      return isExitEarly;
    });

    if (isExitEarly) {
      return Promise.resolve({
        valid: false,
        errors: errors
      });
    }

    return Promise.all(promises).then(function (values) { return values.map(function (v) {
      if (!v.valid) {
        errors.push(v.error);
      }

      return v.valid;
    }).every(function (t) { return t; }); }
    ).then(function (result) {
      return {
        valid: result,
        errors: errors
      };
    });
  };

  Object.defineProperties( Validator.prototype, prototypeAccessors );
  Object.defineProperties( Validator, staticAccessors );

  // 

  /* istanbul ignore next */
  var fakeFlags = createProxy({}, {
    get: function get (target, key) {
      // is a scope
      if (String(key).indexOf('$') === 0) {
        return fakeFlags;
      }

      return createFlags();
    }
  });

  /**
   * Checks if a parent validator instance was requested.
   */
  var requestsValidator = function (injections) {
    if (isObject(injections) && injections.$validator) {
      return true;
    }

    return false;
  };

  /**
   * Creates a validator instance.
   */
  var createValidator = function (vm, options) { return new Validator(null, { vm: vm, fastExit: options.fastExit }); };

  var mixin = {
    provide: function provide () {
      if (this.$validator && !isBuiltInComponent(this.$vnode)) {
        return {
          $validator: this.$validator
        };
      }

      return {};
    },
    beforeCreate: function beforeCreate () {
      // if built in do nothing.
      if (isBuiltInComponent(this.$vnode)) {
        return;
      }

      // if its a root instance set the config if it exists.
      if (!this.$parent) {
        Config.merge(this.$options.$_veeValidate || {});
      }

      var options = Config.resolve(this);
      var Vue = this.$options._base; // the vue constructor.
      // TODO: Deprecate
      /* istanbul ignore next */
      if (this.$options.$validates) {
        warn('The ctor $validates option has been deprecated please set the $_veeValidate.validator option to "new" instead');
        this.$validator = createValidator(this, options);
      }

      // if its a root instance, inject anyways, or if it requested a new instance.
      if (!this.$parent || (this.$options.$_veeValidate && /new/.test(this.$options.$_veeValidate.validator))) {
        this.$validator = createValidator(this, options);
      }

      var requested = requestsValidator(this.$options.inject);

      // if automatic injection is enabled and no instance was requested.
      if (! this.$validator && options.inject && !requested) {
        this.$validator = createValidator(this, options);
      }

      // don't inject errors or fieldBag as no validator was resolved.
      if (! requested && ! this.$validator) {
        return;
      }

      // There is a validator but it isn't injected, mark as reactive.
      if (! requested && this.$validator) {
        Vue.util.defineReactive(this.$validator, 'errors', this.$validator.errors);
        Vue.util.defineReactive(this.$validator, 'flags', this.$validator.flags);
      }

      if (! this.$options.computed) {
        this.$options.computed = {};
      }

      this.$options.computed[options.errorBagName || 'errors'] = function errorBagGetter () {
        return this.$validator.errors;
      };
      this.$options.computed[options.fieldsBagName || 'fields'] = function fieldBagGetter () {
        if (!Object.keys(this.$validator.flags).length) {
          return fakeFlags;
        }

        return this.$validator.flags;
      };
    },
    beforeDestroy: function beforeDestroy () {
      if (isBuiltInComponent(this.$vnode)) { return; }

      // mark the validator paused to prevent delayed validation.
      if (this.$validator && this.$validator.ownerId === this._uid) {
        this.$validator.pause();
        this.$validator.destroy();
      }
    }
  };

  // 

  /**
   * Finds the requested field by id from the context object.
   */
  var findField = function (el, context) {
    if (!context || !context.$validator) {
      return null;
    }

    return context.$validator.fields.find({ id: getDataAttribute(el, 'id') });
  };

  var directive = {
    bind: function bind (el, binding, vnode) {
      var validator = vnode.context.$validator;
      if (! validator) {
        warn("No validator instance is present on vm, did you forget to inject '$validator'?");
        return;
      }

      var fieldOptions = Generator.generate(el, binding, vnode);
      validator.attach(fieldOptions);
    },
    inserted: function (el, binding, vnode) {
      var field = findField(el, vnode.context);
      var scope = Generator.resolveScope(el, binding, vnode);

      // skip if scope hasn't changed.
      if (!field || scope === field.scope) { return; }

      // only update scope.
      field.update({ scope: scope });

      // allows the field to re-evaluated once more in the update hook.
      field.updated = false;
    },
    update: function (el, binding, vnode) {
      var field = findField(el, vnode.context);

      // make sure we don't do unneccasary work if no important change was done.
      if (!field || (field.updated && isEqual(binding.value, binding.oldValue))) { return; }
      var scope = Generator.resolveScope(el, binding, vnode);
      var rules = Generator.resolveRules(el, binding);

      field.update({
        scope: scope,
        rules: rules
      });
    },
    unbind: function unbind (el, binding, ref) {
      var context = ref.context;

      var field = findField(el, context);
      if (!field) { return; }

      context.$validator.detach(field);
    }
  };

  var Vue$1;

  function install (_Vue, options) {
    if ( options === void 0 ) { options = {}; }

    if (Vue$1 && _Vue === Vue$1) {
      return;
    }

    Vue$1 = _Vue;
    Config.merge(options);
    var ref = Config.current;
    var dictionary = ref.dictionary;
    var i18n = ref.i18n;

    if (dictionary) {
      Validator.localize(dictionary); // merge the dictionary.
    }

    // try to watch locale changes.
    if (i18n && i18n._vm && isCallable(i18n._vm.$watch)) {
      i18n._vm.$watch('locale', function () {
        Validator.regenerate();
      });
    }

    if (!i18n && options.locale) {
      Validator.localize(options.locale); // set the locale
    }

    Validator.setStrictMode(Config.current.strict);

    Vue$1.mixin(mixin);
    Vue$1.directive('validate', directive);
  }

  /**
   * Formates file size.
   *
   * @param {Number|String} size
   */
  var formatFileSize = function (size) {
    var units = ['Byte', 'KB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB'];
    var threshold = 1024;
    size = Number(size) * threshold;
    var i = size === 0 ? 0 : Math.floor(Math.log(size) / Math.log(threshold));
    return (((size / Math.pow(threshold, i)).toFixed(2) * 1) + " " + (units[i]));
  };

  /**
   * Checks if vee-validate is defined globally.
   */
  var isDefinedGlobally = function () {
    return typeof VeeValidate !== 'undefined';
  };

  var messages = {
    _default: function (field) { return ("The " + field + " value is not valid."); },
    after: function (field, ref) {
      var target = ref[0];
      var inclusion = ref[1];

      return ("The " + field + " must be after " + (inclusion ? 'or equal to ' : '') + target + ".");
  },
    alpha_dash: function (field) { return ("The " + field + " field may contain alpha-numeric characters as well as dashes and underscores."); },
    alpha_num: function (field) { return ("The " + field + " field may only contain alpha-numeric characters."); },
    alpha_spaces: function (field) { return ("The " + field + " field may only contain alphabetic characters as well as spaces."); },
    alpha: function (field) { return ("The " + field + " field may only contain alphabetic characters."); },
    before: function (field, ref) {
      var target = ref[0];
      var inclusion = ref[1];

      return ("The " + field + " must be before " + (inclusion ? 'or equal to ' : '') + target + ".");
  },
    between: function (field, ref) {
      var min = ref[0];
      var max = ref[1];

      return ("The " + field + " field must be between " + min + " and " + max + ".");
  },
    confirmed: function (field) { return ("The " + field + " confirmation does not match."); },
    credit_card: function (field) { return ("The " + field + " field is invalid."); },
    date_between: function (field, ref) {
      var min = ref[0];
      var max = ref[1];

      return ("The " + field + " must be between " + min + " and " + max + ".");
  },
    date_format: function (field, ref) {
      var format = ref[0];

      return ("The " + field + " must be in the format " + format + ".");
  },
    decimal: function (field, ref) {
      if ( ref === void 0 ) { ref = []; }
      var decimals = ref[0]; if ( decimals === void 0 ) { decimals = '*'; }

      return ("The " + field + " field must be numeric and may contain " + (!decimals || decimals === '*' ? '' : decimals) + " decimal points.");
  },
    digits: function (field, ref) {
      var length = ref[0];

      return ("The " + field + " field must be numeric and exactly contain " + length + " digits.");
  },
    dimensions: function (field, ref) {
      var width = ref[0];
      var height = ref[1];

      return ("The " + field + " field must be " + width + " pixels by " + height + " pixels.");
  },
    email: function (field) { return ("The " + field + " field must be a valid email."); },
    ext: function (field) { return ("The " + field + " field must be a valid file."); },
    image: function (field) { return ("The " + field + " field must be an image."); },
    in: function (field) { return ("The " + field + " field must be a valid value."); },
    integer: function (field) { return ("The " + field + " field must be an integer."); },
    ip: function (field) { return ("The " + field + " field must be a valid ip address."); },
    length: function (field, ref) {
      var length = ref[0];
      var max = ref[1];

      if (max) {
        return ("The " + field + " length be between " + length + " and " + max + ".");
      }

      return ("The " + field + " length must be " + length + ".");
    },
    max: function (field, ref) {
      var length = ref[0];

      return ("The " + field + " field may not be greater than " + length + " characters.");
  },
    max_value: function (field, ref) {
      var max = ref[0];

      return ("The " + field + " field must be " + max + " or less.");
  },
    mimes: function (field) { return ("The " + field + " field must have a valid file type."); },
    min: function (field, ref) {
      var length = ref[0];

      return ("The " + field + " field must be at least " + length + " characters.");
  },
    min_value: function (field, ref) {
      var min = ref[0];

      return ("The " + field + " field must be " + min + " or more.");
  },
    not_in: function (field) { return ("The " + field + " field must be a valid value."); },
    numeric: function (field) { return ("The " + field + " field may only contain numeric characters."); },
    regex: function (field) { return ("The " + field + " field format is invalid."); },
    required: function (field) { return ("The " + field + " field is required."); },
    size: function (field, ref) {
      var size = ref[0];

      return ("The " + field + " size must be less than " + (formatFileSize(size)) + ".");
  },
    url: function (field) { return ("The " + field + " field is not a valid URL."); }
  };

  var locale = {
    name: 'en',
    messages: messages,
    attributes: {}
  };

  if (isDefinedGlobally()) {
    // eslint-disable-next-line
    VeeValidate.Validator.localize(( obj = {}, obj[locale.name] = locale, obj ));
    var obj;
  }

  // 

  function use (plugin, options) {
    if ( options === void 0 ) { options = {}; }

    if (!isCallable(plugin)) {
      return warn('The plugin must be a callable function');
    }

    plugin({ Validator: Validator, ErrorBag: ErrorBag, Rules: Validator.rules }, options);
  }

  var MILLISECONDS_IN_HOUR = 3600000;
  var MILLISECONDS_IN_MINUTE = 60000;
  var DEFAULT_ADDITIONAL_DIGITS = 2;

  var patterns = {
    dateTimeDelimeter: /[T ]/,
    plainTime: /:/,

    // year tokens
    YY: /^(\d{2})$/,
    YYY: [
      /^([+-]\d{2})$/, // 0 additional digits
      /^([+-]\d{3})$/, // 1 additional digit
      /^([+-]\d{4})$/ // 2 additional digits
    ],
    YYYY: /^(\d{4})/,
    YYYYY: [
      /^([+-]\d{4})/, // 0 additional digits
      /^([+-]\d{5})/, // 1 additional digit
      /^([+-]\d{6})/ // 2 additional digits
    ],

    // date tokens
    MM: /^-(\d{2})$/,
    DDD: /^-?(\d{3})$/,
    MMDD: /^-?(\d{2})-?(\d{2})$/,
    Www: /^-?W(\d{2})$/,
    WwwD: /^-?W(\d{2})-?(\d{1})$/,

    HH: /^(\d{2}([.,]\d*)?)$/,
    HHMM: /^(\d{2}):?(\d{2}([.,]\d*)?)$/,
    HHMMSS: /^(\d{2}):?(\d{2}):?(\d{2}([.,]\d*)?)$/,

    // timezone tokens
    timezone: /([Z+-].*)$/,
    timezoneZ: /^(Z)$/,
    timezoneHH: /^([+-])(\d{2})$/,
    timezoneHHMM: /^([+-])(\d{2}):?(\d{2})$/
  };

  /**
   * @name toDate
   * @category Common Helpers
   * @summary Convert the given argument to an instance of Date.
   *
   * @description
   * Convert the given argument to an instance of Date.
   *
   * If the argument is an instance of Date, the function returns its clone.
   *
   * If the argument is a number, it is treated as a timestamp.
   *
   * If an argument is a string, the function tries to parse it.
   * Function accepts complete ISO 8601 formats as well as partial implementations.
   * ISO 8601: http://en.wikipedia.org/wiki/ISO_8601
   *
   * If the argument is null, it is treated as an invalid date.
   *
   * If all above fails, the function passes the given argument to Date constructor.
   *
   * **Note**: *all* Date arguments passed to any *date-fns* function is processed by `toDate`.
   * All *date-fns* functions will throw `RangeError` if `options.additionalDigits` is not 0, 1, 2 or undefined.
   *
   * @param {*} argument - the value to convert
   * @param {Options} [options] - the object with options. See [Options]{@link https://date-fns.org/docs/Options}
   * @param {0|1|2} [options.additionalDigits=2] - the additional number of digits in the extended year format
   * @returns {Date} the parsed date in the local time zone
   * @throws {TypeError} 1 argument required
   * @throws {RangeError} `options.additionalDigits` must be 0, 1 or 2
   *
   * @example
   * // Convert string '2014-02-11T11:30:30' to date:
   * var result = toDate('2014-02-11T11:30:30')
   * //=> Tue Feb 11 2014 11:30:30
   *
   * @example
   * // Convert string '+02014101' to date,
   * // if the additional number of digits in the extended year format is 1:
   * var result = toDate('+02014101', {additionalDigits: 1})
   * //=> Fri Apr 11 2014 00:00:00
   */
  function toDate (argument, dirtyOptions) {
    if (arguments.length < 1) {
      throw new TypeError('1 argument required, but only ' + arguments.length + ' present')
    }

    if (argument === null) {
      return new Date(NaN)
    }

    var options = dirtyOptions || {};

    var additionalDigits = options.additionalDigits === undefined ? DEFAULT_ADDITIONAL_DIGITS : Number(options.additionalDigits);
    if (additionalDigits !== 2 && additionalDigits !== 1 && additionalDigits !== 0) {
      throw new RangeError('additionalDigits must be 0, 1 or 2')
    }

    // Clone the date
    if (argument instanceof Date) {
      // Prevent the date to lose the milliseconds when passed to new Date() in IE10
      return new Date(argument.getTime())
    } else if (typeof argument !== 'string') {
      return new Date(argument)
    }

    var dateStrings = splitDateString(argument);

    var parseYearResult = parseYear(dateStrings.date, additionalDigits);
    var year = parseYearResult.year;
    var restDateString = parseYearResult.restDateString;

    var date = parseDate(restDateString, year);

    if (date) {
      var timestamp = date.getTime();
      var time = 0;
      var offset;

      if (dateStrings.time) {
        time = parseTime(dateStrings.time);
      }

      if (dateStrings.timezone) {
        offset = parseTimezone(dateStrings.timezone);
      } else {
        // get offset accurate to hour in timezones that change offset
        offset = new Date(timestamp + time).getTimezoneOffset();
        offset = new Date(timestamp + time + offset * MILLISECONDS_IN_MINUTE).getTimezoneOffset();
      }

      return new Date(timestamp + time + offset * MILLISECONDS_IN_MINUTE)
    } else {
      return new Date(argument)
    }
  }

  function splitDateString (dateString) {
    var dateStrings = {};
    var array = dateString.split(patterns.dateTimeDelimeter);
    var timeString;

    if (patterns.plainTime.test(array[0])) {
      dateStrings.date = null;
      timeString = array[0];
    } else {
      dateStrings.date = array[0];
      timeString = array[1];
    }

    if (timeString) {
      var token = patterns.timezone.exec(timeString);
      if (token) {
        dateStrings.time = timeString.replace(token[1], '');
        dateStrings.timezone = token[1];
      } else {
        dateStrings.time = timeString;
      }
    }

    return dateStrings
  }

  function parseYear (dateString, additionalDigits) {
    var patternYYY = patterns.YYY[additionalDigits];
    var patternYYYYY = patterns.YYYYY[additionalDigits];

    var token;

    // YYYY or Â±YYYYY
    token = patterns.YYYY.exec(dateString) || patternYYYYY.exec(dateString);
    if (token) {
      var yearString = token[1];
      return {
        year: parseInt(yearString, 10),
        restDateString: dateString.slice(yearString.length)
      }
    }

    // YY or Â±YYY
    token = patterns.YY.exec(dateString) || patternYYY.exec(dateString);
    if (token) {
      var centuryString = token[1];
      return {
        year: parseInt(centuryString, 10) * 100,
        restDateString: dateString.slice(centuryString.length)
      }
    }

    // Invalid ISO-formatted year
    return {
      year: null
    }
  }

  function parseDate (dateString, year) {
    // Invalid ISO-formatted year
    if (year === null) {
      return null
    }

    var token;
    var date;
    var month;
    var week;

    // YYYY
    if (dateString.length === 0) {
      date = new Date(0);
      date.setUTCFullYear(year);
      return date
    }

    // YYYY-MM
    token = patterns.MM.exec(dateString);
    if (token) {
      date = new Date(0);
      month = parseInt(token[1], 10) - 1;
      date.setUTCFullYear(year, month);
      return date
    }

    // YYYY-DDD or YYYYDDD
    token = patterns.DDD.exec(dateString);
    if (token) {
      date = new Date(0);
      var dayOfYear = parseInt(token[1], 10);
      date.setUTCFullYear(year, 0, dayOfYear);
      return date
    }

    // YYYY-MM-DD or YYYYMMDD
    token = patterns.MMDD.exec(dateString);
    if (token) {
      date = new Date(0);
      month = parseInt(token[1], 10) - 1;
      var day = parseInt(token[2], 10);
      date.setUTCFullYear(year, month, day);
      return date
    }

    // YYYY-Www or YYYYWww
    token = patterns.Www.exec(dateString);
    if (token) {
      week = parseInt(token[1], 10) - 1;
      return dayOfISOYear(year, week)
    }

    // YYYY-Www-D or YYYYWwwD
    token = patterns.WwwD.exec(dateString);
    if (token) {
      week = parseInt(token[1], 10) - 1;
      var dayOfWeek = parseInt(token[2], 10) - 1;
      return dayOfISOYear(year, week, dayOfWeek)
    }

    // Invalid ISO-formatted date
    return null
  }

  function parseTime (timeString) {
    var token;
    var hours;
    var minutes;

    // hh
    token = patterns.HH.exec(timeString);
    if (token) {
      hours = parseFloat(token[1].replace(',', '.'));
      return (hours % 24) * MILLISECONDS_IN_HOUR
    }

    // hh:mm or hhmm
    token = patterns.HHMM.exec(timeString);
    if (token) {
      hours = parseInt(token[1], 10);
      minutes = parseFloat(token[2].replace(',', '.'));
      return (hours % 24) * MILLISECONDS_IN_HOUR +
        minutes * MILLISECONDS_IN_MINUTE
    }

    // hh:mm:ss or hhmmss
    token = patterns.HHMMSS.exec(timeString);
    if (token) {
      hours = parseInt(token[1], 10);
      minutes = parseInt(token[2], 10);
      var seconds = parseFloat(token[3].replace(',', '.'));
      return (hours % 24) * MILLISECONDS_IN_HOUR +
        minutes * MILLISECONDS_IN_MINUTE +
        seconds * 1000
    }

    // Invalid ISO-formatted time
    return null
  }

  function parseTimezone (timezoneString) {
    var token;
    var absoluteOffset;

    // Z
    token = patterns.timezoneZ.exec(timezoneString);
    if (token) {
      return 0
    }

    // Â±hh
    token = patterns.timezoneHH.exec(timezoneString);
    if (token) {
      absoluteOffset = parseInt(token[2], 10) * 60;
      return (token[1] === '+') ? -absoluteOffset : absoluteOffset
    }

    // Â±hh:mm or Â±hhmm
    token = patterns.timezoneHHMM.exec(timezoneString);
    if (token) {
      absoluteOffset = parseInt(token[2], 10) * 60 + parseInt(token[3], 10);
      return (token[1] === '+') ? -absoluteOffset : absoluteOffset
    }

    return 0
  }

  function dayOfISOYear (isoYear, week, day) {
    week = week || 0;
    day = day || 0;
    var date = new Date(0);
    date.setUTCFullYear(isoYear, 0, 4);
    var fourthOfJanuaryDay = date.getUTCDay() || 7;
    var diff = week * 7 + day + 1 - fourthOfJanuaryDay;
    date.setUTCDate(date.getUTCDate() + diff);
    return date
  }

  /**
   * @name addMilliseconds
   * @category Millisecond Helpers
   * @summary Add the specified number of milliseconds to the given date.
   *
   * @description
   * Add the specified number of milliseconds to the given date.
   *
   * @param {Date|String|Number} date - the date to be changed
   * @param {Number} amount - the amount of milliseconds to be added
   * @param {Options} [options] - the object with options. See [Options]{@link https://date-fns.org/docs/Options}
   * @param {0|1|2} [options.additionalDigits=2] - passed to `toDate`. See [toDate]{@link https://date-fns.org/docs/toDate}
   * @returns {Date} the new date with the milliseconds added
   * @throws {TypeError} 2 arguments required
   * @throws {RangeError} `options.additionalDigits` must be 0, 1 or 2
   *
   * @example
   * // Add 750 milliseconds to 10 July 2014 12:45:30.000:
   * var result = addMilliseconds(new Date(2014, 6, 10, 12, 45, 30, 0), 750)
   * //=> Thu Jul 10 2014 12:45:30.750
   */
  function addMilliseconds (dirtyDate, dirtyAmount, dirtyOptions) {
    if (arguments.length < 2) {
      throw new TypeError('2 arguments required, but only ' + arguments.length + ' present')
    }

    var timestamp = toDate(dirtyDate, dirtyOptions).getTime();
    var amount = Number(dirtyAmount);
    return new Date(timestamp + amount)
  }

  function cloneObject (dirtyObject) {
    dirtyObject = dirtyObject || {};
    var object = {};

    for (var property in dirtyObject) {
      if (dirtyObject.hasOwnProperty(property)) {
        object[property] = dirtyObject[property];
      }
    }

    return object
  }

  var MILLISECONDS_IN_MINUTE$2 = 60000;

  /**
   * @name addMinutes
   * @category Minute Helpers
   * @summary Add the specified number of minutes to the given date.
   *
   * @description
   * Add the specified number of minutes to the given date.
   *
   * @param {Date|String|Number} date - the date to be changed
   * @param {Number} amount - the amount of minutes to be added
   * @param {Options} [options] - the object with options. See [Options]{@link https://date-fns.org/docs/Options}
   * @param {0|1|2} [options.additionalDigits=2] - passed to `toDate`. See [toDate]{@link https://date-fns.org/docs/toDate}
   * @returns {Date} the new date with the minutes added
   * @throws {TypeError} 2 arguments required
   * @throws {RangeError} `options.additionalDigits` must be 0, 1 or 2
   *
   * @example
   * // Add 30 minutes to 10 July 2014 12:00:00:
   * var result = addMinutes(new Date(2014, 6, 10, 12, 0), 30)
   * //=> Thu Jul 10 2014 12:30:00
   */
  function addMinutes (dirtyDate, dirtyAmount, dirtyOptions) {
    if (arguments.length < 2) {
      throw new TypeError('2 arguments required, but only ' + arguments.length + ' present')
    }

    var amount = Number(dirtyAmount);
    return addMilliseconds(dirtyDate, amount * MILLISECONDS_IN_MINUTE$2, dirtyOptions)
  }

  /**
   * @name isValid
   * @category Common Helpers
   * @summary Is the given date valid?
   *
   * @description
   * Returns false if argument is Invalid Date and true otherwise.
   * Argument is converted to Date using `toDate`. See [toDate]{@link https://date-fns.org/docs/toDate}
   * Invalid Date is a Date, whose time value is NaN.
   *
   * Time value of Date: http://es5.github.io/#x15.9.1.1
   *
   * @param {*} date - the date to check
   * @param {Options} [options] - the object with options. See [Options]{@link https://date-fns.org/docs/Options}
   * @param {0|1|2} [options.additionalDigits=2] - passed to `toDate`. See [toDate]{@link https://date-fns.org/docs/toDate}
   * @returns {Boolean} the date is valid
   * @throws {TypeError} 1 argument required
   * @throws {RangeError} `options.additionalDigits` must be 0, 1 or 2
   *
   * @example
   * // For the valid date:
   * var result = isValid(new Date(2014, 1, 31))
   * //=> true
   *
   * @example
   * // For the value, convertable into a date:
   * var result = isValid('2014-02-31')
   * //=> true
   *
   * @example
   * // For the invalid date:
   * var result = isValid(new Date(''))
   * //=> false
   */
  function isValid (dirtyDate, dirtyOptions) {
    if (arguments.length < 1) {
      throw new TypeError('1 argument required, but only ' + arguments.length + ' present')
    }

    var date = toDate(dirtyDate, dirtyOptions);
    return !isNaN(date)
  }

  var formatDistanceLocale = {
    lessThanXSeconds: {
      one: 'less than a second',
      other: 'less than {{count}} seconds'
    },

    xSeconds: {
      one: '1 second',
      other: '{{count}} seconds'
    },

    halfAMinute: 'half a minute',

    lessThanXMinutes: {
      one: 'less than a minute',
      other: 'less than {{count}} minutes'
    },

    xMinutes: {
      one: '1 minute',
      other: '{{count}} minutes'
    },

    aboutXHours: {
      one: 'about 1 hour',
      other: 'about {{count}} hours'
    },

    xHours: {
      one: '1 hour',
      other: '{{count}} hours'
    },

    xDays: {
      one: '1 day',
      other: '{{count}} days'
    },

    aboutXMonths: {
      one: 'about 1 month',
      other: 'about {{count}} months'
    },

    xMonths: {
      one: '1 month',
      other: '{{count}} months'
    },

    aboutXYears: {
      one: 'about 1 year',
      other: 'about {{count}} years'
    },

    xYears: {
      one: '1 year',
      other: '{{count}} years'
    },

    overXYears: {
      one: 'over 1 year',
      other: 'over {{count}} years'
    },

    almostXYears: {
      one: 'almost 1 year',
      other: 'almost {{count}} years'
    }
  };

  function formatDistance (token, count, options) {
    options = options || {};

    var result;
    if (typeof formatDistanceLocale[token] === 'string') {
      result = formatDistanceLocale[token];
    } else if (count === 1) {
      result = formatDistanceLocale[token].one;
    } else {
      result = formatDistanceLocale[token].other.replace('{{count}}', count);
    }

    if (options.addSuffix) {
      if (options.comparison > 0) {
        return 'in ' + result
      } else {
        return result + ' ago'
      }
    }

    return result
  }

  var tokensToBeShortedPattern = /MMMM|MM|DD|dddd/g;

  function buildShortLongFormat (format) {
    return format.replace(tokensToBeShortedPattern, function (token) {
      return token.slice(1)
    })
  }

  /**
   * @name buildFormatLongFn
   * @category Locale Helpers
   * @summary Build `formatLong` property for locale used by `format`, `formatRelative` and `parse` functions.
   *
   * @description
   * Build `formatLong` property for locale used by `format`, `formatRelative` and `parse` functions.
   * Returns a function which takes one of the following tokens as the argument:
   * `'LTS'`, `'LT'`, `'L'`, `'LL'`, `'LLL'`, `'l'`, `'ll'`, `'lll'`, `'llll'`
   * and returns a long format string written as `format` token strings.
   * See [format]{@link https://date-fns.org/docs/format}
   *
   * `'l'`, `'ll'`, `'lll'` and `'llll'` formats are built automatically
   * by shortening some of the tokens from corresponding unshortened formats
   * (e.g., if `LL` is `'MMMM DD YYYY'` then `ll` will be `MMM D YYYY`)
   *
   * @param {Object} obj - the object with long formats written as `format` token strings
   * @param {String} obj.LT - time format: hours and minutes
   * @param {String} obj.LTS - time format: hours, minutes and seconds
   * @param {String} obj.L - short date format: numeric day, month and year
   * @param {String} [obj.l] - short date format: numeric day, month and year (shortened)
   * @param {String} obj.LL - long date format: day, month in words, and year
   * @param {String} [obj.ll] - long date format: day, month in words, and year (shortened)
   * @param {String} obj.LLL - long date and time format
   * @param {String} [obj.lll] - long date and time format (shortened)
   * @param {String} obj.LLLL - long date, time and weekday format
   * @param {String} [obj.llll] - long date, time and weekday format (shortened)
   * @returns {Function} `formatLong` property of the locale
   *
   * @example
   * // For `en-US` locale:
   * locale.formatLong = buildFormatLongFn({
   *   LT: 'h:mm aa',
   *   LTS: 'h:mm:ss aa',
   *   L: 'MM/DD/YYYY',
   *   LL: 'MMMM D YYYY',
   *   LLL: 'MMMM D YYYY h:mm aa',
   *   LLLL: 'dddd, MMMM D YYYY h:mm aa'
   * })
   */
  function buildFormatLongFn (obj) {
    var formatLongLocale = {
      LTS: obj.LTS,
      LT: obj.LT,
      L: obj.L,
      LL: obj.LL,
      LLL: obj.LLL,
      LLLL: obj.LLLL,
      l: obj.l || buildShortLongFormat(obj.L),
      ll: obj.ll || buildShortLongFormat(obj.LL),
      lll: obj.lll || buildShortLongFormat(obj.LLL),
      llll: obj.llll || buildShortLongFormat(obj.LLLL)
    };

    return function (token) {
      return formatLongLocale[token]
    }
  }

  var formatLong = buildFormatLongFn({
    LT: 'h:mm aa',
    LTS: 'h:mm:ss aa',
    L: 'MM/DD/YYYY',
    LL: 'MMMM D YYYY',
    LLL: 'MMMM D YYYY h:mm aa',
    LLLL: 'dddd, MMMM D YYYY h:mm aa'
  });

  var formatRelativeLocale = {
    lastWeek: '[last] dddd [at] LT',
    yesterday: '[yesterday at] LT',
    today: '[today at] LT',
    tomorrow: '[tomorrow at] LT',
    nextWeek: 'dddd [at] LT',
    other: 'L'
  };

  function formatRelative (token, date, baseDate, options) {
    return formatRelativeLocale[token]
  }

  /**
   * @name buildLocalizeFn
   * @category Locale Helpers
   * @summary Build `localize.weekday`, `localize.month` and `localize.timeOfDay` properties for the locale.
   *
   * @description
   * Build `localize.weekday`, `localize.month` and `localize.timeOfDay` properties for the locale
   * used by `format` function.
   * If no `type` is supplied to the options of the resulting function, `defaultType` will be used (see example).
   *
   * `localize.weekday` function takes the weekday index as argument (0 - Sunday).
   * `localize.month` takes the month index (0 - January).
   * `localize.timeOfDay` takes the hours. Use `indexCallback` to convert them to an array index (see example).
   *
   * @param {Object} values - the object with arrays of values
   * @param {String} defaultType - the default type for the localize function
   * @param {Function} [indexCallback] - the callback which takes the resulting function argument
   *   and converts it into value array index
   * @returns {Function} the resulting function
   *
   * @example
   * var timeOfDayValues = {
   *   uppercase: ['AM', 'PM'],
   *   lowercase: ['am', 'pm'],
   *   long: ['a.m.', 'p.m.']
   * }
   * locale.localize.timeOfDay = buildLocalizeFn(timeOfDayValues, 'long', function (hours) {
   *   // 0 is a.m. array index, 1 is p.m. array index
   *   return (hours / 12) >= 1 ? 1 : 0
   * })
   * locale.localize.timeOfDay(16, {type: 'uppercase'}) //=> 'PM'
   * locale.localize.timeOfDay(5) //=> 'a.m.'
   */
  function buildLocalizeFn (values, defaultType, indexCallback) {
    return function (dirtyIndex, dirtyOptions) {
      var options = dirtyOptions || {};
      var type = options.type ? String(options.type) : defaultType;
      var valuesArray = values[type] || values[defaultType];
      var index = indexCallback ? indexCallback(Number(dirtyIndex)) : Number(dirtyIndex);
      return valuesArray[index]
    }
  }

  /**
   * @name buildLocalizeArrayFn
   * @category Locale Helpers
   * @summary Build `localize.weekdays`, `localize.months` and `localize.timesOfDay` properties for the locale.
   *
   * @description
   * Build `localize.weekdays`, `localize.months` and `localize.timesOfDay` properties for the locale.
   * If no `type` is supplied to the options of the resulting function, `defaultType` will be used (see example).
   *
   * @param {Object} values - the object with arrays of values
   * @param {String} defaultType - the default type for the localize function
   * @returns {Function} the resulting function
   *
   * @example
   * var weekdayValues = {
   *   narrow: ['Su', 'Mo', 'Tu', 'We', 'Th', 'Fr', 'Sa'],
   *   short: ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'],
   *   long: ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday']
   * }
   * locale.localize.weekdays = buildLocalizeArrayFn(weekdayValues, 'long')
   * locale.localize.weekdays({type: 'narrow'}) //=> ['Su', 'Mo', ...]
   * locale.localize.weekdays() //=> ['Sunday', 'Monday', ...]
   */
  function buildLocalizeArrayFn (values, defaultType) {
    return function (dirtyOptions) {
      var options = dirtyOptions || {};
      var type = options.type ? String(options.type) : defaultType;
      return values[type] || values[defaultType]
    }
  }

  // Note: in English, the names of days of the week and months are capitalized.
  // If you are making a new locale based on this one, check if the same is true for the language you're working on.
  // Generally, formatted dates should look like they are in the middle of a sentence,
  // e.g. in Spanish language the weekdays and months should be in the lowercase.
  var weekdayValues = {
    narrow: ['Su', 'Mo', 'Tu', 'We', 'Th', 'Fr', 'Sa'],
    short: ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'],
    long: ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday']
  };

  var monthValues = {
    short: ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'],
    long: ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December']
  };

  // `timeOfDay` is used to designate which part of the day it is, when used with 12-hour clock.
  // Use the system which is used the most commonly in the locale.
  // For example, if the country doesn't use a.m./p.m., you can use `night`/`morning`/`afternoon`/`evening`:
  //
  //   var timeOfDayValues = {
  //     any: ['in the night', 'in the morning', 'in the afternoon', 'in the evening']
  //   }
  //
  // And later:
  //
  //   var localize = {
  //     // The callback takes the hours as the argument and returns the array index
  //     timeOfDay: buildLocalizeFn(timeOfDayValues, 'any', function (hours) {
  //       if (hours >= 17) {
  //         return 3
  //       } else if (hours >= 12) {
  //         return 2
  //       } else if (hours >= 4) {
  //         return 1
  //       } else {
  //         return 0
  //       }
  //     }),
  //     timesOfDay: buildLocalizeArrayFn(timeOfDayValues, 'any')
  //   }
  var timeOfDayValues = {
    uppercase: ['AM', 'PM'],
    lowercase: ['am', 'pm'],
    long: ['a.m.', 'p.m.']
  };

  function ordinalNumber (dirtyNumber, dirtyOptions) {
    var number = Number(dirtyNumber);

    // If ordinal numbers depend on context, for example,
    // if they are different for different grammatical genders,
    // use `options.unit`:
    //
    //   var options = dirtyOptions || {}
    //   var unit = String(options.unit)
    //
    // where `unit` can be 'month', 'quarter', 'week', 'isoWeek', 'dayOfYear',
    // 'dayOfMonth' or 'dayOfWeek'

    var rem100 = number % 100;
    if (rem100 > 20 || rem100 < 10) {
      switch (rem100 % 10) {
        case 1:
          return number + 'st'
        case 2:
          return number + 'nd'
        case 3:
          return number + 'rd'
      }
    }
    return number + 'th'
  }

  var localize = {
    ordinalNumber: ordinalNumber,
    weekday: buildLocalizeFn(weekdayValues, 'long'),
    weekdays: buildLocalizeArrayFn(weekdayValues, 'long'),
    month: buildLocalizeFn(monthValues, 'long'),
    months: buildLocalizeArrayFn(monthValues, 'long'),
    timeOfDay: buildLocalizeFn(timeOfDayValues, 'long', function (hours) {
      return (hours / 12) >= 1 ? 1 : 0
    }),
    timesOfDay: buildLocalizeArrayFn(timeOfDayValues, 'long')
  };

  /**
   * @name buildMatchFn
   * @category Locale Helpers
   * @summary Build `match.weekdays`, `match.months` and `match.timesOfDay` properties for the locale.
   *
   * @description
   * Build `match.weekdays`, `match.months` and `match.timesOfDay` properties for the locale used by `parse` function.
   * If no `type` is supplied to the options of the resulting function, `defaultType` will be used (see example).
   * The result of the match function will be passed into corresponding parser function
   * (`match.weekday`, `match.month` or `match.timeOfDay` respectively. See `buildParseFn`).
   *
   * @param {Object} values - the object with RegExps
   * @param {String} defaultType - the default type for the match function
   * @returns {Function} the resulting function
   *
   * @example
   * var matchWeekdaysPatterns = {
   *   narrow: /^(su|mo|tu|we|th|fr|sa)/i,
   *   short: /^(sun|mon|tue|wed|thu|fri|sat)/i,
   *   long: /^(sunday|monday|tuesday|wednesday|thursday|friday|saturday)/i
   * }
   * locale.match.weekdays = buildMatchFn(matchWeekdaysPatterns, 'long')
   * locale.match.weekdays('Sunday', {type: 'narrow'}) //=> ['Su', 'Su', ...]
   * locale.match.weekdays('Sunday') //=> ['Sunday', 'Sunday', ...]
   */
  function buildMatchFn (patterns, defaultType) {
    return function (dirtyString, dirtyOptions) {
      var options = dirtyOptions || {};
      var type = options.type ? String(options.type) : defaultType;
      var pattern = patterns[type] || patterns[defaultType];
      var string = String(dirtyString);
      return string.match(pattern)
    }
  }

  /**
   * @name buildParseFn
   * @category Locale Helpers
   * @summary Build `match.weekday`, `match.month` and `match.timeOfDay` properties for the locale.
   *
   * @description
   * Build `match.weekday`, `match.month` and `match.timeOfDay` properties for the locale used by `parse` function.
   * The argument of the resulting function is the result of the corresponding match function
   * (`match.weekdays`, `match.months` or `match.timesOfDay` respectively. See `buildMatchFn`).
   *
   * @param {Object} values - the object with arrays of RegExps
   * @param {String} defaultType - the default type for the parser function
   * @returns {Function} the resulting function
   *
   * @example
   * var parseWeekdayPatterns = {
   *   any: [/^su/i, /^m/i, /^tu/i, /^w/i, /^th/i, /^f/i, /^sa/i]
   * }
   * locale.match.weekday = buildParseFn(matchWeekdaysPatterns, 'long')
   * var matchResult = locale.match.weekdays('Friday')
   * locale.match.weekday(matchResult) //=> 5
   */
  function buildParseFn (patterns, defaultType) {
    return function (matchResult, dirtyOptions) {
      var options = dirtyOptions || {};
      var type = options.type ? String(options.type) : defaultType;
      var patternsArray = patterns[type] || patterns[defaultType];
      var string = matchResult[1];

      return patternsArray.findIndex(function (pattern) {
        return pattern.test(string)
      })
    }
  }

  /**
   * @name buildMatchPatternFn
   * @category Locale Helpers
   * @summary Build match function from a single RegExp.
   *
   * @description
   * Build match function from a single RegExp.
   * Usually used for building `match.ordinalNumbers` property of the locale.
   *
   * @param {Object} pattern - the RegExp
   * @returns {Function} the resulting function
   *
   * @example
   * locale.match.ordinalNumbers = buildMatchPatternFn(/^(\d+)(th|st|nd|rd)?/i)
   * locale.match.ordinalNumbers('3rd') //=> ['3rd', '3', 'rd', ...]
   */
  function buildMatchPatternFn (pattern) {
    return function (dirtyString) {
      var string = String(dirtyString);
      return string.match(pattern)
    }
  }

  /**
   * @name parseDecimal
   * @category Locale Helpers
   * @summary Parses the match result into decimal number.
   *
   * @description
   * Parses the match result into decimal number.
   * Uses the string matched with the first set of parentheses of match RegExp.
   *
   * @param {Array} matchResult - the object returned by matching function
   * @returns {Number} the parsed value
   *
   * @example
   * locale.match = {
   *   ordinalNumbers: (dirtyString) {
   *     return String(dirtyString).match(/^(\d+)(th|st|nd|rd)?/i)
   *   },
   *   ordinalNumber: parseDecimal
   * }
   */
  function parseDecimal (matchResult) {
    return parseInt(matchResult[1], 10)
  }

  var matchOrdinalNumbersPattern = /^(\d+)(th|st|nd|rd)?/i;

  var matchWeekdaysPatterns = {
    narrow: /^(su|mo|tu|we|th|fr|sa)/i,
    short: /^(sun|mon|tue|wed|thu|fri|sat)/i,
    long: /^(sunday|monday|tuesday|wednesday|thursday|friday|saturday)/i
  };

  var parseWeekdayPatterns = {
    any: [/^su/i, /^m/i, /^tu/i, /^w/i, /^th/i, /^f/i, /^sa/i]
  };

  var matchMonthsPatterns = {
    short: /^(jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)/i,
    long: /^(january|february|march|april|may|june|july|august|september|october|november|december)/i
  };

  var parseMonthPatterns = {
    any: [/^ja/i, /^f/i, /^mar/i, /^ap/i, /^may/i, /^jun/i, /^jul/i, /^au/i, /^s/i, /^o/i, /^n/i, /^d/i]
  };

  // `timeOfDay` is used to designate which part of the day it is, when used with 12-hour clock.
  // Use the system which is used the most commonly in the locale.
  // For example, if the country doesn't use a.m./p.m., you can use `night`/`morning`/`afternoon`/`evening`:
  //
  //   var matchTimesOfDayPatterns = {
  //     long: /^((in the)? (night|morning|afternoon|evening?))/i
  //   }
  //
  //   var parseTimeOfDayPatterns = {
  //     any: [/(night|morning)/i, /(afternoon|evening)/i]
  //   }
  var matchTimesOfDayPatterns = {
    short: /^(am|pm)/i,
    long: /^([ap]\.?\s?m\.?)/i
  };

  var parseTimeOfDayPatterns = {
    any: [/^a/i, /^p/i]
  };

  var match = {
    ordinalNumbers: buildMatchPatternFn(matchOrdinalNumbersPattern),
    ordinalNumber: parseDecimal,
    weekdays: buildMatchFn(matchWeekdaysPatterns, 'long'),
    weekday: buildParseFn(parseWeekdayPatterns, 'any'),
    months: buildMatchFn(matchMonthsPatterns, 'long'),
    month: buildParseFn(parseMonthPatterns, 'any'),
    timesOfDay: buildMatchFn(matchTimesOfDayPatterns, 'long'),
    timeOfDay: buildParseFn(parseTimeOfDayPatterns, 'any')
  };

  /**
   * @type {Locale}
   * @category Locales
   * @summary English locale (United States).
   * @language English
   * @iso-639-2 eng
   */
  var locale$1 = {
    formatDistance: formatDistance,
    formatLong: formatLong,
    formatRelative: formatRelative,
    localize: localize,
    match: match,
    options: {
      weekStartsOn: 0 /* Sunday */,
      firstWeekContainsDate: 1
    }
  };

  var MILLISECONDS_IN_DAY$1 = 86400000;

  // This function will be a part of public API when UTC function will be implemented.
  // See issue: https://github.com/date-fns/date-fns/issues/376
  function getUTCDayOfYear (dirtyDate, dirtyOptions) {
    var date = toDate(dirtyDate, dirtyOptions);
    var timestamp = date.getTime();
    date.setUTCMonth(0, 1);
    date.setUTCHours(0, 0, 0, 0);
    var startOfYearTimestamp = date.getTime();
    var difference = timestamp - startOfYearTimestamp;
    return Math.floor(difference / MILLISECONDS_IN_DAY$1) + 1
  }

  // This function will be a part of public API when UTC function will be implemented.
  // See issue: https://github.com/date-fns/date-fns/issues/376
  function startOfUTCISOWeek (dirtyDate, dirtyOptions) {
    var weekStartsOn = 1;

    var date = toDate(dirtyDate, dirtyOptions);
    var day = date.getUTCDay();
    var diff = (day < weekStartsOn ? 7 : 0) + day - weekStartsOn;

    date.setUTCDate(date.getUTCDate() - diff);
    date.setUTCHours(0, 0, 0, 0);
    return date
  }

  // This function will be a part of public API when UTC function will be implemented.
  // See issue: https://github.com/date-fns/date-fns/issues/376
  function getUTCISOWeekYear (dirtyDate, dirtyOptions) {
    var date = toDate(dirtyDate, dirtyOptions);
    var year = date.getUTCFullYear();

    var fourthOfJanuaryOfNextYear = new Date(0);
    fourthOfJanuaryOfNextYear.setUTCFullYear(year + 1, 0, 4);
    fourthOfJanuaryOfNextYear.setUTCHours(0, 0, 0, 0);
    var startOfNextYear = startOfUTCISOWeek(fourthOfJanuaryOfNextYear, dirtyOptions);

    var fourthOfJanuaryOfThisYear = new Date(0);
    fourthOfJanuaryOfThisYear.setUTCFullYear(year, 0, 4);
    fourthOfJanuaryOfThisYear.setUTCHours(0, 0, 0, 0);
    var startOfThisYear = startOfUTCISOWeek(fourthOfJanuaryOfThisYear, dirtyOptions);

    if (date.getTime() >= startOfNextYear.getTime()) {
      return year + 1
    } else if (date.getTime() >= startOfThisYear.getTime()) {
      return year
    } else {
      return year - 1
    }
  }

  // This function will be a part of public API when UTC function will be implemented.
  // See issue: https://github.com/date-fns/date-fns/issues/376
  function startOfUTCISOWeekYear (dirtyDate, dirtyOptions) {
    var year = getUTCISOWeekYear(dirtyDate, dirtyOptions);
    var fourthOfJanuary = new Date(0);
    fourthOfJanuary.setUTCFullYear(year, 0, 4);
    fourthOfJanuary.setUTCHours(0, 0, 0, 0);
    var date = startOfUTCISOWeek(fourthOfJanuary, dirtyOptions);
    return date
  }

  var MILLISECONDS_IN_WEEK$2 = 604800000;

  // This function will be a part of public API when UTC function will be implemented.
  // See issue: https://github.com/date-fns/date-fns/issues/376
  function getUTCISOWeek (dirtyDate, dirtyOptions) {
    var date = toDate(dirtyDate, dirtyOptions);
    var diff = startOfUTCISOWeek(date, dirtyOptions).getTime() - startOfUTCISOWeekYear(date, dirtyOptions).getTime();

    // Round the number of days to the nearest integer
    // because the number of milliseconds in a week is not constant
    // (e.g. it's different in the week of the daylight saving time clock shift)
    return Math.round(diff / MILLISECONDS_IN_WEEK$2) + 1
  }

  var formatters = {
    // Month: 1, 2, ..., 12
    'M': function (date) {
      return date.getUTCMonth() + 1
    },

    // Month: 1st, 2nd, ..., 12th
    'Mo': function (date, options) {
      var month = date.getUTCMonth() + 1;
      return options.locale.localize.ordinalNumber(month, {unit: 'month'})
    },

    // Month: 01, 02, ..., 12
    'MM': function (date) {
      return addLeadingZeros(date.getUTCMonth() + 1, 2)
    },

    // Month: Jan, Feb, ..., Dec
    'MMM': function (date, options) {
      return options.locale.localize.month(date.getUTCMonth(), {type: 'short'})
    },

    // Month: January, February, ..., December
    'MMMM': function (date, options) {
      return options.locale.localize.month(date.getUTCMonth(), {type: 'long'})
    },

    // Quarter: 1, 2, 3, 4
    'Q': function (date) {
      return Math.ceil((date.getUTCMonth() + 1) / 3)
    },

    // Quarter: 1st, 2nd, 3rd, 4th
    'Qo': function (date, options) {
      var quarter = Math.ceil((date.getUTCMonth() + 1) / 3);
      return options.locale.localize.ordinalNumber(quarter, {unit: 'quarter'})
    },

    // Day of month: 1, 2, ..., 31
    'D': function (date) {
      return date.getUTCDate()
    },

    // Day of month: 1st, 2nd, ..., 31st
    'Do': function (date, options) {
      return options.locale.localize.ordinalNumber(date.getUTCDate(), {unit: 'dayOfMonth'})
    },

    // Day of month: 01, 02, ..., 31
    'DD': function (date) {
      return addLeadingZeros(date.getUTCDate(), 2)
    },

    // Day of year: 1, 2, ..., 366
    'DDD': function (date) {
      return getUTCDayOfYear(date)
    },

    // Day of year: 1st, 2nd, ..., 366th
    'DDDo': function (date, options) {
      return options.locale.localize.ordinalNumber(getUTCDayOfYear(date), {unit: 'dayOfYear'})
    },

    // Day of year: 001, 002, ..., 366
    'DDDD': function (date) {
      return addLeadingZeros(getUTCDayOfYear(date), 3)
    },

    // Day of week: Su, Mo, ..., Sa
    'dd': function (date, options) {
      return options.locale.localize.weekday(date.getUTCDay(), {type: 'narrow'})
    },

    // Day of week: Sun, Mon, ..., Sat
    'ddd': function (date, options) {
      return options.locale.localize.weekday(date.getUTCDay(), {type: 'short'})
    },

    // Day of week: Sunday, Monday, ..., Saturday
    'dddd': function (date, options) {
      return options.locale.localize.weekday(date.getUTCDay(), {type: 'long'})
    },

    // Day of week: 0, 1, ..., 6
    'd': function (date) {
      return date.getUTCDay()
    },

    // Day of week: 0th, 1st, 2nd, ..., 6th
    'do': function (date, options) {
      return options.locale.localize.ordinalNumber(date.getUTCDay(), {unit: 'dayOfWeek'})
    },

    // Day of ISO week: 1, 2, ..., 7
    'E': function (date) {
      return date.getUTCDay() || 7
    },

    // ISO week: 1, 2, ..., 53
    'W': function (date) {
      return getUTCISOWeek(date)
    },

    // ISO week: 1st, 2nd, ..., 53th
    'Wo': function (date, options) {
      return options.locale.localize.ordinalNumber(getUTCISOWeek(date), {unit: 'isoWeek'})
    },

    // ISO week: 01, 02, ..., 53
    'WW': function (date) {
      return addLeadingZeros(getUTCISOWeek(date), 2)
    },

    // Year: 00, 01, ..., 99
    'YY': function (date) {
      return addLeadingZeros(date.getUTCFullYear(), 4).substr(2)
    },

    // Year: 1900, 1901, ..., 2099
    'YYYY': function (date) {
      return addLeadingZeros(date.getUTCFullYear(), 4)
    },

    // ISO week-numbering year: 00, 01, ..., 99
    'GG': function (date) {
      return String(getUTCISOWeekYear(date)).substr(2)
    },

    // ISO week-numbering year: 1900, 1901, ..., 2099
    'GGGG': function (date) {
      return getUTCISOWeekYear(date)
    },

    // Hour: 0, 1, ... 23
    'H': function (date) {
      return date.getUTCHours()
    },

    // Hour: 00, 01, ..., 23
    'HH': function (date) {
      return addLeadingZeros(date.getUTCHours(), 2)
    },

    // Hour: 1, 2, ..., 12
    'h': function (date) {
      var hours = date.getUTCHours();
      if (hours === 0) {
        return 12
      } else if (hours > 12) {
        return hours % 12
      } else {
        return hours
      }
    },

    // Hour: 01, 02, ..., 12
    'hh': function (date) {
      return addLeadingZeros(formatters['h'](date), 2)
    },

    // Minute: 0, 1, ..., 59
    'm': function (date) {
      return date.getUTCMinutes()
    },

    // Minute: 00, 01, ..., 59
    'mm': function (date) {
      return addLeadingZeros(date.getUTCMinutes(), 2)
    },

    // Second: 0, 1, ..., 59
    's': function (date) {
      return date.getUTCSeconds()
    },

    // Second: 00, 01, ..., 59
    'ss': function (date) {
      return addLeadingZeros(date.getUTCSeconds(), 2)
    },

    // 1/10 of second: 0, 1, ..., 9
    'S': function (date) {
      return Math.floor(date.getUTCMilliseconds() / 100)
    },

    // 1/100 of second: 00, 01, ..., 99
    'SS': function (date) {
      return addLeadingZeros(Math.floor(date.getUTCMilliseconds() / 10), 2)
    },

    // Millisecond: 000, 001, ..., 999
    'SSS': function (date) {
      return addLeadingZeros(date.getUTCMilliseconds(), 3)
    },

    // Timezone: -01:00, +00:00, ... +12:00
    'Z': function (date, options) {
      var originalDate = options._originalDate || date;
      return formatTimezone(originalDate.getTimezoneOffset(), ':')
    },

    // Timezone: -0100, +0000, ... +1200
    'ZZ': function (date, options) {
      var originalDate = options._originalDate || date;
      return formatTimezone(originalDate.getTimezoneOffset())
    },

    // Seconds timestamp: 512969520
    'X': function (date, options) {
      var originalDate = options._originalDate || date;
      return Math.floor(originalDate.getTime() / 1000)
    },

    // Milliseconds timestamp: 512969520900
    'x': function (date, options) {
      var originalDate = options._originalDate || date;
      return originalDate.getTime()
    },

    // AM, PM
    'A': function (date, options) {
      return options.locale.localize.timeOfDay(date.getUTCHours(), {type: 'uppercase'})
    },

    // am, pm
    'a': function (date, options) {
      return options.locale.localize.timeOfDay(date.getUTCHours(), {type: 'lowercase'})
    },

    // a.m., p.m.
    'aa': function (date, options) {
      return options.locale.localize.timeOfDay(date.getUTCHours(), {type: 'long'})
    }
  };

  function formatTimezone (offset, delimeter) {
    delimeter = delimeter || '';
    var sign = offset > 0 ? '-' : '+';
    var absOffset = Math.abs(offset);
    var hours = Math.floor(absOffset / 60);
    var minutes = absOffset % 60;
    return sign + addLeadingZeros(hours, 2) + delimeter + addLeadingZeros(minutes, 2)
  }

  function addLeadingZeros (number, targetLength) {
    var output = Math.abs(number).toString();
    while (output.length < targetLength) {
      output = '0' + output;
    }
    return output
  }

  // This function will be a part of public API when UTC function will be implemented.
  // See issue: https://github.com/date-fns/date-fns/issues/376
  function addUTCMinutes (dirtyDate, dirtyAmount, dirtyOptions) {
    var date = toDate(dirtyDate, dirtyOptions);
    var amount = Number(dirtyAmount);
    date.setUTCMinutes(date.getUTCMinutes() + amount);
    return date
  }

  var longFormattingTokensRegExp = /(\[[^[]*])|(\\)?(LTS|LT|LLLL|LLL|LL|L|llll|lll|ll|l)/g;
  var defaultFormattingTokensRegExp = /(\[[^[]*])|(\\)?(x|ss|s|mm|m|hh|h|do|dddd|ddd|dd|d|aa|a|ZZ|Z|YYYY|YY|X|Wo|WW|W|SSS|SS|S|Qo|Q|Mo|MMMM|MMM|MM|M|HH|H|GGGG|GG|E|Do|DDDo|DDDD|DDD|DD|D|A|.)/g;

  /**
   * @name format
   * @category Common Helpers
   * @summary Format the date.
   *
   * @description
   * Return the formatted date string in the given format.
   *
   * Accepted tokens:
   * | Unit                    | Token | Result examples                  |
   * |-------------------------|-------|----------------------------------|
   * | Month                   | M     | 1, 2, ..., 12                    |
   * |                         | Mo    | 1st, 2nd, ..., 12th              |
   * |                         | MM    | 01, 02, ..., 12                  |
   * |                         | MMM   | Jan, Feb, ..., Dec               |
   * |                         | MMMM  | January, February, ..., December |
   * | Quarter                 | Q     | 1, 2, 3, 4                       |
   * |                         | Qo    | 1st, 2nd, 3rd, 4th               |
   * | Day of month            | D     | 1, 2, ..., 31                    |
   * |                         | Do    | 1st, 2nd, ..., 31st              |
   * |                         | DD    | 01, 02, ..., 31                  |
   * | Day of year             | DDD   | 1, 2, ..., 366                   |
   * |                         | DDDo  | 1st, 2nd, ..., 366th             |
   * |                         | DDDD  | 001, 002, ..., 366               |
   * | Day of week             | d     | 0, 1, ..., 6                     |
   * |                         | do    | 0th, 1st, ..., 6th               |
   * |                         | dd    | Su, Mo, ..., Sa                  |
   * |                         | ddd   | Sun, Mon, ..., Sat               |
   * |                         | dddd  | Sunday, Monday, ..., Saturday    |
   * | Day of ISO week         | E     | 1, 2, ..., 7                     |
   * | ISO week                | W     | 1, 2, ..., 53                    |
   * |                         | Wo    | 1st, 2nd, ..., 53rd              |
   * |                         | WW    | 01, 02, ..., 53                  |
   * | Year                    | YY    | 00, 01, ..., 99                  |
   * |                         | YYYY  | 1900, 1901, ..., 2099            |
   * | ISO week-numbering year | GG    | 00, 01, ..., 99                  |
   * |                         | GGGG  | 1900, 1901, ..., 2099            |
   * | AM/PM                   | A     | AM, PM                           |
   * |                         | a     | am, pm                           |
   * |                         | aa    | a.m., p.m.                       |
   * | Hour                    | H     | 0, 1, ... 23                     |
   * |                         | HH    | 00, 01, ... 23                   |
   * |                         | h     | 1, 2, ..., 12                    |
   * |                         | hh    | 01, 02, ..., 12                  |
   * | Minute                  | m     | 0, 1, ..., 59                    |
   * |                         | mm    | 00, 01, ..., 59                  |
   * | Second                  | s     | 0, 1, ..., 59                    |
   * |                         | ss    | 00, 01, ..., 59                  |
   * | 1/10 of second          | S     | 0, 1, ..., 9                     |
   * | 1/100 of second         | SS    | 00, 01, ..., 99                  |
   * | Millisecond             | SSS   | 000, 001, ..., 999               |
   * | Timezone                | Z     | -01:00, +00:00, ... +12:00       |
   * |                         | ZZ    | -0100, +0000, ..., +1200         |
   * | Seconds timestamp       | X     | 512969520                        |
   * | Milliseconds timestamp  | x     | 512969520900                     |
   * | Long format             | LT    | 05:30 a.m.                       |
   * |                         | LTS   | 05:30:15 a.m.                    |
   * |                         | L     | 07/02/1995                       |
   * |                         | l     | 7/2/1995                         |
   * |                         | LL    | July 2 1995                      |
   * |                         | ll    | Jul 2 1995                       |
   * |                         | LLL   | July 2 1995 05:30 a.m.           |
   * |                         | lll   | Jul 2 1995 05:30 a.m.            |
   * |                         | LLLL  | Sunday, July 2 1995 05:30 a.m.   |
   * |                         | llll  | Sun, Jul 2 1995 05:30 a.m.       |
   *
   * The characters wrapped in square brackets are escaped.
   *
   * The result may vary by locale.
   *
   * @param {Date|String|Number} date - the original date
   * @param {String} format - the string of tokens
   * @param {Options} [options] - the object with options. See [Options]{@link https://date-fns.org/docs/Options}
   * @param {0|1|2} [options.additionalDigits=2] - passed to `toDate`. See [toDate]{@link https://date-fns.org/docs/toDate}
   * @param {Locale} [options.locale=defaultLocale] - the locale object. See [Locale]{@link https://date-fns.org/docs/Locale}
   * @returns {String} the formatted date string
   * @throws {TypeError} 2 arguments required
   * @throws {RangeError} `options.additionalDigits` must be 0, 1 or 2
   * @throws {RangeError} `options.locale` must contain `localize` property
   * @throws {RangeError} `options.locale` must contain `formatLong` property
   *
   * @example
   * // Represent 11 February 2014 in middle-endian format:
   * var result = format(
   *   new Date(2014, 1, 11),
   *   'MM/DD/YYYY'
   * )
   * //=> '02/11/2014'
   *
   * @example
   * // Represent 2 July 2014 in Esperanto:
   * import { eoLocale } from 'date-fns/locale/eo'
   * var result = format(
   *   new Date(2014, 6, 2),
   *   'Do [de] MMMM YYYY',
   *   {locale: eoLocale}
   * )
   * //=> '2-a de julio 2014'
   */
  function format (dirtyDate, dirtyFormatStr, dirtyOptions) {
    if (arguments.length < 2) {
      throw new TypeError('2 arguments required, but only ' + arguments.length + ' present')
    }

    var formatStr = String(dirtyFormatStr);
    var options = dirtyOptions || {};

    var locale = options.locale || locale$1;

    if (!locale.localize) {
      throw new RangeError('locale must contain localize property')
    }

    if (!locale.formatLong) {
      throw new RangeError('locale must contain formatLong property')
    }

    var localeFormatters = locale.formatters || {};
    var formattingTokensRegExp = locale.formattingTokensRegExp || defaultFormattingTokensRegExp;
    var formatLong = locale.formatLong;

    var originalDate = toDate(dirtyDate, options);

    if (!isValid(originalDate, options)) {
      return 'Invalid Date'
    }

    // Convert the date in system timezone to the same date in UTC+00:00 timezone.
    // This ensures that when UTC functions will be implemented, locales will be compatible with them.
    // See an issue about UTC functions: https://github.com/date-fns/date-fns/issues/376
    var timezoneOffset = originalDate.getTimezoneOffset();
    var utcDate = addUTCMinutes(originalDate, -timezoneOffset, options);

    var formatterOptions = cloneObject(options);
    formatterOptions.locale = locale;
    formatterOptions.formatters = formatters;

    // When UTC functions will be implemented, options._originalDate will likely be a part of public API.
    // Right now, please don't use it in locales. If you have to use an original date,
    // please restore it from `date`, adding a timezone offset to it.
    formatterOptions._originalDate = originalDate;

    var result = formatStr
      .replace(longFormattingTokensRegExp, function (substring) {
        if (substring[0] === '[') {
          return substring
        }

        if (substring[0] === '\\') {
          return cleanEscapedString(substring)
        }

        return formatLong(substring)
      })
      .replace(formattingTokensRegExp, function (substring) {
        var formatter = localeFormatters[substring] || formatters[substring];

        if (formatter) {
          return formatter(utcDate, formatterOptions)
        } else {
          return cleanEscapedString(substring)
        }
      });

    return result
  }

  function cleanEscapedString (input) {
    if (input.match(/\[[\s\S]/)) {
      return input.replace(/^\[|]$/g, '')
    }
    return input.replace(/\\/g, '')
  }

  /**
   * @name subMinutes
   * @category Minute Helpers
   * @summary Subtract the specified number of minutes from the given date.
   *
   * @description
   * Subtract the specified number of minutes from the given date.
   *
   * @param {Date|String|Number} date - the date to be changed
   * @param {Number} amount - the amount of minutes to be subtracted
   * @param {Options} [options] - the object with options. See [Options]{@link https://date-fns.org/docs/Options}
   * @param {0|1|2} [options.additionalDigits=2] - passed to `toDate`. See [toDate]{@link https://date-fns.org/docs/toDate}
   * @returns {Date} the new date with the mintues subtracted
   * @throws {TypeError} 2 arguments required
   * @throws {RangeError} `options.additionalDigits` must be 0, 1 or 2
   *
   * @example
   * // Subtract 30 minutes from 10 July 2014 12:00:00:
   * var result = subMinutes(new Date(2014, 6, 10, 12, 0), 30)
   * //=> Thu Jul 10 2014 11:30:00
   */
  function subMinutes (dirtyDate, dirtyAmount, dirtyOptions) {
    if (arguments.length < 2) {
      throw new TypeError('2 arguments required, but only ' + arguments.length + ' present')
    }

    var amount = Number(dirtyAmount);
    return addMinutes(dirtyDate, -amount, dirtyOptions)
  }

  /**
   * @name isAfter
   * @category Common Helpers
   * @summary Is the first date after the second one?
   *
   * @description
   * Is the first date after the second one?
   *
   * @param {Date|String|Number} date - the date that should be after the other one to return true
   * @param {Date|String|Number} dateToCompare - the date to compare with
   * @param {Options} [options] - the object with options. See [Options]{@link https://date-fns.org/docs/Options}
   * @param {0|1|2} [options.additionalDigits=2] - passed to `toDate`. See [toDate]{@link https://date-fns.org/docs/toDate}
   * @returns {Boolean} the first date is after the second date
   * @throws {TypeError} 2 arguments required
   * @throws {RangeError} `options.additionalDigits` must be 0, 1 or 2
   *
   * @example
   * // Is 10 July 1989 after 11 February 1987?
   * var result = isAfter(new Date(1989, 6, 10), new Date(1987, 1, 11))
   * //=> true
   */
  function isAfter (dirtyDate, dirtyDateToCompare, dirtyOptions) {
    if (arguments.length < 2) {
      throw new TypeError('2 arguments required, but only ' + arguments.length + ' present')
    }

    var date = toDate(dirtyDate, dirtyOptions);
    var dateToCompare = toDate(dirtyDateToCompare, dirtyOptions);
    return date.getTime() > dateToCompare.getTime()
  }

  /**
   * @name isBefore
   * @category Common Helpers
   * @summary Is the first date before the second one?
   *
   * @description
   * Is the first date before the second one?
   *
   * @param {Date|String|Number} date - the date that should be before the other one to return true
   * @param {Date|String|Number} dateToCompare - the date to compare with
   * @param {Options} [options] - the object with options. See [Options]{@link https://date-fns.org/docs/Options}
   * @param {0|1|2} [options.additionalDigits=2] - passed to `toDate`. See [toDate]{@link https://date-fns.org/docs/toDate}
   * @returns {Boolean} the first date is before the second date
   * @throws {TypeError} 2 arguments required
   * @throws {RangeError} `options.additionalDigits` must be 0, 1 or 2
   *
   * @example
   * // Is 10 July 1989 before 11 February 1987?
   * var result = isBefore(new Date(1989, 6, 10), new Date(1987, 1, 11))
   * //=> false
   */
  function isBefore (dirtyDate, dirtyDateToCompare, dirtyOptions) {
    if (arguments.length < 2) {
      throw new TypeError('2 arguments required, but only ' + arguments.length + ' present')
    }

    var date = toDate(dirtyDate, dirtyOptions);
    var dateToCompare = toDate(dirtyDateToCompare, dirtyOptions);
    return date.getTime() < dateToCompare.getTime()
  }

  /**
   * @name isEqual
   * @category Common Helpers
   * @summary Are the given dates equal?
   *
   * @description
   * Are the given dates equal?
   *
   * @param {Date|String|Number} dateLeft - the first date to compare
   * @param {Date|String|Number} dateRight - the second date to compare
   * @param {Options} [options] - the object with options. See [Options]{@link https://date-fns.org/docs/Options}
   * @param {0|1|2} [options.additionalDigits=2] - passed to `toDate`. See [toDate]{@link https://date-fns.org/docs/toDate}
   * @returns {Boolean} the dates are equal
   * @throws {TypeError} 2 arguments required
   * @throws {RangeError} `options.additionalDigits` must be 0, 1 or 2
   *
   * @example
   * // Are 2 July 2014 06:30:45.000 and 2 July 2014 06:30:45.500 equal?
   * var result = isEqual(
   *   new Date(2014, 6, 2, 6, 30, 45, 0)
   *   new Date(2014, 6, 2, 6, 30, 45, 500)
   * )
   * //=> false
   */
  function isEqual$1 (dirtyLeftDate, dirtyRightDate, dirtyOptions) {
    if (arguments.length < 2) {
      throw new TypeError('2 arguments required, but only ' + arguments.length + ' present')
    }

    var dateLeft = toDate(dirtyLeftDate, dirtyOptions);
    var dateRight = toDate(dirtyRightDate, dirtyOptions);
    return dateLeft.getTime() === dateRight.getTime()
  }

  var patterns$1 = {
    'M': /^(1[0-2]|0?\d)/, // 0 to 12
    'D': /^(3[0-1]|[0-2]?\d)/, // 0 to 31
    'DDD': /^(36[0-6]|3[0-5]\d|[0-2]?\d?\d)/, // 0 to 366
    'W': /^(5[0-3]|[0-4]?\d)/, // 0 to 53
    'YYYY': /^(\d{1,4})/, // 0 to 9999
    'H': /^(2[0-3]|[0-1]?\d)/, // 0 to 23
    'm': /^([0-5]?\d)/, // 0 to 59
    'Z': /^([+-])(\d{2}):(\d{2})/,
    'ZZ': /^([+-])(\d{2})(\d{2})/,
    singleDigit: /^(\d)/,
    twoDigits: /^(\d{2})/,
    threeDigits: /^(\d{3})/,
    fourDigits: /^(\d{4})/,
    anyDigits: /^(\d+)/
  };

  function parseDecimal$1 (matchResult) {
    return parseInt(matchResult[1], 10)
  }

  var parsers = {
    // Year: 00, 01, ..., 99
    'YY': {
      unit: 'twoDigitYear',
      match: patterns$1.twoDigits,
      parse: function (matchResult) {
        return parseDecimal$1(matchResult)
      }
    },

    // Year: 1900, 1901, ..., 2099
    'YYYY': {
      unit: 'year',
      match: patterns$1.YYYY,
      parse: parseDecimal$1
    },

    // ISO week-numbering year: 00, 01, ..., 99
    'GG': {
      unit: 'isoYear',
      match: patterns$1.twoDigits,
      parse: function (matchResult) {
        return parseDecimal$1(matchResult) + 1900
      }
    },

    // ISO week-numbering year: 1900, 1901, ..., 2099
    'GGGG': {
      unit: 'isoYear',
      match: patterns$1.YYYY,
      parse: parseDecimal$1
    },

    // Quarter: 1, 2, 3, 4
    'Q': {
      unit: 'quarter',
      match: patterns$1.singleDigit,
      parse: parseDecimal$1
    },

    // Ordinal quarter
    'Qo': {
      unit: 'quarter',
      match: function (string, options) {
        return options.locale.match.ordinalNumbers(string, {unit: 'quarter'})
      },
      parse: function (matchResult, options) {
        return options.locale.match.ordinalNumber(matchResult, {unit: 'quarter'})
      }
    },

    // Month: 1, 2, ..., 12
    'M': {
      unit: 'month',
      match: patterns$1.M,
      parse: function (matchResult) {
        return parseDecimal$1(matchResult) - 1
      }
    },

    // Ordinal month
    'Mo': {
      unit: 'month',
      match: function (string, options) {
        return options.locale.match.ordinalNumbers(string, {unit: 'month'})
      },
      parse: function (matchResult, options) {
        return options.locale.match.ordinalNumber(matchResult, {unit: 'month'}) - 1
      }
    },

    // Month: 01, 02, ..., 12
    'MM': {
      unit: 'month',
      match: patterns$1.twoDigits,
      parse: function (matchResult) {
        return parseDecimal$1(matchResult) - 1
      }
    },

    // Month: Jan, Feb, ..., Dec
    'MMM': {
      unit: 'month',
      match: function (string, options) {
        return options.locale.match.months(string, {type: 'short'})
      },
      parse: function (matchResult, options) {
        return options.locale.match.month(matchResult, {type: 'short'})
      }
    },

    // Month: January, February, ..., December
    'MMMM': {
      unit: 'month',
      match: function (string, options) {
        return options.locale.match.months(string, {type: 'long'}) ||
          options.locale.match.months(string, {type: 'short'})
      },
      parse: function (matchResult, options) {
        var parseResult = options.locale.match.month(matchResult, {type: 'long'});

        if (parseResult == null) {
          parseResult = options.locale.match.month(matchResult, {type: 'short'});
        }

        return parseResult
      }
    },

    // ISO week: 1, 2, ..., 53
    'W': {
      unit: 'isoWeek',
      match: patterns$1.W,
      parse: parseDecimal$1
    },

    // Ordinal ISO week
    'Wo': {
      unit: 'isoWeek',
      match: function (string, options) {
        return options.locale.match.ordinalNumbers(string, {unit: 'isoWeek'})
      },
      parse: function (matchResult, options) {
        return options.locale.match.ordinalNumber(matchResult, {unit: 'isoWeek'})
      }
    },

    // ISO week: 01, 02, ..., 53
    'WW': {
      unit: 'isoWeek',
      match: patterns$1.twoDigits,
      parse: parseDecimal$1
    },

    // Day of week: 0, 1, ..., 6
    'd': {
      unit: 'dayOfWeek',
      match: patterns$1.singleDigit,
      parse: parseDecimal$1
    },

    // Ordinal day of week
    'do': {
      unit: 'dayOfWeek',
      match: function (string, options) {
        return options.locale.match.ordinalNumbers(string, {unit: 'dayOfWeek'})
      },
      parse: function (matchResult, options) {
        return options.locale.match.ordinalNumber(matchResult, {unit: 'dayOfWeek'})
      }
    },

    // Day of week: Su, Mo, ..., Sa
    'dd': {
      unit: 'dayOfWeek',
      match: function (string, options) {
        return options.locale.match.weekdays(string, {type: 'narrow'})
      },
      parse: function (matchResult, options) {
        return options.locale.match.weekday(matchResult, {type: 'narrow'})
      }
    },

    // Day of week: Sun, Mon, ..., Sat
    'ddd': {
      unit: 'dayOfWeek',
      match: function (string, options) {
        return options.locale.match.weekdays(string, {type: 'short'}) ||
          options.locale.match.weekdays(string, {type: 'narrow'})
      },
      parse: function (matchResult, options) {
        var parseResult = options.locale.match.weekday(matchResult, {type: 'short'});

        if (parseResult == null) {
          parseResult = options.locale.match.weekday(matchResult, {type: 'narrow'});
        }

        return parseResult
      }
    },

    // Day of week: Sunday, Monday, ..., Saturday
    'dddd': {
      unit: 'dayOfWeek',
      match: function (string, options) {
        return options.locale.match.weekdays(string, {type: 'long'}) ||
          options.locale.match.weekdays(string, {type: 'short'}) ||
          options.locale.match.weekdays(string, {type: 'narrow'})
      },
      parse: function (matchResult, options) {
        var parseResult = options.locale.match.weekday(matchResult, {type: 'long'});

        if (parseResult == null) {
          parseResult = options.locale.match.weekday(matchResult, {type: 'short'});

          if (parseResult == null) {
            parseResult = options.locale.match.weekday(matchResult, {type: 'narrow'});
          }
        }

        return parseResult
      }
    },

    // Day of ISO week: 1, 2, ..., 7
    'E': {
      unit: 'dayOfISOWeek',
      match: patterns$1.singleDigit,
      parse: function (matchResult) {
        return parseDecimal$1(matchResult)
      }
    },

    // Day of month: 1, 2, ..., 31
    'D': {
      unit: 'dayOfMonth',
      match: patterns$1.D,
      parse: parseDecimal$1
    },

    // Ordinal day of month
    'Do': {
      unit: 'dayOfMonth',
      match: function (string, options) {
        return options.locale.match.ordinalNumbers(string, {unit: 'dayOfMonth'})
      },
      parse: function (matchResult, options) {
        return options.locale.match.ordinalNumber(matchResult, {unit: 'dayOfMonth'})
      }
    },

    // Day of month: 01, 02, ..., 31
    'DD': {
      unit: 'dayOfMonth',
      match: patterns$1.twoDigits,
      parse: parseDecimal$1
    },

    // Day of year: 1, 2, ..., 366
    'DDD': {
      unit: 'dayOfYear',
      match: patterns$1.DDD,
      parse: parseDecimal$1
    },

    // Ordinal day of year
    'DDDo': {
      unit: 'dayOfYear',
      match: function (string, options) {
        return options.locale.match.ordinalNumbers(string, {unit: 'dayOfYear'})
      },
      parse: function (matchResult, options) {
        return options.locale.match.ordinalNumber(matchResult, {unit: 'dayOfYear'})
      }
    },

    // Day of year: 001, 002, ..., 366
    'DDDD': {
      unit: 'dayOfYear',
      match: patterns$1.threeDigits,
      parse: parseDecimal$1
    },

    // AM, PM
    'A': {
      unit: 'timeOfDay',
      match: function (string, options) {
        return options.locale.match.timesOfDay(string, {type: 'short'})
      },
      parse: function (matchResult, options) {
        return options.locale.match.timeOfDay(matchResult, {type: 'short'})
      }
    },

    // a.m., p.m.
    'aa': {
      unit: 'timeOfDay',
      match: function (string, options) {
        return options.locale.match.timesOfDay(string, {type: 'long'}) ||
          options.locale.match.timesOfDay(string, {type: 'short'})
      },
      parse: function (matchResult, options) {
        var parseResult = options.locale.match.timeOfDay(matchResult, {type: 'long'});

        if (parseResult == null) {
          parseResult = options.locale.match.timeOfDay(matchResult, {type: 'short'});
        }

        return parseResult
      }
    },

    // Hour: 0, 1, ... 23
    'H': {
      unit: 'hours',
      match: patterns$1.H,
      parse: parseDecimal$1
    },

    // Hour: 00, 01, ..., 23
    'HH': {
      unit: 'hours',
      match: patterns$1.twoDigits,
      parse: parseDecimal$1
    },

    // Hour: 1, 2, ..., 12
    'h': {
      unit: 'timeOfDayHours',
      match: patterns$1.M,
      parse: parseDecimal$1
    },

    // Hour: 01, 02, ..., 12
    'hh': {
      unit: 'timeOfDayHours',
      match: patterns$1.twoDigits,
      parse: parseDecimal$1
    },

    // Minute: 0, 1, ..., 59
    'm': {
      unit: 'minutes',
      match: patterns$1.m,
      parse: parseDecimal$1
    },

    // Minute: 00, 01, ..., 59
    'mm': {
      unit: 'minutes',
      match: patterns$1.twoDigits,
      parse: parseDecimal$1
    },

    // Second: 0, 1, ..., 59
    's': {
      unit: 'seconds',
      match: patterns$1.m,
      parse: parseDecimal$1
    },

    // Second: 00, 01, ..., 59
    'ss': {
      unit: 'seconds',
      match: patterns$1.twoDigits,
      parse: parseDecimal$1
    },

    // 1/10 of second: 0, 1, ..., 9
    'S': {
      unit: 'milliseconds',
      match: patterns$1.singleDigit,
      parse: function (matchResult) {
        return parseDecimal$1(matchResult) * 100
      }
    },

    // 1/100 of second: 00, 01, ..., 99
    'SS': {
      unit: 'milliseconds',
      match: patterns$1.twoDigits,
      parse: function (matchResult) {
        return parseDecimal$1(matchResult) * 10
      }
    },

    // Millisecond: 000, 001, ..., 999
    'SSS': {
      unit: 'milliseconds',
      match: patterns$1.threeDigits,
      parse: parseDecimal$1
    },

    // Timezone: -01:00, +00:00, ... +12:00
    'Z': {
      unit: 'timezone',
      match: patterns$1.Z,
      parse: function (matchResult) {
        var sign = matchResult[1];
        var hours = parseInt(matchResult[2], 10);
        var minutes = parseInt(matchResult[3], 10);
        var absoluteOffset = hours * 60 + minutes;
        return (sign === '+') ? absoluteOffset : -absoluteOffset
      }
    },

    // Timezone: -0100, +0000, ... +1200
    'ZZ': {
      unit: 'timezone',
      match: patterns$1.ZZ,
      parse: function (matchResult) {
        var sign = matchResult[1];
        var hours = parseInt(matchResult[2], 10);
        var minutes = parseInt(matchResult[3], 10);
        var absoluteOffset = hours * 60 + minutes;
        return (sign === '+') ? absoluteOffset : -absoluteOffset
      }
    },

    // Seconds timestamp: 512969520
    'X': {
      unit: 'timestamp',
      match: patterns$1.anyDigits,
      parse: function (matchResult) {
        return parseDecimal$1(matchResult) * 1000
      }
    },

    // Milliseconds timestamp: 512969520900
    'x': {
      unit: 'timestamp',
      match: patterns$1.anyDigits,
      parse: parseDecimal$1
    }
  };

  parsers['a'] = parsers['A'];

  // This function will be a part of public API when UTC function will be implemented.
  // See issue: https://github.com/date-fns/date-fns/issues/376
  function setUTCDay (dirtyDate, dirtyDay, dirtyOptions) {
    var options = dirtyOptions || {};
    var locale = options.locale;
    var localeWeekStartsOn = locale && locale.options && locale.options.weekStartsOn;
    var defaultWeekStartsOn = localeWeekStartsOn === undefined ? 0 : Number(localeWeekStartsOn);
    var weekStartsOn = options.weekStartsOn === undefined ? defaultWeekStartsOn : Number(options.weekStartsOn);

    // Test if weekStartsOn is between 0 and 6 _and_ is not NaN
    if (!(weekStartsOn >= 0 && weekStartsOn <= 6)) {
      throw new RangeError('weekStartsOn must be between 0 and 6 inclusively')
    }

    var date = toDate(dirtyDate, dirtyOptions);
    var day = Number(dirtyDay);

    var currentDay = date.getUTCDay();

    var remainder = day % 7;
    var dayIndex = (remainder + 7) % 7;

    var diff = (dayIndex < weekStartsOn ? 7 : 0) + day - currentDay;

    date.setUTCDate(date.getUTCDate() + diff);
    return date
  }

  // This function will be a part of public API when UTC function will be implemented.
  // See issue: https://github.com/date-fns/date-fns/issues/376
  function setUTCISODay (dirtyDate, dirtyDay, dirtyOptions) {
    var day = Number(dirtyDay);

    if (day % 7 === 0) {
      day = day - 7;
    }

    var weekStartsOn = 1;
    var date = toDate(dirtyDate, dirtyOptions);
    var currentDay = date.getUTCDay();

    var remainder = day % 7;
    var dayIndex = (remainder + 7) % 7;

    var diff = (dayIndex < weekStartsOn ? 7 : 0) + day - currentDay;

    date.setUTCDate(date.getUTCDate() + diff);
    return date
  }

  // This function will be a part of public API when UTC function will be implemented.
  // See issue: https://github.com/date-fns/date-fns/issues/376
  function setUTCISOWeek (dirtyDate, dirtyISOWeek, dirtyOptions) {
    var date = toDate(dirtyDate, dirtyOptions);
    var isoWeek = Number(dirtyISOWeek);
    var diff = getUTCISOWeek(date, dirtyOptions) - isoWeek;
    date.setUTCDate(date.getUTCDate() - diff * 7);
    return date
  }

  var MILLISECONDS_IN_DAY$3 = 86400000;

  // This function will be a part of public API when UTC function will be implemented.
  // See issue: https://github.com/date-fns/date-fns/issues/376
  function setUTCISOWeekYear (dirtyDate, dirtyISOYear, dirtyOptions) {
    var date = toDate(dirtyDate, dirtyOptions);
    var isoYear = Number(dirtyISOYear);
    var dateStartOfYear = startOfUTCISOWeekYear(date, dirtyOptions);
    var diff = Math.floor((date.getTime() - dateStartOfYear.getTime()) / MILLISECONDS_IN_DAY$3);
    var fourthOfJanuary = new Date(0);
    fourthOfJanuary.setUTCFullYear(isoYear, 0, 4);
    fourthOfJanuary.setUTCHours(0, 0, 0, 0);
    date = startOfUTCISOWeekYear(fourthOfJanuary, dirtyOptions);
    date.setUTCDate(date.getUTCDate() + diff);
    return date
  }

  var MILLISECONDS_IN_MINUTE$7 = 60000;

  function setTimeOfDay (hours, timeOfDay) {
    var isAM = timeOfDay === 0;

    if (isAM) {
      if (hours === 12) {
        return 0
      }
    } else {
      if (hours !== 12) {
        return 12 + hours
      }
    }

    return hours
  }

  var units = {
    twoDigitYear: {
      priority: 10,
      set: function (dateValues, value) {
        var century = Math.floor(dateValues.date.getUTCFullYear() / 100);
        var year = century * 100 + value;
        dateValues.date.setUTCFullYear(year, 0, 1);
        dateValues.date.setUTCHours(0, 0, 0, 0);
        return dateValues
      }
    },

    year: {
      priority: 10,
      set: function (dateValues, value) {
        dateValues.date.setUTCFullYear(value, 0, 1);
        dateValues.date.setUTCHours(0, 0, 0, 0);
        return dateValues
      }
    },

    isoYear: {
      priority: 10,
      set: function (dateValues, value, options) {
        dateValues.date = startOfUTCISOWeekYear(setUTCISOWeekYear(dateValues.date, value, options), options);
        return dateValues
      }
    },

    quarter: {
      priority: 20,
      set: function (dateValues, value) {
        dateValues.date.setUTCMonth((value - 1) * 3, 1);
        dateValues.date.setUTCHours(0, 0, 0, 0);
        return dateValues
      }
    },

    month: {
      priority: 30,
      set: function (dateValues, value) {
        dateValues.date.setUTCMonth(value, 1);
        dateValues.date.setUTCHours(0, 0, 0, 0);
        return dateValues
      }
    },

    isoWeek: {
      priority: 40,
      set: function (dateValues, value, options) {
        dateValues.date = startOfUTCISOWeek(setUTCISOWeek(dateValues.date, value, options), options);
        return dateValues
      }
    },

    dayOfWeek: {
      priority: 50,
      set: function (dateValues, value, options) {
        dateValues.date = setUTCDay(dateValues.date, value, options);
        dateValues.date.setUTCHours(0, 0, 0, 0);
        return dateValues
      }
    },

    dayOfISOWeek: {
      priority: 50,
      set: function (dateValues, value, options) {
        dateValues.date = setUTCISODay(dateValues.date, value, options);
        dateValues.date.setUTCHours(0, 0, 0, 0);
        return dateValues
      }
    },

    dayOfMonth: {
      priority: 50,
      set: function (dateValues, value) {
        dateValues.date.setUTCDate(value);
        dateValues.date.setUTCHours(0, 0, 0, 0);
        return dateValues
      }
    },

    dayOfYear: {
      priority: 50,
      set: function (dateValues, value) {
        dateValues.date.setUTCMonth(0, value);
        dateValues.date.setUTCHours(0, 0, 0, 0);
        return dateValues
      }
    },

    timeOfDay: {
      priority: 60,
      set: function (dateValues, value, options) {
        dateValues.timeOfDay = value;
        return dateValues
      }
    },

    hours: {
      priority: 70,
      set: function (dateValues, value, options) {
        dateValues.date.setUTCHours(value, 0, 0, 0);
        return dateValues
      }
    },

    timeOfDayHours: {
      priority: 70,
      set: function (dateValues, value, options) {
        var timeOfDay = dateValues.timeOfDay;
        if (timeOfDay != null) {
          value = setTimeOfDay(value, timeOfDay);
        }
        dateValues.date.setUTCHours(value, 0, 0, 0);
        return dateValues
      }
    },

    minutes: {
      priority: 80,
      set: function (dateValues, value) {
        dateValues.date.setUTCMinutes(value, 0, 0);
        return dateValues
      }
    },

    seconds: {
      priority: 90,
      set: function (dateValues, value) {
        dateValues.date.setUTCSeconds(value, 0);
        return dateValues
      }
    },

    milliseconds: {
      priority: 100,
      set: function (dateValues, value) {
        dateValues.date.setUTCMilliseconds(value);
        return dateValues
      }
    },

    timezone: {
      priority: 110,
      set: function (dateValues, value) {
        dateValues.date = new Date(dateValues.date.getTime() - value * MILLISECONDS_IN_MINUTE$7);
        return dateValues
      }
    },

    timestamp: {
      priority: 120,
      set: function (dateValues, value) {
        dateValues.date = new Date(value);
        return dateValues
      }
    }
  };

  var TIMEZONE_UNIT_PRIORITY = 110;
  var MILLISECONDS_IN_MINUTE$6 = 60000;

  var longFormattingTokensRegExp$1 = /(\[[^[]*])|(\\)?(LTS|LT|LLLL|LLL|LL|L|llll|lll|ll|l)/g;
  var defaultParsingTokensRegExp = /(\[[^[]*])|(\\)?(x|ss|s|mm|m|hh|h|do|dddd|ddd|dd|d|aa|a|ZZ|Z|YYYY|YY|X|Wo|WW|W|SSS|SS|S|Qo|Q|Mo|MMMM|MMM|MM|M|HH|H|GGGG|GG|E|Do|DDDo|DDDD|DDD|DD|D|A|.)/g;

  /**
   * @name parse
   * @category Common Helpers
   * @summary Parse the date.
   *
   * @description
   * Return the date parsed from string using the given format.
   *
   * Accepted format tokens:
   * | Unit                    | Priority | Token | Input examples                   |
   * |-------------------------|----------|-------|----------------------------------|
   * | Year                    | 10       | YY    | 00, 01, ..., 99                  |
   * |                         |          | YYYY  | 1900, 1901, ..., 2099            |
   * | ISO week-numbering year | 10       | GG    | 00, 01, ..., 99                  |
   * |                         |          | GGGG  | 1900, 1901, ..., 2099            |
   * | Quarter                 | 20       | Q     | 1, 2, 3, 4                       |
   * |                         |          | Qo    | 1st, 2nd, 3rd, 4th               |
   * | Month                   | 30       | M     | 1, 2, ..., 12                    |
   * |                         |          | Mo    | 1st, 2nd, ..., 12th              |
   * |                         |          | MM    | 01, 02, ..., 12                  |
   * |                         |          | MMM   | Jan, Feb, ..., Dec               |
   * |                         |          | MMMM  | January, February, ..., December |
   * | ISO week                | 40       | W     | 1, 2, ..., 53                    |
   * |                         |          | Wo    | 1st, 2nd, ..., 53rd              |
   * |                         |          | WW    | 01, 02, ..., 53                  |
   * | Day of week             | 50       | d     | 0, 1, ..., 6                     |
   * |                         |          | do    | 0th, 1st, ..., 6th               |
   * |                         |          | dd    | Su, Mo, ..., Sa                  |
   * |                         |          | ddd   | Sun, Mon, ..., Sat               |
   * |                         |          | dddd  | Sunday, Monday, ..., Saturday    |
   * | Day of ISO week         | 50       | E     | 1, 2, ..., 7                     |
   * | Day of month            | 50       | D     | 1, 2, ..., 31                    |
   * |                         |          | Do    | 1st, 2nd, ..., 31st              |
   * |                         |          | DD    | 01, 02, ..., 31                  |
   * | Day of year             | 50       | DDD   | 1, 2, ..., 366                   |
   * |                         |          | DDDo  | 1st, 2nd, ..., 366th             |
   * |                         |          | DDDD  | 001, 002, ..., 366               |
   * | Time of day             | 60       | A     | AM, PM                           |
   * |                         |          | a     | am, pm                           |
   * |                         |          | aa    | a.m., p.m.                       |
   * | Hour                    | 70       | H     | 0, 1, ... 23                     |
   * |                         |          | HH    | 00, 01, ... 23                   |
   * | Time of day hour        | 70       | h     | 1, 2, ..., 12                    |
   * |                         |          | hh    | 01, 02, ..., 12                  |
   * | Minute                  | 80       | m     | 0, 1, ..., 59                    |
   * |                         |          | mm    | 00, 01, ..., 59                  |
   * | Second                  | 90       | s     | 0, 1, ..., 59                    |
   * |                         |          | ss    | 00, 01, ..., 59                  |
   * | 1/10 of second          | 100      | S     | 0, 1, ..., 9                     |
   * | 1/100 of second         | 100      | SS    | 00, 01, ..., 99                  |
   * | Millisecond             | 100      | SSS   | 000, 001, ..., 999               |
   * | Timezone                | 110      | Z     | -01:00, +00:00, ... +12:00       |
   * |                         |          | ZZ    | -0100, +0000, ..., +1200         |
   * | Seconds timestamp       | 120      | X     | 512969520                        |
   * | Milliseconds timestamp  | 120      | x     | 512969520900                     |
   *
   * Values will be assigned to the date in the ascending order of its unit's priority.
   * Units of an equal priority overwrite each other in the order of appearance.
   *
   * If no values of higher priority are parsed (e.g. when parsing string 'January 1st' without a year),
   * the values will be taken from 3rd argument `baseDate` which works as a context of parsing.
   *
   * `baseDate` must be passed for correct work of the function.
   * If you're not sure which `baseDate` to supply, create a new instance of Date:
   * `parse('02/11/2014', 'MM/DD/YYYY', new Date())`
   * In this case parsing will be done in the context of the current date.
   * If `baseDate` is `Invalid Date` or a value not convertible to valid `Date`,
   * then `Invalid Date` will be returned.
   *
   * Also, `parse` unfolds long formats like those in [format]{@link https://date-fns.org/docs/format}:
   * | Token | Input examples                 |
   * |-------|--------------------------------|
   * | LT    | 05:30 a.m.                     |
   * | LTS   | 05:30:15 a.m.                  |
   * | L     | 07/02/1995                     |
   * | l     | 7/2/1995                       |
   * | LL    | July 2 1995                    |
   * | ll    | Jul 2 1995                     |
   * | LLL   | July 2 1995 05:30 a.m.         |
   * | lll   | Jul 2 1995 05:30 a.m.          |
   * | LLLL  | Sunday, July 2 1995 05:30 a.m. |
   * | llll  | Sun, Jul 2 1995 05:30 a.m.     |
   *
   * The characters wrapped in square brackets in the format string are escaped.
   *
   * The result may vary by locale.
   *
   * If `formatString` matches with `dateString` but does not provides tokens, `baseDate` will be returned.
   *
   * If parsing failed, `Invalid Date` will be returned.
   * Invalid Date is a Date, whose time value is NaN.
   * Time value of Date: http://es5.github.io/#x15.9.1.1
   *
   * @param {String} dateString - the string to parse
   * @param {String} formatString - the string of tokens
   * @param {Date|String|Number} baseDate - the date to took the missing higher priority values from
   * @param {Options} [options] - the object with options. See [Options]{@link https://date-fns.org/docs/Options}
   * @param {0|1|2} [options.additionalDigits=2] - passed to `toDate`. See [toDate]{@link https://date-fns.org/docs/toDate}
   * @param {Locale} [options.locale=defaultLocale] - the locale object. See [Locale]{@link https://date-fns.org/docs/Locale}
   * @param {0|1|2|3|4|5|6} [options.weekStartsOn=0] - the index of the first day of the week (0 - Sunday)
   * @returns {Date} the parsed date
   * @throws {TypeError} 3 arguments required
   * @throws {RangeError} `options.additionalDigits` must be 0, 1 or 2
   * @throws {RangeError} `options.weekStartsOn` must be between 0 and 6
   * @throws {RangeError} `options.locale` must contain `match` property
   * @throws {RangeError} `options.locale` must contain `formatLong` property
   *
   * @example
   * // Parse 11 February 2014 from middle-endian format:
   * var result = parse(
   *   '02/11/2014',
   *   'MM/DD/YYYY',
   *   new Date()
   * )
   * //=> Tue Feb 11 2014 00:00:00
   *
   * @example
   * // Parse 28th of February in English locale in the context of 2010 year:
   * import eoLocale from 'date-fns/locale/eo'
   * var result = parse(
   *   '28-a de februaro',
   *   'Do [de] MMMM',
   *   new Date(2010, 0, 1)
   *   {locale: eoLocale}
   * )
   * //=> Sun Feb 28 2010 00:00:00
   */
  function parse (dirtyDateString, dirtyFormatString, dirtyBaseDate, dirtyOptions) {
    if (arguments.length < 3) {
      throw new TypeError('3 arguments required, but only ' + arguments.length + ' present')
    }

    var dateString = String(dirtyDateString);
    var options = dirtyOptions || {};

    var weekStartsOn = options.weekStartsOn === undefined ? 0 : Number(options.weekStartsOn);

    // Test if weekStartsOn is between 0 and 6 _and_ is not NaN
    if (!(weekStartsOn >= 0 && weekStartsOn <= 6)) {
      throw new RangeError('weekStartsOn must be between 0 and 6 inclusively')
    }

    var locale = options.locale || locale$1;
    var localeParsers = locale.parsers || {};
    var localeUnits = locale.units || {};

    if (!locale.match) {
      throw new RangeError('locale must contain match property')
    }

    if (!locale.formatLong) {
      throw new RangeError('locale must contain formatLong property')
    }

    var formatString = String(dirtyFormatString)
      .replace(longFormattingTokensRegExp$1, function (substring) {
        if (substring[0] === '[') {
          return substring
        }

        if (substring[0] === '\\') {
          return cleanEscapedString$1(substring)
        }

        return locale.formatLong(substring)
      });

    if (formatString === '') {
      if (dateString === '') {
        return toDate(dirtyBaseDate, options)
      } else {
        return new Date(NaN)
      }
    }

    var subFnOptions = cloneObject(options);
    subFnOptions.locale = locale;

    var tokens = formatString.match(locale.parsingTokensRegExp || defaultParsingTokensRegExp);
    var tokensLength = tokens.length;

    // If timezone isn't specified, it will be set to the system timezone
    var setters = [{
      priority: TIMEZONE_UNIT_PRIORITY,
      set: dateToSystemTimezone,
      index: 0
    }];

    var i;
    for (i = 0; i < tokensLength; i++) {
      var token = tokens[i];
      var parser = localeParsers[token] || parsers[token];
      if (parser) {
        var matchResult;

        if (parser.match instanceof RegExp) {
          matchResult = parser.match.exec(dateString);
        } else {
          matchResult = parser.match(dateString, subFnOptions);
        }

        if (!matchResult) {
          return new Date(NaN)
        }

        var unitName = parser.unit;
        var unit = localeUnits[unitName] || units[unitName];

        setters.push({
          priority: unit.priority,
          set: unit.set,
          value: parser.parse(matchResult, subFnOptions),
          index: setters.length
        });

        var substring = matchResult[0];
        dateString = dateString.slice(substring.length);
      } else {
        var head = tokens[i].match(/^\[.*]$/) ? tokens[i].replace(/^\[|]$/g, '') : tokens[i];
        if (dateString.indexOf(head) === 0) {
          dateString = dateString.slice(head.length);
        } else {
          return new Date(NaN)
        }
      }
    }

    var uniquePrioritySetters = setters
      .map(function (setter) {
        return setter.priority
      })
      .sort(function (a, b) {
        return a - b
      })
      .filter(function (priority, index, array) {
        return array.indexOf(priority) === index
      })
      .map(function (priority) {
        return setters
          .filter(function (setter) {
            return setter.priority === priority
          })
          .reverse()
      })
      .map(function (setterArray) {
        return setterArray[0]
      });

    var date = toDate(dirtyBaseDate, options);

    if (isNaN(date)) {
      return new Date(NaN)
    }

    // Convert the date in system timezone to the same date in UTC+00:00 timezone.
    // This ensures that when UTC functions will be implemented, locales will be compatible with them.
    // See an issue about UTC functions: https://github.com/date-fns/date-fns/issues/37
    var utcDate = subMinutes(date, date.getTimezoneOffset());

    var dateValues = {date: utcDate};

    var settersLength = uniquePrioritySetters.length;
    for (i = 0; i < settersLength; i++) {
      var setter = uniquePrioritySetters[i];
      dateValues = setter.set(dateValues, setter.value, subFnOptions);
    }

    return dateValues.date
  }

  function dateToSystemTimezone (dateValues) {
    var date = dateValues.date;
    var time = date.getTime();

    // Get the system timezone offset at (moment of time - offset)
    var offset = date.getTimezoneOffset();

    // Get the system timezone offset at the exact moment of time
    offset = new Date(time + offset * MILLISECONDS_IN_MINUTE$6).getTimezoneOffset();

    // Convert date in timezone "UTC+00:00" to the system timezone
    dateValues.date = new Date(time + offset * MILLISECONDS_IN_MINUTE$6);

    return dateValues
  }

  function cleanEscapedString$1 (input) {
    if (input.match(/\[[\s\S]/)) {
      return input.replace(/^\[|]$/g, '')
    }
    return input.replace(/\\/g, '')
  }

  // This file is generated automatically by `scripts/build/indices.js`. Please, don't change it.

  // 

  /**
   * Custom parse behavior on top of date-fns parse function.
   */
  function parseDate$1 (date, format$$1) {
    if (typeof date !== 'string') {
      return isValid(date) ? date : null;
    }

    var parsed = parse(date, format$$1, new Date());

    // if date is not valid or the formatted output after parsing does not match
    // the string value passed in (avoids overflows)
    if (!isValid(parsed) || format(parsed, format$$1) !== date) {
      return null;
    }

    return parsed;
  }

  var after = function (value, ref) {
    var otherValue = ref[0];
    var inclusion = ref[1];
    var format = ref[2];

    if (typeof format === 'undefined') {
      format = inclusion;
      inclusion = false;
    }
    value = parseDate$1(value, format);
    otherValue = parseDate$1(otherValue, format);

    // if either is not valid.
    if (!value || !otherValue) {
      return false;
    }

    return isAfter(value, otherValue) || (inclusion && isEqual$1(value, otherValue));
  };

  /**
   * Some Alpha Regex helpers.
   * https://github.com/chriso/validator.js/blob/master/src/lib/alpha.js
   */

  var alpha$1 = {
    en: /^[A-Z]*$/i,
    cs: /^[A-ZÃÄÄÃÄÃÅÃÅÅ Å¤ÃÅ®ÃÅ½]*$/i,
    da: /^[A-ZÃÃÃ]*$/i,
    de: /^[A-ZÃÃÃÃ]*$/i,
    es: /^[A-ZÃÃÃÃÃÃÃ]*$/i,
    fr: /^[A-ZÃÃÃÃÃÃÃÃÃÃÃÅÃÃÃÅ¸]*$/i,
    lt: /^[A-ZÄÄÄÄÄ®Å Å²ÅªÅ½]*$/i,
    nl: /^[A-ZÃÃÃÃÃÃ]*$/i,
    hu: /^[A-ZÃÃÃÃÃÅÃÃÅ°]*$/i,
    pl: /^[A-ZÄÄÄÅÅÅÃÅ»Å¹]*$/i,
    pt: /^[A-ZÃÃÃÃÃÃÃÃÃÃÃÃÃ]*$/i,
    ru: /^[Ð-Ð¯Ð]*$/i,
    sk: /^[A-ZÃÃÄÄÃÃÄ¹Ä½ÅÃÅÅ Å¤ÃÃÅ½]*$/i,
    sr: /^[A-ZÄÄÅ½Å Ä]*$/i,
    tr: /^[A-ZÃÄÄ°Ä±ÃÅÃ]*$/i,
    uk: /^[Ð-Ð©Ð¬Ð®Ð¯ÐÐÐÒ]*$/i,
    ar: /^[Ø¡Ø¢Ø£Ø¤Ø¥Ø¦Ø§Ø¨Ø©ØªØ«Ø¬Ø­Ø®Ø¯Ø°Ø±Ø²Ø³Ø´ØµØ¶Ø·Ø¸Ø¹ØºÙÙÙÙÙÙÙÙÙÙÙÙÙÙÙÙÙÙÙ°]*$/
  };

  var alphaSpaces = {
    en: /^[A-Z\s]*$/i,
    cs: /^[A-ZÃÄÄÃÄÃÅÃÅÅ Å¤ÃÅ®ÃÅ½\s]*$/i,
    da: /^[A-ZÃÃÃ\s]*$/i,
    de: /^[A-ZÃÃÃÃ\s]*$/i,
    es: /^[A-ZÃÃÃÃÃÃÃ\s]*$/i,
    fr: /^[A-ZÃÃÃÃÃÃÃÃÃÃÃÅÃÃÃÅ¸\s]*$/i,
    lt: /^[A-ZÄÄÄÄÄ®Å Å²ÅªÅ½\s]*$/i,
    nl: /^[A-ZÃÃÃÃÃÃ\s]*$/i,
    hu: /^[A-ZÃÃÃÃÃÅÃÃÅ°\s]*$/i,
    pl: /^[A-ZÄÄÄÅÅÅÃÅ»Å¹\s]*$/i,
    pt: /^[A-ZÃÃÃÃÃÃÃÃÃÃÃÃÃ\s]*$/i,
    ru: /^[Ð-Ð¯Ð\s]*$/i,
    sk: /^[A-ZÃÃÄÄÃÃÄ¹Ä½ÅÃÅÅ Å¤ÃÃÅ½\s]*$/i,
    sr: /^[A-ZÄÄÅ½Å Ä\s]*$/i,
    tr: /^[A-ZÃÄÄ°Ä±ÃÅÃ\s]*$/i,
    uk: /^[Ð-Ð©Ð¬Ð®Ð¯ÐÐÐÒ\s]*$/i,
    ar: /^[Ø¡Ø¢Ø£Ø¤Ø¥Ø¦Ø§Ø¨Ø©ØªØ«Ø¬Ø­Ø®Ø¯Ø°Ø±Ø²Ø³Ø´ØµØ¶Ø·Ø¸Ø¹ØºÙÙÙÙÙÙÙÙÙÙÙÙÙÙÙÙÙÙÙ°\s]*$/
  };

  var alphanumeric = {
    en: /^[0-9A-Z]*$/i,
    cs: /^[0-9A-ZÃÄÄÃÄÃÅÃÅÅ Å¤ÃÅ®ÃÅ½]*$/i,
    da: /^[0-9A-ZÃÃÃ]$/i,
    de: /^[0-9A-ZÃÃÃÃ]*$/i,
    es: /^[0-9A-ZÃÃÃÃÃÃÃ]*$/i,
    fr: /^[0-9A-ZÃÃÃÃÃÃÃÃÃÃÃÅÃÃÃÅ¸]*$/i,
    lt: /^[0-9A-ZÄÄÄÄÄ®Å Å²ÅªÅ½]*$/i,
    hu: /^[0-9A-ZÃÃÃÃÃÅÃÃÅ°]*$/i,
    nl: /^[0-9A-ZÃÃÃÃÃÃ]*$/i,
    pl: /^[0-9A-ZÄÄÄÅÅÅÃÅ»Å¹]*$/i,
    pt: /^[0-9A-ZÃÃÃÃÃÃÃÃÃÃÃÃÃ]*$/i,
    ru: /^[0-9Ð-Ð¯Ð]*$/i,
    sk: /^[0-9A-ZÃÃÄÄÃÃÄ¹Ä½ÅÃÅÅ Å¤ÃÃÅ½]*$/i,
    sr: /^[0-9A-ZÄÄÅ½Å Ä]*$/i,
    tr: /^[0-9A-ZÃÄÄ°Ä±ÃÅÃ]*$/i,
    uk: /^[0-9Ð-Ð©Ð¬Ð®Ð¯ÐÐÐÒ]*$/i,
    ar: /^[Ù Ù¡Ù¢Ù£Ù¤Ù¥Ù¦Ù§Ù¨Ù©0-9Ø¡Ø¢Ø£Ø¤Ø¥Ø¦Ø§Ø¨Ø©ØªØ«Ø¬Ø­Ø®Ø¯Ø°Ø±Ø²Ø³Ø´ØµØ¶Ø·Ø¸Ø¹ØºÙÙÙÙÙÙÙÙÙÙÙÙÙÙÙÙÙÙÙ°]*$/
  };

  var alphaDash = {
    en: /^[0-9A-Z_-]*$/i,
    cs: /^[0-9A-ZÃÄÄÃÄÃÅÃÅÅ Å¤ÃÅ®ÃÅ½_-]*$/i,
    da: /^[0-9A-ZÃÃÃ_-]*$/i,
    de: /^[0-9A-ZÃÃÃÃ_-]*$/i,
    es: /^[0-9A-ZÃÃÃÃÃÃÃ_-]*$/i,
    fr: /^[0-9A-ZÃÃÃÃÃÃÃÃÃÃÃÅÃÃÃÅ¸_-]*$/i,
    lt: /^[0-9A-ZÄÄÄÄÄ®Å Å²ÅªÅ½_-]*$/i,
    nl: /^[0-9A-ZÃÃÃÃÃÃ_-]*$/i,
    hu: /^[0-9A-ZÃÃÃÃÃÅÃÃÅ°_-]*$/i,
    pl: /^[0-9A-ZÄÄÄÅÅÅÃÅ»Å¹_-]*$/i,
    pt: /^[0-9A-ZÃÃÃÃÃÃÃÃÃÃÃÃÃ_-]*$/i,
    ru: /^[0-9Ð-Ð¯Ð_-]*$/i,
    sk: /^[0-9A-ZÃÃÄÄÃÃÄ¹Ä½ÅÃÅÅ Å¤ÃÃÅ½_-]*$/i,
    sr: /^[0-9A-ZÄÄÅ½Å Ä_-]*$/i,
    tr: /^[0-9A-ZÃÄÄ°Ä±ÃÅÃ_-]*$/i,
    uk: /^[0-9Ð-Ð©Ð¬Ð®Ð¯ÐÐÐÒ_-]*$/i,
    ar: /^[Ù Ù¡Ù¢Ù£Ù¤Ù¥Ù¦Ù§Ù¨Ù©0-9Ø¡Ø¢Ø£Ø¤Ø¥Ø¦Ø§Ø¨Ø©ØªØ«Ø¬Ø­Ø®Ø¯Ø°Ø±Ø²Ø³Ø´ØµØ¶Ø·Ø¸Ø¹ØºÙÙÙÙÙÙÙÙÙÙÙÙÙÙÙÙÙÙÙ°_-]*$/
  };

  var validate = function (value, ref) {
    if ( ref === void 0 ) { ref = []; }
    var locale = ref[0]; if ( locale === void 0 ) { locale = null; }

    if (Array.isArray(value)) {
      return value.every(function (val) { return validate(val, [locale]); });
    }

    // Match at least one locale.
    if (! locale) {
      return Object.keys(alpha$1).some(function (loc) { return alpha$1[loc].test(value); });
    }

    return (alpha$1[locale] || alpha$1.en).test(value);
  };

  var validate$1 = function (value, ref) {
    if ( ref === void 0 ) { ref = []; }
    var locale = ref[0]; if ( locale === void 0 ) { locale = null; }

    if (Array.isArray(value)) {
      return value.every(function (val) { return validate$1(val, [locale]); });
    }

    // Match at least one locale.
    if (! locale) {
      return Object.keys(alphaDash).some(function (loc) { return alphaDash[loc].test(value); });
    }

    return (alphaDash[locale] || alphaDash.en).test(value);
  };

  var validate$2 = function (value, ref) {
    if ( ref === void 0 ) { ref = []; }
    var locale = ref[0]; if ( locale === void 0 ) { locale = null; }

    if (Array.isArray(value)) {
      return value.every(function (val) { return validate$2(val, [locale]); });
    }

    // Match at least one locale.
    if (! locale) {
      return Object.keys(alphanumeric).some(function (loc) { return alphanumeric[loc].test(value); });
    }

    return (alphanumeric[locale] || alphanumeric.en).test(value);
  };

  var validate$3 = function (value, ref) {
    if ( ref === void 0 ) { ref = []; }
    var locale = ref[0]; if ( locale === void 0 ) { locale = null; }

    if (Array.isArray(value)) {
      return value.every(function (val) { return validate$3(val, [locale]); });
    }

    // Match at least one locale.
    if (! locale) {
      return Object.keys(alphaSpaces).some(function (loc) { return alphaSpaces[loc].test(value); });
    }

    return (alphaSpaces[locale] || alphaSpaces.en).test(value);
  };

  var before = function (value, ref) {
    var otherValue = ref[0];
    var inclusion = ref[1];
    var format = ref[2];

    if (typeof format === 'undefined') {
      format = inclusion;
      inclusion = false;
    }
    value = parseDate$1(value, format);
    otherValue = parseDate$1(otherValue, format);

    // if either is not valid.
    if (!value || !otherValue) {
      return false;
    }

    return isBefore(value, otherValue) || (inclusion && isEqual$1(value, otherValue));
  };

  var validate$4 = function (value, ref) {
    var min = ref[0];
    var max = ref[1];

    if (Array.isArray(value)) {
      return value.every(function (val) { return validate$4(val, [min, max]); });
    }

    return Number(min) <= value && Number(max) >= value;
  };

  var confirmed = function (value, other) { return String(value) === String(other); };

  function unwrapExports (x) {
  	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
  }

  function createCommonjsModule(fn, module) {
  	return module = { exports: {} }, fn(module, module.exports), module.exports;
  }

  var assertString_1 = createCommonjsModule(function (module, exports) {
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = assertString;
  function assertString(input) {
    var isString = typeof input === 'string' || input instanceof String;

    if (!isString) {
      throw new TypeError('This library (validator.js) validates strings only');
    }
  }
  module.exports = exports['default'];
  });

  unwrapExports(assertString_1);

  var isCreditCard_1 = createCommonjsModule(function (module, exports) {
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = isCreditCard;



  var _assertString2 = _interopRequireDefault(assertString_1);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  /* eslint-disable max-len */
  var creditCard = /^(?:4[0-9]{12}(?:[0-9]{3})?|5[1-5][0-9]{14}|(222[1-9]|22[3-9][0-9]|2[3-6][0-9]{2}|27[01][0-9]|2720)[0-9]{12}|6(?:011|5[0-9][0-9])[0-9]{12}|3[47][0-9]{13}|3(?:0[0-5]|[68][0-9])[0-9]{11}|(?:2131|1800|35\d{3})\d{11}|62[0-9]{14})$/;
  /* eslint-enable max-len */

  function isCreditCard(str) {
    (0, _assertString2.default)(str);
    var sanitized = str.replace(/[- ]+/g, '');
    if (!creditCard.test(sanitized)) {
      return false;
    }
    var sum = 0;
    var digit = void 0;
    var tmpNum = void 0;
    var shouldDouble = void 0;
    for (var i = sanitized.length - 1; i >= 0; i--) {
      digit = sanitized.substring(i, i + 1);
      tmpNum = parseInt(digit, 10);
      if (shouldDouble) {
        tmpNum *= 2;
        if (tmpNum >= 10) {
          sum += tmpNum % 10 + 1;
        } else {
          sum += tmpNum;
        }
      } else {
        sum += tmpNum;
      }
      shouldDouble = !shouldDouble;
    }
    return !!(sum % 10 === 0 ? sanitized : false);
  }
  module.exports = exports['default'];
  });

  var isCreditCard = unwrapExports(isCreditCard_1);

  var credit_card = function (value) { return isCreditCard(String(value)); };

  var validate$5 = function (value, ref) {
    if ( ref === void 0 ) { ref = []; }
    var decimals = ref[0]; if ( decimals === void 0 ) { decimals = '*'; }
    var separator = ref[1]; if ( separator === void 0 ) { separator = '.'; }

    if (Array.isArray(value)) {
      return value.every(function (val) { return validate$5(val, [decimals, separator]); });
    }

    if (value === null || value === undefined || value === '') {
      return true;
    }

    // if is 0.
    if (Number(decimals) === 0) {
      return /^-?\d*$/.test(value);
    }

    var regexPart = decimals === '*' ? '+' : ("{1," + decimals + "}");
    var regex = new RegExp(("^-?\\d*(\\" + separator + "\\d" + regexPart + ")?$"));

    if (! regex.test(value)) {
      return false;
    }

    var parsedValue = parseFloat(value);

    // eslint-disable-next-line
      return parsedValue === parsedValue;
  };

  var date_between = function (value, params) {
    var min;
    var max;
    var format;
    var inclusivity = '()';

    if (params.length > 3) {
      var assign;
      (assign = params, min = assign[0], max = assign[1], inclusivity = assign[2], format = assign[3]);
    } else {
      var assign$1;
      (assign$1 = params, min = assign$1[0], max = assign$1[1], format = assign$1[2]);
    }

    var minDate = parseDate$1(min, format);
    var maxDate = parseDate$1(max, format);
    var dateVal = parseDate$1(value, format);

    if (!minDate || !maxDate || !dateVal) {
      return false;
    }

    if (inclusivity === '()') {
      return isAfter(dateVal, minDate) && isBefore(dateVal, maxDate);
    }

    if (inclusivity === '(]') {
      return isAfter(dateVal, minDate) && (isEqual$1(dateVal, maxDate) || isBefore(dateVal, maxDate));
    }

    if (inclusivity === '[)') {
      return isBefore(dateVal, maxDate) && (isEqual$1(dateVal, minDate) || isAfter(dateVal, minDate));
    }

    return isEqual$1(dateVal, maxDate) || isEqual$1(dateVal, minDate) ||
          (isBefore(dateVal, maxDate) && isAfter(dateVal, minDate));
  };

  var date_format = function (value, ref) {
    var format = ref[0];

    return !!parseDate$1(value, format);
  };

  var validate$6 = function (value, ref) {
    var length = ref[0];

    if (Array.isArray(value)) {
      return value.every(function (val) { return validate$6(val, [length]); });
    }
    var strVal = String(value);

    return /^[0-9]*$/.test(strVal) && strVal.length === Number(length);
  };

  var validateImage = function (file, width, height) {
    var URL = window.URL || window.webkitURL;
    return new Promise(function (resolve) {
      var image = new Image();
      image.onerror = function () { return resolve({ valid: false }); };
      image.onload = function () { return resolve({
        valid: image.width === Number(width) && image.height === Number(height)
      }); };

      image.src = URL.createObjectURL(file);
    });
  };

  var dimensions = function (files, ref) {
    var width = ref[0];
    var height = ref[1];

    var list = [];
    for (var i = 0; i < files.length; i++) {
      // if file is not an image, reject.
      if (! /\.(jpg|svg|jpeg|png|bmp|gif)$/i.test(files[i].name)) {
        return false;
      }

      list.push(files[i]);
    }

    return Promise.all(list.map(function (file) { return validateImage(file, width, height); }));
  };

  var merge_1 = createCommonjsModule(function (module, exports) {
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = merge;
  function merge() {
    var obj = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    var defaults = arguments[1];

    for (var key in defaults) {
      if (typeof obj[key] === 'undefined') {
        obj[key] = defaults[key];
      }
    }
    return obj;
  }
  module.exports = exports['default'];
  });

  unwrapExports(merge_1);

  var isByteLength_1 = createCommonjsModule(function (module, exports) {
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

  exports.default = isByteLength;



  var _assertString2 = _interopRequireDefault(assertString_1);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  /* eslint-disable prefer-rest-params */
  function isByteLength(str, options) {
    (0, _assertString2.default)(str);
    var min = void 0;
    var max = void 0;
    if ((typeof options === 'undefined' ? 'undefined' : _typeof(options)) === 'object') {
      min = options.min || 0;
      max = options.max;
    } else {
      // backwards compatibility: isByteLength(str, min [, max])
      min = arguments[1];
      max = arguments[2];
    }
    var len = encodeURI(str).split(/%..|./).length - 1;
    return len >= min && (typeof max === 'undefined' || len <= max);
  }
  module.exports = exports['default'];
  });

  unwrapExports(isByteLength_1);

  var isFQDN = createCommonjsModule(function (module, exports) {
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = isFDQN;



  var _assertString2 = _interopRequireDefault(assertString_1);



  var _merge2 = _interopRequireDefault(merge_1);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  var default_fqdn_options = {
    require_tld: true,
    allow_underscores: false,
    allow_trailing_dot: false
  };

  function isFDQN(str, options) {
    (0, _assertString2.default)(str);
    options = (0, _merge2.default)(options, default_fqdn_options);

    /* Remove the optional trailing dot before checking validity */
    if (options.allow_trailing_dot && str[str.length - 1] === '.') {
      str = str.substring(0, str.length - 1);
    }
    var parts = str.split('.');
    if (options.require_tld) {
      var tld = parts.pop();
      if (!parts.length || !/^([a-z\u00a1-\uffff]{2,}|xn[a-z0-9-]{2,})$/i.test(tld)) {
        return false;
      }
      // disallow spaces
      if (/[\s\u2002-\u200B\u202F\u205F\u3000\uFEFF\uDB40\uDC20]/.test(tld)) {
        return false;
      }
    }
    for (var part, i = 0; i < parts.length; i++) {
      part = parts[i];
      if (options.allow_underscores) {
        part = part.replace(/_/g, '');
      }
      if (!/^[a-z\u00a1-\uffff0-9-]+$/i.test(part)) {
        return false;
      }
      // disallow full-width chars
      if (/[\uff01-\uff5e]/.test(part)) {
        return false;
      }
      if (part[0] === '-' || part[part.length - 1] === '-') {
        return false;
      }
    }
    return true;
  }
  module.exports = exports['default'];
  });

  unwrapExports(isFQDN);

  var isEmail_1 = createCommonjsModule(function (module, exports) {
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = isEmail;



  var _assertString2 = _interopRequireDefault(assertString_1);



  var _merge2 = _interopRequireDefault(merge_1);



  var _isByteLength2 = _interopRequireDefault(isByteLength_1);



  var _isFQDN2 = _interopRequireDefault(isFQDN);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  var default_email_options = {
    allow_display_name: false,
    require_display_name: false,
    allow_utf8_local_part: true,
    require_tld: true
  };

  /* eslint-disable max-len */
  /* eslint-disable no-control-regex */
  var displayName = /^[a-z\d!#\$%&'\*\+\-\/=\?\^_`{\|}~\.\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]+[a-z\d!#\$%&'\*\+\-\/=\?\^_`{\|}~\,\.\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF\s]*<(.+)>$/i;
  var emailUserPart = /^[a-z\d!#\$%&'\*\+\-\/=\?\^_`{\|}~]+$/i;
  var quotedEmailUser = /^([\s\x01-\x08\x0b\x0c\x0e-\x1f\x7f\x21\x23-\x5b\x5d-\x7e]|(\\[\x01-\x09\x0b\x0c\x0d-\x7f]))*$/i;
  var emailUserUtf8Part = /^[a-z\d!#\$%&'\*\+\-\/=\?\^_`{\|}~\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]+$/i;
  var quotedEmailUserUtf8 = /^([\s\x01-\x08\x0b\x0c\x0e-\x1f\x7f\x21\x23-\x5b\x5d-\x7e\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]|(\\[\x01-\x09\x0b\x0c\x0d-\x7f\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]))*$/i;
  /* eslint-enable max-len */
  /* eslint-enable no-control-regex */

  function isEmail(str, options) {
    (0, _assertString2.default)(str);
    options = (0, _merge2.default)(options, default_email_options);

    if (options.require_display_name || options.allow_display_name) {
      var display_email = str.match(displayName);
      if (display_email) {
        str = display_email[1];
      } else if (options.require_display_name) {
        return false;
      }
    }

    var parts = str.split('@');
    var domain = parts.pop();
    var user = parts.join('@');

    var lower_domain = domain.toLowerCase();
    if (lower_domain === 'gmail.com' || lower_domain === 'googlemail.com') {
      user = user.replace(/\./g, '').toLowerCase();
    }

    if (!(0, _isByteLength2.default)(user, { max: 64 }) || !(0, _isByteLength2.default)(domain, { max: 254 })) {
      return false;
    }

    if (!(0, _isFQDN2.default)(domain, { require_tld: options.require_tld })) {
      return false;
    }

    if (user[0] === '"') {
      user = user.slice(1, user.length - 1);
      return options.allow_utf8_local_part ? quotedEmailUserUtf8.test(user) : quotedEmailUser.test(user);
    }

    var pattern = options.allow_utf8_local_part ? emailUserUtf8Part : emailUserPart;

    var user_parts = user.split('.');
    for (var i = 0; i < user_parts.length; i++) {
      if (!pattern.test(user_parts[i])) {
        return false;
      }
    }

    return true;
  }
  module.exports = exports['default'];
  });

  var isEmail = unwrapExports(isEmail_1);

  var validate$7 = function (value) {
    if (Array.isArray(value)) {
      return value.every(function (val) { return isEmail(String(val)); });
    }

    return isEmail(String(value));
  };

  var ext = function (files, extensions) {
    var regex = new RegExp((".(" + (extensions.join('|')) + ")$"), 'i');

    return files.every(function (file) { return regex.test(file.name); });
  };

  var image = function (files) { return files.every(function (file) { return /\.(jpg|svg|jpeg|png|bmp|gif)$/i.test(file.name); }
  ); };

  var validate$8 = function (value, options) {
    if (Array.isArray(value)) {
      return value.every(function (val) { return validate$8(val, options); });
    }

    // eslint-disable-next-line
    return !! options.filter(function (option) { return option == value; }).length;
  };

  var isIP_1 = createCommonjsModule(function (module, exports) {
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = isIP;



  var _assertString2 = _interopRequireDefault(assertString_1);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  var ipv4Maybe = /^(\d{1,3})\.(\d{1,3})\.(\d{1,3})\.(\d{1,3})$/;
  var ipv6Block = /^[0-9A-F]{1,4}$/i;

  function isIP(str) {
    var version = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';

    (0, _assertString2.default)(str);
    version = String(version);
    if (!version) {
      return isIP(str, 4) || isIP(str, 6);
    } else if (version === '4') {
      if (!ipv4Maybe.test(str)) {
        return false;
      }
      var parts = str.split('.').sort(function (a, b) {
        return a - b;
      });
      return parts[3] <= 255;
    } else if (version === '6') {
      var blocks = str.split(':');
      var foundOmissionBlock = false; // marker to indicate ::

      // At least some OS accept the last 32 bits of an IPv6 address
      // (i.e. 2 of the blocks) in IPv4 notation, and RFC 3493 says
      // that '::ffff:a.b.c.d' is valid for IPv4-mapped IPv6 addresses,
      // and '::a.b.c.d' is deprecated, but also valid.
      var foundIPv4TransitionBlock = isIP(blocks[blocks.length - 1], 4);
      var expectedNumberOfBlocks = foundIPv4TransitionBlock ? 7 : 8;

      if (blocks.length > expectedNumberOfBlocks) {
        return false;
      }
      // initial or final ::
      if (str === '::') {
        return true;
      } else if (str.substr(0, 2) === '::') {
        blocks.shift();
        blocks.shift();
        foundOmissionBlock = true;
      } else if (str.substr(str.length - 2) === '::') {
        blocks.pop();
        blocks.pop();
        foundOmissionBlock = true;
      }

      for (var i = 0; i < blocks.length; ++i) {
        // test for a :: which can not be at the string start/end
        // since those cases have been handled above
        if (blocks[i] === '' && i > 0 && i < blocks.length - 1) {
          if (foundOmissionBlock) {
            return false; // multiple :: in address
          }
          foundOmissionBlock = true;
        } else if (foundIPv4TransitionBlock && i === blocks.length - 1) {
          // it has been checked before that the last
          // block is a valid IPv4 address
        } else if (!ipv6Block.test(blocks[i])) {
          return false;
        }
      }
      if (foundOmissionBlock) {
        return blocks.length >= 1;
      }
      return blocks.length === expectedNumberOfBlocks;
    }
    return false;
  }
  module.exports = exports['default'];
  });

  var isIP = unwrapExports(isIP_1);

  var ip = function (value, ref) {
    if ( ref === void 0 ) { ref = []; }
    var version = ref[0]; if ( version === void 0 ) { version = 4; }

    if (isNullOrUndefined(value)) {
      value = '';
    }

    if (Array.isArray(value)) {
      return value.every(function (val) { return isIP(val, version); });
    }

    return isIP(value, version);
  };

  var is = function (value, ref) {
    if ( ref === void 0 ) { ref = []; }
    var other = ref[0];

    return value === other;
  };

  var is_not = function (value, ref) {
    if ( ref === void 0 ) { ref = []; }
    var other = ref[0];

    return value !== other;
  };

  /**
   * @param {Array|String} value
   * @param {Number} length
   * @param {Number} max
   */
  var compare = function (value, length, max) {
    if (max === undefined) {
      return value.length === length;
    }

    // cast to number.
    max = Number(max);

    return value.length >= length && value.length <= max;
  };

  var length = function (value, ref) {
    var length = ref[0];
    var max = ref[1]; if ( max === void 0 ) { max = undefined; }

    length = Number(length);
    if (value === undefined || value === null) {
      return false;
    }

    if (typeof value === 'number') {
      value = String(value);
    }

    if (!value.length) {
      value = toArray(value);
    }

    return compare(value, length, max);
  };

  var integer = function (value) {
    if (Array.isArray(value)) {
      return value.every(function (val) { return /^-?[0-9]+$/.test(String(val)); });
    }

    return /^-?[0-9]+$/.test(String(value));
  };

  var max$1 = function (value, ref) {
    var length = ref[0];

    if (value === undefined || value === null) {
      return length >= 0;
    }

    return String(value).length <= length;
  };

  var max_value = function (value, ref) {
    var max = ref[0];

    if (Array.isArray(value) || value === null || value === undefined || value === '') {
      return false;
    }

    return Number(value) <= max;
  };

  var mimes = function (files, mimes) {
    var regex = new RegExp(((mimes.join('|').replace('*', '.+')) + "$"), 'i');

    return files.every(function (file) { return regex.test(file.type); });
  };

  var min$1 = function (value, ref) {
    var length = ref[0];

    if (value === undefined || value === null) {
      return false;
    }
    return String(value).length >= length;
  };

  var min_value = function (value, ref) {
    var min = ref[0];

    if (Array.isArray(value) || value === null || value === undefined || value === '') {
      return false;
    }

    return Number(value) >= min;
  };

  var validate$9 = function (value, options) {
    if (Array.isArray(value)) {
      return value.every(function (val) { return validate$9(val, options); });
    }

    // eslint-disable-next-line
    return ! options.filter(function (option) { return option == value; }).length;
  };

  var numeric = function (value) {
    if (Array.isArray(value)) {
      return value.every(function (val) { return /^[0-9]+$/.test(String(val)); });
    }

    return /^[0-9]+$/.test(String(value));
  };

  var regex = function (value, ref) {
    var regex = ref[0];
    var flags = ref.slice(1);

    if (regex instanceof RegExp) {
      return regex.test(value);
    }

    return new RegExp(regex, flags).test(String(value));
  };

  var required = function (value, ref) {
    if ( ref === void 0 ) { ref = []; }
    var invalidateFalse = ref[0]; if ( invalidateFalse === void 0 ) { invalidateFalse = false; }

    if (Array.isArray(value)) {
      return !! value.length;
    }

    // incase a field considers `false` as an empty value like checkboxes.
    if (value === false && invalidateFalse) {
      return false;
    }

    if (value === undefined || value === null) {
      return false;
    }

    return !! String(value).trim().length;
  };

  var size = function (files, ref) {
    var size = ref[0];

    if (isNaN(size)) {
      return false;
    }

    var nSize = Number(size) * 1024;
    for (var i = 0; i < files.length; i++) {
      if (files[i].size > nSize) {
        return false;
      }
    }

    return true;
  };

  var isURL_1 = createCommonjsModule(function (module, exports) {
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = isURL;



  var _assertString2 = _interopRequireDefault(assertString_1);



  var _isFQDN2 = _interopRequireDefault(isFQDN);



  var _isIP2 = _interopRequireDefault(isIP_1);



  var _merge2 = _interopRequireDefault(merge_1);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  var default_url_options = {
    protocols: ['http', 'https', 'ftp'],
    require_tld: true,
    require_protocol: false,
    require_host: true,
    require_valid_protocol: true,
    allow_underscores: false,
    allow_trailing_dot: false,
    allow_protocol_relative_urls: false
  };

  var wrapped_ipv6 = /^\[([^\]]+)\](?::([0-9]+))?$/;

  function isRegExp(obj) {
    return Object.prototype.toString.call(obj) === '[object RegExp]';
  }

  function checkHost(host, matches) {
    for (var i = 0; i < matches.length; i++) {
      var match = matches[i];
      if (host === match || isRegExp(match) && match.test(host)) {
        return true;
      }
    }
    return false;
  }

  function isURL(url, options) {
    (0, _assertString2.default)(url);
    if (!url || url.length >= 2083 || /[\s<>]/.test(url)) {
      return false;
    }
    if (url.indexOf('mailto:') === 0) {
      return false;
    }
    options = (0, _merge2.default)(options, default_url_options);
    var protocol = void 0,
        auth = void 0,
        host = void 0,
        hostname = void 0,
        port = void 0,
        port_str = void 0,
        split = void 0,
        ipv6 = void 0;

    split = url.split('#');
    url = split.shift();

    split = url.split('?');
    url = split.shift();

    split = url.split('://');
    if (split.length > 1) {
      protocol = split.shift();
      if (options.require_valid_protocol && options.protocols.indexOf(protocol) === -1) {
        return false;
      }
    } else if (options.require_protocol) {
      return false;
    } else if (options.allow_protocol_relative_urls && url.substr(0, 2) === '//') {
      split[0] = url.substr(2);
    }
    url = split.join('://');

    if (url === '') {
      return false;
    }

    split = url.split('/');
    url = split.shift();

    if (url === '' && !options.require_host) {
      return true;
    }

    split = url.split('@');
    if (split.length > 1) {
      auth = split.shift();
      if (auth.indexOf(':') >= 0 && auth.split(':').length > 2) {
        return false;
      }
    }
    hostname = split.join('@');

    port_str = null;
    ipv6 = null;
    var ipv6_match = hostname.match(wrapped_ipv6);
    if (ipv6_match) {
      host = '';
      ipv6 = ipv6_match[1];
      port_str = ipv6_match[2] || null;
    } else {
      split = hostname.split(':');
      host = split.shift();
      if (split.length) {
        port_str = split.join(':');
      }
    }

    if (port_str !== null) {
      port = parseInt(port_str, 10);
      if (!/^[0-9]+$/.test(port_str) || port <= 0 || port > 65535) {
        return false;
      }
    }

    if (!(0, _isIP2.default)(host) && !(0, _isFQDN2.default)(host, options) && (!ipv6 || !(0, _isIP2.default)(ipv6, 6))) {
      return false;
    }

    host = host || ipv6;

    if (options.host_whitelist && !checkHost(host, options.host_whitelist)) {
      return false;
    }
    if (options.host_blacklist && checkHost(host, options.host_blacklist)) {
      return false;
    }

    return true;
  }
  module.exports = exports['default'];
  });

  var isURL = unwrapExports(isURL_1);

  var url = function (value, ref) {
    if ( ref === void 0 ) { ref = []; }
    var requireProtocol = ref[0]; if ( requireProtocol === void 0 ) { requireProtocol = false; }

    var options = { require_protocol: !!requireProtocol, allow_underscores: true };
    if (isNullOrUndefined(value)) {
      value = '';
    }

    if (Array.isArray(value)) {
      return value.every(function (val) { return isURL(val, options); });
    }

    return isURL(value, options);
  };

  /* eslint-disable camelcase */
  var Rules = {
    after: after,
    alpha_dash: validate$1,
    alpha_num: validate$2,
    alpha_spaces: validate$3,
    alpha: validate,
    before: before,
    between: validate$4,
    confirmed: confirmed,
    credit_card: credit_card,
    date_between: date_between,
    date_format: date_format,
    decimal: validate$5,
    digits: validate$6,
    dimensions: dimensions,
    email: validate$7,
    ext: ext,
    image: image,
    in: validate$8,
    integer: integer,
    length: length,
    ip: ip,
    is_not: is_not,
    is: is,
    max: max$1,
    max_value: max_value,
    mimes: mimes,
    min: min$1,
    min_value: min_value,
    not_in: validate$9,
    numeric: numeric,
    regex: regex,
    required: required,
    size: size,
    url: url
  };

  // 

  var normalize = function (fields) {
    if (Array.isArray(fields)) {
      return fields.reduce(function (prev, curr) {
        if (~curr.indexOf('.')) {
          prev[curr.split('.')[1]] = curr;
        } else {
          prev[curr] = curr;
        }

        return prev;
      }, {});
    }

    return fields;
  };

  // Combines two flags using either AND or OR depending on the flag type.
  var combine = function (lhs, rhs) {
    var mapper = {
      pristine: function (lhs, rhs) { return lhs && rhs; },
      dirty: function (lhs, rhs) { return lhs || rhs; },
      touched: function (lhs, rhs) { return lhs || rhs; },
      untouched: function (lhs, rhs) { return lhs && rhs; },
      valid: function (lhs, rhs) { return lhs && rhs; },
      invalid: function (lhs, rhs) { return lhs || rhs; },
      pending: function (lhs, rhs) { return lhs || rhs; },
      required: function (lhs, rhs) { return lhs || rhs; },
      validated: function (lhs, rhs) { return lhs && rhs; }
    };

    return Object.keys(mapper).reduce(function (flags, flag) {
      flags[flag] = mapper[flag](lhs[flag], rhs[flag]);

      return flags;
    }, {});
  };

  var mapScope = function (scope, deep) {
    if ( deep === void 0 ) { deep = true; }

    return Object.keys(scope).reduce(function (flags, field) {
      if (!flags) {
        flags = assign({}, scope[field]);
        return flags;
      }

      // scope.
      var isScope = field.indexOf('$') === 0;
      if (deep && isScope) {
        return combine(mapScope(scope[field]), flags);
      } else if (!deep && isScope) {
        return flags;
      }

      flags = combine(flags, scope[field]);

      return flags;
    }, null);
  };

  /**
   * Maps fields to computed functions.
   */
  var mapFields = function (fields) {
    if (!fields) {
      return function () {
        return mapScope(this.$validator.flags);
      };
    }

    var normalized = normalize(fields);
    return Object.keys(normalized).reduce(function (prev, curr) {
      var field = normalized[curr];
      prev[curr] = function mappedField () {
        // if field exists
        if (this.$validator.flags[field]) {
          return this.$validator.flags[field];
        }

        // scopeless fields were selected.
        if (normalized[curr] === '*') {
          return mapScope(this.$validator.flags, false);
        }

        // if it has a scope defined
        var index = field.indexOf('.');
        if (index <= 0) {
          return {};
        }

        var ref = field.split('.');
        var scope = ref[0];
        var name = ref.slice(1);

        scope = this.$validator.flags[("$" + scope)];
        name = name.join('.');

        // an entire scope was selected: scope.*
        if (name === '*' && scope) {
          return mapScope(scope);
        }

        if (scope && scope[name]) {
          return scope[name];
        }

        return {};
      };

      return prev;
    }, {});
  };

  var version = '2.0.1';

  var rulesPlugin = function (ref) {
    var Validator$$1 = ref.Validator;

    Object.keys(Rules).forEach(function (rule) {
      Validator$$1.extend(rule, Rules[rule]);
    });

    // Merge the english messages.
    Validator$$1.localize('en', locale);
  };

  use(rulesPlugin);

  var index_esm = {
    install: install,
    use: use,
    directive: directive,
    mixin: mixin,
    mapFields: mapFields,
    Validator: Validator,
    ErrorBag: ErrorBag,
    Rules: Rules,
    version: version
  };

  var commonjsGlobal = typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};



  function unwrapExports$1 (x) {
  	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
  }

  function createCommonjsModule$1(fn, module) {
  	return module = { exports: {} }, fn(module, module.exports), module.exports;
  }

  var vResetInput = createCommonjsModule$1(function (module, exports) {
  (function(e,t){module.exports=t();})(commonjsGlobal,function(){return function(e){function t(r){if(n[r]){ return n[r].exports; }var o=n[r]={i:r,l:!1,exports:{}};return e[r].call(o.exports,o,o.exports,t),o.l=!0,o.exports}var n={};return t.m=e,t.c=n,t.i=function(e){return e},t.d=function(e,n,r){t.o(e,n)||Object.defineProperty(e,n,{configurable:!1,enumerable:!0,get:r});},t.n=function(e){var n=e&&e.__esModule?function(){return e.default}:function(){return e};return t.d(n,"a",n),n},t.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},t.p=".",t(t.s=2)}([function(e,t,n){var r=n(1);r.install=function(e){return e.directive("reset-input",r(e))},r.version="1.1.1",e.exports=r;},function(e,t){var n=null;e.exports=function(e){return{inserted:function(t,r,o){t.onfocus=function(){o.elm.parentElement.style.position="relative",t.value&&n.$el.classList.add("v-reset-input-active");},t.onblur=function(){setTimeout(function(){n.$el.classList.remove("v-reset-input-active");},150);};var u=function(){t.value="",t.dispatchEvent(new Event("input"));},i=e.extend({render:function(e){return e("span",{on:{click:u},domProps:{innerHTML:"&#10006;"},class:{"v-reset-input":!0},style:{position:"absolute",cursor:"default"}})}}),s=document.createElement("span");t.after(s),n=(new i).$mount(s);},update:function(e,t,r){e.value?n.$el.classList.add("v-reset-input-active"):n.$el.classList.remove("v-reset-input-active");}}};},function(e,t,n){e.exports=n(0);}])});
  });

  var ResetInput = unwrapExports$1(vResetInput);

  // import Vue from './vue';
  var Checkout = function Checkout () {
    // bootstrap
    this.__wrapper = document.getElementById('checkout');

    if (this.__wrapper) {
      this.$onInit();
      $$1(document).ready(this.$onReady.bind(this));
    }
  };

  /**
   * Init
   */
  Checkout.prototype.$onInit = function $onInit () {
    this._defaultView = 'overview';
    this._breakpointMobile = 600;
    this._breadcrumbs = ['overview', 'payment', 'thanks'];

    var initialView = window.location.hash.replace('#', '') || this._defaultView;
    this.deeplink(initialView);

    Vue.use(index_esm);
    Vue.use(ResetInput);

    Vue.component('app-input', {
      template: '<input id="<% input_id %>" name="<% name %>" type="<% type %>" class="form-control" v-model="<% vue_model %>">',
      data: function () {
        return {
          id: '',
          name: '',
          type: '',
          required: ''
        }
      }
    });

    this.vue = new Vue({
      el: this.__wrapper,
      performance: true,
      productionTip: false,
      delimiters: ['<%', '%>'],
      data: function () {
        return window['hsCheckout']
      },
      filters: {
        price: function (value, limit) {
          return value ? value.toFixed(limit || 2).replace('.', ',') : 0;
        }
      },
      mounted: function () {
        console.log('vue is mounted');
      },
      methods: {
        onSubmit: function () {
          console.log("onchange this is ", this, "arguments are ", arguments);
        },
        clearInput: function (modelProp) {
        },
        onchange: function () {
          var d = this.data;
          var v = this.value;
          console.log("onchange d is ", d, "v is ", v);
        }
      }
    });

  };

  Checkout.prototype.loaded = function loaded () {
    // this.__$form.show();
  };

  /**
   * On document ready
   */
  Checkout.prototype.$onReady = function $onReady () {
    // console.log('app.js document is ready');
    this.__$form = $$1('#checkout');

    // bail if we are not on the checkout page
    if (!this.__$form.length) {
      return;
    }

    this.__$htmlBody = $$1('html, body');
    this.__$modalEdit = $$1('#Checkout__edit');
    this.__$breadcrumbs = $$1('.Checkout__breadcrumbs-item');
    this.__$methodsList = $$1('.Checkout__methods');
    this.__$methodExpandables = $$1('.Checkout__method-details');

    this._initModals();
    this._initMethods();
    this.displayView();












    // this.__$wrapperLeft = $('.Checkout__main-left');
    // // this.__$breadcrumbs = $('.Checkout__breadcrumb');

    // this.__$couponArea = $('.Checkout__coupon-area');
    // this.__$couponTrigger = $('.Checkout__coupon-trigger');
    // this.__$couponInput = $('.Checkout__coupon-input');
    // this.__$couponSubmit = $('.Checkout__coupon-submit');
    // this.__$couponFeedback = $('.Checkout__coupon-feedback');

    // this.__$addressPrefilled = $('#appAddress__prefilled');
    // this.__$inputVoornam = $('#voornaam');
    // this.__$inputAchternaam = $('#achternaam');
    // this.__$inputStraat = $('#straat');
    // this.__$inputHuisnummer = $('#huisnummer');
    // this.__$inputPostcode = $('#postcode');
    // this.__$inputWoonplaats = $('#woonplaats');
    // this.__$inputLand = $('#land');
    // this.__$addressDisplay = $('#appAddress__display');

    // this.__$costWinbedrag = $('.Checkout__cost-winbedrag');
    // this.__$costWinbedragDel = $('.Checkout__cost-winbedrag--del');
    // this.__$costVerzendkosten = $('.Checkout__cost-verzendkosten');
    // this.__$costVeilingkosten = $('.Checkout__cost-veilingkosten');
    // this.__$costTotaal = $('.Checkout__cost-totaal');

    // this.__$expander = $('.Checkout__expander');
    // this.__$step0 = $('#Checkout__step-0');
    // this.__$step1 = $('#Checkout__step-1');
    // this.__$btnToStep1 = $('.Checkout__tostep1');
    // this.__$btnToStep2 = $('.Checkout__tostep2');
    // this.__$summary = $('.Checkout__main-summary');

    // this.__$paymentMethods = $('input[name="pay-method"]');
    // this.__$paymentBanks = $('input[name="pay-bank"]');
    // this.__$methodIdeal = $('.Checkout__method--ideal');
    // this.__$bankSelector = $('.Checkout__banks');
    // this.__$btnSubmit = $('.Checkout__submit');

    // this.__$details = $('.Checkout__details');

    // animate steps @@disabled
    // const minHeight = this.__$step0.outerHeight() * 1.5;
    // this.__$wrapper.css('min-height', minHeight);
    // this.__$wrapperLeft.css('min-height', minHeight);

    // this.manageValidation();

  };

  /**
   * Deeplink through hash tag
   *
   * @param{String}
   */
  Checkout.prototype.deeplink = function deeplink (viewName) {
    window.location.hash = viewName;
    this._lastView = this.view;
    this.view = viewName;
  };

  /**
   * Init modals
   */
  Checkout.prototype._initModals = function _initModals () {
      var this$1 = this;

    this.__$modalEdit
      .modal('hide')
      .on('show.bs.modal', function () {
        this$1.deeplink('edit');
      })
      .on('hide.bs.modal', function () {
        var toView = this$1._lastView;
        if (toView === 'edit') {
          toView = this$1._defaultView;
        }
        this$1.deeplink(toView);
      });
  };

  /**
   * Init methods collapsable
   */
  Checkout.prototype._initMethods = function _initMethods () {
      var this$1 = this;

    var isPayView = this.view.substr(0, 4) === 'pay-';
    var paySubview = isPayView ? this.view.substr(4, this.view.length) : false;

    this.__$methodExpandables.each(function (idx, element) {
      var $expandable = $$1(element);
      var name = $expandable.attr('data-checkout-method');
      var isdeeplinked = paySubview ? paySubview === name : false;

      $expandable
        .collapse({
          target: ("#Checkout__method-expandable-" + name),
          parent: '#Checkout__methods',
          toggle: isdeeplinked,
        })
        .on('show.bs.collapse', function () {
          this$1.deeplink(("pay-" + name));
        });
    });
  };

  /**
   * Display view
   *
   * @param{?String} givenView
   * @return {String}           The view name
   */
  Checkout.prototype.displayView = function displayView (givenView) {
      var this$1 = this;

    var view = givenView || this.view;

    if (view === 'edit') {
      this.__$modalEdit.modal('show');
    }

    // useful for global styling and hiding/showing based on current step
    this.__$form.attr('data-checkout-view', view);

    // highlight current breadcrumb if view name corresponds
    var breadcrumbView = false;
    for (var i = this._breadcrumbs.length - 1; i >= 0; i--) {
      if (this$1._breadcrumbs[i] === view) {
        breadcrumbView = view;
        break;
      }
    }
    if (breadcrumbView) {
      this.__$breadcrumbs.filter(function (index, elem) {
        if (elem.getAttribute('data-checkout-view') === breadcrumbView) {
          $$1(elem).addClass('done');
        } else {
          $$1(elem).removeClass('done');
        }
      });
    }
  };

  /**
   * Set view "edit"
   *
   * @param {String} view The view name as in the `location.hash`
   */
  // _setViewEdit (view) {
  // this.__$modalEdit.modal('show');
  // }

  /**
   * Manage form validation
   *
   * @see options here https://jqueryvalidation.org/validate/
   * @@todo perhaps use this to style the validator on the all
   * website: `$.validator.setDefaults({})`
   */
  // manageValidation () {
  // this._validation = this.__$form.validate({
  //   errorClass: 'has-feedback has-error',
  //   validClass: 'has-feedback has-success',
  //   errorElement: 'span',
  //   errorClass: 'help-feedback',
  //   errorPlacement: function(error, element) {
  //     const $parent = element.parent();
  //     if ($parent.hasClass('input-group')) {
  //       error.insertAfter($parent);
  //     }
  //     else if ($parent.hasClass('custom-control')) {
  //       $parent.after(error);
  //     } else {
  //       error.insertAfter(element);
  //     }
  //   },
  //   highlight: function(element) {
  //     $(element).parents('.form-group').addClass('has-feedback has-error')
  //       .removeClass('has-warning has-success');
  //   },
  //   unhighlight: function(element) {
  //     $(element).parents('.form-group').addClass('has-feedback has-success')
  //       .removeClass('has-error has-warning');
  //   }
  //   // submitHandler: () => {
  //   // this.goToStep(1);
  //   // },

  //   // errorClass: 'has-danger',
  //   // validClass: 'has-success',

  //   // errorElement: '<div class="form-control-feedback">',
  //   // highlight: function(element, errorClass, validClass) {
  //   // $(element).parent().addClass(errorClass).removeClass(validClass);
  //   // },
  //   // unhighlight: function(element, errorClass, validClass) {
  //   // $(element).parent().removeClass(errorClass).addClass(validClass);
  //   // }
  // });
  // console.log(this._validation)
  // }

  /**
   * Is form valid
   *
   * @return {Boolean}
   */
  Checkout.prototype.isFormValid = function isFormValid () {
    console.log(this.vue.$validator.errors.items);
    return this.__$form.valid();
  };

  /**
   * Apply coupon
   * @param{Number} discount The amount of discount in cash
   */
  Checkout.prototype.applyCoupon = function applyCoupon (discount) {
  };

  /**
   * Add zeroes
   * @see http://stackoverflow.com/a/24039448/1938970
   * @param {Number} value
   * @return {String}
   */
  Checkout.prototype.formatPrice = function formatPrice (value) {
    var asNumber = parseFloat(value);
    // replace dot with comma as in design
    var price = asNumber.toFixed(2).replace('.', ',');
    return this.getCurrency() + ' ' + price;
  };

  // export to public API
  api$1['checkout'] = new Checkout();

  var Seller = function Seller () {
    // bootstrap
    $$1(document).ready(this.$onReady.bind(this));
  };

  /**
   * On document ready
   */
  Seller.prototype.$onReady = function $onReady () {
    // console.log('app.js document is ready');
    this.__$wrapper = $$1('#hsSellercontact');

    // bail if we are not on the right page
    if (!this.__$wrapper.length) {
      return;
    }

    this.__$countrySelector = $$1('.hsLeverenCountry');

    this._bindUI();
  };

  /**
   * Bind UI
   */
  Seller.prototype._bindUI = function _bindUI () {
    var self = this;

    self.__$countrySelector.hide();
    // if (!!$('input[name="leveren"]:checked').val()) {
    // self.__$countrySelector.slideDown();
    // }

    $$1('input[name="leveren"]').on('change', function () {
      var isYes = this.value === 'ja';
      if (isYes) {
        self.__$countrySelector.slideDown();
      } else {
        self.__$countrySelector.slideUp();
      }
    });
  };

  // export to public API
  api$1['seller'] = new Seller();

  var Account = function Account () {
    // bootstrap
    this.$onInit();
    $$1(document).ready(this.$onReady.bind(this));
  };

  /**
   * Init
   */
  Account.prototype.$onInit = function $onInit () {
    this._breakpointMobile = 600;
  };

  /**
   * On document ready
   */
  Account.prototype.$onReady = function $onReady () {
    // console.log('app.js document is ready');
    this.__$wrapper = $$1('.hsAccount');

    // bail if we are not on the account page
    if (!this.__$wrapper.length) {
      return;
    }

    this._ttModal();
    this._gegevens();
  };

  /**
   * Track and trace modal
   */
  Account.prototype._ttModal = function _ttModal () {
    var $ttModal = $$1('#hsTtModal');
    if (!$ttModal.length) {
      return;
    }
    $$1(document).on('click', '.hsAccount__table-tt', function (e) {
      e.preventDefault();
      $ttModal.modal();
      $ttModal.find('.tt__verzendpartij').text(this.getAttribute('data-verzendpartij'));
      $ttModal.find('.tt__code').text(this.getAttribute('data-code'));
      // $ttModal.on('show.bs.modal', function (e) {
      // // do something...
      // })
    });
  };

  /**
   * Gegevens views switch
   */
  Account.prototype._gegevens = function _gegevens () {
      var this$1 = this;

    var $btnToEdit = $$1('#gegevens_switchedit');
    var $viewShow = $$1('#gegevens_show');
    var $viewEdit = $$1('#gegevens_edit');

    if (!$btnToEdit.length) {
      return;
    }

    var _switchView = function (event, name) {
      var newView = name;
      var currentView = this$1._currentView;
      if (event) {
        event.preventDefault();
      }
      if (!newView) {
        newView = location.hash.replace('#', '');
      }
      if (!newView) {
        return;
      }
      if (newView === 'show' && currentView !== 'show') {
        $viewEdit.slideUp();
        $viewShow.slideDown();
        location.hash = this$1._currentView = 'show';
      } else if (newView === 'edit' && currentView !== 'edit') {
        $viewShow.slideUp();
        $viewEdit.slideDown();
        location.hash = this$1._currentView = 'edit';
      }
    };

    window.addEventListener('hashchange', _switchView, false);

    _switchView(null, 'show');

    $btnToEdit.click(function (e) { _switchView(e, 'edit' );});
  };

  // export to public API
  api$1['account'] = new Account();

  var Countdown = function Countdown () {
    this.$onInit();
    $$1(document).ready(this.$onReady.bind(this));
  };

  /**
   * Init
   */
  Countdown.prototype.$onInit = function $onInit () {
  };

  /**
   * On document ready
   */
  Countdown.prototype.$onReady = function $onReady () {
    this.__$wrapper = $$1('.countdown');

    if (!this.__$wrapper.length) {
      return;
    }

    this.__$days = this.__$wrapper.find('[data-countdown="days"]');
    this.__$hours = this.__$wrapper.find('[data-countdown="hours"]');
    this.__$minutes = this.__$wrapper.find('[data-countdown="minutes"]');
    this.__$seconds = this.__$wrapper.find('[data-countdown="seconds"]');

    this._startCounter();
  };

  /**
   * Manually init
   */
  Countdown.prototype.init = function init () {
    this.$onReady();
  };

  /**
   * Start counter;
   * @return {[type]} [description]
   */
  Countdown.prototype._startCounter = function _startCounter () {
      var this$1 = this;

    this._seconds = 0;
    if (this._interval) {
      clearInterval(this._interval);
    }
    this._interval = setInterval(function () {
      this$1._seconds = this$1._seconds + 1;
      this$1._update();
    }, 1000);
  };

  /**
   * Update UI every second
   */
  Countdown.prototype._update = function _update () {
    var currentSeconds = parseInt(this.__$seconds.html(), 10);
    var currentMinutes = parseInt(this.__$minutes.html(), 10);
    var currentHours = parseInt(this.__$hours.html(), 10);
    var currentDays = parseInt(this.__$days.html(), 10);

    var newSeconds = Math.max(-1, Math.min(currentSeconds - 1, 60));
    var newMinutes = currentMinutes;
    var newHours = currentHours;
    var newDays = currentDays;

    if (newSeconds === -1) {
      newSeconds = 59;
      newMinutes = Math.max(-1, Math.min(currentMinutes - 1, 59));

      if (newMinutes === -1) {
        newMinutes = 59;
        newHours = Math.max(-1, Math.min(currentHours - 1, 23));

        if (newHours === -1) {
          newHours = 23;
          newDays = Math.max(-1, Math.min(newDays - 1, 364));
        }
      }
    }

    this.__$seconds.html(this._pad(newSeconds));
    this.__$minutes.html(this._pad(newMinutes));
    this.__$hours.html(this._pad(newHours));
    this.__$days.html(this._pad(newDays));
  };

  /**
   * Pad numbers (add leading zero)
   *
   * @param{Number} num
   * @param{Number} size
   * @return {String}
   */
  Countdown.prototype._pad = function _pad (num, size) {
      if ( size === void 0 ) size=2;

    var s = num + '';
    while (s.length < size) { s = '0' + s; }
    return s;
  };

  // export to public API
  api$1['countdown'] = new Countdown();

  // import tether from 'tether';
  // import './bootstrap-4-dev/collapse'; // 'bootstrap/js/src/collapse';
  // import './bootstrap-4-dev/alert'; // 'bootstrap/js/src/alert';
  // import './bootstrap-4-dev/modal'; // 'bootstrap/js/src/modal';
  // import './bootstrap-4-dev/tooltip'; // 'bootstrap/js/src/tooltip';
  // import './bootstrap-4-dev/dropdown'; // 'bootstrap/js/src/dropdown';

  // import 'jquery-match-height/dist/jquery.matchHeight';
  // import 'datatables.net';
  // import 'slick-carousel/slick/slick.js';

  // import './forms';
  var App = function App () {
    // bootstrap
    this.$onInit();
    $$1(document).ready(this.$onReady.bind(this));
  };

  /**
   * Init
   */
  App.prototype.$onInit = function $onInit () {
    // console.log('app.js initialized');
    this._updateCopyrightYear();
    this._accountMenu();
  };

  /**
   * On document ready
   */
  App.prototype.$onReady = function $onReady () {
    // console.log('app.js document is ready');
    this.__$itemCols = $$1('.hsItem__col');

    this._$win = $$1(window);

    // this._mobileImages();
    this._matchColsHeight();
    this._manageCatsSlider();
    this._initModals();
    this._initForms();
    this._initTables();
    this._initDropdowns();
    this._initAuthModal();
    this._$win.resize(this._matchColsHeight.bind(this));
    this._$win.resize(this._manageCatsSlider.bind(this));
    // this._$win.resize(this._mobileImages.bind(this));
  };

  /**
   * Init tooltips
   *
   */
  App.prototype._initTooltips = function _initTooltips () {
    // bootstrap tooltips
    // $('.js-tooltip').tooltip({});
    $$1('.shippingtime-tooltip').tooltip({
      animation: false,
      offset: '-10px 0',
      // delay: { hide: 1000000 }, // for debugging
      template: '<div class="tooltip tooltip-top tooltip--light shippingtime__tooltip" role="tooltip"><div class="tooltip-arrow"></div><div class="tooltip-inner"></div></div>'
    });
    // $('.shippingtime').each(function () {
    // $(this).tooltip({
    //   template: '<div class="tooltip tooltip--light" role="tooltip"><div class="tooltip-arrow"></div><div class="tooltip-inner"></div></div>'
    //   container: this,
    //   offset: '0 -80%',
    //   delay: { hide: 1000000 } // for debugging
    // });
    // });
  };

  /**
   * Manage item card's mobile images
   */
  App.prototype._mobileImages = function _mobileImages () {
    if ($$1(window).width() < 992) {
      var mobileProductImages = document.getElementsByClassName('hsItemCard__bottom-img');
      if (mobileProductImages) {
        var loop = function ( i ) {
          var tmpImg = new Image();
          var img = mobileProductImages[i];
          tmpImg.src = img.src;

          var $wrapper = $$1(img.parentNode);

          var imgCssString = '';

          tmpImg.onload = function () {
            var wrapperWidth = $wrapper.outerWidth(true);//.offsetWidth;
            var wrapperHeight = $wrapper.outerHeight(true);// .offsetHeight;
            var imgWidth = tmpImg.naturalWidth;
            var imgHeight = tmpImg.naturalHeight;
            console.log('wrapperHeight', wrapperHeight, 'wrapperHeight', wrapperHeight);
            if (imgHeight > imgWidth) {
              imgCssString += "max-width:" + wrapperWidth + "px;height:auto;left:0;top:50%;margin-top:-" + (img.height / 2) + "px;";
            } else {
              imgCssString += "max-height:" + wrapperHeight + "px;width:auto;left:50%;top:0;margin-left:-" + (img.width / 2) + "px;";
            }

            img.style.cssText = imgCssString + 'opacity:1;';
          };
        };

          for (var i = 0; i < mobileProductImages.length; i++) loop( i );
      }
    }
  };

  /**
   * Match the height of the item cards' columns
   */
  App.prototype._matchColsHeight = function _matchColsHeight () {
    if (this.__$itemCols.length) {
      if ($$1(window).width() >= 992) {
        this.__$itemCols.matchHeight({});
      } else {
        this.__$itemCols.matchHeight({ remove: true });
      }
    }
  };

  /**
   * Manage categories slider
   */
  App.prototype._manageCatsSlider = function _manageCatsSlider () {
    var $subheaderList = $$1('.appSubheader__list');
    var $subheaderLinks = $$1('.appSubheader__link');
    var listFullWidth = 0;
    var currentLinkIdx;
    var oneSlideWidth;

    /**
     * Show hint scrolls only when it's needed
     *
     */
    var _maybeShowHintScrolls = function (e, slick, current, nextIdx) {
      if (nextIdx < $subheaderLinks.length - 3) {
        $subheaderList.addClass('slick-hint-next');
      } else {
        $subheaderList.removeClass('slick-hint-next');
      }

      if (nextIdx > 1) {
        $subheaderList.addClass('slick-hint-prev');
      } else {
        $subheaderList.removeClass('slick-hint-prev');
      }
    };

    if (!$subheaderList.length) {
      return;
    }
    $subheaderLinks.each(function (idx, item) {
      var $item = $$1(item);
      oneSlideWidth = $item.width();
      listFullWidth = listFullWidth + oneSlideWidth;
      if ($item.hasClass('active')) {
        currentLinkIdx = idx;
      }
    });

    // if we have a slider
    if ($subheaderList.width() < listFullWidth) {
      // just update the current slide
      if (this._catsSlider) {
        if (currentLinkIdx || currentLinkIdx === 0) {
          this._catsSlider.trigger('slickGoTo', currentLinkIdx);
        }
      // or init the slider
      } else {
        this._catsSliderHtmlPreSlick = $subheaderList.html();

        this._catsSlider = $subheaderList.slick({
          // slidesToShow: 4, // $subheaderLinks.length,
          dots: false,
          arrows: false,
          variableWidth: true,
          slidesToScroll: 1,
          centerMode: this._determineIfCenterMode(listFullWidth, oneSlideWidth, currentLinkIdx),
          infinite: false,
          initialSlide: currentLinkIdx
        });

        _maybeShowHintScrolls(null, null, null, currentLinkIdx);

        this._catsSlider.on('beforeChange', _maybeShowHintScrolls);
      }
    // if we don't want to have a slider
    } else {
      if (this._catsSlider) {
        this._catsSlider.slick('unslick')
          .removeClass('slick-hint-prev')
          .removeClass('slick-hint-next');
        $subheaderList.html(this._catsSliderHtmlPreSlick);
        this._catsSlider = null;
      }
    }
  };

  /**
   * Determine if the categories slider should put the current icon
   * in the center, this is to prevent to have a partially empty slider
   * on the left hand side.
   *
   * @param{Number}listFullWidth
   * @param{Number}oneSlideWidth
   * @param{Number}currentLinkIdx
   * @return {boolean}
   */
  App.prototype._determineIfCenterMode = function _determineIfCenterMode (listFullWidth, oneSlideWidth, currentLinkIdx) {
    var containerWidth = $$1(window).width();
    if (currentLinkIdx === 0) {
      return false;
    }
    return true;
  };

  /**
   * For centered modal
   *
   * @seehttps://stackoverflow.com/a/41377502/1938970
   */
  App.prototype._initModals = function _initModals () {
    $$1('.modal-dialog').on('click tap', function(e) {
      var __$modalDialog = $$1(this);
      if ($$1(e.target).hasClass('modal-dialog')) {
        __$modalDialog.parent().modal('hide');
      }
    });
  };

  /**
   * Init forms (validation)
   */
  App.prototype._initForms = function _initForms () {
    $$1('.form-validate').validate({
      errorClass: 'has-danger',
      validClass: 'has-success',
    });
  };

  /**
   * Init tables
   */
  App.prototype._initTables = function _initTables () {
    // datable on 'my account' pages
    $$1('.datatable').DataTable({
      searching: false,
      ordering: false,
      drawCallback: this._initTooltips.bind(this)
    });
  };

  /**
   * Init dropdowns
   */
  App.prototype._initDropdowns = function _initDropdowns () {
    // dropdown
    $$1('#hsLang__header')
      .on('show.bs.dropdown', function () {
        $$1('#hsHeader').addClass('last-dropdown-open');
      })
      .on('hide.bs.dropdown', function () {
        $$1('#hsHeader').removeClass('last-dropdown-open');
      });

    // $('.navselector') // 991 change to <option>
    $$1('.JSnavsel__select').on('change', function () {
      window.location.href = this.value;
      // getAttribute('data-href');
    });
  };

  /**
   * Update copyright year
   */
  App.prototype._updateCopyrightYear = function _updateCopyrightYear () {
    var el = document.getElementById('js-copyyear');
    if (el) {
      el.innerHTML = new Date().getFullYear();
    }
  };

  /**
   * Account menu
   */
  App.prototype._accountMenu = function _accountMenu () {
    var el = document.getElementById('js-myaccount_btn');
    if (el) {
      el.onclick = function () {
        document.body.classList.add('hsAccount--menu-open');
      };
    }
  };

  /**
   * Init authentication modals
   */
  App.prototype._initAuthModal = function _initAuthModal () {
    var $authModal = $$1('#hsAuthModal');
    this.__$authModal = $authModal;
    if (!$authModal.length) {
      return;
    }

    $authModal.on('show.bs.modal', function (e) {
      $$1('body').addClass('appAuthModal--open');
    });
    $authModal.on('hidden.bs.modal', function (e) {
      $$1('body').removeClass('appAuthModal--open');
    });
    $authModal.modal('hide');
    // $authModal.modal('hide');

    $$1(document).on('click', '[data-authmodal]', function (e) {
      e.preventDefault();
      var $btn = $$1(this);
      var view = this.getAttribute('data-authmodal');
      if (!view) {
        throw new Error('`data-authmodal` must have a value (e.g. `login` or `register`)');
        return;
      }
      $authModal.attr('data-view', view);
      try {
        $authModal.modal('show');
      } catch (e) {
        console.log(e);
      }
    });
  };

  /**
   * Prompt login modal
   *
   * @public
   */
  App.prototype.promptLogin = function promptLogin () {
    if (this.__$authModal) {
      this.__$authModal.attr('data-view', 'login');
      this.__$authModal.modal();
    }
  };

  /**
   * Prompt register modal
   *
   * @public
   */
  App.prototype.promptRegister = function promptRegister () {
    if (this.__$authModal) {
      this.__$authModal.attr('data-view', 'register');
      this.__$authModal.modal();
    }
  };

  /**
   * Update UI (Erwin call's this when opening the item modal)
   *
   * @public
   */
  App.prototype.updateUI = function updateUI () {
    try {
      api$1['itemDetail'].$onReady();
    } catch (e) {}
  };

  // export to public API
  api$1['app'] = new App();

}(jQuery));

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjpudWxsLCJzb3VyY2VzIjpbIi9tZWRpYS9kYXRhL3dlYi93ZWItcHJvamVjdHMvaGVsbG9zcGVjaWFsL25vZGVfbW9kdWxlcy9ib290c3RyYXAvanMvc3JjL3V0aWwuanMiLCIvbWVkaWEvZGF0YS93ZWIvd2ViLXByb2plY3RzL2hlbGxvc3BlY2lhbC9ub2RlX21vZHVsZXMvYm9vdHN0cmFwL2pzL3NyYy9jb2xsYXBzZS5qcyIsIi9tZWRpYS9kYXRhL3dlYi93ZWItcHJvamVjdHMvaGVsbG9zcGVjaWFsL25vZGVfbW9kdWxlcy9ib290c3RyYXAvanMvc3JjL2FsZXJ0LmpzIiwiL21lZGlhL2RhdGEvd2ViL3dlYi1wcm9qZWN0cy9oZWxsb3NwZWNpYWwvbm9kZV9tb2R1bGVzL2Jvb3RzdHJhcC9qcy9zcmMvbW9kYWwuanMiLCIvbWVkaWEvZGF0YS93ZWIvd2ViLXByb2plY3RzL2hlbGxvc3BlY2lhbC9ub2RlX21vZHVsZXMvYm9vdHN0cmFwL2pzL3NyYy90b29sdGlwLmpzIiwiL21lZGlhL2RhdGEvd2ViL3dlYi1wcm9qZWN0cy9oZWxsb3NwZWNpYWwvbm9kZV9tb2R1bGVzL2Jvb3RzdHJhcC9qcy9zcmMvZHJvcGRvd24uanMiLCIvbWVkaWEvZGF0YS93ZWIvd2ViLXByb2plY3RzL2hlbGxvc3BlY2lhbC9zcmMvYXBwL3NjcmlwdHMvYXBpLmpzIiwiL21lZGlhL2RhdGEvd2ViL3dlYi1wcm9qZWN0cy9oZWxsb3NwZWNpYWwvc3JjL2FwcC9zY3JpcHRzL2kxOG4uanMiLCIvbWVkaWEvZGF0YS93ZWIvd2ViLXByb2plY3RzL2hlbGxvc3BlY2lhbC9zcmMvYXBwL3NjcmlwdHMvc3RhdGVzLmRlZmF1bHRzLmpzIiwiL21lZGlhL2RhdGEvd2ViL3dlYi1wcm9qZWN0cy9oZWxsb3NwZWNpYWwvc3JjL2FwcC9zY3JpcHRzL2NvbG9ycy5kZWZhdWx0cy5qcyIsIi9tZWRpYS9kYXRhL3dlYi93ZWItcHJvamVjdHMvaGVsbG9zcGVjaWFsL3NyYy9hcHAvc2NyaXB0cy9zdmdQaWVUaW1lci5qcyIsIi9tZWRpYS9kYXRhL3dlYi93ZWItcHJvamVjdHMvaGVsbG9zcGVjaWFsL3NyYy9hcHAvc2NyaXB0cy9pdGVtLmpzIiwiL21lZGlhL2RhdGEvd2ViL3dlYi1wcm9qZWN0cy9oZWxsb3NwZWNpYWwvc3JjL2FwcC9zY3JpcHRzL2RlbW8uanMiLCIvbWVkaWEvZGF0YS93ZWIvd2ViLXByb2plY3RzL2hlbGxvc3BlY2lhbC9zcmMvYXBwL3NjcmlwdHMvYWJ0ZXN0aW5nLmpzIiwiL21lZGlhL2RhdGEvd2ViL3dlYi1wcm9qZWN0cy9oZWxsb3NwZWNpYWwvc3JjL2FwcC9zY3JpcHRzL2Nvb2tpZWFubm91bmNlbWVudC5qcyIsIi9tZWRpYS9kYXRhL3dlYi93ZWItcHJvamVjdHMvaGVsbG9zcGVjaWFsL3NyYy9hcHAvc2NyaXB0cy9uYXNrLmpzIiwiL21lZGlhL2RhdGEvd2ViL3dlYi1wcm9qZWN0cy9oZWxsb3NwZWNpYWwvc3JjL2FwcC9zY3JpcHRzL2ZhcS5qcyIsIi9tZWRpYS9kYXRhL3dlYi93ZWItcHJvamVjdHMvaGVsbG9zcGVjaWFsL3NyYy9hcHAvc2NyaXB0cy9pdGVtRGV0YWlsLmpzIiwiL21lZGlhL2RhdGEvd2ViL3dlYi1wcm9qZWN0cy9oZWxsb3NwZWNpYWwvc3JjL2FwcC9zY3JpcHRzL2Jyb3dzZXJzLmpzIiwiL21lZGlhL2RhdGEvd2ViL3dlYi1wcm9qZWN0cy9oZWxsb3NwZWNpYWwvbm9kZV9tb2R1bGVzL3ZlZS12YWxpZGF0ZS9kaXN0L3ZlZS12YWxpZGF0ZS5lc20uanMiLCIvbWVkaWEvZGF0YS93ZWIvd2ViLXByb2plY3RzL2hlbGxvc3BlY2lhbC9ub2RlX21vZHVsZXMvdi1yZXNldC1pbnB1dC9kaXN0L3YtcmVzZXQtaW5wdXQuanMiLCIvbWVkaWEvZGF0YS93ZWIvd2ViLXByb2plY3RzL2hlbGxvc3BlY2lhbC9zcmMvYXBwL3NjcmlwdHMvY2hlY2tvdXQuanMiLCIvbWVkaWEvZGF0YS93ZWIvd2ViLXByb2plY3RzL2hlbGxvc3BlY2lhbC9zcmMvYXBwL3NjcmlwdHMvc2VsbGVyLmpzIiwiL21lZGlhL2RhdGEvd2ViL3dlYi1wcm9qZWN0cy9oZWxsb3NwZWNpYWwvc3JjL2FwcC9zY3JpcHRzL2FjY291bnQuanMiLCIvbWVkaWEvZGF0YS93ZWIvd2ViLXByb2plY3RzL2hlbGxvc3BlY2lhbC9zcmMvYXBwL3NjcmlwdHMvY291bnRkb3duLmpzIiwiL21lZGlhL2RhdGEvd2ViL3dlYi1wcm9qZWN0cy9oZWxsb3NwZWNpYWwvc3JjL2FwcC9zY3JpcHRzL2FwcC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBCb290c3RyYXAgKHY0LjAuMC1hbHBoYS42KTogdXRpbC5qc1xuICogTGljZW5zZWQgdW5kZXIgTUlUIChodHRwczovL2dpdGh1Yi5jb20vdHdicy9ib290c3RyYXAvYmxvYi9tYXN0ZXIvTElDRU5TRSlcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKi9cblxuY29uc3QgVXRpbCA9ICgoJCkgPT4ge1xuXG5cbiAgLyoqXG4gICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgKiBQcml2YXRlIFRyYW5zaXRpb25FbmQgSGVscGVyc1xuICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICovXG5cbiAgbGV0IHRyYW5zaXRpb24gPSBmYWxzZVxuXG4gIGNvbnN0IE1BWF9VSUQgPSAxMDAwMDAwXG5cbiAgY29uc3QgVHJhbnNpdGlvbkVuZEV2ZW50ID0ge1xuICAgIFdlYmtpdFRyYW5zaXRpb24gOiAnd2Via2l0VHJhbnNpdGlvbkVuZCcsXG4gICAgTW96VHJhbnNpdGlvbiAgICA6ICd0cmFuc2l0aW9uZW5kJyxcbiAgICBPVHJhbnNpdGlvbiAgICAgIDogJ29UcmFuc2l0aW9uRW5kIG90cmFuc2l0aW9uZW5kJyxcbiAgICB0cmFuc2l0aW9uICAgICAgIDogJ3RyYW5zaXRpb25lbmQnXG4gIH1cblxuICAvLyBzaG91dG91dCBBbmd1c0Nyb2xsIChodHRwczovL2dvby5nbC9weHdRR3ApXG4gIGZ1bmN0aW9uIHRvVHlwZShvYmopIHtcbiAgICByZXR1cm4ge30udG9TdHJpbmcuY2FsbChvYmopLm1hdGNoKC9cXHMoW2EtekEtWl0rKS8pWzFdLnRvTG93ZXJDYXNlKClcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzRWxlbWVudChvYmopIHtcbiAgICByZXR1cm4gKG9ialswXSB8fCBvYmopLm5vZGVUeXBlXG4gIH1cblxuICBmdW5jdGlvbiBnZXRTcGVjaWFsVHJhbnNpdGlvbkVuZEV2ZW50KCkge1xuICAgIHJldHVybiB7XG4gICAgICBiaW5kVHlwZTogdHJhbnNpdGlvbi5lbmQsXG4gICAgICBkZWxlZ2F0ZVR5cGU6IHRyYW5zaXRpb24uZW5kLFxuICAgICAgaGFuZGxlKGV2ZW50KSB7XG4gICAgICAgIGlmICgkKGV2ZW50LnRhcmdldCkuaXModGhpcykpIHtcbiAgICAgICAgICByZXR1cm4gZXZlbnQuaGFuZGxlT2JqLmhhbmRsZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIHByZWZlci1yZXN0LXBhcmFtc1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1bmRlZmluZWRcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiB0cmFuc2l0aW9uRW5kVGVzdCgpIHtcbiAgICBpZiAod2luZG93LlFVbml0KSB7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG5cbiAgICBjb25zdCBlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2Jvb3RzdHJhcCcpXG5cbiAgICBmb3IgKGNvbnN0IG5hbWUgaW4gVHJhbnNpdGlvbkVuZEV2ZW50KSB7XG4gICAgICBpZiAoZWwuc3R5bGVbbmFtZV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGVuZDogVHJhbnNpdGlvbkVuZEV2ZW50W25hbWVdXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIGZ1bmN0aW9uIHRyYW5zaXRpb25FbmRFbXVsYXRvcihkdXJhdGlvbikge1xuICAgIGxldCBjYWxsZWQgPSBmYWxzZVxuXG4gICAgJCh0aGlzKS5vbmUoVXRpbC5UUkFOU0lUSU9OX0VORCwgKCkgPT4ge1xuICAgICAgY2FsbGVkID0gdHJ1ZVxuICAgIH0pXG5cbiAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIGlmICghY2FsbGVkKSB7XG4gICAgICAgIFV0aWwudHJpZ2dlclRyYW5zaXRpb25FbmQodGhpcylcbiAgICAgIH1cbiAgICB9LCBkdXJhdGlvbilcblxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICBmdW5jdGlvbiBzZXRUcmFuc2l0aW9uRW5kU3VwcG9ydCgpIHtcbiAgICB0cmFuc2l0aW9uID0gdHJhbnNpdGlvbkVuZFRlc3QoKVxuXG4gICAgJC5mbi5lbXVsYXRlVHJhbnNpdGlvbkVuZCA9IHRyYW5zaXRpb25FbmRFbXVsYXRvclxuXG4gICAgaWYgKFV0aWwuc3VwcG9ydHNUcmFuc2l0aW9uRW5kKCkpIHtcbiAgICAgICQuZXZlbnQuc3BlY2lhbFtVdGlsLlRSQU5TSVRJT05fRU5EXSA9IGdldFNwZWNpYWxUcmFuc2l0aW9uRW5kRXZlbnQoKVxuICAgIH1cbiAgfVxuXG5cbiAgLyoqXG4gICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAqIFB1YmxpYyBVdGlsIEFwaVxuICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgKi9cblxuICBjb25zdCBVdGlsID0ge1xuXG4gICAgVFJBTlNJVElPTl9FTkQ6ICdic1RyYW5zaXRpb25FbmQnLFxuXG4gICAgZ2V0VUlEKHByZWZpeCkge1xuICAgICAgZG8ge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tYml0d2lzZVxuICAgICAgICBwcmVmaXggKz0gfn4oTWF0aC5yYW5kb20oKSAqIE1BWF9VSUQpIC8vIFwifn5cIiBhY3RzIGxpa2UgYSBmYXN0ZXIgTWF0aC5mbG9vcigpIGhlcmVcbiAgICAgIH0gd2hpbGUgKGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKHByZWZpeCkpXG4gICAgICByZXR1cm4gcHJlZml4XG4gICAgfSxcblxuICAgIGdldFNlbGVjdG9yRnJvbUVsZW1lbnQoZWxlbWVudCkge1xuICAgICAgbGV0IHNlbGVjdG9yID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ2RhdGEtdGFyZ2V0JylcblxuICAgICAgaWYgKCFzZWxlY3Rvcikge1xuICAgICAgICBzZWxlY3RvciA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKCdocmVmJykgfHwgJydcbiAgICAgICAgc2VsZWN0b3IgPSAvXiNbYS16XS9pLnRlc3Qoc2VsZWN0b3IpID8gc2VsZWN0b3IgOiBudWxsXG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzZWxlY3RvclxuICAgIH0sXG5cbiAgICByZWZsb3coZWxlbWVudCkge1xuICAgICAgcmV0dXJuIGVsZW1lbnQub2Zmc2V0SGVpZ2h0XG4gICAgfSxcblxuICAgIHRyaWdnZXJUcmFuc2l0aW9uRW5kKGVsZW1lbnQpIHtcbiAgICAgICQoZWxlbWVudCkudHJpZ2dlcih0cmFuc2l0aW9uLmVuZClcbiAgICB9LFxuXG4gICAgc3VwcG9ydHNUcmFuc2l0aW9uRW5kKCkge1xuICAgICAgcmV0dXJuIEJvb2xlYW4odHJhbnNpdGlvbilcbiAgICB9LFxuXG4gICAgdHlwZUNoZWNrQ29uZmlnKGNvbXBvbmVudE5hbWUsIGNvbmZpZywgY29uZmlnVHlwZXMpIHtcbiAgICAgIGZvciAoY29uc3QgcHJvcGVydHkgaW4gY29uZmlnVHlwZXMpIHtcbiAgICAgICAgaWYgKGNvbmZpZ1R5cGVzLmhhc093blByb3BlcnR5KHByb3BlcnR5KSkge1xuICAgICAgICAgIGNvbnN0IGV4cGVjdGVkVHlwZXMgPSBjb25maWdUeXBlc1twcm9wZXJ0eV1cbiAgICAgICAgICBjb25zdCB2YWx1ZSAgICAgICAgID0gY29uZmlnW3Byb3BlcnR5XVxuICAgICAgICAgIGNvbnN0IHZhbHVlVHlwZSAgICAgPSB2YWx1ZSAmJiBpc0VsZW1lbnQodmFsdWUpID9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2VsZW1lbnQnIDogdG9UeXBlKHZhbHVlKVxuXG4gICAgICAgICAgaWYgKCFuZXcgUmVnRXhwKGV4cGVjdGVkVHlwZXMpLnRlc3QodmFsdWVUeXBlKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgICBgJHtjb21wb25lbnROYW1lLnRvVXBwZXJDYXNlKCl9OiBgICtcbiAgICAgICAgICAgICAgYE9wdGlvbiBcIiR7cHJvcGVydHl9XCIgcHJvdmlkZWQgdHlwZSBcIiR7dmFsdWVUeXBlfVwiIGAgK1xuICAgICAgICAgICAgICBgYnV0IGV4cGVjdGVkIHR5cGUgXCIke2V4cGVjdGVkVHlwZXN9XCIuYClcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBzZXRUcmFuc2l0aW9uRW5kU3VwcG9ydCgpXG5cbiAgcmV0dXJuIFV0aWxcblxufSkoalF1ZXJ5KVxuXG5leHBvcnQgZGVmYXVsdCBVdGlsXG4iLCJpbXBvcnQgVXRpbCBmcm9tICcuL3V0aWwnXG5cblxuLyoqXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogQm9vdHN0cmFwICh2NC4wLjAtYWxwaGEuNik6IGNvbGxhcHNlLmpzXG4gKiBMaWNlbnNlZCB1bmRlciBNSVQgKGh0dHBzOi8vZ2l0aHViLmNvbS90d2JzL2Jvb3RzdHJhcC9ibG9iL21hc3Rlci9MSUNFTlNFKVxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqL1xuXG5jb25zdCBDb2xsYXBzZSA9ICgoJCkgPT4ge1xuXG5cbiAgLyoqXG4gICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgKiBDb25zdGFudHNcbiAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAqL1xuXG4gIGNvbnN0IE5BTUUgICAgICAgICAgICAgICAgPSAnY29sbGFwc2UnXG4gIGNvbnN0IFZFUlNJT04gICAgICAgICAgICAgPSAnNC4wLjAtYWxwaGEuNidcbiAgY29uc3QgREFUQV9LRVkgICAgICAgICAgICA9ICdicy5jb2xsYXBzZSdcbiAgY29uc3QgRVZFTlRfS0VZICAgICAgICAgICA9IGAuJHtEQVRBX0tFWX1gXG4gIGNvbnN0IERBVEFfQVBJX0tFWSAgICAgICAgPSAnLmRhdGEtYXBpJ1xuICBjb25zdCBKUVVFUllfTk9fQ09ORkxJQ1QgID0gJC5mbltOQU1FXVxuICBjb25zdCBUUkFOU0lUSU9OX0RVUkFUSU9OID0gNjAwXG5cbiAgY29uc3QgRGVmYXVsdCA9IHtcbiAgICB0b2dnbGUgOiB0cnVlLFxuICAgIHBhcmVudCA6ICcnXG4gIH1cblxuICBjb25zdCBEZWZhdWx0VHlwZSA9IHtcbiAgICB0b2dnbGUgOiAnYm9vbGVhbicsXG4gICAgcGFyZW50IDogJ3N0cmluZydcbiAgfVxuXG4gIGNvbnN0IEV2ZW50ID0ge1xuICAgIFNIT1cgICAgICAgICAgIDogYHNob3cke0VWRU5UX0tFWX1gLFxuICAgIFNIT1dOICAgICAgICAgIDogYHNob3duJHtFVkVOVF9LRVl9YCxcbiAgICBISURFICAgICAgICAgICA6IGBoaWRlJHtFVkVOVF9LRVl9YCxcbiAgICBISURERU4gICAgICAgICA6IGBoaWRkZW4ke0VWRU5UX0tFWX1gLFxuICAgIENMSUNLX0RBVEFfQVBJIDogYGNsaWNrJHtFVkVOVF9LRVl9JHtEQVRBX0FQSV9LRVl9YFxuICB9XG5cbiAgY29uc3QgQ2xhc3NOYW1lID0ge1xuICAgIFNIT1cgICAgICAgOiAnc2hvdycsXG4gICAgQ09MTEFQU0UgICA6ICdjb2xsYXBzZScsXG4gICAgQ09MTEFQU0lORyA6ICdjb2xsYXBzaW5nJyxcbiAgICBDT0xMQVBTRUQgIDogJ2NvbGxhcHNlZCdcbiAgfVxuXG4gIGNvbnN0IERpbWVuc2lvbiA9IHtcbiAgICBXSURUSCAgOiAnd2lkdGgnLFxuICAgIEhFSUdIVCA6ICdoZWlnaHQnXG4gIH1cblxuICBjb25zdCBTZWxlY3RvciA9IHtcbiAgICBBQ1RJVkVTICAgICA6ICcuY2FyZCA+IC5zaG93LCAuY2FyZCA+IC5jb2xsYXBzaW5nJyxcbiAgICBEQVRBX1RPR0dMRSA6ICdbZGF0YS10b2dnbGU9XCJjb2xsYXBzZVwiXSdcbiAgfVxuXG5cbiAgLyoqXG4gICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgKiBDbGFzcyBEZWZpbml0aW9uXG4gICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgKi9cblxuICBjbGFzcyBDb2xsYXBzZSB7XG5cbiAgICBjb25zdHJ1Y3RvcihlbGVtZW50LCBjb25maWcpIHtcbiAgICAgIHRoaXMuX2lzVHJhbnNpdGlvbmluZyA9IGZhbHNlXG4gICAgICB0aGlzLl9lbGVtZW50ICAgICAgICAgPSBlbGVtZW50XG4gICAgICB0aGlzLl9jb25maWcgICAgICAgICAgPSB0aGlzLl9nZXRDb25maWcoY29uZmlnKVxuICAgICAgdGhpcy5fdHJpZ2dlckFycmF5ICAgID0gJC5tYWtlQXJyYXkoJChcbiAgICAgICAgYFtkYXRhLXRvZ2dsZT1cImNvbGxhcHNlXCJdW2hyZWY9XCIjJHtlbGVtZW50LmlkfVwiXSxgICtcbiAgICAgICAgYFtkYXRhLXRvZ2dsZT1cImNvbGxhcHNlXCJdW2RhdGEtdGFyZ2V0PVwiIyR7ZWxlbWVudC5pZH1cIl1gXG4gICAgICApKVxuXG4gICAgICB0aGlzLl9wYXJlbnQgPSB0aGlzLl9jb25maWcucGFyZW50ID8gdGhpcy5fZ2V0UGFyZW50KCkgOiBudWxsXG5cbiAgICAgIGlmICghdGhpcy5fY29uZmlnLnBhcmVudCkge1xuICAgICAgICB0aGlzLl9hZGRBcmlhQW5kQ29sbGFwc2VkQ2xhc3ModGhpcy5fZWxlbWVudCwgdGhpcy5fdHJpZ2dlckFycmF5KVxuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5fY29uZmlnLnRvZ2dsZSkge1xuICAgICAgICB0aGlzLnRvZ2dsZSgpXG4gICAgICB9XG4gICAgfVxuXG5cbiAgICAvLyBnZXR0ZXJzXG5cbiAgICBzdGF0aWMgZ2V0IFZFUlNJT04oKSB7XG4gICAgICByZXR1cm4gVkVSU0lPTlxuICAgIH1cblxuICAgIHN0YXRpYyBnZXQgRGVmYXVsdCgpIHtcbiAgICAgIHJldHVybiBEZWZhdWx0XG4gICAgfVxuXG5cbiAgICAvLyBwdWJsaWNcblxuICAgIHRvZ2dsZSgpIHtcbiAgICAgIGlmICgkKHRoaXMuX2VsZW1lbnQpLmhhc0NsYXNzKENsYXNzTmFtZS5TSE9XKSkge1xuICAgICAgICB0aGlzLmhpZGUoKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5zaG93KClcbiAgICAgIH1cbiAgICB9XG5cbiAgICBzaG93KCkge1xuICAgICAgaWYgKHRoaXMuX2lzVHJhbnNpdGlvbmluZykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvbGxhcHNlIGlzIHRyYW5zaXRpb25pbmcnKVxuICAgICAgfVxuXG4gICAgICBpZiAoJCh0aGlzLl9lbGVtZW50KS5oYXNDbGFzcyhDbGFzc05hbWUuU0hPVykpIHtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG5cbiAgICAgIGxldCBhY3RpdmVzXG4gICAgICBsZXQgYWN0aXZlc0RhdGFcblxuICAgICAgaWYgKHRoaXMuX3BhcmVudCkge1xuICAgICAgICBhY3RpdmVzID0gJC5tYWtlQXJyYXkoJCh0aGlzLl9wYXJlbnQpLmZpbmQoU2VsZWN0b3IuQUNUSVZFUykpXG4gICAgICAgIGlmICghYWN0aXZlcy5sZW5ndGgpIHtcbiAgICAgICAgICBhY3RpdmVzID0gbnVsbFxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChhY3RpdmVzKSB7XG4gICAgICAgIGFjdGl2ZXNEYXRhID0gJChhY3RpdmVzKS5kYXRhKERBVEFfS0VZKVxuICAgICAgICBpZiAoYWN0aXZlc0RhdGEgJiYgYWN0aXZlc0RhdGEuX2lzVHJhbnNpdGlvbmluZykge1xuICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHN0YXJ0RXZlbnQgPSAkLkV2ZW50KEV2ZW50LlNIT1cpXG4gICAgICAkKHRoaXMuX2VsZW1lbnQpLnRyaWdnZXIoc3RhcnRFdmVudClcbiAgICAgIGlmIChzdGFydEV2ZW50LmlzRGVmYXVsdFByZXZlbnRlZCgpKSB7XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuXG4gICAgICBpZiAoYWN0aXZlcykge1xuICAgICAgICBDb2xsYXBzZS5falF1ZXJ5SW50ZXJmYWNlLmNhbGwoJChhY3RpdmVzKSwgJ2hpZGUnKVxuICAgICAgICBpZiAoIWFjdGl2ZXNEYXRhKSB7XG4gICAgICAgICAgJChhY3RpdmVzKS5kYXRhKERBVEFfS0VZLCBudWxsKVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGRpbWVuc2lvbiA9IHRoaXMuX2dldERpbWVuc2lvbigpXG5cbiAgICAgICQodGhpcy5fZWxlbWVudClcbiAgICAgICAgLnJlbW92ZUNsYXNzKENsYXNzTmFtZS5DT0xMQVBTRSlcbiAgICAgICAgLmFkZENsYXNzKENsYXNzTmFtZS5DT0xMQVBTSU5HKVxuXG4gICAgICB0aGlzLl9lbGVtZW50LnN0eWxlW2RpbWVuc2lvbl0gPSAwXG4gICAgICB0aGlzLl9lbGVtZW50LnNldEF0dHJpYnV0ZSgnYXJpYS1leHBhbmRlZCcsIHRydWUpXG5cbiAgICAgIGlmICh0aGlzLl90cmlnZ2VyQXJyYXkubGVuZ3RoKSB7XG4gICAgICAgICQodGhpcy5fdHJpZ2dlckFycmF5KVxuICAgICAgICAgIC5yZW1vdmVDbGFzcyhDbGFzc05hbWUuQ09MTEFQU0VEKVxuICAgICAgICAgIC5hdHRyKCdhcmlhLWV4cGFuZGVkJywgdHJ1ZSlcbiAgICAgIH1cblxuICAgICAgdGhpcy5zZXRUcmFuc2l0aW9uaW5nKHRydWUpXG5cbiAgICAgIGNvbnN0IGNvbXBsZXRlID0gKCkgPT4ge1xuICAgICAgICAkKHRoaXMuX2VsZW1lbnQpXG4gICAgICAgICAgLnJlbW92ZUNsYXNzKENsYXNzTmFtZS5DT0xMQVBTSU5HKVxuICAgICAgICAgIC5hZGRDbGFzcyhDbGFzc05hbWUuQ09MTEFQU0UpXG4gICAgICAgICAgLmFkZENsYXNzKENsYXNzTmFtZS5TSE9XKVxuXG4gICAgICAgIHRoaXMuX2VsZW1lbnQuc3R5bGVbZGltZW5zaW9uXSA9ICcnXG5cbiAgICAgICAgdGhpcy5zZXRUcmFuc2l0aW9uaW5nKGZhbHNlKVxuXG4gICAgICAgICQodGhpcy5fZWxlbWVudCkudHJpZ2dlcihFdmVudC5TSE9XTilcbiAgICAgIH1cblxuICAgICAgaWYgKCFVdGlsLnN1cHBvcnRzVHJhbnNpdGlvbkVuZCgpKSB7XG4gICAgICAgIGNvbXBsZXRlKClcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGNhcGl0YWxpemVkRGltZW5zaW9uID0gZGltZW5zaW9uWzBdLnRvVXBwZXJDYXNlKCkgKyBkaW1lbnNpb24uc2xpY2UoMSlcbiAgICAgIGNvbnN0IHNjcm9sbFNpemUgICAgICAgICAgID0gYHNjcm9sbCR7Y2FwaXRhbGl6ZWREaW1lbnNpb259YFxuXG4gICAgICAkKHRoaXMuX2VsZW1lbnQpXG4gICAgICAgIC5vbmUoVXRpbC5UUkFOU0lUSU9OX0VORCwgY29tcGxldGUpXG4gICAgICAgIC5lbXVsYXRlVHJhbnNpdGlvbkVuZChUUkFOU0lUSU9OX0RVUkFUSU9OKVxuXG4gICAgICB0aGlzLl9lbGVtZW50LnN0eWxlW2RpbWVuc2lvbl0gPSBgJHt0aGlzLl9lbGVtZW50W3Njcm9sbFNpemVdfXB4YFxuICAgIH1cblxuICAgIGhpZGUoKSB7XG4gICAgICBpZiAodGhpcy5faXNUcmFuc2l0aW9uaW5nKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQ29sbGFwc2UgaXMgdHJhbnNpdGlvbmluZycpXG4gICAgICB9XG5cbiAgICAgIGlmICghJCh0aGlzLl9lbGVtZW50KS5oYXNDbGFzcyhDbGFzc05hbWUuU0hPVykpIHtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHN0YXJ0RXZlbnQgPSAkLkV2ZW50KEV2ZW50LkhJREUpXG4gICAgICAkKHRoaXMuX2VsZW1lbnQpLnRyaWdnZXIoc3RhcnRFdmVudClcbiAgICAgIGlmIChzdGFydEV2ZW50LmlzRGVmYXVsdFByZXZlbnRlZCgpKSB7XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuXG4gICAgICBjb25zdCBkaW1lbnNpb24gICAgICAgPSB0aGlzLl9nZXREaW1lbnNpb24oKVxuICAgICAgY29uc3Qgb2Zmc2V0RGltZW5zaW9uID0gZGltZW5zaW9uID09PSBEaW1lbnNpb24uV0lEVEggP1xuICAgICAgICAnb2Zmc2V0V2lkdGgnIDogJ29mZnNldEhlaWdodCdcblxuICAgICAgdGhpcy5fZWxlbWVudC5zdHlsZVtkaW1lbnNpb25dID0gYCR7dGhpcy5fZWxlbWVudFtvZmZzZXREaW1lbnNpb25dfXB4YFxuXG4gICAgICBVdGlsLnJlZmxvdyh0aGlzLl9lbGVtZW50KVxuXG4gICAgICAkKHRoaXMuX2VsZW1lbnQpXG4gICAgICAgIC5hZGRDbGFzcyhDbGFzc05hbWUuQ09MTEFQU0lORylcbiAgICAgICAgLnJlbW92ZUNsYXNzKENsYXNzTmFtZS5DT0xMQVBTRSlcbiAgICAgICAgLnJlbW92ZUNsYXNzKENsYXNzTmFtZS5TSE9XKVxuXG4gICAgICB0aGlzLl9lbGVtZW50LnNldEF0dHJpYnV0ZSgnYXJpYS1leHBhbmRlZCcsIGZhbHNlKVxuXG4gICAgICBpZiAodGhpcy5fdHJpZ2dlckFycmF5Lmxlbmd0aCkge1xuICAgICAgICAkKHRoaXMuX3RyaWdnZXJBcnJheSlcbiAgICAgICAgICAuYWRkQ2xhc3MoQ2xhc3NOYW1lLkNPTExBUFNFRClcbiAgICAgICAgICAuYXR0cignYXJpYS1leHBhbmRlZCcsIGZhbHNlKVxuICAgICAgfVxuXG4gICAgICB0aGlzLnNldFRyYW5zaXRpb25pbmcodHJ1ZSlcblxuICAgICAgY29uc3QgY29tcGxldGUgPSAoKSA9PiB7XG4gICAgICAgIHRoaXMuc2V0VHJhbnNpdGlvbmluZyhmYWxzZSlcbiAgICAgICAgJCh0aGlzLl9lbGVtZW50KVxuICAgICAgICAgIC5yZW1vdmVDbGFzcyhDbGFzc05hbWUuQ09MTEFQU0lORylcbiAgICAgICAgICAuYWRkQ2xhc3MoQ2xhc3NOYW1lLkNPTExBUFNFKVxuICAgICAgICAgIC50cmlnZ2VyKEV2ZW50LkhJRERFTilcbiAgICAgIH1cblxuICAgICAgdGhpcy5fZWxlbWVudC5zdHlsZVtkaW1lbnNpb25dID0gJydcblxuICAgICAgaWYgKCFVdGlsLnN1cHBvcnRzVHJhbnNpdGlvbkVuZCgpKSB7XG4gICAgICAgIGNvbXBsZXRlKClcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG5cbiAgICAgICQodGhpcy5fZWxlbWVudClcbiAgICAgICAgLm9uZShVdGlsLlRSQU5TSVRJT05fRU5ELCBjb21wbGV0ZSlcbiAgICAgICAgLmVtdWxhdGVUcmFuc2l0aW9uRW5kKFRSQU5TSVRJT05fRFVSQVRJT04pXG4gICAgfVxuXG4gICAgc2V0VHJhbnNpdGlvbmluZyhpc1RyYW5zaXRpb25pbmcpIHtcbiAgICAgIHRoaXMuX2lzVHJhbnNpdGlvbmluZyA9IGlzVHJhbnNpdGlvbmluZ1xuICAgIH1cblxuICAgIGRpc3Bvc2UoKSB7XG4gICAgICAkLnJlbW92ZURhdGEodGhpcy5fZWxlbWVudCwgREFUQV9LRVkpXG5cbiAgICAgIHRoaXMuX2NvbmZpZyAgICAgICAgICA9IG51bGxcbiAgICAgIHRoaXMuX3BhcmVudCAgICAgICAgICA9IG51bGxcbiAgICAgIHRoaXMuX2VsZW1lbnQgICAgICAgICA9IG51bGxcbiAgICAgIHRoaXMuX3RyaWdnZXJBcnJheSAgICA9IG51bGxcbiAgICAgIHRoaXMuX2lzVHJhbnNpdGlvbmluZyA9IG51bGxcbiAgICB9XG5cblxuICAgIC8vIHByaXZhdGVcblxuICAgIF9nZXRDb25maWcoY29uZmlnKSB7XG4gICAgICBjb25maWcgPSAkLmV4dGVuZCh7fSwgRGVmYXVsdCwgY29uZmlnKVxuICAgICAgY29uZmlnLnRvZ2dsZSA9IEJvb2xlYW4oY29uZmlnLnRvZ2dsZSkgLy8gY29lcmNlIHN0cmluZyB2YWx1ZXNcbiAgICAgIFV0aWwudHlwZUNoZWNrQ29uZmlnKE5BTUUsIGNvbmZpZywgRGVmYXVsdFR5cGUpXG4gICAgICByZXR1cm4gY29uZmlnXG4gICAgfVxuXG4gICAgX2dldERpbWVuc2lvbigpIHtcbiAgICAgIGNvbnN0IGhhc1dpZHRoID0gJCh0aGlzLl9lbGVtZW50KS5oYXNDbGFzcyhEaW1lbnNpb24uV0lEVEgpXG4gICAgICByZXR1cm4gaGFzV2lkdGggPyBEaW1lbnNpb24uV0lEVEggOiBEaW1lbnNpb24uSEVJR0hUXG4gICAgfVxuXG4gICAgX2dldFBhcmVudCgpIHtcbiAgICAgIGNvbnN0IHBhcmVudCAgID0gJCh0aGlzLl9jb25maWcucGFyZW50KVswXVxuICAgICAgY29uc3Qgc2VsZWN0b3IgPVxuICAgICAgICBgW2RhdGEtdG9nZ2xlPVwiY29sbGFwc2VcIl1bZGF0YS1wYXJlbnQ9XCIke3RoaXMuX2NvbmZpZy5wYXJlbnR9XCJdYFxuXG4gICAgICAkKHBhcmVudCkuZmluZChzZWxlY3RvcikuZWFjaCgoaSwgZWxlbWVudCkgPT4ge1xuICAgICAgICB0aGlzLl9hZGRBcmlhQW5kQ29sbGFwc2VkQ2xhc3MoXG4gICAgICAgICAgQ29sbGFwc2UuX2dldFRhcmdldEZyb21FbGVtZW50KGVsZW1lbnQpLFxuICAgICAgICAgIFtlbGVtZW50XVxuICAgICAgICApXG4gICAgICB9KVxuXG4gICAgICByZXR1cm4gcGFyZW50XG4gICAgfVxuXG4gICAgX2FkZEFyaWFBbmRDb2xsYXBzZWRDbGFzcyhlbGVtZW50LCB0cmlnZ2VyQXJyYXkpIHtcbiAgICAgIGlmIChlbGVtZW50KSB7XG4gICAgICAgIGNvbnN0IGlzT3BlbiA9ICQoZWxlbWVudCkuaGFzQ2xhc3MoQ2xhc3NOYW1lLlNIT1cpXG4gICAgICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKCdhcmlhLWV4cGFuZGVkJywgaXNPcGVuKVxuXG4gICAgICAgIGlmICh0cmlnZ2VyQXJyYXkubGVuZ3RoKSB7XG4gICAgICAgICAgJCh0cmlnZ2VyQXJyYXkpXG4gICAgICAgICAgICAudG9nZ2xlQ2xhc3MoQ2xhc3NOYW1lLkNPTExBUFNFRCwgIWlzT3BlbilcbiAgICAgICAgICAgIC5hdHRyKCdhcmlhLWV4cGFuZGVkJywgaXNPcGVuKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG5cbiAgICAvLyBzdGF0aWNcblxuICAgIHN0YXRpYyBfZ2V0VGFyZ2V0RnJvbUVsZW1lbnQoZWxlbWVudCkge1xuICAgICAgY29uc3Qgc2VsZWN0b3IgPSBVdGlsLmdldFNlbGVjdG9yRnJvbUVsZW1lbnQoZWxlbWVudClcbiAgICAgIHJldHVybiBzZWxlY3RvciA/ICQoc2VsZWN0b3IpWzBdIDogbnVsbFxuICAgIH1cblxuICAgIHN0YXRpYyBfalF1ZXJ5SW50ZXJmYWNlKGNvbmZpZykge1xuICAgICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGNvbnN0ICR0aGlzICAgPSAkKHRoaXMpXG4gICAgICAgIGxldCBkYXRhICAgICAgPSAkdGhpcy5kYXRhKERBVEFfS0VZKVxuICAgICAgICBjb25zdCBfY29uZmlnID0gJC5leHRlbmQoXG4gICAgICAgICAge30sXG4gICAgICAgICAgRGVmYXVsdCxcbiAgICAgICAgICAkdGhpcy5kYXRhKCksXG4gICAgICAgICAgdHlwZW9mIGNvbmZpZyA9PT0gJ29iamVjdCcgJiYgY29uZmlnXG4gICAgICAgIClcblxuICAgICAgICBpZiAoIWRhdGEgJiYgX2NvbmZpZy50b2dnbGUgJiYgL3Nob3d8aGlkZS8udGVzdChjb25maWcpKSB7XG4gICAgICAgICAgX2NvbmZpZy50b2dnbGUgPSBmYWxzZVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFkYXRhKSB7XG4gICAgICAgICAgZGF0YSA9IG5ldyBDb2xsYXBzZSh0aGlzLCBfY29uZmlnKVxuICAgICAgICAgICR0aGlzLmRhdGEoREFUQV9LRVksIGRhdGEpXG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIGNvbmZpZyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICBpZiAoZGF0YVtjb25maWddID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgTm8gbWV0aG9kIG5hbWVkIFwiJHtjb25maWd9XCJgKVxuICAgICAgICAgIH1cbiAgICAgICAgICBkYXRhW2NvbmZpZ10oKVxuICAgICAgICB9XG4gICAgICB9KVxuICAgIH1cblxuICB9XG5cblxuICAvKipcbiAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAqIERhdGEgQXBpIGltcGxlbWVudGF0aW9uXG4gICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgKi9cblxuICAkKGRvY3VtZW50KS5vbihFdmVudC5DTElDS19EQVRBX0FQSSwgU2VsZWN0b3IuREFUQV9UT0dHTEUsIGZ1bmN0aW9uIChldmVudCkge1xuICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KClcblxuICAgIGNvbnN0IHRhcmdldCA9IENvbGxhcHNlLl9nZXRUYXJnZXRGcm9tRWxlbWVudCh0aGlzKVxuICAgIGNvbnN0IGRhdGEgICA9ICQodGFyZ2V0KS5kYXRhKERBVEFfS0VZKVxuICAgIGNvbnN0IGNvbmZpZyA9IGRhdGEgPyAndG9nZ2xlJyA6ICQodGhpcykuZGF0YSgpXG5cbiAgICBDb2xsYXBzZS5falF1ZXJ5SW50ZXJmYWNlLmNhbGwoJCh0YXJnZXQpLCBjb25maWcpXG4gIH0pXG5cblxuICAvKipcbiAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAqIGpRdWVyeVxuICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICovXG5cbiAgJC5mbltOQU1FXSAgICAgICAgICAgICA9IENvbGxhcHNlLl9qUXVlcnlJbnRlcmZhY2VcbiAgJC5mbltOQU1FXS5Db25zdHJ1Y3RvciA9IENvbGxhcHNlXG4gICQuZm5bTkFNRV0ubm9Db25mbGljdCAgPSBmdW5jdGlvbiAoKSB7XG4gICAgJC5mbltOQU1FXSA9IEpRVUVSWV9OT19DT05GTElDVFxuICAgIHJldHVybiBDb2xsYXBzZS5falF1ZXJ5SW50ZXJmYWNlXG4gIH1cblxuICByZXR1cm4gQ29sbGFwc2VcblxufSkoalF1ZXJ5KVxuXG5leHBvcnQgZGVmYXVsdCBDb2xsYXBzZVxuIiwiaW1wb3J0IFV0aWwgZnJvbSAnLi91dGlsJ1xuXG5cbi8qKlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIEJvb3RzdHJhcCAodjQuMC4wLWFscGhhLjYpOiBhbGVydC5qc1xuICogTGljZW5zZWQgdW5kZXIgTUlUIChodHRwczovL2dpdGh1Yi5jb20vdHdicy9ib290c3RyYXAvYmxvYi9tYXN0ZXIvTElDRU5TRSlcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKi9cblxuY29uc3QgQWxlcnQgPSAoKCQpID0+IHtcblxuXG4gIC8qKlxuICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICogQ29uc3RhbnRzXG4gICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgKi9cblxuICBjb25zdCBOQU1FICAgICAgICAgICAgICAgID0gJ2FsZXJ0J1xuICBjb25zdCBWRVJTSU9OICAgICAgICAgICAgID0gJzQuMC4wLWFscGhhLjYnXG4gIGNvbnN0IERBVEFfS0VZICAgICAgICAgICAgPSAnYnMuYWxlcnQnXG4gIGNvbnN0IEVWRU5UX0tFWSAgICAgICAgICAgPSBgLiR7REFUQV9LRVl9YFxuICBjb25zdCBEQVRBX0FQSV9LRVkgICAgICAgID0gJy5kYXRhLWFwaSdcbiAgY29uc3QgSlFVRVJZX05PX0NPTkZMSUNUICA9ICQuZm5bTkFNRV1cbiAgY29uc3QgVFJBTlNJVElPTl9EVVJBVElPTiA9IDE1MFxuXG4gIGNvbnN0IFNlbGVjdG9yID0ge1xuICAgIERJU01JU1MgOiAnW2RhdGEtZGlzbWlzcz1cImFsZXJ0XCJdJ1xuICB9XG5cbiAgY29uc3QgRXZlbnQgPSB7XG4gICAgQ0xPU0UgICAgICAgICAgOiBgY2xvc2Uke0VWRU5UX0tFWX1gLFxuICAgIENMT1NFRCAgICAgICAgIDogYGNsb3NlZCR7RVZFTlRfS0VZfWAsXG4gICAgQ0xJQ0tfREFUQV9BUEkgOiBgY2xpY2ske0VWRU5UX0tFWX0ke0RBVEFfQVBJX0tFWX1gXG4gIH1cblxuICBjb25zdCBDbGFzc05hbWUgPSB7XG4gICAgQUxFUlQgOiAnYWxlcnQnLFxuICAgIEZBREUgIDogJ2ZhZGUnLFxuICAgIFNIT1cgIDogJ3Nob3cnXG4gIH1cblxuXG4gIC8qKlxuICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICogQ2xhc3MgRGVmaW5pdGlvblxuICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICovXG5cbiAgY2xhc3MgQWxlcnQge1xuXG4gICAgY29uc3RydWN0b3IoZWxlbWVudCkge1xuICAgICAgdGhpcy5fZWxlbWVudCA9IGVsZW1lbnRcbiAgICB9XG5cblxuICAgIC8vIGdldHRlcnNcblxuICAgIHN0YXRpYyBnZXQgVkVSU0lPTigpIHtcbiAgICAgIHJldHVybiBWRVJTSU9OXG4gICAgfVxuXG5cbiAgICAvLyBwdWJsaWNcblxuICAgIGNsb3NlKGVsZW1lbnQpIHtcbiAgICAgIGVsZW1lbnQgPSBlbGVtZW50IHx8IHRoaXMuX2VsZW1lbnRcblxuICAgICAgY29uc3Qgcm9vdEVsZW1lbnQgPSB0aGlzLl9nZXRSb290RWxlbWVudChlbGVtZW50KVxuICAgICAgY29uc3QgY3VzdG9tRXZlbnQgPSB0aGlzLl90cmlnZ2VyQ2xvc2VFdmVudChyb290RWxlbWVudClcblxuICAgICAgaWYgKGN1c3RvbUV2ZW50LmlzRGVmYXVsdFByZXZlbnRlZCgpKSB7XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuXG4gICAgICB0aGlzLl9yZW1vdmVFbGVtZW50KHJvb3RFbGVtZW50KVxuICAgIH1cblxuICAgIGRpc3Bvc2UoKSB7XG4gICAgICAkLnJlbW92ZURhdGEodGhpcy5fZWxlbWVudCwgREFUQV9LRVkpXG4gICAgICB0aGlzLl9lbGVtZW50ID0gbnVsbFxuICAgIH1cblxuXG4gICAgLy8gcHJpdmF0ZVxuXG4gICAgX2dldFJvb3RFbGVtZW50KGVsZW1lbnQpIHtcbiAgICAgIGNvbnN0IHNlbGVjdG9yID0gVXRpbC5nZXRTZWxlY3RvckZyb21FbGVtZW50KGVsZW1lbnQpXG4gICAgICBsZXQgcGFyZW50ICAgICA9IGZhbHNlXG5cbiAgICAgIGlmIChzZWxlY3Rvcikge1xuICAgICAgICBwYXJlbnQgPSAkKHNlbGVjdG9yKVswXVxuICAgICAgfVxuXG4gICAgICBpZiAoIXBhcmVudCkge1xuICAgICAgICBwYXJlbnQgPSAkKGVsZW1lbnQpLmNsb3Nlc3QoYC4ke0NsYXNzTmFtZS5BTEVSVH1gKVswXVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gcGFyZW50XG4gICAgfVxuXG4gICAgX3RyaWdnZXJDbG9zZUV2ZW50KGVsZW1lbnQpIHtcbiAgICAgIGNvbnN0IGNsb3NlRXZlbnQgPSAkLkV2ZW50KEV2ZW50LkNMT1NFKVxuXG4gICAgICAkKGVsZW1lbnQpLnRyaWdnZXIoY2xvc2VFdmVudClcbiAgICAgIHJldHVybiBjbG9zZUV2ZW50XG4gICAgfVxuXG4gICAgX3JlbW92ZUVsZW1lbnQoZWxlbWVudCkge1xuICAgICAgJChlbGVtZW50KS5yZW1vdmVDbGFzcyhDbGFzc05hbWUuU0hPVylcblxuICAgICAgaWYgKCFVdGlsLnN1cHBvcnRzVHJhbnNpdGlvbkVuZCgpIHx8XG4gICAgICAgICAgISQoZWxlbWVudCkuaGFzQ2xhc3MoQ2xhc3NOYW1lLkZBREUpKSB7XG4gICAgICAgIHRoaXMuX2Rlc3Ryb3lFbGVtZW50KGVsZW1lbnQpXG4gICAgICAgIHJldHVyblxuICAgICAgfVxuXG4gICAgICAkKGVsZW1lbnQpXG4gICAgICAgIC5vbmUoVXRpbC5UUkFOU0lUSU9OX0VORCwgKGV2ZW50KSA9PiB0aGlzLl9kZXN0cm95RWxlbWVudChlbGVtZW50LCBldmVudCkpXG4gICAgICAgIC5lbXVsYXRlVHJhbnNpdGlvbkVuZChUUkFOU0lUSU9OX0RVUkFUSU9OKVxuICAgIH1cblxuICAgIF9kZXN0cm95RWxlbWVudChlbGVtZW50KSB7XG4gICAgICAkKGVsZW1lbnQpXG4gICAgICAgIC5kZXRhY2goKVxuICAgICAgICAudHJpZ2dlcihFdmVudC5DTE9TRUQpXG4gICAgICAgIC5yZW1vdmUoKVxuICAgIH1cblxuXG4gICAgLy8gc3RhdGljXG5cbiAgICBzdGF0aWMgX2pRdWVyeUludGVyZmFjZShjb25maWcpIHtcbiAgICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24gKCkge1xuICAgICAgICBjb25zdCAkZWxlbWVudCA9ICQodGhpcylcbiAgICAgICAgbGV0IGRhdGEgICAgICAgPSAkZWxlbWVudC5kYXRhKERBVEFfS0VZKVxuXG4gICAgICAgIGlmICghZGF0YSkge1xuICAgICAgICAgIGRhdGEgPSBuZXcgQWxlcnQodGhpcylcbiAgICAgICAgICAkZWxlbWVudC5kYXRhKERBVEFfS0VZLCBkYXRhKVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNvbmZpZyA9PT0gJ2Nsb3NlJykge1xuICAgICAgICAgIGRhdGFbY29uZmlnXSh0aGlzKVxuICAgICAgICB9XG4gICAgICB9KVxuICAgIH1cblxuICAgIHN0YXRpYyBfaGFuZGxlRGlzbWlzcyhhbGVydEluc3RhbmNlKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIGlmIChldmVudCkge1xuICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KClcbiAgICAgICAgfVxuXG4gICAgICAgIGFsZXJ0SW5zdGFuY2UuY2xvc2UodGhpcylcbiAgICAgIH1cbiAgICB9XG5cbiAgfVxuXG5cbiAgLyoqXG4gICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgKiBEYXRhIEFwaSBpbXBsZW1lbnRhdGlvblxuICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICovXG5cbiAgJChkb2N1bWVudCkub24oXG4gICAgRXZlbnQuQ0xJQ0tfREFUQV9BUEksXG4gICAgU2VsZWN0b3IuRElTTUlTUyxcbiAgICBBbGVydC5faGFuZGxlRGlzbWlzcyhuZXcgQWxlcnQoKSlcbiAgKVxuXG5cbiAgLyoqXG4gICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgKiBqUXVlcnlcbiAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAqL1xuXG4gICQuZm5bTkFNRV0gICAgICAgICAgICAgPSBBbGVydC5falF1ZXJ5SW50ZXJmYWNlXG4gICQuZm5bTkFNRV0uQ29uc3RydWN0b3IgPSBBbGVydFxuICAkLmZuW05BTUVdLm5vQ29uZmxpY3QgID0gZnVuY3Rpb24gKCkge1xuICAgICQuZm5bTkFNRV0gPSBKUVVFUllfTk9fQ09ORkxJQ1RcbiAgICByZXR1cm4gQWxlcnQuX2pRdWVyeUludGVyZmFjZVxuICB9XG5cbiAgcmV0dXJuIEFsZXJ0XG5cbn0pKGpRdWVyeSlcblxuZXhwb3J0IGRlZmF1bHQgQWxlcnRcbiIsImltcG9ydCBVdGlsIGZyb20gJy4vdXRpbCdcblxuXG4vKipcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBCb290c3RyYXAgKHY0LjAuMC1hbHBoYS42KTogbW9kYWwuanNcbiAqIExpY2Vuc2VkIHVuZGVyIE1JVCAoaHR0cHM6Ly9naXRodWIuY29tL3R3YnMvYm9vdHN0cmFwL2Jsb2IvbWFzdGVyL0xJQ0VOU0UpXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICovXG5cbmNvbnN0IE1vZGFsID0gKCgkKSA9PiB7XG5cblxuICAvKipcbiAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAqIENvbnN0YW50c1xuICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICovXG5cbiAgY29uc3QgTkFNRSAgICAgICAgICAgICAgICAgICAgICAgICA9ICdtb2RhbCdcbiAgY29uc3QgVkVSU0lPTiAgICAgICAgICAgICAgICAgICAgICA9ICc0LjAuMC1hbHBoYS42J1xuICBjb25zdCBEQVRBX0tFWSAgICAgICAgICAgICAgICAgICAgID0gJ2JzLm1vZGFsJ1xuICBjb25zdCBFVkVOVF9LRVkgICAgICAgICAgICAgICAgICAgID0gYC4ke0RBVEFfS0VZfWBcbiAgY29uc3QgREFUQV9BUElfS0VZICAgICAgICAgICAgICAgICA9ICcuZGF0YS1hcGknXG4gIGNvbnN0IEpRVUVSWV9OT19DT05GTElDVCAgICAgICAgICAgPSAkLmZuW05BTUVdXG4gIGNvbnN0IFRSQU5TSVRJT05fRFVSQVRJT04gICAgICAgICAgPSAzMDBcbiAgY29uc3QgQkFDS0RST1BfVFJBTlNJVElPTl9EVVJBVElPTiA9IDE1MFxuICBjb25zdCBFU0NBUEVfS0VZQ09ERSAgICAgICAgICAgICAgID0gMjcgLy8gS2V5Ym9hcmRFdmVudC53aGljaCB2YWx1ZSBmb3IgRXNjYXBlIChFc2MpIGtleVxuXG4gIGNvbnN0IERlZmF1bHQgPSB7XG4gICAgYmFja2Ryb3AgOiB0cnVlLFxuICAgIGtleWJvYXJkIDogdHJ1ZSxcbiAgICBmb2N1cyAgICA6IHRydWUsXG4gICAgc2hvdyAgICAgOiB0cnVlXG4gIH1cblxuICBjb25zdCBEZWZhdWx0VHlwZSA9IHtcbiAgICBiYWNrZHJvcCA6ICcoYm9vbGVhbnxzdHJpbmcpJyxcbiAgICBrZXlib2FyZCA6ICdib29sZWFuJyxcbiAgICBmb2N1cyAgICA6ICdib29sZWFuJyxcbiAgICBzaG93ICAgICA6ICdib29sZWFuJ1xuICB9XG5cbiAgY29uc3QgRXZlbnQgPSB7XG4gICAgSElERSAgICAgICAgICAgICAgOiBgaGlkZSR7RVZFTlRfS0VZfWAsXG4gICAgSElEREVOICAgICAgICAgICAgOiBgaGlkZGVuJHtFVkVOVF9LRVl9YCxcbiAgICBTSE9XICAgICAgICAgICAgICA6IGBzaG93JHtFVkVOVF9LRVl9YCxcbiAgICBTSE9XTiAgICAgICAgICAgICA6IGBzaG93biR7RVZFTlRfS0VZfWAsXG4gICAgRk9DVVNJTiAgICAgICAgICAgOiBgZm9jdXNpbiR7RVZFTlRfS0VZfWAsXG4gICAgUkVTSVpFICAgICAgICAgICAgOiBgcmVzaXplJHtFVkVOVF9LRVl9YCxcbiAgICBDTElDS19ESVNNSVNTICAgICA6IGBjbGljay5kaXNtaXNzJHtFVkVOVF9LRVl9YCxcbiAgICBLRVlET1dOX0RJU01JU1MgICA6IGBrZXlkb3duLmRpc21pc3Mke0VWRU5UX0tFWX1gLFxuICAgIE1PVVNFVVBfRElTTUlTUyAgIDogYG1vdXNldXAuZGlzbWlzcyR7RVZFTlRfS0VZfWAsXG4gICAgTU9VU0VET1dOX0RJU01JU1MgOiBgbW91c2Vkb3duLmRpc21pc3Mke0VWRU5UX0tFWX1gLFxuICAgIENMSUNLX0RBVEFfQVBJICAgIDogYGNsaWNrJHtFVkVOVF9LRVl9JHtEQVRBX0FQSV9LRVl9YFxuICB9XG5cbiAgY29uc3QgQ2xhc3NOYW1lID0ge1xuICAgIFNDUk9MTEJBUl9NRUFTVVJFUiA6ICdtb2RhbC1zY3JvbGxiYXItbWVhc3VyZScsXG4gICAgQkFDS0RST1AgICAgICAgICAgIDogJ21vZGFsLWJhY2tkcm9wJyxcbiAgICBPUEVOICAgICAgICAgICAgICAgOiAnbW9kYWwtb3BlbicsXG4gICAgRkFERSAgICAgICAgICAgICAgIDogJ2ZhZGUnLFxuICAgIFNIT1cgICAgICAgICAgICAgICA6ICdzaG93J1xuICB9XG5cbiAgY29uc3QgU2VsZWN0b3IgPSB7XG4gICAgRElBTE9HICAgICAgICAgICAgIDogJy5tb2RhbC1kaWFsb2cnLFxuICAgIERBVEFfVE9HR0xFICAgICAgICA6ICdbZGF0YS10b2dnbGU9XCJtb2RhbFwiXScsXG4gICAgREFUQV9ESVNNSVNTICAgICAgIDogJ1tkYXRhLWRpc21pc3M9XCJtb2RhbFwiXScsXG4gICAgRklYRURfQ09OVEVOVCAgICAgIDogJy5maXhlZC10b3AsIC5maXhlZC1ib3R0b20sIC5pcy1maXhlZCwgLnN0aWNreS10b3AnXG4gIH1cblxuXG4gIC8qKlxuICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICogQ2xhc3MgRGVmaW5pdGlvblxuICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICovXG5cbiAgY2xhc3MgTW9kYWwge1xuXG4gICAgY29uc3RydWN0b3IoZWxlbWVudCwgY29uZmlnKSB7XG4gICAgICB0aGlzLl9jb25maWcgICAgICAgICAgICAgID0gdGhpcy5fZ2V0Q29uZmlnKGNvbmZpZylcbiAgICAgIHRoaXMuX2VsZW1lbnQgICAgICAgICAgICAgPSBlbGVtZW50XG4gICAgICB0aGlzLl9kaWFsb2cgICAgICAgICAgICAgID0gJChlbGVtZW50KS5maW5kKFNlbGVjdG9yLkRJQUxPRylbMF1cbiAgICAgIHRoaXMuX2JhY2tkcm9wICAgICAgICAgICAgPSBudWxsXG4gICAgICB0aGlzLl9pc1Nob3duICAgICAgICAgICAgID0gZmFsc2VcbiAgICAgIHRoaXMuX2lzQm9keU92ZXJmbG93aW5nICAgPSBmYWxzZVxuICAgICAgdGhpcy5faWdub3JlQmFja2Ryb3BDbGljayA9IGZhbHNlXG4gICAgICB0aGlzLl9pc1RyYW5zaXRpb25pbmcgICAgID0gZmFsc2VcbiAgICAgIHRoaXMuX29yaWdpbmFsQm9keVBhZGRpbmcgPSAwXG4gICAgICB0aGlzLl9zY3JvbGxiYXJXaWR0aCAgICAgID0gMFxuICAgIH1cblxuXG4gICAgLy8gZ2V0dGVyc1xuXG4gICAgc3RhdGljIGdldCBWRVJTSU9OKCkge1xuICAgICAgcmV0dXJuIFZFUlNJT05cbiAgICB9XG5cbiAgICBzdGF0aWMgZ2V0IERlZmF1bHQoKSB7XG4gICAgICByZXR1cm4gRGVmYXVsdFxuICAgIH1cblxuXG4gICAgLy8gcHVibGljXG5cbiAgICB0b2dnbGUocmVsYXRlZFRhcmdldCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2lzU2hvd24gPyB0aGlzLmhpZGUoKSA6IHRoaXMuc2hvdyhyZWxhdGVkVGFyZ2V0KVxuICAgIH1cblxuICAgIHNob3cocmVsYXRlZFRhcmdldCkge1xuICAgICAgaWYgKHRoaXMuX2lzVHJhbnNpdGlvbmluZykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ01vZGFsIGlzIHRyYW5zaXRpb25pbmcnKVxuICAgICAgfVxuXG4gICAgICBpZiAoVXRpbC5zdXBwb3J0c1RyYW5zaXRpb25FbmQoKSAmJlxuICAgICAgICAkKHRoaXMuX2VsZW1lbnQpLmhhc0NsYXNzKENsYXNzTmFtZS5GQURFKSkge1xuICAgICAgICB0aGlzLl9pc1RyYW5zaXRpb25pbmcgPSB0cnVlXG4gICAgICB9XG4gICAgICBjb25zdCBzaG93RXZlbnQgPSAkLkV2ZW50KEV2ZW50LlNIT1csIHtcbiAgICAgICAgcmVsYXRlZFRhcmdldFxuICAgICAgfSlcblxuICAgICAgJCh0aGlzLl9lbGVtZW50KS50cmlnZ2VyKHNob3dFdmVudClcblxuICAgICAgaWYgKHRoaXMuX2lzU2hvd24gfHwgc2hvd0V2ZW50LmlzRGVmYXVsdFByZXZlbnRlZCgpKSB7XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuXG4gICAgICB0aGlzLl9pc1Nob3duID0gdHJ1ZVxuXG4gICAgICB0aGlzLl9jaGVja1Njcm9sbGJhcigpXG4gICAgICB0aGlzLl9zZXRTY3JvbGxiYXIoKVxuXG4gICAgICAkKGRvY3VtZW50LmJvZHkpLmFkZENsYXNzKENsYXNzTmFtZS5PUEVOKVxuXG4gICAgICB0aGlzLl9zZXRFc2NhcGVFdmVudCgpXG4gICAgICB0aGlzLl9zZXRSZXNpemVFdmVudCgpXG5cbiAgICAgICQodGhpcy5fZWxlbWVudCkub24oXG4gICAgICAgIEV2ZW50LkNMSUNLX0RJU01JU1MsXG4gICAgICAgIFNlbGVjdG9yLkRBVEFfRElTTUlTUyxcbiAgICAgICAgKGV2ZW50KSA9PiB0aGlzLmhpZGUoZXZlbnQpXG4gICAgICApXG5cbiAgICAgICQodGhpcy5fZGlhbG9nKS5vbihFdmVudC5NT1VTRURPV05fRElTTUlTUywgKCkgPT4ge1xuICAgICAgICAkKHRoaXMuX2VsZW1lbnQpLm9uZShFdmVudC5NT1VTRVVQX0RJU01JU1MsIChldmVudCkgPT4ge1xuICAgICAgICAgIGlmICgkKGV2ZW50LnRhcmdldCkuaXModGhpcy5fZWxlbWVudCkpIHtcbiAgICAgICAgICAgIHRoaXMuX2lnbm9yZUJhY2tkcm9wQ2xpY2sgPSB0cnVlXG4gICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgfSlcblxuICAgICAgdGhpcy5fc2hvd0JhY2tkcm9wKCgpID0+IHRoaXMuX3Nob3dFbGVtZW50KHJlbGF0ZWRUYXJnZXQpKVxuICAgIH1cblxuICAgIGhpZGUoZXZlbnQpIHtcbiAgICAgIGlmIChldmVudCkge1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpXG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLl9pc1RyYW5zaXRpb25pbmcpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNb2RhbCBpcyB0cmFuc2l0aW9uaW5nJylcbiAgICAgIH1cblxuICAgICAgY29uc3QgdHJhbnNpdGlvbiA9IFV0aWwuc3VwcG9ydHNUcmFuc2l0aW9uRW5kKCkgJiZcbiAgICAgICAgJCh0aGlzLl9lbGVtZW50KS5oYXNDbGFzcyhDbGFzc05hbWUuRkFERSlcbiAgICAgIGlmICh0cmFuc2l0aW9uKSB7XG4gICAgICAgIHRoaXMuX2lzVHJhbnNpdGlvbmluZyA9IHRydWVcbiAgICAgIH1cblxuICAgICAgY29uc3QgaGlkZUV2ZW50ID0gJC5FdmVudChFdmVudC5ISURFKVxuICAgICAgJCh0aGlzLl9lbGVtZW50KS50cmlnZ2VyKGhpZGVFdmVudClcblxuICAgICAgaWYgKCF0aGlzLl9pc1Nob3duIHx8IGhpZGVFdmVudC5pc0RlZmF1bHRQcmV2ZW50ZWQoKSkge1xuICAgICAgICByZXR1cm5cbiAgICAgIH1cblxuICAgICAgdGhpcy5faXNTaG93biA9IGZhbHNlXG5cbiAgICAgIHRoaXMuX3NldEVzY2FwZUV2ZW50KClcbiAgICAgIHRoaXMuX3NldFJlc2l6ZUV2ZW50KClcblxuICAgICAgJChkb2N1bWVudCkub2ZmKEV2ZW50LkZPQ1VTSU4pXG5cbiAgICAgICQodGhpcy5fZWxlbWVudCkucmVtb3ZlQ2xhc3MoQ2xhc3NOYW1lLlNIT1cpXG5cbiAgICAgICQodGhpcy5fZWxlbWVudCkub2ZmKEV2ZW50LkNMSUNLX0RJU01JU1MpXG4gICAgICAkKHRoaXMuX2RpYWxvZykub2ZmKEV2ZW50Lk1PVVNFRE9XTl9ESVNNSVNTKVxuXG4gICAgICBpZiAodHJhbnNpdGlvbikge1xuICAgICAgICAkKHRoaXMuX2VsZW1lbnQpXG4gICAgICAgICAgLm9uZShVdGlsLlRSQU5TSVRJT05fRU5ELCAoZXZlbnQpID0+IHRoaXMuX2hpZGVNb2RhbChldmVudCkpXG4gICAgICAgICAgLmVtdWxhdGVUcmFuc2l0aW9uRW5kKFRSQU5TSVRJT05fRFVSQVRJT04pXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9oaWRlTW9kYWwoKVxuICAgICAgfVxuICAgIH1cblxuICAgIGRpc3Bvc2UoKSB7XG4gICAgICAkLnJlbW92ZURhdGEodGhpcy5fZWxlbWVudCwgREFUQV9LRVkpXG5cbiAgICAgICQod2luZG93LCBkb2N1bWVudCwgdGhpcy5fZWxlbWVudCwgdGhpcy5fYmFja2Ryb3ApLm9mZihFVkVOVF9LRVkpXG5cbiAgICAgIHRoaXMuX2NvbmZpZyAgICAgICAgICAgICAgPSBudWxsXG4gICAgICB0aGlzLl9lbGVtZW50ICAgICAgICAgICAgID0gbnVsbFxuICAgICAgdGhpcy5fZGlhbG9nICAgICAgICAgICAgICA9IG51bGxcbiAgICAgIHRoaXMuX2JhY2tkcm9wICAgICAgICAgICAgPSBudWxsXG4gICAgICB0aGlzLl9pc1Nob3duICAgICAgICAgICAgID0gbnVsbFxuICAgICAgdGhpcy5faXNCb2R5T3ZlcmZsb3dpbmcgICA9IG51bGxcbiAgICAgIHRoaXMuX2lnbm9yZUJhY2tkcm9wQ2xpY2sgPSBudWxsXG4gICAgICB0aGlzLl9vcmlnaW5hbEJvZHlQYWRkaW5nID0gbnVsbFxuICAgICAgdGhpcy5fc2Nyb2xsYmFyV2lkdGggICAgICA9IG51bGxcbiAgICB9XG5cblxuICAgIC8vIHByaXZhdGVcblxuICAgIF9nZXRDb25maWcoY29uZmlnKSB7XG4gICAgICBjb25maWcgPSAkLmV4dGVuZCh7fSwgRGVmYXVsdCwgY29uZmlnKVxuICAgICAgVXRpbC50eXBlQ2hlY2tDb25maWcoTkFNRSwgY29uZmlnLCBEZWZhdWx0VHlwZSlcbiAgICAgIHJldHVybiBjb25maWdcbiAgICB9XG5cbiAgICBfc2hvd0VsZW1lbnQocmVsYXRlZFRhcmdldCkge1xuICAgICAgY29uc3QgdHJhbnNpdGlvbiA9IFV0aWwuc3VwcG9ydHNUcmFuc2l0aW9uRW5kKCkgJiZcbiAgICAgICAgJCh0aGlzLl9lbGVtZW50KS5oYXNDbGFzcyhDbGFzc05hbWUuRkFERSlcblxuICAgICAgaWYgKCF0aGlzLl9lbGVtZW50LnBhcmVudE5vZGUgfHxcbiAgICAgICAgIHRoaXMuX2VsZW1lbnQucGFyZW50Tm9kZS5ub2RlVHlwZSAhPT0gTm9kZS5FTEVNRU5UX05PREUpIHtcbiAgICAgICAgLy8gZG9uJ3QgbW92ZSBtb2RhbHMgZG9tIHBvc2l0aW9uXG4gICAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQodGhpcy5fZWxlbWVudClcbiAgICAgIH1cblxuICAgICAgdGhpcy5fZWxlbWVudC5zdHlsZS5kaXNwbGF5ID0gJ2Jsb2NrJ1xuICAgICAgdGhpcy5fZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoJ2FyaWEtaGlkZGVuJylcbiAgICAgIHRoaXMuX2VsZW1lbnQuc2Nyb2xsVG9wID0gMFxuXG4gICAgICBpZiAodHJhbnNpdGlvbikge1xuICAgICAgICBVdGlsLnJlZmxvdyh0aGlzLl9lbGVtZW50KVxuICAgICAgfVxuXG4gICAgICAkKHRoaXMuX2VsZW1lbnQpLmFkZENsYXNzKENsYXNzTmFtZS5TSE9XKVxuXG4gICAgICBpZiAodGhpcy5fY29uZmlnLmZvY3VzKSB7XG4gICAgICAgIHRoaXMuX2VuZm9yY2VGb2N1cygpXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHNob3duRXZlbnQgPSAkLkV2ZW50KEV2ZW50LlNIT1dOLCB7XG4gICAgICAgIHJlbGF0ZWRUYXJnZXRcbiAgICAgIH0pXG5cbiAgICAgIGNvbnN0IHRyYW5zaXRpb25Db21wbGV0ZSA9ICgpID0+IHtcbiAgICAgICAgaWYgKHRoaXMuX2NvbmZpZy5mb2N1cykge1xuICAgICAgICAgIHRoaXMuX2VsZW1lbnQuZm9jdXMoKVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2lzVHJhbnNpdGlvbmluZyA9IGZhbHNlXG4gICAgICAgICQodGhpcy5fZWxlbWVudCkudHJpZ2dlcihzaG93bkV2ZW50KVxuICAgICAgfVxuXG4gICAgICBpZiAodHJhbnNpdGlvbikge1xuICAgICAgICAkKHRoaXMuX2RpYWxvZylcbiAgICAgICAgICAub25lKFV0aWwuVFJBTlNJVElPTl9FTkQsIHRyYW5zaXRpb25Db21wbGV0ZSlcbiAgICAgICAgICAuZW11bGF0ZVRyYW5zaXRpb25FbmQoVFJBTlNJVElPTl9EVVJBVElPTilcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRyYW5zaXRpb25Db21wbGV0ZSgpXG4gICAgICB9XG4gICAgfVxuXG4gICAgX2VuZm9yY2VGb2N1cygpIHtcbiAgICAgICQoZG9jdW1lbnQpXG4gICAgICAgIC5vZmYoRXZlbnQuRk9DVVNJTikgLy8gZ3VhcmQgYWdhaW5zdCBpbmZpbml0ZSBmb2N1cyBsb29wXG4gICAgICAgIC5vbihFdmVudC5GT0NVU0lOLCAoZXZlbnQpID0+IHtcbiAgICAgICAgICBpZiAoZG9jdW1lbnQgIT09IGV2ZW50LnRhcmdldCAmJlxuICAgICAgICAgICAgICB0aGlzLl9lbGVtZW50ICE9PSBldmVudC50YXJnZXQgJiZcbiAgICAgICAgICAgICAgISQodGhpcy5fZWxlbWVudCkuaGFzKGV2ZW50LnRhcmdldCkubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aGlzLl9lbGVtZW50LmZvY3VzKClcbiAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgfVxuXG4gICAgX3NldEVzY2FwZUV2ZW50KCkge1xuICAgICAgaWYgKHRoaXMuX2lzU2hvd24gJiYgdGhpcy5fY29uZmlnLmtleWJvYXJkKSB7XG4gICAgICAgICQodGhpcy5fZWxlbWVudCkub24oRXZlbnQuS0VZRE9XTl9ESVNNSVNTLCAoZXZlbnQpID0+IHtcbiAgICAgICAgICBpZiAoZXZlbnQud2hpY2ggPT09IEVTQ0FQRV9LRVlDT0RFKSB7XG4gICAgICAgICAgICB0aGlzLmhpZGUoKVxuICAgICAgICAgIH1cbiAgICAgICAgfSlcblxuICAgICAgfSBlbHNlIGlmICghdGhpcy5faXNTaG93bikge1xuICAgICAgICAkKHRoaXMuX2VsZW1lbnQpLm9mZihFdmVudC5LRVlET1dOX0RJU01JU1MpXG4gICAgICB9XG4gICAgfVxuXG4gICAgX3NldFJlc2l6ZUV2ZW50KCkge1xuICAgICAgaWYgKHRoaXMuX2lzU2hvd24pIHtcbiAgICAgICAgJCh3aW5kb3cpLm9uKEV2ZW50LlJFU0laRSwgKGV2ZW50KSA9PiB0aGlzLl9oYW5kbGVVcGRhdGUoZXZlbnQpKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgJCh3aW5kb3cpLm9mZihFdmVudC5SRVNJWkUpXG4gICAgICB9XG4gICAgfVxuXG4gICAgX2hpZGVNb2RhbCgpIHtcbiAgICAgIHRoaXMuX2VsZW1lbnQuc3R5bGUuZGlzcGxheSA9ICdub25lJ1xuICAgICAgdGhpcy5fZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2FyaWEtaGlkZGVuJywgJ3RydWUnKVxuICAgICAgdGhpcy5faXNUcmFuc2l0aW9uaW5nID0gZmFsc2VcbiAgICAgIHRoaXMuX3Nob3dCYWNrZHJvcCgoKSA9PiB7XG4gICAgICAgICQoZG9jdW1lbnQuYm9keSkucmVtb3ZlQ2xhc3MoQ2xhc3NOYW1lLk9QRU4pXG4gICAgICAgIHRoaXMuX3Jlc2V0QWRqdXN0bWVudHMoKVxuICAgICAgICB0aGlzLl9yZXNldFNjcm9sbGJhcigpXG4gICAgICAgICQodGhpcy5fZWxlbWVudCkudHJpZ2dlcihFdmVudC5ISURERU4pXG4gICAgICB9KVxuICAgIH1cblxuICAgIF9yZW1vdmVCYWNrZHJvcCgpIHtcbiAgICAgIGlmICh0aGlzLl9iYWNrZHJvcCkge1xuICAgICAgICAkKHRoaXMuX2JhY2tkcm9wKS5yZW1vdmUoKVxuICAgICAgICB0aGlzLl9iYWNrZHJvcCA9IG51bGxcbiAgICAgIH1cbiAgICB9XG5cbiAgICBfc2hvd0JhY2tkcm9wKGNhbGxiYWNrKSB7XG4gICAgICBjb25zdCBhbmltYXRlID0gJCh0aGlzLl9lbGVtZW50KS5oYXNDbGFzcyhDbGFzc05hbWUuRkFERSkgP1xuICAgICAgICBDbGFzc05hbWUuRkFERSA6ICcnXG5cbiAgICAgIGlmICh0aGlzLl9pc1Nob3duICYmIHRoaXMuX2NvbmZpZy5iYWNrZHJvcCkge1xuICAgICAgICBjb25zdCBkb0FuaW1hdGUgPSBVdGlsLnN1cHBvcnRzVHJhbnNpdGlvbkVuZCgpICYmIGFuaW1hdGVcblxuICAgICAgICB0aGlzLl9iYWNrZHJvcCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpXG4gICAgICAgIHRoaXMuX2JhY2tkcm9wLmNsYXNzTmFtZSA9IENsYXNzTmFtZS5CQUNLRFJPUFxuXG4gICAgICAgIGlmIChhbmltYXRlKSB7XG4gICAgICAgICAgJCh0aGlzLl9iYWNrZHJvcCkuYWRkQ2xhc3MoYW5pbWF0ZSlcbiAgICAgICAgfVxuXG4gICAgICAgICQodGhpcy5fYmFja2Ryb3ApLmFwcGVuZFRvKGRvY3VtZW50LmJvZHkpXG5cbiAgICAgICAgJCh0aGlzLl9lbGVtZW50KS5vbihFdmVudC5DTElDS19ESVNNSVNTLCAoZXZlbnQpID0+IHtcbiAgICAgICAgICBpZiAodGhpcy5faWdub3JlQmFja2Ryb3BDbGljaykge1xuICAgICAgICAgICAgdGhpcy5faWdub3JlQmFja2Ryb3BDbGljayA9IGZhbHNlXG4gICAgICAgICAgICByZXR1cm5cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGV2ZW50LnRhcmdldCAhPT0gZXZlbnQuY3VycmVudFRhcmdldCkge1xuICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh0aGlzLl9jb25maWcuYmFja2Ryb3AgPT09ICdzdGF0aWMnKSB7XG4gICAgICAgICAgICB0aGlzLl9lbGVtZW50LmZvY3VzKClcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5oaWRlKClcbiAgICAgICAgICB9XG4gICAgICAgIH0pXG5cbiAgICAgICAgaWYgKGRvQW5pbWF0ZSkge1xuICAgICAgICAgIFV0aWwucmVmbG93KHRoaXMuX2JhY2tkcm9wKVxuICAgICAgICB9XG5cbiAgICAgICAgJCh0aGlzLl9iYWNrZHJvcCkuYWRkQ2xhc3MoQ2xhc3NOYW1lLlNIT1cpXG5cbiAgICAgICAgaWYgKCFjYWxsYmFjaykge1xuICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFkb0FuaW1hdGUpIHtcbiAgICAgICAgICBjYWxsYmFjaygpXG4gICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cblxuICAgICAgICAkKHRoaXMuX2JhY2tkcm9wKVxuICAgICAgICAgIC5vbmUoVXRpbC5UUkFOU0lUSU9OX0VORCwgY2FsbGJhY2spXG4gICAgICAgICAgLmVtdWxhdGVUcmFuc2l0aW9uRW5kKEJBQ0tEUk9QX1RSQU5TSVRJT05fRFVSQVRJT04pXG5cbiAgICAgIH0gZWxzZSBpZiAoIXRoaXMuX2lzU2hvd24gJiYgdGhpcy5fYmFja2Ryb3ApIHtcbiAgICAgICAgJCh0aGlzLl9iYWNrZHJvcCkucmVtb3ZlQ2xhc3MoQ2xhc3NOYW1lLlNIT1cpXG5cbiAgICAgICAgY29uc3QgY2FsbGJhY2tSZW1vdmUgPSAoKSA9PiB7XG4gICAgICAgICAgdGhpcy5fcmVtb3ZlQmFja2Ryb3AoKVxuICAgICAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICAgICAgY2FsbGJhY2soKVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChVdGlsLnN1cHBvcnRzVHJhbnNpdGlvbkVuZCgpICYmXG4gICAgICAgICAgICQodGhpcy5fZWxlbWVudCkuaGFzQ2xhc3MoQ2xhc3NOYW1lLkZBREUpKSB7XG4gICAgICAgICAgJCh0aGlzLl9iYWNrZHJvcClcbiAgICAgICAgICAgIC5vbmUoVXRpbC5UUkFOU0lUSU9OX0VORCwgY2FsbGJhY2tSZW1vdmUpXG4gICAgICAgICAgICAuZW11bGF0ZVRyYW5zaXRpb25FbmQoQkFDS0RST1BfVFJBTlNJVElPTl9EVVJBVElPTilcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjYWxsYmFja1JlbW92ZSgpXG4gICAgICAgIH1cblxuICAgICAgfSBlbHNlIGlmIChjYWxsYmFjaykge1xuICAgICAgICBjYWxsYmFjaygpXG4gICAgICB9XG4gICAgfVxuXG5cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgLy8gdGhlIGZvbGxvd2luZyBtZXRob2RzIGFyZSB1c2VkIHRvIGhhbmRsZSBvdmVyZmxvd2luZyBtb2RhbHNcbiAgICAvLyB0b2RvIChmYXQpOiB0aGVzZSBzaG91bGQgcHJvYmFibHkgYmUgcmVmYWN0b3JlZCBvdXQgb2YgbW9kYWwuanNcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICBfaGFuZGxlVXBkYXRlKCkge1xuICAgICAgdGhpcy5fYWRqdXN0RGlhbG9nKClcbiAgICB9XG5cbiAgICBfYWRqdXN0RGlhbG9nKCkge1xuICAgICAgY29uc3QgaXNNb2RhbE92ZXJmbG93aW5nID1cbiAgICAgICAgdGhpcy5fZWxlbWVudC5zY3JvbGxIZWlnaHQgPiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50SGVpZ2h0XG5cbiAgICAgIGlmICghdGhpcy5faXNCb2R5T3ZlcmZsb3dpbmcgJiYgaXNNb2RhbE92ZXJmbG93aW5nKSB7XG4gICAgICAgIHRoaXMuX2VsZW1lbnQuc3R5bGUucGFkZGluZ0xlZnQgPSBgJHt0aGlzLl9zY3JvbGxiYXJXaWR0aH1weGBcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuX2lzQm9keU92ZXJmbG93aW5nICYmICFpc01vZGFsT3ZlcmZsb3dpbmcpIHtcbiAgICAgICAgdGhpcy5fZWxlbWVudC5zdHlsZS5wYWRkaW5nUmlnaHQgPSBgJHt0aGlzLl9zY3JvbGxiYXJXaWR0aH1weGBcbiAgICAgIH1cbiAgICB9XG5cbiAgICBfcmVzZXRBZGp1c3RtZW50cygpIHtcbiAgICAgIHRoaXMuX2VsZW1lbnQuc3R5bGUucGFkZGluZ0xlZnQgPSAnJ1xuICAgICAgdGhpcy5fZWxlbWVudC5zdHlsZS5wYWRkaW5nUmlnaHQgPSAnJ1xuICAgIH1cblxuICAgIF9jaGVja1Njcm9sbGJhcigpIHtcbiAgICAgIHRoaXMuX2lzQm9keU92ZXJmbG93aW5nID0gZG9jdW1lbnQuYm9keS5jbGllbnRXaWR0aCA8IHdpbmRvdy5pbm5lcldpZHRoXG4gICAgICB0aGlzLl9zY3JvbGxiYXJXaWR0aCA9IHRoaXMuX2dldFNjcm9sbGJhcldpZHRoKClcbiAgICB9XG5cbiAgICBfc2V0U2Nyb2xsYmFyKCkge1xuICAgICAgY29uc3QgYm9keVBhZGRpbmcgPSBwYXJzZUludChcbiAgICAgICAgJChTZWxlY3Rvci5GSVhFRF9DT05URU5UKS5jc3MoJ3BhZGRpbmctcmlnaHQnKSB8fCAwLFxuICAgICAgICAxMFxuICAgICAgKVxuXG4gICAgICB0aGlzLl9vcmlnaW5hbEJvZHlQYWRkaW5nID0gZG9jdW1lbnQuYm9keS5zdHlsZS5wYWRkaW5nUmlnaHQgfHwgJydcblxuICAgICAgaWYgKHRoaXMuX2lzQm9keU92ZXJmbG93aW5nKSB7XG4gICAgICAgIGRvY3VtZW50LmJvZHkuc3R5bGUucGFkZGluZ1JpZ2h0ID1cbiAgICAgICAgICBgJHtib2R5UGFkZGluZyArIHRoaXMuX3Njcm9sbGJhcldpZHRofXB4YFxuICAgICAgfVxuICAgIH1cblxuICAgIF9yZXNldFNjcm9sbGJhcigpIHtcbiAgICAgIGRvY3VtZW50LmJvZHkuc3R5bGUucGFkZGluZ1JpZ2h0ID0gdGhpcy5fb3JpZ2luYWxCb2R5UGFkZGluZ1xuICAgIH1cblxuICAgIF9nZXRTY3JvbGxiYXJXaWR0aCgpIHsgLy8gdGh4IGQud2Fsc2hcbiAgICAgIGNvbnN0IHNjcm9sbERpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpXG4gICAgICBzY3JvbGxEaXYuY2xhc3NOYW1lID0gQ2xhc3NOYW1lLlNDUk9MTEJBUl9NRUFTVVJFUlxuICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChzY3JvbGxEaXYpXG4gICAgICBjb25zdCBzY3JvbGxiYXJXaWR0aCA9IHNjcm9sbERpdi5vZmZzZXRXaWR0aCAtIHNjcm9sbERpdi5jbGllbnRXaWR0aFxuICAgICAgZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZChzY3JvbGxEaXYpXG4gICAgICByZXR1cm4gc2Nyb2xsYmFyV2lkdGhcbiAgICB9XG5cblxuICAgIC8vIHN0YXRpY1xuXG4gICAgc3RhdGljIF9qUXVlcnlJbnRlcmZhY2UoY29uZmlnLCByZWxhdGVkVGFyZ2V0KSB7XG4gICAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgbGV0IGRhdGEgICAgICA9ICQodGhpcykuZGF0YShEQVRBX0tFWSlcbiAgICAgICAgY29uc3QgX2NvbmZpZyA9ICQuZXh0ZW5kKFxuICAgICAgICAgIHt9LFxuICAgICAgICAgIE1vZGFsLkRlZmF1bHQsXG4gICAgICAgICAgJCh0aGlzKS5kYXRhKCksXG4gICAgICAgICAgdHlwZW9mIGNvbmZpZyA9PT0gJ29iamVjdCcgJiYgY29uZmlnXG4gICAgICAgIClcblxuICAgICAgICBpZiAoIWRhdGEpIHtcbiAgICAgICAgICBkYXRhID0gbmV3IE1vZGFsKHRoaXMsIF9jb25maWcpXG4gICAgICAgICAgJCh0aGlzKS5kYXRhKERBVEFfS0VZLCBkYXRhKVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBjb25maWcgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgaWYgKGRhdGFbY29uZmlnXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYE5vIG1ldGhvZCBuYW1lZCBcIiR7Y29uZmlnfVwiYClcbiAgICAgICAgICB9XG4gICAgICAgICAgZGF0YVtjb25maWddKHJlbGF0ZWRUYXJnZXQpXG4gICAgICAgIH0gZWxzZSBpZiAoX2NvbmZpZy5zaG93KSB7XG4gICAgICAgICAgZGF0YS5zaG93KHJlbGF0ZWRUYXJnZXQpXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgfVxuXG4gIH1cblxuXG4gIC8qKlxuICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICogRGF0YSBBcGkgaW1wbGVtZW50YXRpb25cbiAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAqL1xuXG4gICQoZG9jdW1lbnQpLm9uKEV2ZW50LkNMSUNLX0RBVEFfQVBJLCBTZWxlY3Rvci5EQVRBX1RPR0dMRSwgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgbGV0IHRhcmdldFxuICAgIGNvbnN0IHNlbGVjdG9yID0gVXRpbC5nZXRTZWxlY3RvckZyb21FbGVtZW50KHRoaXMpXG5cbiAgICBpZiAoc2VsZWN0b3IpIHtcbiAgICAgIHRhcmdldCA9ICQoc2VsZWN0b3IpWzBdXG4gICAgfVxuXG4gICAgY29uc3QgY29uZmlnID0gJCh0YXJnZXQpLmRhdGEoREFUQV9LRVkpID9cbiAgICAgICd0b2dnbGUnIDogJC5leHRlbmQoe30sICQodGFyZ2V0KS5kYXRhKCksICQodGhpcykuZGF0YSgpKVxuXG4gICAgaWYgKHRoaXMudGFnTmFtZSA9PT0gJ0EnIHx8IHRoaXMudGFnTmFtZSA9PT0gJ0FSRUEnKSB7XG4gICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpXG4gICAgfVxuXG4gICAgY29uc3QgJHRhcmdldCA9ICQodGFyZ2V0KS5vbmUoRXZlbnQuU0hPVywgKHNob3dFdmVudCkgPT4ge1xuICAgICAgaWYgKHNob3dFdmVudC5pc0RlZmF1bHRQcmV2ZW50ZWQoKSkge1xuICAgICAgICAvLyBvbmx5IHJlZ2lzdGVyIGZvY3VzIHJlc3RvcmVyIGlmIG1vZGFsIHdpbGwgYWN0dWFsbHkgZ2V0IHNob3duXG4gICAgICAgIHJldHVyblxuICAgICAgfVxuXG4gICAgICAkdGFyZ2V0Lm9uZShFdmVudC5ISURERU4sICgpID0+IHtcbiAgICAgICAgaWYgKCQodGhpcykuaXMoJzp2aXNpYmxlJykpIHtcbiAgICAgICAgICB0aGlzLmZvY3VzKClcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICB9KVxuXG4gICAgTW9kYWwuX2pRdWVyeUludGVyZmFjZS5jYWxsKCQodGFyZ2V0KSwgY29uZmlnLCB0aGlzKVxuICB9KVxuXG5cbiAgLyoqXG4gICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgKiBqUXVlcnlcbiAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAqL1xuXG4gICQuZm5bTkFNRV0gICAgICAgICAgICAgPSBNb2RhbC5falF1ZXJ5SW50ZXJmYWNlXG4gICQuZm5bTkFNRV0uQ29uc3RydWN0b3IgPSBNb2RhbFxuICAkLmZuW05BTUVdLm5vQ29uZmxpY3QgID0gZnVuY3Rpb24gKCkge1xuICAgICQuZm5bTkFNRV0gPSBKUVVFUllfTk9fQ09ORkxJQ1RcbiAgICByZXR1cm4gTW9kYWwuX2pRdWVyeUludGVyZmFjZVxuICB9XG5cbiAgcmV0dXJuIE1vZGFsXG5cbn0pKGpRdWVyeSlcblxuZXhwb3J0IGRlZmF1bHQgTW9kYWxcbiIsIi8qIGdsb2JhbCBUZXRoZXIgKi9cblxuaW1wb3J0IFV0aWwgZnJvbSAnLi91dGlsJ1xuXG5cbi8qKlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIEJvb3RzdHJhcCAodjQuMC4wLWFscGhhLjYpOiB0b29sdGlwLmpzXG4gKiBMaWNlbnNlZCB1bmRlciBNSVQgKGh0dHBzOi8vZ2l0aHViLmNvbS90d2JzL2Jvb3RzdHJhcC9ibG9iL21hc3Rlci9MSUNFTlNFKVxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqL1xuXG5jb25zdCBUb29sdGlwID0gKCgkKSA9PiB7XG5cbiAgLyoqXG4gICAqIENoZWNrIGZvciBUZXRoZXIgZGVwZW5kZW5jeVxuICAgKiBUZXRoZXIgLSBodHRwOi8vdGV0aGVyLmlvL1xuICAgKi9cbiAgaWYgKHR5cGVvZiBUZXRoZXIgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdCb290c3RyYXAgdG9vbHRpcHMgcmVxdWlyZSBUZXRoZXIgKGh0dHA6Ly90ZXRoZXIuaW8vKScpXG4gIH1cblxuXG4gIC8qKlxuICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICogQ29uc3RhbnRzXG4gICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgKi9cblxuICBjb25zdCBOQU1FICAgICAgICAgICAgICAgID0gJ3Rvb2x0aXAnXG4gIGNvbnN0IFZFUlNJT04gICAgICAgICAgICAgPSAnNC4wLjAtYWxwaGEuNidcbiAgY29uc3QgREFUQV9LRVkgICAgICAgICAgICA9ICdicy50b29sdGlwJ1xuICBjb25zdCBFVkVOVF9LRVkgICAgICAgICAgID0gYC4ke0RBVEFfS0VZfWBcbiAgY29uc3QgSlFVRVJZX05PX0NPTkZMSUNUICA9ICQuZm5bTkFNRV1cbiAgY29uc3QgVFJBTlNJVElPTl9EVVJBVElPTiA9IDE1MFxuICBjb25zdCBDTEFTU19QUkVGSVggICAgICAgID0gJ2JzLXRldGhlcidcblxuICBjb25zdCBEZWZhdWx0ID0ge1xuICAgIGFuaW1hdGlvbiAgIDogdHJ1ZSxcbiAgICB0ZW1wbGF0ZSAgICA6ICc8ZGl2IGNsYXNzPVwidG9vbHRpcFwiIHJvbGU9XCJ0b29sdGlwXCI+J1xuICAgICAgICAgICAgICAgICsgJzxkaXYgY2xhc3M9XCJ0b29sdGlwLWlubmVyXCI+PC9kaXY+PC9kaXY+JyxcbiAgICB0cmlnZ2VyICAgICA6ICdob3ZlciBmb2N1cycsXG4gICAgdGl0bGUgICAgICAgOiAnJyxcbiAgICBkZWxheSAgICAgICA6IDAsXG4gICAgaHRtbCAgICAgICAgOiBmYWxzZSxcbiAgICBzZWxlY3RvciAgICA6IGZhbHNlLFxuICAgIHBsYWNlbWVudCAgIDogJ3RvcCcsXG4gICAgb2Zmc2V0ICAgICAgOiAnMCAwJyxcbiAgICBjb25zdHJhaW50cyA6IFtdLFxuICAgIGNvbnRhaW5lciAgIDogZmFsc2VcbiAgfVxuXG4gIGNvbnN0IERlZmF1bHRUeXBlID0ge1xuICAgIGFuaW1hdGlvbiAgIDogJ2Jvb2xlYW4nLFxuICAgIHRlbXBsYXRlICAgIDogJ3N0cmluZycsXG4gICAgdGl0bGUgICAgICAgOiAnKHN0cmluZ3xlbGVtZW50fGZ1bmN0aW9uKScsXG4gICAgdHJpZ2dlciAgICAgOiAnc3RyaW5nJyxcbiAgICBkZWxheSAgICAgICA6ICcobnVtYmVyfG9iamVjdCknLFxuICAgIGh0bWwgICAgICAgIDogJ2Jvb2xlYW4nLFxuICAgIHNlbGVjdG9yICAgIDogJyhzdHJpbmd8Ym9vbGVhbiknLFxuICAgIHBsYWNlbWVudCAgIDogJyhzdHJpbmd8ZnVuY3Rpb24pJyxcbiAgICBvZmZzZXQgICAgICA6ICdzdHJpbmcnLFxuICAgIGNvbnN0cmFpbnRzIDogJ2FycmF5JyxcbiAgICBjb250YWluZXIgICA6ICcoc3RyaW5nfGVsZW1lbnR8Ym9vbGVhbiknXG4gIH1cblxuICBjb25zdCBBdHRhY2htZW50TWFwID0ge1xuICAgIFRPUCAgICA6ICdib3R0b20gY2VudGVyJyxcbiAgICBSSUdIVCAgOiAnbWlkZGxlIGxlZnQnLFxuICAgIEJPVFRPTSA6ICd0b3AgY2VudGVyJyxcbiAgICBMRUZUICAgOiAnbWlkZGxlIHJpZ2h0J1xuICB9XG5cbiAgY29uc3QgSG92ZXJTdGF0ZSA9IHtcbiAgICBTSE9XIDogJ3Nob3cnLFxuICAgIE9VVCAgOiAnb3V0J1xuICB9XG5cbiAgY29uc3QgRXZlbnQgPSB7XG4gICAgSElERSAgICAgICA6IGBoaWRlJHtFVkVOVF9LRVl9YCxcbiAgICBISURERU4gICAgIDogYGhpZGRlbiR7RVZFTlRfS0VZfWAsXG4gICAgU0hPVyAgICAgICA6IGBzaG93JHtFVkVOVF9LRVl9YCxcbiAgICBTSE9XTiAgICAgIDogYHNob3duJHtFVkVOVF9LRVl9YCxcbiAgICBJTlNFUlRFRCAgIDogYGluc2VydGVkJHtFVkVOVF9LRVl9YCxcbiAgICBDTElDSyAgICAgIDogYGNsaWNrJHtFVkVOVF9LRVl9YCxcbiAgICBGT0NVU0lOICAgIDogYGZvY3VzaW4ke0VWRU5UX0tFWX1gLFxuICAgIEZPQ1VTT1VUICAgOiBgZm9jdXNvdXQke0VWRU5UX0tFWX1gLFxuICAgIE1PVVNFRU5URVIgOiBgbW91c2VlbnRlciR7RVZFTlRfS0VZfWAsXG4gICAgTU9VU0VMRUFWRSA6IGBtb3VzZWxlYXZlJHtFVkVOVF9LRVl9YFxuICB9XG5cbiAgY29uc3QgQ2xhc3NOYW1lID0ge1xuICAgIEZBREUgOiAnZmFkZScsXG4gICAgU0hPVyA6ICdzaG93J1xuICB9XG5cbiAgY29uc3QgU2VsZWN0b3IgPSB7XG4gICAgVE9PTFRJUCAgICAgICA6ICcudG9vbHRpcCcsXG4gICAgVE9PTFRJUF9JTk5FUiA6ICcudG9vbHRpcC1pbm5lcidcbiAgfVxuXG4gIGNvbnN0IFRldGhlckNsYXNzID0ge1xuICAgIGVsZW1lbnQgOiBmYWxzZSxcbiAgICBlbmFibGVkIDogZmFsc2VcbiAgfVxuXG4gIGNvbnN0IFRyaWdnZXIgPSB7XG4gICAgSE9WRVIgIDogJ2hvdmVyJyxcbiAgICBGT0NVUyAgOiAnZm9jdXMnLFxuICAgIENMSUNLICA6ICdjbGljaycsXG4gICAgTUFOVUFMIDogJ21hbnVhbCdcbiAgfVxuXG5cbiAgLyoqXG4gICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgKiBDbGFzcyBEZWZpbml0aW9uXG4gICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgKi9cblxuICBjbGFzcyBUb29sdGlwIHtcblxuICAgIGNvbnN0cnVjdG9yKGVsZW1lbnQsIGNvbmZpZykge1xuXG4gICAgICAvLyBwcml2YXRlXG4gICAgICB0aGlzLl9pc0VuYWJsZWQgICAgICAgID0gdHJ1ZVxuICAgICAgdGhpcy5fdGltZW91dCAgICAgICAgICA9IDBcbiAgICAgIHRoaXMuX2hvdmVyU3RhdGUgICAgICAgPSAnJ1xuICAgICAgdGhpcy5fYWN0aXZlVHJpZ2dlciAgICA9IHt9XG4gICAgICB0aGlzLl9pc1RyYW5zaXRpb25pbmcgID0gZmFsc2VcbiAgICAgIHRoaXMuX3RldGhlciAgICAgICAgICAgPSBudWxsXG5cbiAgICAgIC8vIHByb3RlY3RlZFxuICAgICAgdGhpcy5lbGVtZW50ID0gZWxlbWVudFxuICAgICAgdGhpcy5jb25maWcgID0gdGhpcy5fZ2V0Q29uZmlnKGNvbmZpZylcbiAgICAgIHRoaXMudGlwICAgICA9IG51bGxcblxuICAgICAgdGhpcy5fc2V0TGlzdGVuZXJzKClcblxuICAgIH1cblxuXG4gICAgLy8gZ2V0dGVyc1xuXG4gICAgc3RhdGljIGdldCBWRVJTSU9OKCkge1xuICAgICAgcmV0dXJuIFZFUlNJT05cbiAgICB9XG5cbiAgICBzdGF0aWMgZ2V0IERlZmF1bHQoKSB7XG4gICAgICByZXR1cm4gRGVmYXVsdFxuICAgIH1cblxuICAgIHN0YXRpYyBnZXQgTkFNRSgpIHtcbiAgICAgIHJldHVybiBOQU1FXG4gICAgfVxuXG4gICAgc3RhdGljIGdldCBEQVRBX0tFWSgpIHtcbiAgICAgIHJldHVybiBEQVRBX0tFWVxuICAgIH1cblxuICAgIHN0YXRpYyBnZXQgRXZlbnQoKSB7XG4gICAgICByZXR1cm4gRXZlbnRcbiAgICB9XG5cbiAgICBzdGF0aWMgZ2V0IEVWRU5UX0tFWSgpIHtcbiAgICAgIHJldHVybiBFVkVOVF9LRVlcbiAgICB9XG5cbiAgICBzdGF0aWMgZ2V0IERlZmF1bHRUeXBlKCkge1xuICAgICAgcmV0dXJuIERlZmF1bHRUeXBlXG4gICAgfVxuXG5cbiAgICAvLyBwdWJsaWNcblxuICAgIGVuYWJsZSgpIHtcbiAgICAgIHRoaXMuX2lzRW5hYmxlZCA9IHRydWVcbiAgICB9XG5cbiAgICBkaXNhYmxlKCkge1xuICAgICAgdGhpcy5faXNFbmFibGVkID0gZmFsc2VcbiAgICB9XG5cbiAgICB0b2dnbGVFbmFibGVkKCkge1xuICAgICAgdGhpcy5faXNFbmFibGVkID0gIXRoaXMuX2lzRW5hYmxlZFxuICAgIH1cblxuICAgIHRvZ2dsZShldmVudCkge1xuICAgICAgaWYgKGV2ZW50KSB7XG4gICAgICAgIGNvbnN0IGRhdGFLZXkgPSB0aGlzLmNvbnN0cnVjdG9yLkRBVEFfS0VZXG4gICAgICAgIGxldCBjb250ZXh0ID0gJChldmVudC5jdXJyZW50VGFyZ2V0KS5kYXRhKGRhdGFLZXkpXG5cbiAgICAgICAgaWYgKCFjb250ZXh0KSB7XG4gICAgICAgICAgY29udGV4dCA9IG5ldyB0aGlzLmNvbnN0cnVjdG9yKFxuICAgICAgICAgICAgZXZlbnQuY3VycmVudFRhcmdldCxcbiAgICAgICAgICAgIHRoaXMuX2dldERlbGVnYXRlQ29uZmlnKClcbiAgICAgICAgICApXG4gICAgICAgICAgJChldmVudC5jdXJyZW50VGFyZ2V0KS5kYXRhKGRhdGFLZXksIGNvbnRleHQpXG4gICAgICAgIH1cblxuICAgICAgICBjb250ZXh0Ll9hY3RpdmVUcmlnZ2VyLmNsaWNrID0gIWNvbnRleHQuX2FjdGl2ZVRyaWdnZXIuY2xpY2tcblxuICAgICAgICBpZiAoY29udGV4dC5faXNXaXRoQWN0aXZlVHJpZ2dlcigpKSB7XG4gICAgICAgICAgY29udGV4dC5fZW50ZXIobnVsbCwgY29udGV4dClcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb250ZXh0Ll9sZWF2ZShudWxsLCBjb250ZXh0KVxuICAgICAgICB9XG5cbiAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgaWYgKCQodGhpcy5nZXRUaXBFbGVtZW50KCkpLmhhc0NsYXNzKENsYXNzTmFtZS5TSE9XKSkge1xuICAgICAgICAgIHRoaXMuX2xlYXZlKG51bGwsIHRoaXMpXG4gICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9lbnRlcihudWxsLCB0aGlzKVxuICAgICAgfVxuICAgIH1cblxuICAgIGRpc3Bvc2UoKSB7XG4gICAgICBjbGVhclRpbWVvdXQodGhpcy5fdGltZW91dClcblxuICAgICAgdGhpcy5jbGVhbnVwVGV0aGVyKClcblxuICAgICAgJC5yZW1vdmVEYXRhKHRoaXMuZWxlbWVudCwgdGhpcy5jb25zdHJ1Y3Rvci5EQVRBX0tFWSlcblxuICAgICAgJCh0aGlzLmVsZW1lbnQpLm9mZih0aGlzLmNvbnN0cnVjdG9yLkVWRU5UX0tFWSlcbiAgICAgICQodGhpcy5lbGVtZW50KS5jbG9zZXN0KCcubW9kYWwnKS5vZmYoJ2hpZGUuYnMubW9kYWwnKVxuXG4gICAgICBpZiAodGhpcy50aXApIHtcbiAgICAgICAgJCh0aGlzLnRpcCkucmVtb3ZlKClcbiAgICAgIH1cblxuICAgICAgdGhpcy5faXNFbmFibGVkICAgICA9IG51bGxcbiAgICAgIHRoaXMuX3RpbWVvdXQgICAgICAgPSBudWxsXG4gICAgICB0aGlzLl9ob3ZlclN0YXRlICAgID0gbnVsbFxuICAgICAgdGhpcy5fYWN0aXZlVHJpZ2dlciA9IG51bGxcbiAgICAgIHRoaXMuX3RldGhlciAgICAgICAgPSBudWxsXG5cbiAgICAgIHRoaXMuZWxlbWVudCA9IG51bGxcbiAgICAgIHRoaXMuY29uZmlnICA9IG51bGxcbiAgICAgIHRoaXMudGlwICAgICA9IG51bGxcbiAgICB9XG5cbiAgICBzaG93KCkge1xuICAgICAgaWYgKCQodGhpcy5lbGVtZW50KS5jc3MoJ2Rpc3BsYXknKSA9PT0gJ25vbmUnKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignUGxlYXNlIHVzZSBzaG93IG9uIHZpc2libGUgZWxlbWVudHMnKVxuICAgICAgfVxuXG4gICAgICBjb25zdCBzaG93RXZlbnQgPSAkLkV2ZW50KHRoaXMuY29uc3RydWN0b3IuRXZlbnQuU0hPVylcbiAgICAgIGlmICh0aGlzLmlzV2l0aENvbnRlbnQoKSAmJiB0aGlzLl9pc0VuYWJsZWQpIHtcbiAgICAgICAgaWYgKHRoaXMuX2lzVHJhbnNpdGlvbmluZykge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVG9vbHRpcCBpcyB0cmFuc2l0aW9uaW5nJylcbiAgICAgICAgfVxuICAgICAgICAkKHRoaXMuZWxlbWVudCkudHJpZ2dlcihzaG93RXZlbnQpXG5cbiAgICAgICAgY29uc3QgaXNJblRoZURvbSA9ICQuY29udGFpbnMoXG4gICAgICAgICAgdGhpcy5lbGVtZW50Lm93bmVyRG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LFxuICAgICAgICAgIHRoaXMuZWxlbWVudFxuICAgICAgICApXG5cbiAgICAgICAgaWYgKHNob3dFdmVudC5pc0RlZmF1bHRQcmV2ZW50ZWQoKSB8fCAhaXNJblRoZURvbSkge1xuICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgdGlwICAgPSB0aGlzLmdldFRpcEVsZW1lbnQoKVxuICAgICAgICBjb25zdCB0aXBJZCA9IFV0aWwuZ2V0VUlEKHRoaXMuY29uc3RydWN0b3IuTkFNRSlcblxuICAgICAgICB0aXAuc2V0QXR0cmlidXRlKCdpZCcsIHRpcElkKVxuICAgICAgICB0aGlzLmVsZW1lbnQuc2V0QXR0cmlidXRlKCdhcmlhLWRlc2NyaWJlZGJ5JywgdGlwSWQpXG5cbiAgICAgICAgdGhpcy5zZXRDb250ZW50KClcblxuICAgICAgICBpZiAodGhpcy5jb25maWcuYW5pbWF0aW9uKSB7XG4gICAgICAgICAgJCh0aXApLmFkZENsYXNzKENsYXNzTmFtZS5GQURFKVxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgcGxhY2VtZW50ICA9IHR5cGVvZiB0aGlzLmNvbmZpZy5wbGFjZW1lbnQgPT09ICdmdW5jdGlvbicgP1xuICAgICAgICAgIHRoaXMuY29uZmlnLnBsYWNlbWVudC5jYWxsKHRoaXMsIHRpcCwgdGhpcy5lbGVtZW50KSA6XG4gICAgICAgICAgdGhpcy5jb25maWcucGxhY2VtZW50XG5cbiAgICAgICAgY29uc3QgYXR0YWNobWVudCA9IHRoaXMuX2dldEF0dGFjaG1lbnQocGxhY2VtZW50KVxuXG4gICAgICAgIGNvbnN0IGNvbnRhaW5lciA9IHRoaXMuY29uZmlnLmNvbnRhaW5lciA9PT0gZmFsc2UgPyBkb2N1bWVudC5ib2R5IDogJCh0aGlzLmNvbmZpZy5jb250YWluZXIpXG5cbiAgICAgICAgJCh0aXApXG4gICAgICAgICAgLmRhdGEodGhpcy5jb25zdHJ1Y3Rvci5EQVRBX0tFWSwgdGhpcylcbiAgICAgICAgICAuYXBwZW5kVG8oY29udGFpbmVyKVxuXG4gICAgICAgICQodGhpcy5lbGVtZW50KS50cmlnZ2VyKHRoaXMuY29uc3RydWN0b3IuRXZlbnQuSU5TRVJURUQpXG5cbiAgICAgICAgdGhpcy5fdGV0aGVyID0gbmV3IFRldGhlcih7XG4gICAgICAgICAgYXR0YWNobWVudCxcbiAgICAgICAgICBlbGVtZW50ICAgICAgICAgOiB0aXAsXG4gICAgICAgICAgdGFyZ2V0ICAgICAgICAgIDogdGhpcy5lbGVtZW50LFxuICAgICAgICAgIGNsYXNzZXMgICAgICAgICA6IFRldGhlckNsYXNzLFxuICAgICAgICAgIGNsYXNzUHJlZml4ICAgICA6IENMQVNTX1BSRUZJWCxcbiAgICAgICAgICBvZmZzZXQgICAgICAgICAgOiB0aGlzLmNvbmZpZy5vZmZzZXQsXG4gICAgICAgICAgY29uc3RyYWludHMgICAgIDogdGhpcy5jb25maWcuY29uc3RyYWludHMsXG4gICAgICAgICAgYWRkVGFyZ2V0Q2xhc3NlczogZmFsc2VcbiAgICAgICAgfSlcblxuICAgICAgICBVdGlsLnJlZmxvdyh0aXApXG4gICAgICAgIHRoaXMuX3RldGhlci5wb3NpdGlvbigpXG5cbiAgICAgICAgJCh0aXApLmFkZENsYXNzKENsYXNzTmFtZS5TSE9XKVxuXG4gICAgICAgIGNvbnN0IGNvbXBsZXRlID0gKCkgPT4ge1xuICAgICAgICAgIGNvbnN0IHByZXZIb3ZlclN0YXRlID0gdGhpcy5faG92ZXJTdGF0ZVxuICAgICAgICAgIHRoaXMuX2hvdmVyU3RhdGUgICA9IG51bGxcbiAgICAgICAgICB0aGlzLl9pc1RyYW5zaXRpb25pbmcgPSBmYWxzZVxuXG4gICAgICAgICAgJCh0aGlzLmVsZW1lbnQpLnRyaWdnZXIodGhpcy5jb25zdHJ1Y3Rvci5FdmVudC5TSE9XTilcblxuICAgICAgICAgIGlmIChwcmV2SG92ZXJTdGF0ZSA9PT0gSG92ZXJTdGF0ZS5PVVQpIHtcbiAgICAgICAgICAgIHRoaXMuX2xlYXZlKG51bGwsIHRoaXMpXG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKFV0aWwuc3VwcG9ydHNUcmFuc2l0aW9uRW5kKCkgJiYgJCh0aGlzLnRpcCkuaGFzQ2xhc3MoQ2xhc3NOYW1lLkZBREUpKSB7XG4gICAgICAgICAgdGhpcy5faXNUcmFuc2l0aW9uaW5nID0gdHJ1ZVxuICAgICAgICAgICQodGhpcy50aXApXG4gICAgICAgICAgICAub25lKFV0aWwuVFJBTlNJVElPTl9FTkQsIGNvbXBsZXRlKVxuICAgICAgICAgICAgLmVtdWxhdGVUcmFuc2l0aW9uRW5kKFRvb2x0aXAuX1RSQU5TSVRJT05fRFVSQVRJT04pXG4gICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cblxuICAgICAgICBjb21wbGV0ZSgpXG4gICAgICB9XG4gICAgfVxuXG4gICAgaGlkZShjYWxsYmFjaykge1xuICAgICAgY29uc3QgdGlwICAgICAgID0gdGhpcy5nZXRUaXBFbGVtZW50KClcbiAgICAgIGNvbnN0IGhpZGVFdmVudCA9ICQuRXZlbnQodGhpcy5jb25zdHJ1Y3Rvci5FdmVudC5ISURFKVxuICAgICAgaWYgKHRoaXMuX2lzVHJhbnNpdGlvbmluZykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Rvb2x0aXAgaXMgdHJhbnNpdGlvbmluZycpXG4gICAgICB9XG4gICAgICBjb25zdCBjb21wbGV0ZSAgPSAoKSA9PiB7XG4gICAgICAgIGlmICh0aGlzLl9ob3ZlclN0YXRlICE9PSBIb3ZlclN0YXRlLlNIT1cgJiYgdGlwLnBhcmVudE5vZGUpIHtcbiAgICAgICAgICB0aXAucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aXApXG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKCdhcmlhLWRlc2NyaWJlZGJ5JylcbiAgICAgICAgJCh0aGlzLmVsZW1lbnQpLnRyaWdnZXIodGhpcy5jb25zdHJ1Y3Rvci5FdmVudC5ISURERU4pXG4gICAgICAgIHRoaXMuX2lzVHJhbnNpdGlvbmluZyA9IGZhbHNlXG4gICAgICAgIHRoaXMuY2xlYW51cFRldGhlcigpXG5cbiAgICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgICAgY2FsbGJhY2soKVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgICQodGhpcy5lbGVtZW50KS50cmlnZ2VyKGhpZGVFdmVudClcblxuICAgICAgaWYgKGhpZGVFdmVudC5pc0RlZmF1bHRQcmV2ZW50ZWQoKSkge1xuICAgICAgICByZXR1cm5cbiAgICAgIH1cblxuICAgICAgJCh0aXApLnJlbW92ZUNsYXNzKENsYXNzTmFtZS5TSE9XKVxuXG4gICAgICB0aGlzLl9hY3RpdmVUcmlnZ2VyW1RyaWdnZXIuQ0xJQ0tdID0gZmFsc2VcbiAgICAgIHRoaXMuX2FjdGl2ZVRyaWdnZXJbVHJpZ2dlci5GT0NVU10gPSBmYWxzZVxuICAgICAgdGhpcy5fYWN0aXZlVHJpZ2dlcltUcmlnZ2VyLkhPVkVSXSA9IGZhbHNlXG5cbiAgICAgIGlmIChVdGlsLnN1cHBvcnRzVHJhbnNpdGlvbkVuZCgpICYmXG4gICAgICAgICAgJCh0aGlzLnRpcCkuaGFzQ2xhc3MoQ2xhc3NOYW1lLkZBREUpKSB7XG4gICAgICAgIHRoaXMuX2lzVHJhbnNpdGlvbmluZyA9IHRydWVcbiAgICAgICAgJCh0aXApXG4gICAgICAgICAgLm9uZShVdGlsLlRSQU5TSVRJT05fRU5ELCBjb21wbGV0ZSlcbiAgICAgICAgICAuZW11bGF0ZVRyYW5zaXRpb25FbmQoVFJBTlNJVElPTl9EVVJBVElPTilcblxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29tcGxldGUoKVxuICAgICAgfVxuXG4gICAgICB0aGlzLl9ob3ZlclN0YXRlID0gJydcbiAgICB9XG5cblxuICAgIC8vIHByb3RlY3RlZFxuXG4gICAgaXNXaXRoQ29udGVudCgpIHtcbiAgICAgIHJldHVybiBCb29sZWFuKHRoaXMuZ2V0VGl0bGUoKSlcbiAgICB9XG5cbiAgICBnZXRUaXBFbGVtZW50KCkge1xuICAgICAgcmV0dXJuIHRoaXMudGlwID0gdGhpcy50aXAgfHwgJCh0aGlzLmNvbmZpZy50ZW1wbGF0ZSlbMF1cbiAgICB9XG5cbiAgICBzZXRDb250ZW50KCkge1xuICAgICAgY29uc3QgJHRpcCA9ICQodGhpcy5nZXRUaXBFbGVtZW50KCkpXG5cbiAgICAgIHRoaXMuc2V0RWxlbWVudENvbnRlbnQoJHRpcC5maW5kKFNlbGVjdG9yLlRPT0xUSVBfSU5ORVIpLCB0aGlzLmdldFRpdGxlKCkpXG5cbiAgICAgICR0aXAucmVtb3ZlQ2xhc3MoYCR7Q2xhc3NOYW1lLkZBREV9ICR7Q2xhc3NOYW1lLlNIT1d9YClcblxuICAgICAgdGhpcy5jbGVhbnVwVGV0aGVyKClcbiAgICB9XG5cbiAgICBzZXRFbGVtZW50Q29udGVudCgkZWxlbWVudCwgY29udGVudCkge1xuICAgICAgY29uc3QgaHRtbCA9IHRoaXMuY29uZmlnLmh0bWxcbiAgICAgIGlmICh0eXBlb2YgY29udGVudCA9PT0gJ29iamVjdCcgJiYgKGNvbnRlbnQubm9kZVR5cGUgfHwgY29udGVudC5qcXVlcnkpKSB7XG4gICAgICAgIC8vIGNvbnRlbnQgaXMgYSBET00gbm9kZSBvciBhIGpRdWVyeVxuICAgICAgICBpZiAoaHRtbCkge1xuICAgICAgICAgIGlmICghJChjb250ZW50KS5wYXJlbnQoKS5pcygkZWxlbWVudCkpIHtcbiAgICAgICAgICAgICRlbGVtZW50LmVtcHR5KCkuYXBwZW5kKGNvbnRlbnQpXG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICRlbGVtZW50LnRleHQoJChjb250ZW50KS50ZXh0KCkpXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgICRlbGVtZW50W2h0bWwgPyAnaHRtbCcgOiAndGV4dCddKGNvbnRlbnQpXG4gICAgICB9XG4gICAgfVxuXG4gICAgZ2V0VGl0bGUoKSB7XG4gICAgICBsZXQgdGl0bGUgPSB0aGlzLmVsZW1lbnQuZ2V0QXR0cmlidXRlKCdkYXRhLW9yaWdpbmFsLXRpdGxlJylcblxuICAgICAgaWYgKCF0aXRsZSkge1xuICAgICAgICB0aXRsZSA9IHR5cGVvZiB0aGlzLmNvbmZpZy50aXRsZSA9PT0gJ2Z1bmN0aW9uJyA/XG4gICAgICAgICAgdGhpcy5jb25maWcudGl0bGUuY2FsbCh0aGlzLmVsZW1lbnQpIDpcbiAgICAgICAgICB0aGlzLmNvbmZpZy50aXRsZVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGl0bGVcbiAgICB9XG5cbiAgICBjbGVhbnVwVGV0aGVyKCkge1xuICAgICAgaWYgKHRoaXMuX3RldGhlcikge1xuICAgICAgICB0aGlzLl90ZXRoZXIuZGVzdHJveSgpXG4gICAgICB9XG4gICAgfVxuXG5cbiAgICAvLyBwcml2YXRlXG5cbiAgICBfZ2V0QXR0YWNobWVudChwbGFjZW1lbnQpIHtcbiAgICAgIHJldHVybiBBdHRhY2htZW50TWFwW3BsYWNlbWVudC50b1VwcGVyQ2FzZSgpXVxuICAgIH1cblxuICAgIF9zZXRMaXN0ZW5lcnMoKSB7XG4gICAgICBjb25zdCB0cmlnZ2VycyA9IHRoaXMuY29uZmlnLnRyaWdnZXIuc3BsaXQoJyAnKVxuXG4gICAgICB0cmlnZ2Vycy5mb3JFYWNoKCh0cmlnZ2VyKSA9PiB7XG4gICAgICAgIGlmICh0cmlnZ2VyID09PSAnY2xpY2snKSB7XG4gICAgICAgICAgJCh0aGlzLmVsZW1lbnQpLm9uKFxuICAgICAgICAgICAgdGhpcy5jb25zdHJ1Y3Rvci5FdmVudC5DTElDSyxcbiAgICAgICAgICAgIHRoaXMuY29uZmlnLnNlbGVjdG9yLFxuICAgICAgICAgICAgKGV2ZW50KSA9PiB0aGlzLnRvZ2dsZShldmVudClcbiAgICAgICAgICApXG5cbiAgICAgICAgfSBlbHNlIGlmICh0cmlnZ2VyICE9PSBUcmlnZ2VyLk1BTlVBTCkge1xuICAgICAgICAgIGNvbnN0IGV2ZW50SW4gID0gdHJpZ2dlciA9PT0gVHJpZ2dlci5IT1ZFUiA/XG4gICAgICAgICAgICB0aGlzLmNvbnN0cnVjdG9yLkV2ZW50Lk1PVVNFRU5URVIgOlxuICAgICAgICAgICAgdGhpcy5jb25zdHJ1Y3Rvci5FdmVudC5GT0NVU0lOXG4gICAgICAgICAgY29uc3QgZXZlbnRPdXQgPSB0cmlnZ2VyID09PSBUcmlnZ2VyLkhPVkVSID9cbiAgICAgICAgICAgIHRoaXMuY29uc3RydWN0b3IuRXZlbnQuTU9VU0VMRUFWRSA6XG4gICAgICAgICAgICB0aGlzLmNvbnN0cnVjdG9yLkV2ZW50LkZPQ1VTT1VUXG5cbiAgICAgICAgICAkKHRoaXMuZWxlbWVudClcbiAgICAgICAgICAgIC5vbihcbiAgICAgICAgICAgICAgZXZlbnRJbixcbiAgICAgICAgICAgICAgdGhpcy5jb25maWcuc2VsZWN0b3IsXG4gICAgICAgICAgICAgIChldmVudCkgPT4gdGhpcy5fZW50ZXIoZXZlbnQpXG4gICAgICAgICAgICApXG4gICAgICAgICAgICAub24oXG4gICAgICAgICAgICAgIGV2ZW50T3V0LFxuICAgICAgICAgICAgICB0aGlzLmNvbmZpZy5zZWxlY3RvcixcbiAgICAgICAgICAgICAgKGV2ZW50KSA9PiB0aGlzLl9sZWF2ZShldmVudClcbiAgICAgICAgICAgIClcbiAgICAgICAgfVxuXG4gICAgICAgICQodGhpcy5lbGVtZW50KS5jbG9zZXN0KCcubW9kYWwnKS5vbihcbiAgICAgICAgICAnaGlkZS5icy5tb2RhbCcsXG4gICAgICAgICAgKCkgPT4gdGhpcy5oaWRlKClcbiAgICAgICAgKVxuICAgICAgfSlcblxuICAgICAgaWYgKHRoaXMuY29uZmlnLnNlbGVjdG9yKSB7XG4gICAgICAgIHRoaXMuY29uZmlnID0gJC5leHRlbmQoe30sIHRoaXMuY29uZmlnLCB7XG4gICAgICAgICAgdHJpZ2dlciAgOiAnbWFudWFsJyxcbiAgICAgICAgICBzZWxlY3RvciA6ICcnXG4gICAgICAgIH0pXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9maXhUaXRsZSgpXG4gICAgICB9XG4gICAgfVxuXG4gICAgX2ZpeFRpdGxlKCkge1xuICAgICAgY29uc3QgdGl0bGVUeXBlID0gdHlwZW9mIHRoaXMuZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ2RhdGEtb3JpZ2luYWwtdGl0bGUnKVxuICAgICAgaWYgKHRoaXMuZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ3RpdGxlJykgfHxcbiAgICAgICAgIHRpdGxlVHlwZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgdGhpcy5lbGVtZW50LnNldEF0dHJpYnV0ZShcbiAgICAgICAgICAnZGF0YS1vcmlnaW5hbC10aXRsZScsXG4gICAgICAgICAgdGhpcy5lbGVtZW50LmdldEF0dHJpYnV0ZSgndGl0bGUnKSB8fCAnJ1xuICAgICAgICApXG4gICAgICAgIHRoaXMuZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ3RpdGxlJywgJycpXG4gICAgICB9XG4gICAgfVxuXG4gICAgX2VudGVyKGV2ZW50LCBjb250ZXh0KSB7XG4gICAgICBjb25zdCBkYXRhS2V5ID0gdGhpcy5jb25zdHJ1Y3Rvci5EQVRBX0tFWVxuXG4gICAgICBjb250ZXh0ID0gY29udGV4dCB8fCAkKGV2ZW50LmN1cnJlbnRUYXJnZXQpLmRhdGEoZGF0YUtleSlcblxuICAgICAgaWYgKCFjb250ZXh0KSB7XG4gICAgICAgIGNvbnRleHQgPSBuZXcgdGhpcy5jb25zdHJ1Y3RvcihcbiAgICAgICAgICBldmVudC5jdXJyZW50VGFyZ2V0LFxuICAgICAgICAgIHRoaXMuX2dldERlbGVnYXRlQ29uZmlnKClcbiAgICAgICAgKVxuICAgICAgICAkKGV2ZW50LmN1cnJlbnRUYXJnZXQpLmRhdGEoZGF0YUtleSwgY29udGV4dClcbiAgICAgIH1cblxuICAgICAgaWYgKGV2ZW50KSB7XG4gICAgICAgIGNvbnRleHQuX2FjdGl2ZVRyaWdnZXJbXG4gICAgICAgICAgZXZlbnQudHlwZSA9PT0gJ2ZvY3VzaW4nID8gVHJpZ2dlci5GT0NVUyA6IFRyaWdnZXIuSE9WRVJcbiAgICAgICAgXSA9IHRydWVcbiAgICAgIH1cblxuICAgICAgaWYgKCQoY29udGV4dC5nZXRUaXBFbGVtZW50KCkpLmhhc0NsYXNzKENsYXNzTmFtZS5TSE9XKSB8fFxuICAgICAgICAgY29udGV4dC5faG92ZXJTdGF0ZSA9PT0gSG92ZXJTdGF0ZS5TSE9XKSB7XG4gICAgICAgIGNvbnRleHQuX2hvdmVyU3RhdGUgPSBIb3ZlclN0YXRlLlNIT1dcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG5cbiAgICAgIGNsZWFyVGltZW91dChjb250ZXh0Ll90aW1lb3V0KVxuXG4gICAgICBjb250ZXh0Ll9ob3ZlclN0YXRlID0gSG92ZXJTdGF0ZS5TSE9XXG5cbiAgICAgIGlmICghY29udGV4dC5jb25maWcuZGVsYXkgfHwgIWNvbnRleHQuY29uZmlnLmRlbGF5LnNob3cpIHtcbiAgICAgICAgY29udGV4dC5zaG93KClcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG5cbiAgICAgIGNvbnRleHQuX3RpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgaWYgKGNvbnRleHQuX2hvdmVyU3RhdGUgPT09IEhvdmVyU3RhdGUuU0hPVykge1xuICAgICAgICAgIGNvbnRleHQuc2hvdygpXG4gICAgICAgIH1cbiAgICAgIH0sIGNvbnRleHQuY29uZmlnLmRlbGF5LnNob3cpXG4gICAgfVxuXG4gICAgX2xlYXZlKGV2ZW50LCBjb250ZXh0KSB7XG4gICAgICBjb25zdCBkYXRhS2V5ID0gdGhpcy5jb25zdHJ1Y3Rvci5EQVRBX0tFWVxuXG4gICAgICBjb250ZXh0ID0gY29udGV4dCB8fCAkKGV2ZW50LmN1cnJlbnRUYXJnZXQpLmRhdGEoZGF0YUtleSlcblxuICAgICAgaWYgKCFjb250ZXh0KSB7XG4gICAgICAgIGNvbnRleHQgPSBuZXcgdGhpcy5jb25zdHJ1Y3RvcihcbiAgICAgICAgICBldmVudC5jdXJyZW50VGFyZ2V0LFxuICAgICAgICAgIHRoaXMuX2dldERlbGVnYXRlQ29uZmlnKClcbiAgICAgICAgKVxuICAgICAgICAkKGV2ZW50LmN1cnJlbnRUYXJnZXQpLmRhdGEoZGF0YUtleSwgY29udGV4dClcbiAgICAgIH1cblxuICAgICAgaWYgKGV2ZW50KSB7XG4gICAgICAgIGNvbnRleHQuX2FjdGl2ZVRyaWdnZXJbXG4gICAgICAgICAgZXZlbnQudHlwZSA9PT0gJ2ZvY3Vzb3V0JyA/IFRyaWdnZXIuRk9DVVMgOiBUcmlnZ2VyLkhPVkVSXG4gICAgICAgIF0gPSBmYWxzZVxuICAgICAgfVxuXG4gICAgICBpZiAoY29udGV4dC5faXNXaXRoQWN0aXZlVHJpZ2dlcigpKSB7XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuXG4gICAgICBjbGVhclRpbWVvdXQoY29udGV4dC5fdGltZW91dClcblxuICAgICAgY29udGV4dC5faG92ZXJTdGF0ZSA9IEhvdmVyU3RhdGUuT1VUXG5cbiAgICAgIGlmICghY29udGV4dC5jb25maWcuZGVsYXkgfHwgIWNvbnRleHQuY29uZmlnLmRlbGF5LmhpZGUpIHtcbiAgICAgICAgY29udGV4dC5oaWRlKClcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG5cbiAgICAgIGNvbnRleHQuX3RpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgaWYgKGNvbnRleHQuX2hvdmVyU3RhdGUgPT09IEhvdmVyU3RhdGUuT1VUKSB7XG4gICAgICAgICAgY29udGV4dC5oaWRlKClcbiAgICAgICAgfVxuICAgICAgfSwgY29udGV4dC5jb25maWcuZGVsYXkuaGlkZSlcbiAgICB9XG5cbiAgICBfaXNXaXRoQWN0aXZlVHJpZ2dlcigpIHtcbiAgICAgIGZvciAoY29uc3QgdHJpZ2dlciBpbiB0aGlzLl9hY3RpdmVUcmlnZ2VyKSB7XG4gICAgICAgIGlmICh0aGlzLl9hY3RpdmVUcmlnZ2VyW3RyaWdnZXJdKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG5cbiAgICBfZ2V0Q29uZmlnKGNvbmZpZykge1xuICAgICAgY29uZmlnID0gJC5leHRlbmQoXG4gICAgICAgIHt9LFxuICAgICAgICB0aGlzLmNvbnN0cnVjdG9yLkRlZmF1bHQsXG4gICAgICAgICQodGhpcy5lbGVtZW50KS5kYXRhKCksXG4gICAgICAgIGNvbmZpZ1xuICAgICAgKVxuXG4gICAgICBpZiAoY29uZmlnLmRlbGF5ICYmIHR5cGVvZiBjb25maWcuZGVsYXkgPT09ICdudW1iZXInKSB7XG4gICAgICAgIGNvbmZpZy5kZWxheSA9IHtcbiAgICAgICAgICBzaG93IDogY29uZmlnLmRlbGF5LFxuICAgICAgICAgIGhpZGUgOiBjb25maWcuZGVsYXlcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBVdGlsLnR5cGVDaGVja0NvbmZpZyhcbiAgICAgICAgTkFNRSxcbiAgICAgICAgY29uZmlnLFxuICAgICAgICB0aGlzLmNvbnN0cnVjdG9yLkRlZmF1bHRUeXBlXG4gICAgICApXG5cbiAgICAgIHJldHVybiBjb25maWdcbiAgICB9XG5cbiAgICBfZ2V0RGVsZWdhdGVDb25maWcoKSB7XG4gICAgICBjb25zdCBjb25maWcgPSB7fVxuXG4gICAgICBpZiAodGhpcy5jb25maWcpIHtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gdGhpcy5jb25maWcpIHtcbiAgICAgICAgICBpZiAodGhpcy5jb25zdHJ1Y3Rvci5EZWZhdWx0W2tleV0gIT09IHRoaXMuY29uZmlnW2tleV0pIHtcbiAgICAgICAgICAgIGNvbmZpZ1trZXldID0gdGhpcy5jb25maWdba2V5XVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gY29uZmlnXG4gICAgfVxuXG5cbiAgICAvLyBzdGF0aWNcblxuICAgIHN0YXRpYyBfalF1ZXJ5SW50ZXJmYWNlKGNvbmZpZykge1xuICAgICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGxldCBkYXRhICAgICAgPSAkKHRoaXMpLmRhdGEoREFUQV9LRVkpXG4gICAgICAgIGNvbnN0IF9jb25maWcgPSB0eXBlb2YgY29uZmlnID09PSAnb2JqZWN0JyAmJiBjb25maWdcblxuICAgICAgICBpZiAoIWRhdGEgJiYgL2Rpc3Bvc2V8aGlkZS8udGVzdChjb25maWcpKSB7XG4gICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWRhdGEpIHtcbiAgICAgICAgICBkYXRhID0gbmV3IFRvb2x0aXAodGhpcywgX2NvbmZpZylcbiAgICAgICAgICAkKHRoaXMpLmRhdGEoREFUQV9LRVksIGRhdGEpXG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIGNvbmZpZyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICBpZiAoZGF0YVtjb25maWddID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgTm8gbWV0aG9kIG5hbWVkIFwiJHtjb25maWd9XCJgKVxuICAgICAgICAgIH1cbiAgICAgICAgICBkYXRhW2NvbmZpZ10oKVxuICAgICAgICB9XG4gICAgICB9KVxuICAgIH1cblxuICB9XG5cblxuICAvKipcbiAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAqIGpRdWVyeVxuICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICovXG5cbiAgJC5mbltOQU1FXSAgICAgICAgICAgICA9IFRvb2x0aXAuX2pRdWVyeUludGVyZmFjZVxuICAkLmZuW05BTUVdLkNvbnN0cnVjdG9yID0gVG9vbHRpcFxuICAkLmZuW05BTUVdLm5vQ29uZmxpY3QgID0gZnVuY3Rpb24gKCkge1xuICAgICQuZm5bTkFNRV0gPSBKUVVFUllfTk9fQ09ORkxJQ1RcbiAgICByZXR1cm4gVG9vbHRpcC5falF1ZXJ5SW50ZXJmYWNlXG4gIH1cblxuICByZXR1cm4gVG9vbHRpcFxuXG59KShqUXVlcnkpXG5cbmV4cG9ydCBkZWZhdWx0IFRvb2x0aXBcbiIsImltcG9ydCBVdGlsIGZyb20gJy4vdXRpbCdcblxuXG4vKipcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBCb290c3RyYXAgKHY0LjAuMC1hbHBoYS42KTogZHJvcGRvd24uanNcbiAqIExpY2Vuc2VkIHVuZGVyIE1JVCAoaHR0cHM6Ly9naXRodWIuY29tL3R3YnMvYm9vdHN0cmFwL2Jsb2IvbWFzdGVyL0xJQ0VOU0UpXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICovXG5cbmNvbnN0IERyb3Bkb3duID0gKCgkKSA9PiB7XG5cblxuICAvKipcbiAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAqIENvbnN0YW50c1xuICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICovXG5cbiAgY29uc3QgTkFNRSAgICAgICAgICAgICAgICAgICAgID0gJ2Ryb3Bkb3duJ1xuICBjb25zdCBWRVJTSU9OICAgICAgICAgICAgICAgICAgPSAnNC4wLjAtYWxwaGEuNidcbiAgY29uc3QgREFUQV9LRVkgICAgICAgICAgICAgICAgID0gJ2JzLmRyb3Bkb3duJ1xuICBjb25zdCBFVkVOVF9LRVkgICAgICAgICAgICAgICAgPSBgLiR7REFUQV9LRVl9YFxuICBjb25zdCBEQVRBX0FQSV9LRVkgICAgICAgICAgICAgPSAnLmRhdGEtYXBpJ1xuICBjb25zdCBKUVVFUllfTk9fQ09ORkxJQ1QgICAgICAgPSAkLmZuW05BTUVdXG4gIGNvbnN0IEVTQ0FQRV9LRVlDT0RFICAgICAgICAgICA9IDI3IC8vIEtleWJvYXJkRXZlbnQud2hpY2ggdmFsdWUgZm9yIEVzY2FwZSAoRXNjKSBrZXlcbiAgY29uc3QgQVJST1dfVVBfS0VZQ09ERSAgICAgICAgID0gMzggLy8gS2V5Ym9hcmRFdmVudC53aGljaCB2YWx1ZSBmb3IgdXAgYXJyb3cga2V5XG4gIGNvbnN0IEFSUk9XX0RPV05fS0VZQ09ERSAgICAgICA9IDQwIC8vIEtleWJvYXJkRXZlbnQud2hpY2ggdmFsdWUgZm9yIGRvd24gYXJyb3cga2V5XG4gIGNvbnN0IFJJR0hUX01PVVNFX0JVVFRPTl9XSElDSCA9IDMgLy8gTW91c2VFdmVudC53aGljaCB2YWx1ZSBmb3IgdGhlIHJpZ2h0IGJ1dHRvbiAoYXNzdW1pbmcgYSByaWdodC1oYW5kZWQgbW91c2UpXG5cbiAgY29uc3QgRXZlbnQgPSB7XG4gICAgSElERSAgICAgICAgICAgICA6IGBoaWRlJHtFVkVOVF9LRVl9YCxcbiAgICBISURERU4gICAgICAgICAgIDogYGhpZGRlbiR7RVZFTlRfS0VZfWAsXG4gICAgU0hPVyAgICAgICAgICAgICA6IGBzaG93JHtFVkVOVF9LRVl9YCxcbiAgICBTSE9XTiAgICAgICAgICAgIDogYHNob3duJHtFVkVOVF9LRVl9YCxcbiAgICBDTElDSyAgICAgICAgICAgIDogYGNsaWNrJHtFVkVOVF9LRVl9YCxcbiAgICBDTElDS19EQVRBX0FQSSAgIDogYGNsaWNrJHtFVkVOVF9LRVl9JHtEQVRBX0FQSV9LRVl9YCxcbiAgICBGT0NVU0lOX0RBVEFfQVBJIDogYGZvY3VzaW4ke0VWRU5UX0tFWX0ke0RBVEFfQVBJX0tFWX1gLFxuICAgIEtFWURPV05fREFUQV9BUEkgOiBga2V5ZG93biR7RVZFTlRfS0VZfSR7REFUQV9BUElfS0VZfWBcbiAgfVxuXG4gIGNvbnN0IENsYXNzTmFtZSA9IHtcbiAgICBCQUNLRFJPUCA6ICdkcm9wZG93bi1iYWNrZHJvcCcsXG4gICAgRElTQUJMRUQgOiAnZGlzYWJsZWQnLFxuICAgIFNIT1cgICAgIDogJ3Nob3cnXG4gIH1cblxuICBjb25zdCBTZWxlY3RvciA9IHtcbiAgICBCQUNLRFJPUCAgICAgIDogJy5kcm9wZG93bi1iYWNrZHJvcCcsXG4gICAgREFUQV9UT0dHTEUgICA6ICdbZGF0YS10b2dnbGU9XCJkcm9wZG93blwiXScsXG4gICAgRk9STV9DSElMRCAgICA6ICcuZHJvcGRvd24gZm9ybScsXG4gICAgUk9MRV9NRU5VICAgICA6ICdbcm9sZT1cIm1lbnVcIl0nLFxuICAgIFJPTEVfTElTVEJPWCAgOiAnW3JvbGU9XCJsaXN0Ym94XCJdJyxcbiAgICBOQVZCQVJfTkFWICAgIDogJy5uYXZiYXItbmF2JyxcbiAgICBWSVNJQkxFX0lURU1TIDogJ1tyb2xlPVwibWVudVwiXSBsaTpub3QoLmRpc2FibGVkKSBhLCAnXG4gICAgICAgICAgICAgICAgICArICdbcm9sZT1cImxpc3Rib3hcIl0gbGk6bm90KC5kaXNhYmxlZCkgYSdcbiAgfVxuXG5cbiAgLyoqXG4gICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgKiBDbGFzcyBEZWZpbml0aW9uXG4gICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgKi9cblxuICBjbGFzcyBEcm9wZG93biB7XG5cbiAgICBjb25zdHJ1Y3RvcihlbGVtZW50KSB7XG4gICAgICB0aGlzLl9lbGVtZW50ID0gZWxlbWVudFxuXG4gICAgICB0aGlzLl9hZGRFdmVudExpc3RlbmVycygpXG4gICAgfVxuXG5cbiAgICAvLyBnZXR0ZXJzXG5cbiAgICBzdGF0aWMgZ2V0IFZFUlNJT04oKSB7XG4gICAgICByZXR1cm4gVkVSU0lPTlxuICAgIH1cblxuXG4gICAgLy8gcHVibGljXG5cbiAgICB0b2dnbGUoKSB7XG4gICAgICBpZiAodGhpcy5kaXNhYmxlZCB8fCAkKHRoaXMpLmhhc0NsYXNzKENsYXNzTmFtZS5ESVNBQkxFRCkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHBhcmVudCAgID0gRHJvcGRvd24uX2dldFBhcmVudEZyb21FbGVtZW50KHRoaXMpXG4gICAgICBjb25zdCBpc0FjdGl2ZSA9ICQocGFyZW50KS5oYXNDbGFzcyhDbGFzc05hbWUuU0hPVylcblxuICAgICAgRHJvcGRvd24uX2NsZWFyTWVudXMoKVxuXG4gICAgICBpZiAoaXNBY3RpdmUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9XG5cbiAgICAgIGlmICgnb250b3VjaHN0YXJ0JyBpbiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQgJiZcbiAgICAgICAgICEkKHBhcmVudCkuY2xvc2VzdChTZWxlY3Rvci5OQVZCQVJfTkFWKS5sZW5ndGgpIHtcblxuICAgICAgICAvLyBpZiBtb2JpbGUgd2UgdXNlIGEgYmFja2Ryb3AgYmVjYXVzZSBjbGljayBldmVudHMgZG9uJ3QgZGVsZWdhdGVcbiAgICAgICAgY29uc3QgZHJvcGRvd24gICAgID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JylcbiAgICAgICAgZHJvcGRvd24uY2xhc3NOYW1lID0gQ2xhc3NOYW1lLkJBQ0tEUk9QXG4gICAgICAgICQoZHJvcGRvd24pLmluc2VydEJlZm9yZSh0aGlzKVxuICAgICAgICAkKGRyb3Bkb3duKS5vbignY2xpY2snLCBEcm9wZG93bi5fY2xlYXJNZW51cylcbiAgICAgIH1cblxuICAgICAgY29uc3QgcmVsYXRlZFRhcmdldCA9IHtcbiAgICAgICAgcmVsYXRlZFRhcmdldCA6IHRoaXNcbiAgICAgIH1cbiAgICAgIGNvbnN0IHNob3dFdmVudCAgICAgPSAkLkV2ZW50KEV2ZW50LlNIT1csIHJlbGF0ZWRUYXJnZXQpXG5cbiAgICAgICQocGFyZW50KS50cmlnZ2VyKHNob3dFdmVudClcblxuICAgICAgaWYgKHNob3dFdmVudC5pc0RlZmF1bHRQcmV2ZW50ZWQoKSkge1xuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH1cblxuICAgICAgdGhpcy5mb2N1cygpXG4gICAgICB0aGlzLnNldEF0dHJpYnV0ZSgnYXJpYS1leHBhbmRlZCcsIHRydWUpXG5cbiAgICAgICQocGFyZW50KS50b2dnbGVDbGFzcyhDbGFzc05hbWUuU0hPVylcbiAgICAgICQocGFyZW50KS50cmlnZ2VyKCQuRXZlbnQoRXZlbnQuU0hPV04sIHJlbGF0ZWRUYXJnZXQpKVxuXG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG5cbiAgICBkaXNwb3NlKCkge1xuICAgICAgJC5yZW1vdmVEYXRhKHRoaXMuX2VsZW1lbnQsIERBVEFfS0VZKVxuICAgICAgJCh0aGlzLl9lbGVtZW50KS5vZmYoRVZFTlRfS0VZKVxuICAgICAgdGhpcy5fZWxlbWVudCA9IG51bGxcbiAgICB9XG5cblxuICAgIC8vIHByaXZhdGVcblxuICAgIF9hZGRFdmVudExpc3RlbmVycygpIHtcbiAgICAgICQodGhpcy5fZWxlbWVudCkub24oRXZlbnQuQ0xJQ0ssIHRoaXMudG9nZ2xlKVxuICAgIH1cblxuXG4gICAgLy8gc3RhdGljXG5cbiAgICBzdGF0aWMgX2pRdWVyeUludGVyZmFjZShjb25maWcpIHtcbiAgICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24gKCkge1xuICAgICAgICBsZXQgZGF0YSA9ICQodGhpcykuZGF0YShEQVRBX0tFWSlcblxuICAgICAgICBpZiAoIWRhdGEpIHtcbiAgICAgICAgICBkYXRhID0gbmV3IERyb3Bkb3duKHRoaXMpXG4gICAgICAgICAgJCh0aGlzKS5kYXRhKERBVEFfS0VZLCBkYXRhKVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBjb25maWcgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgaWYgKGRhdGFbY29uZmlnXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYE5vIG1ldGhvZCBuYW1lZCBcIiR7Y29uZmlnfVwiYClcbiAgICAgICAgICB9XG4gICAgICAgICAgZGF0YVtjb25maWddLmNhbGwodGhpcylcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICB9XG5cbiAgICBzdGF0aWMgX2NsZWFyTWVudXMoZXZlbnQpIHtcbiAgICAgIGlmIChldmVudCAmJiBldmVudC53aGljaCA9PT0gUklHSFRfTU9VU0VfQlVUVE9OX1dISUNIKSB7XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuXG4gICAgICBjb25zdCBiYWNrZHJvcCA9ICQoU2VsZWN0b3IuQkFDS0RST1ApWzBdXG4gICAgICBpZiAoYmFja2Ryb3ApIHtcbiAgICAgICAgYmFja2Ryb3AucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChiYWNrZHJvcClcbiAgICAgIH1cblxuICAgICAgY29uc3QgdG9nZ2xlcyA9ICQubWFrZUFycmF5KCQoU2VsZWN0b3IuREFUQV9UT0dHTEUpKVxuXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRvZ2dsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgcGFyZW50ICAgICAgICA9IERyb3Bkb3duLl9nZXRQYXJlbnRGcm9tRWxlbWVudCh0b2dnbGVzW2ldKVxuICAgICAgICBjb25zdCByZWxhdGVkVGFyZ2V0ID0ge1xuICAgICAgICAgIHJlbGF0ZWRUYXJnZXQgOiB0b2dnbGVzW2ldXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoISQocGFyZW50KS5oYXNDbGFzcyhDbGFzc05hbWUuU0hPVykpIHtcbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGV2ZW50ICYmIChldmVudC50eXBlID09PSAnY2xpY2snICYmXG4gICAgICAgICAgICAvaW5wdXR8dGV4dGFyZWEvaS50ZXN0KGV2ZW50LnRhcmdldC50YWdOYW1lKSB8fCBldmVudC50eXBlID09PSAnZm9jdXNpbicpXG4gICAgICAgICAgICAmJiAkLmNvbnRhaW5zKHBhcmVudCwgZXZlbnQudGFyZ2V0KSkge1xuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBoaWRlRXZlbnQgPSAkLkV2ZW50KEV2ZW50LkhJREUsIHJlbGF0ZWRUYXJnZXQpXG4gICAgICAgICQocGFyZW50KS50cmlnZ2VyKGhpZGVFdmVudClcbiAgICAgICAgaWYgKGhpZGVFdmVudC5pc0RlZmF1bHRQcmV2ZW50ZWQoKSkge1xuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH1cblxuICAgICAgICB0b2dnbGVzW2ldLnNldEF0dHJpYnV0ZSgnYXJpYS1leHBhbmRlZCcsICdmYWxzZScpXG5cbiAgICAgICAgJChwYXJlbnQpXG4gICAgICAgICAgLnJlbW92ZUNsYXNzKENsYXNzTmFtZS5TSE9XKVxuICAgICAgICAgIC50cmlnZ2VyKCQuRXZlbnQoRXZlbnQuSElEREVOLCByZWxhdGVkVGFyZ2V0KSlcbiAgICAgIH1cbiAgICB9XG5cbiAgICBzdGF0aWMgX2dldFBhcmVudEZyb21FbGVtZW50KGVsZW1lbnQpIHtcbiAgICAgIGxldCBwYXJlbnRcbiAgICAgIGNvbnN0IHNlbGVjdG9yID0gVXRpbC5nZXRTZWxlY3RvckZyb21FbGVtZW50KGVsZW1lbnQpXG5cbiAgICAgIGlmIChzZWxlY3Rvcikge1xuICAgICAgICBwYXJlbnQgPSAkKHNlbGVjdG9yKVswXVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gcGFyZW50IHx8IGVsZW1lbnQucGFyZW50Tm9kZVxuICAgIH1cblxuICAgIHN0YXRpYyBfZGF0YUFwaUtleWRvd25IYW5kbGVyKGV2ZW50KSB7XG4gICAgICBpZiAoIS8oMzh8NDB8Mjd8MzIpLy50ZXN0KGV2ZW50LndoaWNoKSB8fFxuICAgICAgICAgL2lucHV0fHRleHRhcmVhL2kudGVzdChldmVudC50YXJnZXQudGFnTmFtZSkpIHtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG5cbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KClcbiAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpXG5cbiAgICAgIGlmICh0aGlzLmRpc2FibGVkIHx8ICQodGhpcykuaGFzQ2xhc3MoQ2xhc3NOYW1lLkRJU0FCTEVEKSkge1xuICAgICAgICByZXR1cm5cbiAgICAgIH1cblxuICAgICAgY29uc3QgcGFyZW50ICAgPSBEcm9wZG93bi5fZ2V0UGFyZW50RnJvbUVsZW1lbnQodGhpcylcbiAgICAgIGNvbnN0IGlzQWN0aXZlID0gJChwYXJlbnQpLmhhc0NsYXNzKENsYXNzTmFtZS5TSE9XKVxuXG4gICAgICBpZiAoIWlzQWN0aXZlICYmIGV2ZW50LndoaWNoICE9PSBFU0NBUEVfS0VZQ09ERSB8fFxuICAgICAgICAgICBpc0FjdGl2ZSAmJiBldmVudC53aGljaCA9PT0gRVNDQVBFX0tFWUNPREUpIHtcblxuICAgICAgICBpZiAoZXZlbnQud2hpY2ggPT09IEVTQ0FQRV9LRVlDT0RFKSB7XG4gICAgICAgICAgY29uc3QgdG9nZ2xlID0gJChwYXJlbnQpLmZpbmQoU2VsZWN0b3IuREFUQV9UT0dHTEUpWzBdXG4gICAgICAgICAgJCh0b2dnbGUpLnRyaWdnZXIoJ2ZvY3VzJylcbiAgICAgICAgfVxuXG4gICAgICAgICQodGhpcykudHJpZ2dlcignY2xpY2snKVxuICAgICAgICByZXR1cm5cbiAgICAgIH1cblxuICAgICAgY29uc3QgaXRlbXMgPSAkKHBhcmVudCkuZmluZChTZWxlY3Rvci5WSVNJQkxFX0lURU1TKS5nZXQoKVxuXG4gICAgICBpZiAoIWl0ZW1zLmxlbmd0aCkge1xuICAgICAgICByZXR1cm5cbiAgICAgIH1cblxuICAgICAgbGV0IGluZGV4ID0gaXRlbXMuaW5kZXhPZihldmVudC50YXJnZXQpXG5cbiAgICAgIGlmIChldmVudC53aGljaCA9PT0gQVJST1dfVVBfS0VZQ09ERSAmJiBpbmRleCA+IDApIHsgLy8gdXBcbiAgICAgICAgaW5kZXgtLVxuICAgICAgfVxuXG4gICAgICBpZiAoZXZlbnQud2hpY2ggPT09IEFSUk9XX0RPV05fS0VZQ09ERSAmJiBpbmRleCA8IGl0ZW1zLmxlbmd0aCAtIDEpIHsgLy8gZG93blxuICAgICAgICBpbmRleCsrXG4gICAgICB9XG5cbiAgICAgIGlmIChpbmRleCA8IDApIHtcbiAgICAgICAgaW5kZXggPSAwXG4gICAgICB9XG5cbiAgICAgIGl0ZW1zW2luZGV4XS5mb2N1cygpXG4gICAgfVxuXG4gIH1cblxuXG4gIC8qKlxuICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICogRGF0YSBBcGkgaW1wbGVtZW50YXRpb25cbiAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAqL1xuXG4gICQoZG9jdW1lbnQpXG4gICAgLm9uKEV2ZW50LktFWURPV05fREFUQV9BUEksIFNlbGVjdG9yLkRBVEFfVE9HR0xFLCAgRHJvcGRvd24uX2RhdGFBcGlLZXlkb3duSGFuZGxlcilcbiAgICAub24oRXZlbnQuS0VZRE9XTl9EQVRBX0FQSSwgU2VsZWN0b3IuUk9MRV9NRU5VLCAgICBEcm9wZG93bi5fZGF0YUFwaUtleWRvd25IYW5kbGVyKVxuICAgIC5vbihFdmVudC5LRVlET1dOX0RBVEFfQVBJLCBTZWxlY3Rvci5ST0xFX0xJU1RCT1gsIERyb3Bkb3duLl9kYXRhQXBpS2V5ZG93bkhhbmRsZXIpXG4gICAgLm9uKGAke0V2ZW50LkNMSUNLX0RBVEFfQVBJfSAke0V2ZW50LkZPQ1VTSU5fREFUQV9BUEl9YCwgRHJvcGRvd24uX2NsZWFyTWVudXMpXG4gICAgLm9uKEV2ZW50LkNMSUNLX0RBVEFfQVBJLCBTZWxlY3Rvci5EQVRBX1RPR0dMRSwgRHJvcGRvd24ucHJvdG90eXBlLnRvZ2dsZSlcbiAgICAub24oRXZlbnQuQ0xJQ0tfREFUQV9BUEksIFNlbGVjdG9yLkZPUk1fQ0hJTEQsIChlKSA9PiB7XG4gICAgICBlLnN0b3BQcm9wYWdhdGlvbigpXG4gICAgfSlcblxuXG4gIC8qKlxuICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICogalF1ZXJ5XG4gICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgKi9cblxuICAkLmZuW05BTUVdICAgICAgICAgICAgID0gRHJvcGRvd24uX2pRdWVyeUludGVyZmFjZVxuICAkLmZuW05BTUVdLkNvbnN0cnVjdG9yID0gRHJvcGRvd25cbiAgJC5mbltOQU1FXS5ub0NvbmZsaWN0ICA9IGZ1bmN0aW9uICgpIHtcbiAgICAkLmZuW05BTUVdID0gSlFVRVJZX05PX0NPTkZMSUNUXG4gICAgcmV0dXJuIERyb3Bkb3duLl9qUXVlcnlJbnRlcmZhY2VcbiAgfVxuXG4gIHJldHVybiBEcm9wZG93blxuXG59KShqUXVlcnkpXG5cbmV4cG9ydCBkZWZhdWx0IERyb3Bkb3duXG4iLCIvLyBhbGxvdyB0aGlzIHRvIGJlIHNldCBmcm9tIG91dHNpZGUgb2YgdGhpcyBzY3JpcHQsIGUuZy4gZnJvbSB0aGUgYmFja2VuZFxuY29uc3QgYXBpID0gd2luZG93WydoZWxsb3NwZWNpYWwnXSB8fCB7XG4gICdvcHRzJzoge1xuICAgICdkZW1vJzogZmFsc2VcbiAgfVxufTtcblxuZXhwb3J0IGRlZmF1bHQgd2luZG93WydoZWxsb3NwZWNpYWwnXSA9IGFwaTtcbiIsImltcG9ydCBhcGkgZnJvbSAnLi9hcGknO1xuXG4vKipcbiAqIEdldCBsYW5nIGNvZGUgZnJvbSB1cmxcbiAqXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIGdldExhbmdGcm9tVXJsICgpIHtcbiAgY29uc3QgdXJsUGFydHMgPSBsb2NhdGlvbi5ocmVmLnNwbGl0KCcvJyk7XG4gIGNvbnN0IGxhbmdNYXAgPSB3aW5kb3cuaTE4bjtcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IHVybFBhcnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgbGV0IHVybFBhcnQgPSB1cmxQYXJ0c1tpXTtcbiAgICBpZiAobGFuZ01hcFt1cmxQYXJ0XSAmJiB1cmxQYXJ0ICE9PSAnY3VycmVudCcpIHtcbiAgICAgIHJldHVybiB1cmxQYXJ0O1xuICAgIH1cbiAgfVxuICByZXR1cm4gJ2VuJzsgLy8gZGVmYXVsdCBsYW5ndWFnZVxufVxuXG4vKipcbiAqIEdldCBpMThuIHN0cmluZyBieSBpdHMgaWRcbiAqXG4gKiBAcGFyYW0gIHtTdHJpbmd9ICBpZFxuICogQHBhcmFtICB7P1N0cmluZ30gZ2l2ZW5MYW5nXG4gKiBAcGFyYW0gIHs/U3RyaW5nfSBmYWxsYmFja1xuICogQHJldHVybiB7U3RyaW5nfVxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0STE4biAoaWQsIGdpdmVuTGFuZywgZmFsbGJhY2spIHtcbiAgY29uc3QgaTE4biA9IHdpbmRvdy5pMThuO1xuICBjb25zdCBsYW5nID0gZ2l2ZW5MYW5nIHx8IGkxOG5bJ2N1cnJlbnQnXSB8fCBnZXRMYW5nRnJvbVVybCgpO1xuICBjb25zdCBsYW5nU3RyaW5ncyA9IGkxOG5bbGFuZ107XG4gIHJldHVybiBsYW5nU3RyaW5nc1tpZF0gfHwgZmFsbGJhY2sgfHwgJyc7XG59XG5cbmFwaVsnZ2V0STE4biddID0gZ2V0STE4bjtcbiIsImltcG9ydCBhcGkgZnJvbSAnLi9hcGknO1xuaW1wb3J0IHsgZ2V0STE4biB9IGZyb20gJy4vaTE4bic7XG5cbi8qKlxuICogQW5hdG9teSBvZiBhIHN0YXRlIG9iamVjdFxuICpcbiAqICh2YWx1ZXMgcHJlY2VkZWQgYnkgYSBxdWVzdGlvbiBtYXJrIGFyZSBvcHRpb25hbClcbmBgYFxue1xuICBpZDoge3N0cmluZ30sICAgICAgICAgICAgLy8gQWxsIGxvd2VyY2FzZSwgbm8gd2hpdGVzcGFjZXMuIFRoaXMgaXMgdXNlZCBpbiB0aGUgY3NzIGFzIHdlbGwuIGUuZy4gJydlZW5tYWFsJycsXG4gIGlkeDoge051bWJlcn0sICAgICAgICAgICAvLyBUaGUgaW5kZXggb2YgdGhlIHN0YXRlIGluIHRoZSBzdGF0ZXMgc3VjY2Vzc2lvbi4gZS5nLiBgMWBcbiAgdGV4dDoge3N0cmluZ30sICAgICAgICAgIC8vIFRoZSBkaXNwbGF5ZWQgdGV4dCBmb3IgdGhlIHN0YXRlLiBFLmcuIGAnRWVubWFhbC4uLidgLFxuICBkdXJhdGlvbjogez9OdW1iZXJ9LCAgICAgLy8gRHluYW1pY2FsbHkgc2V0IGJ5IHRoZSBJdGVtIGNsYXNzLCBpdCBjYW4gaGF2ZSBhIGRlZmF1bHQgdmFsdWUgdGhvdWdoXG4gIGlzTGFzdDogez9ib29sZWFufSwgICAgICAvLyBTZXQgaXQgdG8gdHJ1ZSBpZiB5b3Ugd2FudCB0byBpbmRpY2F0ZSB0aGF0IHRoaXMgc3RhdGUgaXMgdGhlIGxhc3QuIE90aGVyd2lzZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhlIGxhc3QgaXMgYWx3YXlzIGNvbnNpZGVyZWQgYCd2ZXJrb2NodCdgXG4gIGV4cGlyYXRpb25zOiB7QXJyYXk8XG4gICAgICBPYmplY3Q8XG4gICAgICAgIHBlcmNlbnQ6IHtOdW1iZXJ9LCAvLyBOdW1iZXIgdGhhdCBpbmRpY2F0ZXMgYXQgd2hpY2ggcG9pbnQgaW4gdGltZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gKGV4cHJlc3NlZCBpbiBwZXJjZW50YWdlKSB0aGlzIGV4cGlyYXRpb24gYnJlYWtwb2ludCBpcyB0cmlnZ2VyZWRcbiAgICAgICAgbmFtZToge3N0cmluZ30gICAgIC8vIEFsbCBsb3dlcmNhc2UsIG5vIHdoaXRlc3BhY2VzLiBUaGlzIGlzIHVzZWQgaW4gdGhlIGNzcyBhcyB3ZWxsLiBlLmcuIGAnYmxpbmsnYCxcbiAgICAgICAgPlxuICAgID59XG4gIFt7XG4gICAgcGVyY2VudDogNzAsXG4gICAgbmFtZTogJ2JsaW5rJ1xuICB9XVxufVxuYGBgXG4qL1xuXG4vKipcbiAqIFRoZSBgdGV4dGAgaXMgZGlzcGxheWVkIGluIHRoZSBzdGF0dXMgYmFyLlxuICpcbiAqIFRoZSBgZHVyYXRpb25gIGlzIHNldCBkeW5hbWljYWxseSwgaXQncyBoZXJlIGp1c3QgZm9yIHJlZmVyZW5jZS5cbiAqXG4gKiBUaGUgYGV4cGlyYXRpb25zYCB2YWx1ZXMgYXZhaWxhYmxlIGFyZSBmb3Igbm93OlxuICogJ2JsaW5rLCBjbG9zZSwgaHVycnksIGZpbmFsJzsgdG8gZWFjaCBvZiB0aGVtIGNvcnJlc3BvbmRcbiAqIHNvbWUgdmFyaWF0aW9ucyBhbmQgYW5pbWF0aW9uIGFwcGxpZWQgdGhyb3VnaCBjc3MuIEVhY2ggZXhwaXJhdGlvbiBtdXN0XG4gKiBkZWNsYXJlIGEgYHBlcmNlbnRgIHByb3BlcnR5IHRoYXQgaW5kaWNhdGVzIHRoZSBwZXJjZW50YWdlIGF0IHdoaWNoIHBvaW50XG4gKiBpbiB0aW1lIHRyaWdnZXIgdGhlIGV4cGlyYXRpb24gYW5pbWF0aW9uIChvciB3aGF0ZXZlciksXG4gKiBlLmcuIGEgYHBlcmNlbnRgIHZhbHVlIG9mIGA1MGAgd291bGQgdHJpZ2dlciBhdCB0aGUgMTR0aCBzZWNvbmQgZm9yIGFcbiAqIHN0YXRlIHRoYXQgbGFzdHMgMjhzXG4gKi9cbmNvbnN0IGRlZmF1bHRTdGF0ZXMgPSBbXG4gIHtcbiAgICBpZDogJ2Vlbm1hYWwnLFxuICAgIGlkeDogMCxcbiAgICB0ZXh0OiBnZXRJMThuKCdlZW5tYWFsJyksXG4gICAgZHVyYXRpb246IG51bGwsXG4gICAgZXhwaXJhdGlvbnM6IFt7XG4gICAgICBwZXJjZW50OiA3MCxcbiAgICAgIG5hbWU6ICdibGluaydcbiAgICB9XVxuICB9LCB7XG4gICAgaWQ6ICdhbmRlcm1hYWwnLFxuICAgIGlkeDogMSxcbiAgICB0ZXh0OiBnZXRJMThuKCdhbmRlcm1hYWwnKSxcbiAgICBkdXJhdGlvbjogbnVsbCxcbiAgICBleHBpcmF0aW9uczogW3tcbiAgICAgIHBlcmNlbnQ6IDUwLFxuICAgICAgbmFtZTogJ2h1cnJ5J1xuICAgIH0sIHtcbiAgICAgIHBlcmNlbnQ6IDcwLFxuICAgICAgbmFtZTogJ2JsaW5rJ1xuICAgIH0sIHtcbiAgICAgIHBlcmNlbnQ6IDkwLFxuICAgICAgbmFtZTogJ2ZpbmFsJ1xuICAgIH1dXG4gIH0sIHtcbiAgICBpZDogJ2dlYm9kZW4nLFxuICAgIGlkeDogMixcbiAgICB0ZXh0OiBnZXRJMThuKCdnZWJvZGVuJyksXG4gICAgZHVyYXRpb246IG51bGwsXG4gICAgZXhwaXJhdGlvbnM6IFt7XG4gICAgICBwZXJjZW50OiA1MCxcbiAgICAgIG5hbWU6ICdodXJyeSdcbiAgICB9LCB7XG4gICAgICBwZXJjZW50OiA3MCxcbiAgICAgIG5hbWU6ICdibGluaydcbiAgICB9LCB7XG4gICAgICBwZXJjZW50OiA5MCxcbiAgICAgIG5hbWU6ICdmaW5hbCdcbiAgICB9XVxuICB9LCB7XG4gICAgaWQ6ICdnZWJvZGVuLXRpbWVsZXNzJyxcbiAgICBpZHg6IDMsXG4gICAgdGV4dDogZ2V0STE4bignZ2Vib2Rlbi10aW1lbGVzcycpLFxuICAgIGR1cmF0aW9uOiBudWxsXG4gIH0sIHtcbiAgICBpZDogJ3ZlcmtvY2h0JyxcbiAgICBpZHg6IDQsXG4gICAgdGV4dDogZ2V0STE4bigndmVya29jaHQnKSxcbiAgICBkdXJhdGlvbjogbnVsbFxuICB9LCB7XG4gICAgaWQ6ICdiaWVkZW4nLFxuICAgIGlkeDogNSxcbiAgICB0ZXh0OiBnZXRJMThuKCdiaWVkZW4nKSxcbiAgICBkdXJhdGlvbjogbnVsbCxcbiAgICBleHBpcmF0aW9uczogW3tcbiAgICAgIHBlcmNlbnQ6IDcwLFxuICAgICAgbmFtZTogJ2JsaW5rJ1xuICAgIH1dXG4gIH0sIHtcbiAgICBpZDogJ3dpbm5lbicsXG4gICAgaWR4OiA2LFxuICAgIHRleHQ6IGdldEkxOG4oJ3dpbm5lbicpLFxuICAgIGR1cmF0aW9uOiBudWxsLFxuICAgIGV4cGlyYXRpb25zOiBbe1xuICAgICAgcGVyY2VudDogNTAsXG4gICAgICBuYW1lOiAnaHVycnknXG4gICAgfSwge1xuICAgICAgcGVyY2VudDogNzAsXG4gICAgICBuYW1lOiAnYmxpbmsnXG4gICAgfV1cbiAgfSwge1xuICAgIGlkOiAnZ2VsYWRlbicsXG4gICAgaWR4OiA3LFxuICAgIHRleHQ6IGdldEkxOG4oJ2dlbGFkZW4nKSxcbiAgICBkdXJhdGlvbjogbnVsbCxcbiAgICBleHBpcmF0aW9uczogW3tcbiAgICAgIHBlcmNlbnQ6IDcwLFxuICAgICAgbmFtZTogJ2JsaW5rJ1xuICAgIH1dXG4gIH0sIHtcbiAgICBpZDogJ2dlc2xvdGVuJyxcbiAgICBpZHg6IDgsXG4gICAgdGV4dDogZ2V0STE4bignZ2VzbG90ZW4nKSxcbiAgICBkdXJhdGlvbjogbnVsbCxcbiAgICBleHBpcmF0aW9uczogW3tcbiAgICAgIHBlcmNlbnQ6IDcwLFxuICAgICAgbmFtZTogJ2JsaW5rJ1xuICAgIH1dXG4gIH0sIHtcbiAgICBpZDogJ2NvbnRyb2xlcmVuJyxcbiAgICBpZHg6IDksXG4gICAgdGV4dDogZ2V0STE4bignY29udHJvbGVyZW4nKSxcbiAgICBkdXJhdGlvbjogbnVsbFxuICB9LCB7XG4gICAgaWQ6ICd1aXR2ZXJrb2NodCcsXG4gICAgaWR4OiAxMCxcbiAgICB0ZXh0OiBnZXRJMThuKCd1aXR2ZXJrb2NodCcpLFxuICAgIGR1cmF0aW9uOiBudWxsXG4gIH0sXG5dO1xuXG4vLyBleHBvcnQgdG8gcHVibGljIEFQSVxuYXBpWydkZWZhdWx0U3RhdGVzJ10gPSBkZWZhdWx0U3RhdGVzO1xuXG5leHBvcnQgZGVmYXVsdCBkZWZhdWx0U3RhdGVzO1xuIiwiaW1wb3J0IGFwaSBmcm9tICcuL2FwaSc7XG5cbmNvbnN0IGRlZmF1bHRDb2xvcnMgPSB7XG4gICdlZW5tYWFsJzogWycjNkRCRjUyJywgJyNCQ0Q1M0EnXSxcbiAgJ2FuZGVybWFhbCc6IFsnI0VDMjgyRScsICcjRjU4NjM5J10sXG4gICdnZWJvZGVuJzogWycjODc1NkEzJywgJyNCQzkxQzAnXSxcbiAgJ2dlYm9kZW4tdGltZWxlc3MnOiBbJyM2YjQ0ODInLCAnI2E4NzFhZCddLFxuICAndmVya29jaHQnOiBbJyNCMkIyQjInLCAnI0U2RTdFNiddLFxuICAnYmllZGVuJzogWycjMEI3MkJBJywgJyM0QTlERDYnXSxcbiAgJ3dpbm5lbic6IFsnI2FkMDA1ZCcsICdkZWVwcGluayddLFxuICAnZ2VsYWRlbic6IFsnI2EzOGQ4ZCcsICcjZTJiYWI3J10sXG4gICdnZXNsb3Rlbic6IFsnIzlkOGY4ZicsICcjZDdiZmJkJ10sXG4gICdjb250cm9sZXJlbic6IFsnIzk3OTA5MCcsICcjY2VjNGMxJ11cbn07XG5cbi8vIGV4cG9ydCB0byBwdWJsaWMgQVBJXG5hcGlbJ2RlZmF1bHRDb2xvcnMnXSA9IGRlZmF1bHRDb2xvcnM7XG5cbmV4cG9ydCBkZWZhdWx0IGRlZmF1bHRDb2xvcnM7XG4iLCIvKiFcbiAqIEhlYXZpbHkgaW5zcGlyZWQgYnlcbiAqXG4gKiBTVkcgUGllIFRpbWVyIDAuOS4xIHwgQW5kZXJzIEdyaW1zcnVkLCBncmludC5ubyB8IE1JVCBMaWNlbnNlIHwgZ2l0aHViLmNvbS9hZ3JpbXNydWQvc3ZnUGllVGltZXIuanNcbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU3ZnUGllVGltZXIge1xuXG4gIGNvbnN0cnVjdG9yIChwcm9wcykge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB0aGlzLl9lbGVtZW50ID0gcHJvcHMuZWxlbWVudDtcbiAgICB0aGlzLl9zaXplID0gNDA7XG4gICAgdGhpcy5fc3RhcnRGcm9tID0gcHJvcHMuc3RhcnRGcm9tID8gcHJvcHMuc3RhcnRGcm9tICogMTAwMDogMDsgLy8gc3RhcnRGcm9tIGlzIGdpdmVuIGluIHNlY29uZHNcbiAgICB0aGlzLl9kdXJhdGlvbiA9IHByb3BzLmR1cmF0aW9uID8gcHJvcHMuZHVyYXRpb24gKiAxMDAwIDogMTAwMDsgLy8gZHVyYXRpb24gaXMgZ2l2ZW4gaW4gc2Vjb25kc1xuICAgIHRoaXMuX2FjdHVhbER1cmF0aW9uID0gdGhpcy5fZHVyYXRpb24gLSB0aGlzLl9zdGFydEZyb207XG4gICAgdmFyIG4gPSBwcm9wcy5sb29wcztcblxuICAgIGlmICh0aGlzLnJlcSkge1xuICAgICAgdGhpcy5zdG9wKCk7XG4gICAgfVxuXG4gICAgLy8gVGhpcyBwYXJ0IG1pZ2h0IGJlIGNvbmZ1c2luZzpcbiAgICAvLyBJZiBuPT0wLCBkbyBpbmZpbml0ZSBsb29wc1xuICAgIC8vIEluIG90aGVyIGNhc2VzIHdoZXJlIG4gaXMgc2V0LCBkbyBuIGxvb3BzXG4gICAgLy8gSWYgbiBpcyBub3Qgc2V0LCBkbyAxIGxvb3BcbiAgICAvLyBEbyBpdCB0aGlzIHdheSB0byBwcmV2ZW50IG1peGluZyBuPT0wIGFuZCAhblxuICAgIG4gPSAobiA9PT0gMCkgPyAwIDogbiA/IG4gOiAxO1xuXG4gICAgdmFyIGVuZCA9IERhdGUubm93KCkgKyB0aGlzLl9hY3R1YWxEdXJhdGlvbiAqIG47XG4gICAgdmFyIHRvdGFsZHVyID0gdGhpcy5fYWN0dWFsRHVyYXRpb24gKiBuO1xuXG4gICAgLy8gRGF0ZS5ub3cgZml4IGJ5IEFyaSBGdWNocywgYWZ1Y2hzLnR1bWJsci5jb20vcG9zdC8yMzU1MDEyNDc3NC9kYXRlLW5vdy1pbi1pZThcbiAgICBEYXRlLm5vdyA9IERhdGUubm93IHx8IGZ1bmN0aW9uKCkgeyByZXR1cm4gK25ldyBEYXRlKCk7IH07XG5cbiAgICAvLyBBbmltYXRlIGZyYW1lIGJ5IGZyYW1lXG4gICAgKGZ1bmN0aW9uIGZyYW1lKCkge1xuICAgICAgdmFyIGN1cnJlbnQgPSBEYXRlLm5vdygpO1xuICAgICAgdmFyIHJlbWFpbmluZyA9IGVuZCAtIGN1cnJlbnQ7XG5cbiAgICAgIC8vIE5vdyBzZXQgcm90YXRpb24gcmF0ZVxuICAgICAgLy8gRS5nLiA1MCUgb2YgZmlyc3QgbG9vcCByZXR1cm5zIDEuNVxuICAgICAgLy8gRS5nLiA3NSUgb2Ygc2l4dGggbG9vcCByZXR1cm5zIDYuNzVcbiAgICAgIC8vIEhhcyB0byByZXR1cm4gPjAgZm9yIFNWRyB0byBiZSBkcmF3biBjb3JyZWN0bHlcbiAgICAgIC8vIElmIHlvdSBuZWVkIHRoZSBjdXJyZW50IGxvb3AsIHVzZSBNYXRoLmZsb29yKHJhdGUpXG4gICAgICB2YXIgcmF0ZSA9IG4gKyAxIC0gcmVtYWluaW5nIC8gc2VsZi5fZHVyYXRpb247XG4gICAgICAvLyB0b3RhbCByYXRlIGZvciBhIGZ1bGwgY3ljbGUgaXMgMCB0byAyXG4gICAgICByYXRlID0gcmF0ZTsvLyArICgoc2VsZi5fc3RhcnRGcm9tICogMikgLyBzZWxmLl9kdXJhdGlvbik7XG5cbiAgICAgIC8vIEFzIHJlcXVlc3RBbmltYXRpb25GcmFtZSB3aWxsIGRyYXcgd2hlbmV2ZXIgY2FwYWJsZSxcbiAgICAgIC8vIHRoZSBhbmltYXRpb24gbWlnaHQgZW5kIGJlZm9yZSBpdCByZWFjaGVzIDEwMCUuXG4gICAgICAvLyBMZXQncyBzaW11bGF0ZSBjb21wbGV0ZW5lc3Mgb24gdGhlIGxhc3QgdmlzdWFsXG4gICAgICAvLyBmcmFtZSBvZiB0aGUgbG9vcCwgcmVnYXJkbGVzcyBvZiBhY3R1YWwgcHJvZ3Jlc3NcbiAgICAgIC8vIGNvbnNvbGUubG9nKGN1cnJlbnQpXG4gICAgICBpZiAocmVtYWluaW5nIDwgNjApIHtcbiAgICAgICAgLy8gMS4wIG1pZ2h0IGJyZWFrLCBzZXQgdG8gc2xpZ2h0bHkgbG93ZXIgdGhhbiAxXG4gICAgICAgIC8vIFVwZGF0ZTogU2V0IHRvIHNsaWdodGx5IGxvd2VyIHRoYW4gbiBpbnN0ZWFkXG4gICAgICAgIHNlbGYuX2RyYXcobiAtIDAuMDAwMSk7XG4gICAgICAgIC8vIFN0b3AgYW5pbWF0aW5nIHdoZW4gd2UgcmVhY2ggbiBsb29wcyAoaWYgbiBpcyBzZXQpXG4gICAgICAgIGlmKHJlbWFpbmluZyA8IHRvdGFsZHVyICYmIG4pIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIFRvIHJldmVyc2UsIHVuY29tbWVudCB0aGlzIGxpbmVcbiAgICAgIC8vIHJhdGUgPSAzNjAgLSByYXRlO1xuXG4gICAgICAvLyBkcmF3XG4gICAgICBzZWxmLl9kcmF3KHJhdGUpO1xuICAgICAgLy8gcmVxdWVzdCBuZXh0IGZyYW1lXG4gICAgICBzZWxmLnJlcSA9IHJlcXVlc3RBbmltYXRpb25GcmFtZShmcmFtZSk7XG4gICAgfSgpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEcmF3IFNWRyBwYXRoXG4gICAqXG4gICAqIHggb24gdGhlIHJpZ2h0IHNpZGUgaXMgcG9zaXRpdmUsIHkgb24gdGhlIGJvdHRvbSBzaWRlIGlzIHBvc2l0aXZlLFxuICAgKiBvbiB0aGUgb3RoZXIgc2lkZXMgdGhleSBhcmUgbmVnYXRpdmVcbiAgICogQHBhcmFtICB7TnVtYmVyfSByYXRlXG4gICAqL1xuICBfZHJhdyAocmF0ZSkge1xuICAgIGxldCBhbmdsZSA9IDM2MCAqIHJhdGU7XG4gICAgYW5nbGUgJT0gMzYwO1xuICAgIC8vIGlmIChhbmdsZSA+PSAzNTkuOSkge1xuICAgIC8vICAgY29uc29sZS5sb2coYW5nbGUpXG4gICAgLy8gfVxuXG4gICAgbGV0IHJhZCA9IChhbmdsZSAqIE1hdGguUEkgLyAxODApO1xuICAgIGxldCBtaWQgPSAoYW5nbGUgPiAxODApID8gMSA6IDA7XG4gICAgbGV0IHggPSBNYXRoLnNpbihyYWQpICogdGhpcy5fc2l6ZTtcbiAgICBsZXQgeSA9IE1hdGguY29zKHJhZCkgKiAtdGhpcy5fc2l6ZTtcbiAgICBsZXQgc2hhcGUgPSBgTSAwIDAgdiAtJHt0aGlzLl9zaXplfSBBICR7dGhpcy5fc2l6ZX0gJHt0aGlzLl9zaXplfSAxICR7bWlkfSAxICR7eH0gJHt5fSB6YDtcblxuICAgIHRoaXMuX2VsZW1lbnQuc2V0QXR0cmlidXRlKCdkJywgc2hhcGUpO1xuICB9XG5cbiAgLyoqXG4gICAqIFN0b3AgdGhlIGFuaW1hdGlvbiBjYW5jZWwgdGhlIHJlcXVlc3QgYW5pbWF0aW9uIGZyYW1lXG4gICAqL1xuICBzdG9wICgpIHtcbiAgICB3aW5kb3cuY2FuY2VsQW5pbWF0aW9uRnJhbWUodGhpcy5fcmVxKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZXN0cm95IHRoZSBhbmltYXRpb25cbiAgICogQHJldHVybiB7W3R5cGVdfSBbZGVzY3JpcHRpb25dXG4gICAqL1xuICBkZXN0cm95ICgpIHtcbiAgICB0aGlzLnN0b3AoKTtcbiAgfVxufVxuIiwiaW1wb3J0IGFwaSBmcm9tICcuL2FwaSc7XG5pbXBvcnQgZGVmYXVsdFN0YXRlcyBmcm9tICcuL3N0YXRlcy5kZWZhdWx0cyc7XG5pbXBvcnQgZGVmYXVsdENvbG9ycyBmcm9tICcuL2NvbG9ycy5kZWZhdWx0cyc7XG5pbXBvcnQgU3ZnUGllVGltZXIgZnJvbSAnLi9zdmdQaWVUaW1lcic7XG5cbi8vIEV4YW1wbGUgdXNlIG9mIHRoZSBBUElcbi8vIChmdW5jdGlvbiAod2luZG93LCBkb2N1bWVudCwgJCwgYXBpKSB7XG4vLyAgIHZhciBteURPTW9ySnF1ZXJ5ID0gJCgnLmhzSXRlbScpWzBdO1xuXG4vLyAgIHZhciBteUl0ZW0gPSBuZXcgYXBpLkl0ZW0oe1xuLy8gICAgIGlkOiAxMCxcbi8vICAgICBlbGVtOiBteURPTW9ySnF1ZXJ5LFxuLy8gICAgIC8vIHN0YXRlOiAzLFxuLy8gICAgIG9uU3RhdGU6IGZ1bmN0aW9uIChpdGVtKSB7XG4vLyAgICAgICBjb25zb2xlLmxvZygnb25TdGF0ZSAnICsgaXRlbS5zdGF0ZS5pZCwgaXRlbSk7XG4vLyAgICAgfSxcbi8vICAgICBvbkVuZDogZnVuY3Rpb24gKGl0ZW0pIHtcbi8vICAgICAgIGNvbnNvbGUubG9nKCdBdWN0aW9uIGVuZHMhIG9uRW5kJywgaXRlbSk7XG4vLyAgICAgfSxcbi8vICAgICBvbkJpZDogZnVuY3Rpb24gKGl0ZW0pIHtcbi8vICAgICAgIGNvbnNvbGUubG9nKCdCaWQhIG9uIGl0ZW0nLCBpdGVtKTtcbi8vICAgICB9XG4vLyAgIH0pO1xuLy8gICBteUl0ZW0uc2V0U3RhdGUoMCwgMTUpO1xuLy8gICAvLyBteUl0ZW0uZGVzdHJveSgpO1xuLy8gfSkod2luZG93LCBkb2N1bWVudCwgalF1ZXJ5LCB3aW5kb3cuaGVsbG9zcGVjaWFsKTtcblxuLy8gKGZ1bmN0aW9uKHdpbmRvdywgZG9jdW1lbnQsICQsIGFwaSkge1xuLy8gICAvLyBjYWxsaW5nIHRoZSBjb250cnVjdG9yIG9yIHRoZSBzZXRTdGF0ZSBtZXRob2QgcmV0dXJuIHRoZSBpdGVtIGluc3RhbmNlXG4vLyAgIHZhciBteUl0ZW0gPSBuZXcgaGVsbG9zcGVjaWFsLkl0ZW0oe1xuLy8gICAgIGlkOiAxMixcbi8vICAgICBlbGVtOiAkKCcuaHNJdGVtJylbMF0gLy8gdGhlIGl0ZW0gZWxlbWVudCBpbiB0aGUgY2F0ZWdvcnkgcGFnZVxuLy8gICB9KS5zZXRTdGF0ZSgnZ2Vib2RlbicsIDExKTtcbi8vICAgLy8gZ3JhYiB0aGUgc3RhdGUgaW4gYSB2YXJpYWJsZSB0byB1c2UgY2xvc3VyZVxuLy8gICB2YXIgbXlTdGF0ZSA9IG15SXRlbS5zdGF0ZTtcblxuLy8gICAvLyBmYWtlIGFzeW5jIGxvYWRpbmcgb2YgYWpheCBjb250ZW50XG4vLyAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuLy8gICAgIHZhciBteUl0ZW1Qb3B1cCA9IG5ldyBoZWxsb3NwZWNpYWwuSXRlbSh7XG4vLyAgICAgICBpZDogMTIsXG4vLyAgICAgICBlbGVtOiAkKCcuaHNJdGVtJylbMV0gLy8gdGhlIGl0ZW0gZWxlbWVudCBpbiB0aGUgcG9wdXBcbi8vICAgICB9KTtcbi8vICAgICBteUl0ZW1Qb3B1cC5yZXN1bWVTdGF0ZShteVN0YXRlKTtcbi8vICAgfSwgMzAwMCk7XG5cbi8vICAgLy8gZmFrZSBhc3luYyBzb21ldGhpbmcgZWxlc2Vcbi8vICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4vLyAgICAgdmFyIG15QXN5bmNJdGVtID0gbmV3IGhlbGxvc3BlY2lhbC5JdGVtKHtcbi8vICAgICAgIGlkOiAxMixcbi8vICAgICAgIGVsZW06ICQoJy5oc0l0ZW0nKVsyXSAvLyBhbm90aGVyIGl0ZW0gZWxlbWVudFxuLy8gICAgIH0pO1xuLy8gICAgIG15QXN5bmNJdGVtLnJlc3VtZVN0YXRlKG15U3RhdGUpO1xuLy8gICB9LCA1MDAwKTtcbi8vIH0pKHdpbmRvdywgZG9jdW1lbnQsIGpRdWVyeSwgd2luZG93WydoZWxsb3NwZWNpYWwnXSk7XG5cbi8qKlxuICogVGhlIEl0ZW0gY2xhc3MgZGVmYXVsdCBvcHRpb25zXG4gKiBAdHlwZSB7T2JqZWN0fVxuICovXG5jb25zdCBkZWZhdWx0T3B0cyA9IHtcbiAgLyoqIEB0eXBlIHtBcnJheX0gRGVmYXVsdCBzdGF0ZXMgKi9cbiAgc3RhdGVzOiBkZWZhdWx0U3RhdGVzLFxuICAvKiogQHR5cGUge3N0cmluZ30gYXR0cmlidXRlIG5hbWUgKi9cbiAgYXR0clN0YXRlOiAnZGF0YS1zdGF0ZScsXG4gIC8qKiBAdHlwZSB7c3RyaW5nfSBhdHRyaWJ1dGUgbmFtZSAqL1xuICBhdHRyRXhwaXJhdGlvbjogJ2RhdGEtZXhwaXJhdGlvbicsXG4gIC8qKiBAdHlwZSB7ZnVuY3Rpb24oSXRlbSl9IENhbGxiYWNrIGF0IHRoZSBlbmQgb2YgZWFjaCBzdGF0ZSAqL1xuICBvblN0YXRlOiBmdW5jdGlvbiAoKSB7fSxcbiAgLyoqIEB0eXBlIHtmdW5jdGlvbihJdGVtLCBOdW1iZXIpfSBDYWxsYmFjayBlYWNoIHNlY29uZCBvZiBhIHN0YXRlIHByb2dyZXNzaW9uICovXG4gIC8vIG9uU2Vjb25kOiBmdW5jdGlvbiAoKSB7fSxcbiAgLyoqIEB0eXBlIHtmdW5jdGlvbihJdGVtKX0gQ2FsbGJhY2sgYXQgdGhlIGVuZCBvZiB0aGUgbGFzdCBzdGF0ZSAqL1xuICBvbkVuZDogZnVuY3Rpb24gKCkge30sXG4gIC8qKiBAdHlwZSB7ZnVuY3Rpb24oSXRlbSl9IENhbGxiYWNrIGF0IGJpZCBjbGljayAqL1xuICBvbkJpZDogZnVuY3Rpb24gKCkge30sXG59XG5cbi8qKlxuICogVGhlIEl0ZW0gY2xhc3MgbmVlZHMgdG8gYmUgaW5pdGlhbGl6ZWQgb24gZG9jdW1lbnQgcmVhZHkgd2l0aCBhbiBpZCBhbmQgYVxuICogY29udGFpbmVyIGVsZW1lbnRcbiAqL1xuY2xhc3MgSXRlbSB7XG5cbiAgLyoqXG4gICAqIENvbnN0cnVjdG9yXG4gICAqIEBwYXJhbSAge09iamVjdH0gb3B0cyBDb250YWlucyBwcm9wZXJ0aWVzOlxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgJ2lkJzoge3N0cmluZ30sXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAnZWxlbSc6IHtIVE1MZWxlbWVudH0sXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAnc3RhdGUnOiB7P051bWJlcn1cbiAgICogQHJldHVybiB7SXRlbX0gICAgICAgIFRoZSBpdGVtIGluc3RhbmNlXG4gICAqL1xuICBjb25zdHJ1Y3RvciAob3B0cykge1xuICAgIGlmICh0eXBlb2Ygb3B0cy5pZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2BlbGVtYCBwcm9wZXJ0eSBpcyByZXF1aXJlZCB3aGVuIGluc3RhbnRpYXRlIGEgbmV3IEl0ZW0nKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBvcHRzLmlkID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignYGlkYCBwcm9wZXJ0eSBpcyByZXF1aXJlZCB3aGVuIGluc3RhbnRpYXRlIGEgbmV3IEl0ZW0nKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvKiogQHR5cGUge09iamVjdH0gSXRlbSBnaXZlbiBvcHRzICovXG4gICAgdGhpcy5vcHRzID0gJC5leHRlbmQoe30sIGRlZmF1bHRPcHRzLCBvcHRzKTtcblxuICAgIC8qKiBAZGVwcmVjYXRlZCAgQHR5cGUge0hUTUxlbGVtZW50fSBCYXNpYyBET00gY29udGFpbmVyIGZvciB0aGUgaXRlbSAqL1xuICAgIHRoaXMuY29udGFpbmVyID0gb3B0cy5lbGVtLmpxdWVyeSA/IG9wdHMuZWxlbVswXSA6IG9wdHMuZWxlbTtcblxuICAgIC8qKiBAdHlwZSB7alF1ZXJ5fSBCYXNpYyBET00gY29udGFpbmVyIGZvciB0aGUgaXRlbSAoalF1ZXJ5IHdyYXApICovXG4gICAgdGhpcy4kY29udGFpbmVyID0gb3B0cy5lbGVtLmpxdWVyeSA/IG9wdHMuZWxlbSA6ICQob3B0cy5lbGVtKTtcblxuICAgIC8qKiBAdHlwZSB7c3RyaW5nfSBJdGVtIGlkICovXG4gICAgdGhpcy5pZCA9IG9wdHMuaWQgfHwgdGhpcy4kY29udGFpbmVyLmF0dHIoJ2lkJyk7XG5cbiAgICAvKiogQHR5cGUge0FycmF5fSBDb250YWlucyB0aGUgcG9zc2libGUgc3RhdGVzIGZvciB0aGUgaXRlbSwgYXMgYW4gYXJyYXkgKi9cbiAgICB0aGlzLnN0YXRlcyA9IHRoaXMub3B0cy5zdGF0ZXM7XG5cbiAgICAvKiogQHR5cGUge09iamVjdH0gQ29udGFpbnMgdGhlIHBvc3NpYmxlIHN0YXRlcyBmb3IgdGhlIGl0ZW0sIGFzIGFuIG9iamVjdCAoaW5kZXhlZCBieSBpZCkgKi9cbiAgICB0aGlzLnN0YXRlc01hcCA9IHRoaXMuX2dldE9iakZyb21BcnJheSh0aGlzLm9wdHMuc3RhdGVzLCAnaWQnKTtcblxuICAgIC8qKiBAdHlwZSB7ZnVuY3Rpb24oKX0gSG9sZHMgdGhlIGludGVydmFsbGVkIHJlZmVyZW5jZSBmb3Igb25lIGN5Y2xlICovXG4gICAgdGhpcy5fY3ljbGUgPSBudWxsO1xuXG4gICAgLyoqIEB0eXBlIHtOdW1iZXJ9IElEIG9mIG9uZSBvZiB0aGUgZm91ciBzdGF0ZXMgKi9cbiAgICB0aGlzLl9pbml0aWFsU3RhdGVJZCA9IG9wdHMuc3RhdGUgfHwgdGhpcy4kY29udGFpbmVyLmF0dHIodGhpcy5vcHRzLmF0dHJTdGF0ZSk7XG5cbiAgICAvKiogQHR5cGUge0FycmF5PFN2Z1BpZVRpbWVyPn0gT25lIGFuaW1hdGlvbiBwZXIgc3ZnIGVsZW1lbnQgKi9cbiAgICB0aGlzLl9hbmltYXRpb25zID0gW107XG5cbiAgICAvLyBzZXQgRE9NIHJlbGF0ZWQgc3R1ZmZcbiAgICB0aGlzLl9iaW5kVUkoKTtcblxuICAgIC8vIGlmICh0aGlzLl9pbml0aWFsU3RhdGVJZCkge1xuICAgIC8vICAgdGhpcy5zZXRTdGF0ZSh0aGlzLl9pbml0aWFsU3RhdGVJZCk7XG4gICAgLy8gfVxuXG4gICAgLy8gY29uc29sZS5sb2coJ0l0ZW0tPmNvbnN0cnVjdG9yKCknLCB0aGlzKTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIEluaXRcbiAgICovXG4gIF9iaW5kVUkgKCkge1xuXG4gICAgLyoqIEB0eXBlIHtqUXVlcnl9IFRoZSAnQmllZCcgYnV0dG9ucyAqL1xuICAgIHRoaXMuX18kYmlkID0gdGhpcy4kY29udGFpbmVyLmZpbmQoJ1tkYXRhLWJpZF0nKTtcblxuICAgIC8qKiBAdHlwZSB7alF1ZXJ5fSAqL1xuICAgIHRoaXMuX18kcHJpY2UgPSB0aGlzLiRjb250YWluZXIuZmluZCgnW2RhdGEtcHJpY2VdJyk7XG5cbiAgICAvKiogQHR5cGUge2pRdWVyeX0gKi9cbiAgICB0aGlzLl9fJGJpZGRlciA9IHRoaXMuJGNvbnRhaW5lci5maW5kKCdbZGF0YS1iaWRkZXJdJyk7XG5cbiAgICAvKiogQHR5cGUge0FycmF5PGpRdWVyeT59ICovXG4gICAgdGhpcy5fXyRzdGF0ZVN2Z3MgPSB0aGlzLiRjb250YWluZXIuZmluZCgnW2RhdGEtc3RhdGUtc3ZnXScpO1xuXG4gICAgLyoqIEB0eXBlIHtBcnJheTxqUXVlcnk+fSAqL1xuICAgIHRoaXMuX18kc3RhdGVNc2dzID0gdGhpcy4kY29udGFpbmVyLmZpbmQoJ1tkYXRhLXN0YXRlLW1zZ10nKTtcblxuICAgIC8qKiBAdHlwZSB7QXJyYXk8alF1ZXJ5Pn0gKi9cbiAgICB0aGlzLl9fJHN0b3BzMSA9IHRoaXMuJGNvbnRhaW5lci5maW5kKCcuc3RvcDEnKTtcblxuICAgIC8qKiBAdHlwZSB7QXJyYXk8alF1ZXJ5Pn0gKi9cbiAgICB0aGlzLl9fJHN0b3BzMiA9IHRoaXMuJGNvbnRhaW5lci5maW5kKCcuc3RvcDInKTtcblxuICAgIC8vIGJpbmQgY2xpY2sgYnV0dG9uXG4gICAgdGhpcy5fXyRiaWQub24oJ2NsaWNrJywgdGhpcy5vbkJpZC5iaW5kKHRoaXMpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGQgbmV3IHN0YXRlXG4gICAqIEBwYXJhbSB7U3RhdGV9IHN0YXRlT2JqZWN0XG4gICAqL1xuICBhZGRTdGF0ZSAoc3RhdGVPYmplY3QpIHtcbiAgICBsZXQgc3RhdGVJZCA9IHN0YXRlT2JqZWN0LmlkO1xuICAgIHRoaXMuc3RhdGVzTWFwW3N0YXRlSWRdID0gc3RhdGVPYmplY3Q7XG5cbiAgICAvLyBoZXJlIHdlIGNvdWxkIG9yIHNob3VsZCBvciBwdXNoIHRoZSBuZXcgc3RhdGVcbiAgICAvLyBhdCB0aGUgc3BlY2lmaWVkIGluZGV4IGluIHRoZSBhcnJheSBidXQgSSBkb24ndCByZWFsbHlcbiAgICAvLyBzZWUgdGhlIHBvaW50IG9mIHRoaXMgYXQgdGhpcyBzdGFnZS4gV2UgdXNlIHN0YXRlIGlkc1xuICAgIC8vIG5vdyBhbnl3YXkgdG8gY2hhbmdlIHRoZSBpdGVtIHN0eWxlIHRocm91Z2ggY3NzXG4gICAgdGhpcy5zdGF0ZXMucHVzaChzdGF0ZU9iamVjdCk7XG5cbiAgICByZXR1cm4gc3RhdGVPYmplY3Q7XG4gIH1cblxuICAvKipcbiAgICogU2V0IHN0YXRlIHVwZGF0aW5nIFVJIGFuZCBydW5uaW5nIHRoZSBhbmltYXRpb25cbiAgICpcbiAgICogSXQganVzdCB1cGRhdGVzIHRoZSBzdGF0ZSBhbmltYXRpb24vY29sb3IgYW5kIHRleHQgbXNnLFxuICAgKiBlLmcuICdiaWRkaW5nLCBnb2luZyBvbmNlLCBnb2luZyB0d2ljZSwgc29sZCcsIGl0IGFsc28gYWRkcyBhbiBhdHRyXG4gICAqIG9uIHRoZSBpdGVtIGNvbnRhaW5lciBzbyB0aGF0IHdlIGNhbiB0d2VhayB0aGUgc3R5bGUgb2YgaXRlbVxuICAgKiBkaWZmZXJlbnRseSBmb3IgZWFjaCBzdGF0ZS5cbiAgICpcbiAgICogQHBhcmFtIHs/TnVtYmVyfFN0cmluZ3xTdGF0ZX0gZ2l2ZW5TdGF0ZSBUaGUgc3RhdGUgaW5kZXggYDAsMSwyLDNgLFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9yIGlkIChlLmcuICd2ZXJrb2NodCcpIG9yXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3IGN1c3RvbSBvYmplY3QgKHNlZSB0aGVcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZS5kZWZhdWx0cy5qcyB0byBzZWUgdGhlXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYW5hdG9teSBvZiBhIHN0YXRlIG9iamVjdClcbiAgICogQHBhcmFtIHs/TnVtYmVyfSAgICAgICAgICAgICAgIGR1cmF0aW9uICBUaGUgZHVyYXRpb24gaW4gc2Vjb25kc1xuICAgKiBAcGFyYW0gez9OdW1iZXJ9ICAgICAgICAgICAgICAgc3RhcnRGcm9tIFRoZSByZXN1bWluZyBwb2ludCBpbiBzZWNvbmRzXG4gICAqIEByZXR1cm4ge0l0ZW19ICAgICAgICAgICAgICAgICAgICAgICAgICAgVGhlIGl0ZW0gaW5zdGFuY2VcbiAgICovXG4gIHNldFN0YXRlIChnaXZlblN0YXRlLCBkdXJhdGlvbiwgc3RhcnRGcm9tKSB7XG4gICAgLy8gc2V0IGN1cnJlbnQgc3RhdGVcbiAgICBpZiAoJC5pc1BsYWluT2JqZWN0KGdpdmVuU3RhdGUpKSB7XG4gICAgICAvLyBpZiB3ZSBhcmUgcmVzdW1pbmcganVzdCBhc3NpZ24gdGhlIGdpdmVuIHN0YXRlXG4gICAgICBpZiAoKGdpdmVuU3RhdGUuc2Vjb25kICYmIGdpdmVuU3RhdGUuc2Vjb25kID4gMCkgfHwgc3RhcnRGcm9tKSB7XG4gICAgICAgIHRoaXMuc3RhdGUgPSBnaXZlblN0YXRlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gZWl0aGVyIGJ5IHVzaW5nIHRoZSBnaXZlbiBvYmplY3RcbiAgICAgICAgdGhpcy5zdGF0ZSA9IHRoaXMuYWRkU3RhdGUoZ2l2ZW5TdGF0ZSk7XG4gICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKHRoaXMuc3RhdGVzW2dpdmVuU3RhdGVdKSB7XG4gICAgICAvLyBvciBieSBncmFiYmluZyB0aGUgc3RhdGUgd2l0aCBpdHMgaWR4IHZhbHVlXG4gICAgICB0aGlzLnN0YXRlID0gdGhpcy5zdGF0ZXNbZ2l2ZW5TdGF0ZV07XG4gICAgfVxuICAgIGVsc2UgaWYgKHRoaXMuc3RhdGVzTWFwW2dpdmVuU3RhdGVdKSB7XG4gICAgICAvLyBvciBieSBncmFiYmluZyB0aGUgc3RhdGUgd2l0aCBpdHMgaWR4IHZhbHVlXG4gICAgICB0aGlzLnN0YXRlID0gdGhpcy5zdGF0ZXNNYXBbZ2l2ZW5TdGF0ZV07XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgLy8gb3IgYnkgZ3JhYmJpbmcgdGhlIHN0YXRlIHdpdGggdGhlIGluaXRpYWwgc3RhdGUgaWQgdmFsdWVcbiAgICAgIHRoaXMuc3RhdGUgPSB0aGlzLnN0YXRlc01hcFt0aGlzLl9pbml0aWFsU3RhdGVJZF07XG4gICAgfVxuICAgIGlmICghdGhpcy5zdGF0ZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvLyBzZXQgY3VycmVudCBzdGF0ZSBzZWNvbmRcbiAgICB0aGlzLnN0YXRlLnNlY29uZCA9IHN0YXJ0RnJvbSB8fCAwO1xuXG4gICAgLy8gc2V0IGN1cnJlbnQgc3RhdGUgZHVyYXRpb25cbiAgICBpZiAoZHVyYXRpb24pIHtcbiAgICAgIHRoaXMuc3RhdGUuZHVyYXRpb24gPSBkdXJhdGlvbjtcbiAgICB9XG4gICAgLy8gc2V0IGN5Y2xlIGR1cmF0aW9uXG4gICAgdGhpcy5fY3ljbGVEdXJhdGlvbiA9IHRoaXMuc3RhdGUuZHVyYXRpb24gLSB0aGlzLnN0YXRlLnNlY29uZDtcblxuICAgIC8vIGRpc3BsYXkgc3RhdGUgbWVzc2FnZVxuICAgIGlmICh0aGlzLl9fJHN0YXRlTXNncyAmJiB0aGlzLl9fJHN0YXRlTXNncy5sZW5ndGgpIHtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5fXyRzdGF0ZU1zZ3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdGhpcy5fXyRzdGF0ZU1zZ3NbaV0udGV4dENvbnRlbnQgPSB0aGlzLnN0YXRlLnRleHQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gZGlzcGxheSBzdGF0ZSBzdHlsZSB0aHJvdWdoIGNzc1xuICAgIHRoaXMuJGNvbnRhaW5lci5hdHRyKHRoaXMub3B0cy5hdHRyU3RhdGUsIHRoaXMuc3RhdGUuaWQpO1xuXG4gICAgbGV0IHBhbGV0dGUgPSBkZWZhdWx0Q29sb3JzW3RoaXMuc3RhdGUuaWRdO1xuICAgIGlmIChwYWxldHRlKSB7XG4gICAgICBpZiAodGhpcy5fXyRzdG9wczEgJiYgdGhpcy5fXyRzdG9wczEubGVuZ3RoKSB7XG4gICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgdGhpcy5fXyRzdG9wczEubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICB0aGlzLl9fJHN0b3BzMVtqXS5zZXRBdHRyaWJ1dGUoJ3N0b3AtY29sb3InLCBwYWxldHRlWzBdKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHRoaXMuX18kc3RvcHMyICYmIHRoaXMuX18kc3RvcHMyLmxlbmd0aCkge1xuICAgICAgICBmb3IgKGxldCBrID0gMDsgayA8IHRoaXMuX18kc3RvcHMyLmxlbmd0aDsgaysrKSB7XG4gICAgICAgICAgdGhpcy5fXyRzdG9wczJba10uc2V0QXR0cmlidXRlKCdzdG9wLWNvbG9yJywgcGFsZXR0ZVsxXSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyAuLi4gYW5kIGZpcmVzIHRoZSBhbmltYXRpb25cbiAgICB0aGlzLl9ydW5BbmltYXRpb24oKTtcbiAgICAvLyBzdGFydCB0aGUgdGltZXIuLi5cbiAgICB0aGlzLl9zdGFydEN5Y2xlKCk7XG5cbiAgICAvLyBjYWxsYmFja1xuICAgIHRoaXMub3B0cy5vblN0YXRlKHRoaXMpO1xuICAgIC8vIGNhbGxiYWNrIG9uIGxhc3Qgc3RhdGUgKCd2ZXJrb2NodCcpXG4gICAgaWYgKHRoaXMuc3RhdGUuaWQgPT09ICd2ZXJrb2NodCcgfHwgdGhpcy5zdGF0ZS5pc0xhc3QpIHtcbiAgICAgIHRoaXMub3B0cy5vbkVuZCh0aGlzKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXN1bWUgc3RhdGVcbiAgICogQHBhcmFtICB7U3RhdGV9IHN0YXRlIFRoZSBzdGF0ZSBvYmplY3RcbiAgICogQHJldHVybiB7SXRlbX0gICAgICAgIFRoZSBpdGVtIGluc3RhbmNlXG4gICAqL1xuICByZXN1bWVTdGF0ZSAoc3RhdGUpIHtcbiAgICAvLyBjcmVhdGUgYSBuZXcgc3RhdGUgb2JqZWN0IHRvIGRvbid0IGludGVyZmVyZSB3aXRoIG90aGVyIGl0ZW1zXG4gICAgLy8gc3RhdGVzXG4gICAgbGV0IG5ld1N0YXRlID0gJC5leHRlbmQoe30sIHN0YXRlKTtcbiAgICB0aGlzLnNldFN0YXRlKG5ld1N0YXRlLCBudWxsLCBzdGF0ZS5zZWNvbmQpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCBkYXRhXG4gICAqXG4gICAqIEBwYXJhbSAge09iamVjdH0gZGF0YSBEYXRhIGZyb20gc2VydmVyIHRoYXQgbmVlZCB0byB1cGRhdGUgdGhlIFVJXG4gICAqL1xuICBzZXREYXRhIChkYXRhKSB7XG4gICAgaWYgKGRhdGFbJ2N1cnJlbnRfcHJpY2UnXSkge1xuICAgICAgdGhpcy5fXyRwcmljZS50ZXh0KGRhdGFbJ2N1cnJlbnRfcHJpY2UnXSk7XG4gICAgfVxuICAgIGlmIChkYXRhWydoaWdoZXN0X2JpZGRlciddKSB7XG4gICAgICB0aGlzLl9fJGJpZGRlci50ZXh0KGRhdGFbJ2hpZ2hlc3RfYmlkZGVyJ10pO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBVc2VyIGhhcyBjbGlja2VkIGJpZFxuICAgKi9cbiAgb25CaWQgKCkge1xuICAgIHRoaXMub3B0cy5vbkJpZCh0aGlzLml0ZW0pO1xuICAgIC8vIGNvbnNvbGUubG9nKCdiaWQhIG5ld1NlY29uZHM6JywgbmV3U2Vjb25kcyk7XG4gIH1cblxuICAvKipcbiAgICogRGVzdHJveSBpdGVtIGluc3RhbmNlXG4gICAqL1xuICBkZXN0cm95ICgpIHtcbiAgICBpZiAodGhpcy5fYW5pbWF0aW9ucyAmJiB0aGlzLl9hbmltYXRpb25zLmxlbmd0aCkge1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLl9hbmltYXRpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHRoaXMuX2FuaW1hdGlvbnNbaV0uZGVzdHJveSgpO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLl9jbGVhckN5Y2xlKCk7XG4gIH1cblxuICAvKipcbiAgICogU3RhcnQgc2luZ2xlIGN5Y2xlIHRpbWVyXG4gICAqL1xuICBfY2xlYXJDeWNsZSAoKSB7XG4gICAgaWYgKHRoaXMuX2N5Y2xlKSB7XG4gICAgICB3aW5kb3cuY2xlYXJJbnRlcnZhbCh0aGlzLl9jeWNsZSk7XG4gICAgICB0aGlzLl9jeWNsZSA9IG51bGw7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFN0YXJ0IHNpbmdsZSBjeWNsZSB0aW1lclxuICAgKi9cbiAgX3N0YXJ0Q3ljbGUgKCkge1xuICAgIHRoaXMuX2NsZWFyQ3ljbGUoKTtcbiAgICB0aGlzLl9jeWNsZSA9IHdpbmRvdy5zZXRJbnRlcnZhbCh0aGlzLl9vbkN5Y2xlVGljay5iaW5kKHRoaXMpLCAxMDAwKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBPbiBzZWNvbmQgdGljaywgaXQgcnVucyBldmVyeSBzZWNvbmQgdXNpbmcgYHNldEludGVydmFsYCwgaXRcbiAgICogY29vcmRpbmF0ZXMgdGhlIGFuaW1hdGlvbiBzdGF0ZXMuXG4gICAqL1xuICBfb25DeWNsZVRpY2sgKCkge1xuICAgIC8vIG1heWJlIHRyaWdnZXIgZXhwaXJhdGlvbiBiZWhhdmlvdXJcbiAgICB0aGlzLl9tYXliZVRyaWdnZXJFeHBpcmF0aW9uKCk7XG5cbiAgICAvLyBpbmNyZW1lbnQgc2Vjb25kXG4gICAgdGhpcy5zdGF0ZS5zZWNvbmQrKztcblxuICAgIC8vIGFwaSBjYWxsYmFja1xuICAgIC8vIHRoaXMub3B0cy5vblNlY29uZCh0aGlzLnN0YXRlLnNlY29uZCwgdGhpcy5zdGF0ZSwgdGhpcyk7XG5cbiAgICBpZiAodGhpcy5zdGF0ZS5zZWNvbmQgPj0gdGhpcy5zdGF0ZS5kdXJhdGlvbikge1xuICAgICAgdGhpcy5fY2xlYXJDeWNsZSgpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgZXhwaXJhdGlvbiBhdHRyaWJ1dGUgdG8gdHJpZ2dlciBmdXJ0aGVyIGFuaW1hdGlvbnMgdGhyb3VnaCBjc3NcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IFRoZSBleHBpcmF0aW9uIG5hbWUgdG8gc2V0IG9uIHRoZSBhdHRyaWJ1dGVcbiAgICovXG4gIF91cGRhdGVVaUV4cGlyYXRpb24gKG5hbWUpIHtcbiAgICB0aGlzLiRjb250YWluZXIuYXR0cih0aGlzLm9wdHMuYXR0ckV4cGlyYXRpb24sIG5hbWUpO1xuICB9XG5cbiAgLyoqXG4gICAqIExvb3AgdGhyb3VnaCB0aGUgZXhwaXJhdGlvbiBicmVha3BvaW50cyBvZiB0aGUgZ2l2ZW4gc3RhdGVcbiAgICogYW5kIGNoZWNrIGlmIHRoZSBjdXJyZW50IHNlY29uZCBoYXMgcGFzdCB0aGUgZXhwaXJhdGlvbiBicmVha3BvaW50XG4gICAqICh3aGljaCBpcyBkZWZpbmVkIGluIHBlcmNlbnRhZ2UgYmVjYXVzZSB0aGUgc3RhdGUgZHVyYXRpb24gaXMgZHluYW1pYyxcbiAgICogc28gd2UgbmVlZCB0byBjYWxjdWxhdGUgdGhlIGJyZWFrcG9pbnQgaW4gc2Vjb25kcykuXG4gICAqL1xuICBfbWF5YmVUcmlnZ2VyRXhwaXJhdGlvbiAoKSB7XG4gICAgbGV0IGV4cGlyYXRpb25zID0gdGhpcy5zdGF0ZS5leHBpcmF0aW9ucztcbiAgICBpZiAoIWV4cGlyYXRpb25zKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gZXhwaXJhdGlvbnMgYXJyYXkgbXVzdCBiZSBzZXQgaW4gb3JkZXIgZnJvbSBsb3dlciB0byBoaWdoZXIgcGVyY2VudGFnZVxuICAgIGZvciAobGV0IGkgPSBleHBpcmF0aW9ucy5sZW5ndGg7IGktLTspIHtcbiAgICAgIGxldCBleHBpcmF0aW9uID0gZXhwaXJhdGlvbnNbaV07XG4gICAgICBsZXQgc2Vjb25kQnJlYWtwb2ludCA9ICh0aGlzLnN0YXRlLmR1cmF0aW9uIC8gMTAwKSAqIGV4cGlyYXRpb24ucGVyY2VudDtcblxuICAgICAgaWYgKHRoaXMuc3RhdGUuc2Vjb25kID4gc2Vjb25kQnJlYWtwb2ludCkge1xuICAgICAgICB0aGlzLl91cGRhdGVVaUV4cGlyYXRpb24oZXhwaXJhdGlvbi5uYW1lKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cbiAgICAvLyBvdGhlcndpc2UgcmVzZXQgdGhlIGV4cGlyYXRpb24gYXR0cmlidXRlXG4gICAgdGhpcy5fdXBkYXRlVWlFeHBpcmF0aW9uKCcnKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJdCBtYWtlcyBvbmUgZnVsbCBsb29wIHdpdGggdGhlIGdpdmVuIGR1cmF0aW9uIG9yIGJ5IHJlYWRpbmcgdGhlIGN1cnJlbnRcbiAgICogc3RhdGUgZHVyYXRpb25cbiAgICovXG4gIF9ydW5BbmltYXRpb24gKCkge1xuICAgIGlmICh0aGlzLl9hbmltYXRpb25zICYmIHRoaXMuX2FuaW1hdGlvbnMubGVuZ3RoKSB7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuX2FuaW1hdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdGhpcy5fYW5pbWF0aW9uc1tpXS5kZXN0cm95KCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gaW5pdCBhbmltYXRpb25zXG4gICAgdGhpcy5fYW5pbWF0aW9ucyA9IFtdO1xuICAgIGlmICh0aGlzLl9fJHN0YXRlU3ZncyAmJiB0aGlzLl9fJHN0YXRlU3Zncy5sZW5ndGgpIHtcbiAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgdGhpcy5fXyRzdGF0ZVN2Z3MubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgLy8gY29uc29sZS5sb2coJ3J1biBmb3IgJywgdGhpcy5fXyRzdGF0ZVN2Z3NbaV0pXG4gICAgICAgIHRoaXMuX2FuaW1hdGlvbnMucHVzaChuZXcgU3ZnUGllVGltZXIoe1xuICAgICAgICAgIGVsZW1lbnQ6IHRoaXMuX18kc3RhdGVTdmdzW2pdLFxuICAgICAgICAgIGR1cmF0aW9uOiB0aGlzLnN0YXRlLmR1cmF0aW9uLCAvLyBzZWNvbmRzXG4gICAgICAgICAgc3RhcnRGcm9tOiB0aGlzLnN0YXRlLnNlY29uZCAvLyBzZWNvbmRzXG4gICAgICAgIH0pKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogR2V0IG9iamVjdCBmcm9tIGFycmF5XG4gICAqXG4gICAqIEBwYXJhbSAge0FycmF5fSBhcnJheVxuICAgKiBAcGFyYW0gIHtzdHJpbmd9IHZhbHVlXG4gICAqIEByZXR1cm4ge09iamVjdH0gICAgICAgVGhlIGxvb2t1cCBvYmplY3RcbiAgICovXG4gIF9nZXRPYmpGcm9tQXJyYXkgKGFycmF5LCB2YWx1ZSkge1xuICAgIGxldCBsb29rdXBPYmplY3QgPSB7fTtcbiAgICBmb3IgKGxldCBpID0gMCwgbCA9IGFycmF5Lmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgbG9va3VwT2JqZWN0W2FycmF5W2ldW3ZhbHVlXV0gPSBhcnJheVtpXTtcbiAgICB9XG4gICAgcmV0dXJuIGxvb2t1cE9iamVjdDtcbiAgfVxufVxuXG4vLyBleHBvcnQgdG8gcHVibGljIEFQSVxuYXBpWydJdGVtJ10gPSBJdGVtO1xuXG5leHBvcnQgZGVmYXVsdCBJdGVtO1xuIiwiaW1wb3J0ICQgZnJvbSAnanF1ZXJ5JztcbmltcG9ydCBhcGkgZnJvbSAnLi9hcGknO1xuaW1wb3J0IEl0ZW0gZnJvbSAnLi9pdGVtJztcblxuY2xhc3MgRGVtbyB7XG5cbiAgY29uc3RydWN0b3IgKCkge1xuICAgIGNvbnN0IGhvc3QgPSB3aW5kb3cubG9jYXRpb24uaG9zdDtcbiAgICBpZiAoaG9zdCA9PT0gJ2t1dXMuZ2l0aHViLmlvJyB8fCBob3N0LnNwbGl0KCc6JylbMF0gPT09ICdsb2NhbGhvc3QnKSB7XG4gICAgICB0aGlzLmluaXQoKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogSW5pdFxuICAgKi9cbiAgaW5pdCAoKSB7XG4gICAgLyoqIEB0eXBlIHtOdW1iZXJ9IEBAZGVtb29ubHkgTWF4IHNlY29uZHMgZm9yIHRvdGFsIGxvb3Agb2YgZm91ciBzdGF0ZSAqL1xuICAgIHRoaXMuX2xvb3BNYXhTZWNvbmRzID0gMTI7XG5cbiAgICAkKGRvY3VtZW50KS5yZWFkeSh0aGlzLiRvblJlYWR5LmJpbmQodGhpcykpO1xuICB9XG5cbiAgLyoqXG4gICAqIE9uIGRvY3VtZW50IHJlYWR5XG4gICAqL1xuICAkb25SZWFkeSAoKSB7XG4gICAgLy8gdGhpcy5pbml0TW9kYWxzKCk7XG4gICAgdGhpcy5pbml0SXRlbXMoKTtcbiAgICB0aGlzLmNoZWNrb3V0KCk7XG4gIH1cblxuICAvKipcbiAgICogSW5pdGlhbGl6ZSBpdGVtc1xuICAgKi9cbiAgaW5pdEl0ZW1zICgpIHtcbiAgICAkKCcuaHNJdGVtJykuZWFjaCgoaW5kZXgsIGVsZW1lbnQpID0+IHtcbiAgICAgIGxldCBpbml0aWFsU3RhdGUgPSB1bmRlZmluZWQ7XG4gICAgICBpZiAoJChlbGVtZW50KS5oYXNDbGFzcygnYXBwSXRlbURldGFpbCcpKSB7XG4gICAgICAgIGluaXRpYWxTdGF0ZSA9ICdnZWJvZGVuJztcbiAgICAgIH1cbiAgICAgIGxldCBpdGVtID0gbmV3IEl0ZW0oe1xuICAgICAgICBpZDogaW5kZXgsXG4gICAgICAgIGVsZW06IGVsZW1lbnQsXG4gICAgICAgIC8vIHN0YXRlOiAzLFxuICAgICAgICBvblN0YXRlOiB0aGlzLl9zZXROZXh0U3RhdGUuYmluZCh0aGlzKSxcbiAgICAgICAgLy8gb25FbmQ6IHRoaXMuX29uRW5kLmJpbmQodGhpcyksXG4gICAgICB9KTtcbiAgICAgIGl0ZW0uc2V0U3RhdGUoaW5pdGlhbFN0YXRlLCB0aGlzLl9nZXRBdmVyYWdlU3RhdGVEdXJhdGlvbihpdGVtKSk7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IGF2ZXJhZ2Ugc3RhdGUgZHVyYXRpb25cbiAgICpcbiAgICogRHVyYXRpb25zIGFyZSBjYWxjdWxhdGVkIGR5bmFtaWNhbGx5IGRpdmlkaW5nIGVxdWFsbHkgdGhlIG1heCB0aW1lIGJ5IHRoZVxuICAgKiBudW1iZXIgb2Ygc3RhdGVzXG4gICAqXG4gICAqIEBwYXJhbSAge0l0ZW19ICAgaXRlbVxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9IER1cmF0aW9uIGluIHNlY29uZHNcbiAgICovXG4gIF9nZXRBdmVyYWdlU3RhdGVEdXJhdGlvbiAoaXRlbSkge1xuICAgIHJldHVybiB0aGlzLl9sb29wTWF4U2Vjb25kcyAvIGl0ZW0uc3RhdGVzLmxlbmd0aDtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgbmV4dCBzdGF0ZVxuICAgKlxuICAgKiBAcGFyYW0gIHtJdGVtfSAgIGl0ZW1cbiAgICovXG4gIF9zZXROZXh0U3RhdGUgKGl0ZW0pIHtcbiAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIC8vIGNvbnNvbGUubG9nKCdpdGVtLmlkJywgaXRlbS5zdGF0ZS5pZCwgJ2lkeCcsIGl0ZW0uc3RhdGUuaWR4KVxuICAgICAgaWYgKGl0ZW0uc3RhdGUuaWR4ID09PSBpdGVtLnN0YXRlcy5sZW5ndGggLSAxKSB7XG4gICAgICAgIGl0ZW0uc2V0U3RhdGUoMCwgdGhpcy5fZ2V0QXZlcmFnZVN0YXRlRHVyYXRpb24oaXRlbSkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaXRlbS5zZXRTdGF0ZShpdGVtLnN0YXRlLmlkeCArIDEsIHRoaXMuX2dldEF2ZXJhZ2VTdGF0ZUR1cmF0aW9uKGl0ZW0pKTtcbiAgICAgIH1cbiAgICB9LCB0aGlzLl9nZXRBdmVyYWdlU3RhdGVEdXJhdGlvbihpdGVtKSAqIDEwMDApO1xuICB9XG5cbiAgLyoqXG4gICAqIEluaXRpYWxpemUgdmFyaW91cyBtb2RhbHMsIGUuZy4gd2lubmluZyBiZXQgbW9kYWxcbiAgICovXG4gIGluaXRNb2RhbHMgKCkge1xuICAgIC8vICQoJyNoc1dpbk1vZGFsJykubW9kYWwoJ3Nob3cnKTtcbiAgICAkKCcjYXBwUGF5cmVtaW5kZXJNb2RhbCcpLm1vZGFsKCdzaG93Jyk7XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2tvdXQgZmFrZSBiZWhhdmlvdXJcbiAgICovXG4gIGNoZWNrb3V0ICgpIHtcbiAgICAvLyBicmVhYWRjcnVtYnNcbiAgICAkKCcuaHNDaGVja291dF9fYnJlYWRjcnVtYicpLm9uKCdjbGljaycsIChlKSA9PiB7XG4gICAgICBsZXQgY2hlY2tvdXQgPSB3aW5kb3cuaGVsbG9zcGVjaWFsLmNoZWNrb3V0O1xuICAgICAgY29uc3QgZWwgPSBlLnRhcmdldC5wYXJlbnROb2RlO1xuICAgICAgaWYgKGVsKSB7XG4gICAgICAgIGNvbnN0IHN0ZXAgPSAkKGVsKS5pbmRleCgpO1xuICAgICAgICBpZiAoc3RlcCA9PT0gMSkge1xuICAgICAgICAgIGlmIChjaGVja291dC5pc0Zvcm1WYWxpZCgpKSB7XG4gICAgICAgICAgICBjaGVja291dC5nb1RvU3RlcChzdGVwKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY2hlY2tvdXQuZ29Ub1N0ZXAoc3RlcCk7XG4gICAgICAgIH1cbiAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgLy8gdG8gc3RlcDJcbiAgICAkKCcuaHNDaGVja291dF9fdG9zdGVwMicpLm9uKCdjbGljaycsIGZ1bmN0aW9uIChlKSB7XG4gICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICBsZXQgY2hlY2tvdXQgPSB3aW5kb3cuaGVsbG9zcGVjaWFsLmNoZWNrb3V0O1xuICAgICAgaWYgKGNoZWNrb3V0LmlzRm9ybVZhbGlkKCkpIHtcbiAgICAgICAgY2hlY2tvdXQuZ29Ub1N0ZXAoMSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbn1cblxubGV0IGRlbW8gPSBuZXcgRGVtbygpO1xuXG4vLyBleHBvcnQgdG8gcHVibGljIEFQSVxuYXBpWydkZW1vJ10gPSBkZW1vO1xuXG5leHBvcnQgZGVmYXVsdCBkZW1vO1xuIiwiaW1wb3J0ICQgZnJvbSAnanF1ZXJ5JztcbmltcG9ydCBhcGkgZnJvbSAnLi9hcGknO1xuXG5jbGFzcyBBQnRlc3Qge1xuXG4gIGNvbnN0cnVjdG9yICgpIHtcbiAgICAvLyBib290c3RyYXBcbiAgICB0aGlzLiRvbkluaXQoKTtcbiAgICAkKGRvY3VtZW50KS5yZWFkeSh0aGlzLiRvblJlYWR5LmJpbmQodGhpcykpO1xuICB9XG5cbiAgLyoqXG4gICAqIEluaXRcbiAgICovXG4gICRvbkluaXQgKCkge1xuICAgIC8vIGNvbnNvbGUubG9nKCdhcHAuanMgaW5pdGlhbGl6ZWQnKTtcbiAgICB0aGlzLnRlc3RzID0ge1xuICAgICAgJ1N0YW5kb3V0cmVnaXN0cmF0aW9uJzoge30sXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBPbiBkb2N1bWVudCByZWFkeVxuICAgKi9cbiAgJG9uUmVhZHkgKCkge1xuICAgIC8vIHRoaXMuQUJ0ZXN0MDEoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSdW4gdGVzdFxuICAgKiBAcGFyYW0gIHtTdHJpbmd9IGlkXG4gICAqL1xuICBydW4gKGlkKSB7XG4gICAgaWYgKHRoaXMudGVzdHNbaWRdKSB7XG4gICAgICB0aGlzWyd0ZXN0JyArIGlkXSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zb2xlLmVycm9yKGBBQnRlc3Qgd2l0aCBpZCAke2lkfSBkb2VzIG5vdCBleGlzdHNgKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogVGVzdCAwMTogQUJ0ZXN0LS1zdGFuZG91dHJlZ2lzdHJhdGlvblxuICAgKi9cbiAgdGVzdFN0YW5kb3V0cmVnaXN0cmF0aW9uICgpIHtcbiAgICBjb25zdCAkaG9tZXBhZ2VDYXJkID0gJCgnI2hvbWVwYWdlUmVnaXN0ZXJDYXJkJyk7XG4gICAgY29uc3QgJGJvZHkgPSAkKCdib2R5Jyk7XG4gICAgaWYgKCEkaG9tZXBhZ2VDYXJkLmxlbmd0aCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAkYm9keS5hZGRDbGFzcygnQUJ0ZXN0LS1zdGFuZG91dHJlZ2lzdHJhdGlvbicpO1xuICAgIC8vIG9uIGNsaWNrIGFueXdoZXJlIHJlbW92ZSB0aGUgY2xhc3NcbiAgICBkb2N1bWVudC5ib2R5LmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgKCkgPT4ge1xuICAgICAgJGJvZHkucmVtb3ZlQ2xhc3MoJ0FCdGVzdC0tc3RhbmRvdXRyZWdpc3RyYXRpb24nKTtcbiAgICB9LCB0cnVlKTtcbiAgfVxufVxuXG4vLyBleHBvcnQgdG8gcHVibGljIEFQSVxuYXBpWydBQnRlc3QnXSA9IG5ldyBBQnRlc3QoKTtcbiIsImltcG9ydCAkIGZyb20gJ2pxdWVyeSc7XG5pbXBvcnQgYXBpIGZyb20gJy4vYXBpJztcblxuY2xhc3MgQ29va2llQW5ub3VuY2VtZW50IHtcblxuICBjb25zdHJ1Y3RvciAoKSB7XG4gICAgLy8gYm9vdHN0cmFwXG4gICAgdGhpcy4kb25Jbml0KCk7XG4gICAgJChkb2N1bWVudCkucmVhZHkodGhpcy4kb25SZWFkeS5iaW5kKHRoaXMpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJbml0XG4gICAqL1xuICAkb25Jbml0ICgpIHtcbiAgICAvLyBjb25zb2xlLmxvZygnYXBwLmpzIGluaXRpYWxpemVkJyk7XG4gIH1cblxuICAvKipcbiAgICogT24gZG9jdW1lbnQgcmVhZHlcbiAgICovXG4gICRvblJlYWR5ICgpIHtcbiAgICBjb25zdCBzZWxmID0gdGhpcztcblxuICAgIGNvbnN0ICRjb250YWluZXIgPSAkKCcjanMtY29va2llYW5ub3VuY2VtZW50Jyk7XG4gICAgY29uc3QgJGRpc21pc3NUcmlnZ2VycyA9ICQoJy5qcy1jb29raWVhbm5vdW5jZW1lbnQtZGlzbWlzcycpO1xuXG4gICAgaWYgKCEkY29udGFpbmVyLmxlbmd0aCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IGNvb2tpZVZhbHVlID0gdGhpcy5fcmVhZENvb2tpZSgnY29va2llYW5ub3VuY2VtZW50Jyk7XG5cbiAgICBpZiAoY29va2llVmFsdWUgIT09ICdzaG93bicpIHtcbiAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAkY29udGFpbmVyLmFkZENsYXNzKCdpbicpO1xuICAgICAgfSwgNTAwKTtcblxuICAgICAgJGRpc21pc3NUcmlnZ2Vycy5vbignY2xpY2snLCAoKSA9PiB7XG4gICAgICAgICRjb250YWluZXIucmVtb3ZlQ2xhc3MoJ2luJyk7XG4gICAgICAgIHRoaXMuX2NyZWF0ZUNvb2tpZSgnY29va2llYW5ub3VuY2VtZW50JywgJ3Nob3duJywgMzY1KTtcbiAgICAgIH0pO1xuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGNvb2tpZVxuICAgKiBAc2VlIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8yNDEwMzU5Ni8xOTM4OTcwXG4gICAqXG4gICAqIEBwYXJhbSAge1N0cmluZ30gbmFtZVxuICAgKiBAcGFyYW0gIHtNaXhlZH0gIHZhbHVlXG4gICAqIEBwYXJhbSAge051bWJlcn0gZGF5c1xuICAgKi9cbiAgX2NyZWF0ZUNvb2tpZSAobmFtZSwgdmFsdWUsIGRheXMpIHtcbiAgICB2YXIgZXhwaXJlcyA9IFwiXCI7XG4gICAgaWYgKGRheXMpIHtcbiAgICAgICAgdmFyIGRhdGUgPSBuZXcgRGF0ZSgpO1xuICAgICAgICBkYXRlLnNldFRpbWUoZGF0ZS5nZXRUaW1lKCkgKyAoZGF5cyoyNCo2MCo2MCoxMDAwKSk7XG4gICAgICAgIGV4cGlyZXMgPSBcIjsgZXhwaXJlcz1cIiArIGRhdGUudG9VVENTdHJpbmcoKTtcbiAgICB9XG4gICAgZG9jdW1lbnQuY29va2llID0gbmFtZSArIFwiPVwiICsgdmFsdWUgKyBleHBpcmVzICsgXCI7IHBhdGg9L1wiO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlYWQgY29va2llXG4gICAqIEBzZWUgaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9hLzI0MTAzNTk2LzE5Mzg5NzBcbiAgICpcbiAgICogQHBhcmFtICB7U3RyaW5nfSBuYW1lXG4gICAqIEByZXR1cm4gez9TdHJpbmd9XG4gICAqL1xuICBfcmVhZENvb2tpZSAobmFtZSkge1xuICAgIHZhciBuYW1lRVEgPSBuYW1lICsgXCI9XCI7XG4gICAgdmFyIGNhID0gZG9jdW1lbnQuY29va2llLnNwbGl0KCc7Jyk7XG4gICAgZm9yKHZhciBpPTA7aSA8IGNhLmxlbmd0aDtpKyspIHtcbiAgICAgICAgdmFyIGMgPSBjYVtpXTtcbiAgICAgICAgd2hpbGUgKGMuY2hhckF0KDApPT0nICcpIGMgPSBjLnN1YnN0cmluZygxLGMubGVuZ3RoKTtcbiAgICAgICAgaWYgKGMuaW5kZXhPZihuYW1lRVEpID09IDApIHJldHVybiBjLnN1YnN0cmluZyhuYW1lRVEubGVuZ3RoLGMubGVuZ3RoKTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBfZXJhc2VDb29raWUgKG5hbWUpIHtcbiAgICB0aGlzLl9jcmVhdGVDb29raWUobmFtZSxcIlwiLC0xKTtcbiAgfVxufVxuXG5uZXcgQ29va2llQW5ub3VuY2VtZW50KCk7XG4iLCJpbXBvcnQgJCBmcm9tICdqcXVlcnknO1xuaW1wb3J0IGFwaSBmcm9tICcuL2FwaSc7XG5cbmNsYXNzIE5hc2sge1xuXG4gIGNvbnN0cnVjdG9yICgpIHtcbiAgICB0aGlzLiRvbkluaXQoKTtcblxuICAgIC8vIGJvb3RzdHJhcFxuICAgICQoZG9jdW1lbnQpLnJlYWR5KHRoaXMuJG9uUmVhZHkuYmluZCh0aGlzKSk7XG4gIH1cblxuICAvKipcbiAgICogSW5pdFxuICAgKi9cbiAgJG9uSW5pdCAoKSB7XG4gICAgLy8gdHJ5IHRvIGltbWVkaWF0ZWx5IGhpZGUgdGhlIGNvbnRhaW5lciB0byBkb24ndCBjYXVzZSBhIGZsYXNoIG9mIFwidW5zdHlsZWRcIiBjb250ZW50XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGNvbnRhaW5lcnMgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKCduYXNrJyk7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvbnRhaW5lcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29udGFpbmVyc1tpXS5zdHlsZS5vcGFjaXR5ID0gMDtcbiAgICAgIH1cbiAgICB9IGNhdGNoKGUpIHt9XG5cbiAgICB0aGlzLl9icm93c2VyID0gdGhpcy5fZ2V0QnJvd3NlcigpO1xuICAgIHRoaXMuX21vYmlsZU9TID0gdGhpcy5fZ2V0TW9iaWxlT1MoKTtcbiAgICB0aGlzLl9wZXJtaXNzaW9uID0gdGhpcy5fZ2V0UGVybWlzc2lvbigpO1xuXG4gICAgLy8gY29uc29sZS5sb2coYE5hc2stPiRvbkluaXQ6IG1vYmlsZSBvcyBpcyAke3RoaXMuX21vYmlsZU9TfSBicm93c2VyIGRldGVjdGVkIGlzICR7dGhpcy5fYnJvd3Nlcn0sIHBlcm1pc3Npb24gaXMgJHt0aGlzLl9wZXJtaXNzaW9ufWApO1xuICB9XG5cbiAgLyoqXG4gICAqIE9uIGRvY3VtZW50IHJlYWR5XG4gICAqL1xuICAkb25SZWFkeSAoKSB7XG4gICAgY29uc3QgJGNvbnRhaW5lciA9ICQoJy5uYXNrJyk7XG5cbiAgICBpZiAoISRjb250YWluZXIubGVuZ3RoKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5fXyRjb250YWluZXIgPSAkY29udGFpbmVyO1xuXG4gICAgY29uc3QgdmlldyA9IHRoaXMuX2dldFZpZXdOYW1lKCk7XG4gICAgdGhpcy5zZXRWaWV3KHZpZXcpO1xuXG4gICAgaWYgKHZpZXcgPT09ICdyZXF1ZXN0JyB8fCB2aWV3ID09PSAncmVxdWVzdC1tb2JpbGUnKSB7XG4gICAgICB0aGlzLmFzaygpO1xuICAgIH1cblxuICAgIHRoaXMuc2V0RW52KHRoaXMuX2dldEVudk5hbWUoKSk7XG5cbiAgICB0aGlzLl9fJGNvbnRhaW5lci5hZGRDbGFzcygnbmFzay0tcmVhZHknKS5jc3MoJ29wYWNpdHknLCAxKTtcblxuICAgIC8vIEBAZGlzYWJsZWQgZm9yIG5vdywgYmVjYXVzZSBpdCB3b3VsZG4ndCB3b3JrIGFueXdheS4uLlxuICAgIC8vIEBzZWUgaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9hLzMxODY4NzA4LzE5Mzg5NzBcbiAgICAvLyAkY29udGFpbmVyLmZpbmQoJy5uYXNrX19hc2tidXR0b24nKS5jbGljaygoKSA9PiB7XG4gICAgLy8gICB0aGlzLmFzaygpXG4gICAgLy8gfSk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IGJyb3dzZXJcbiAgICpcbiAgICogYmFzZWQgb24gQGxpbmsgaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9hLzk4NTE3NjkvMTkzODk3MFxuICAgKlxuICAgKiBAcmV0dXJuIHtTdHJpbmd9XG4gICAqL1xuICBfZ2V0QnJvd3NlciAoKSB7XG4gICAgLy8gT3BlcmEgOC4wK1xuICAgIGlmICgoISF3aW5kb3cub3ByICYmICEhb3ByLmFkZG9ucykgfHwgISF3aW5kb3cub3BlcmEgfHwgbmF2aWdhdG9yLnVzZXJBZ2VudC5pbmRleE9mKCcgT1BSLycpID49IDApIHtcbiAgICAgIHJldHVybiAnb3BlcmEnO1xuICAgIH1cblxuICAgIC8vIEZpcmVmb3ggMS4wK1xuICAgIGlmICh0eXBlb2YgSW5zdGFsbFRyaWdnZXIgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICByZXR1cm4gJ2ZpcmVmb3gnO1xuICAgIH1cblxuICAgIC8vIFNhZmFyaSAzLjArIFwiW29iamVjdCBIVE1MRWxlbWVudENvbnN0cnVjdG9yXVwiXG4gICAgaWYgKC9jb25zdHJ1Y3Rvci9pLnRlc3Qod2luZG93LkhUTUxFbGVtZW50KSB8fCAoZnVuY3Rpb24gKHApIHsgcmV0dXJuIHAudG9TdHJpbmcoKSA9PT0gXCJbb2JqZWN0IFNhZmFyaVJlbW90ZU5vdGlmaWNhdGlvbl1cIjsgfSkoIXdpbmRvd1snc2FmYXJpJ10gfHwgKHR5cGVvZiBzYWZhcmkgIT09ICd1bmRlZmluZWQnICYmIHNhZmFyaS5wdXNoTm90aWZpY2F0aW9uKSkpIHtcbiAgICAgIHJldHVybiAnc2FmYXJpJztcbiAgICB9XG5cbiAgICAvLyBJbnRlcm5ldCBFeHBsb3JlciA2LTExXG4gICAgaWYgKC8qQGNjX29uIUAqL2ZhbHNlIHx8ICEhZG9jdW1lbnQuZG9jdW1lbnRNb2RlKSB7XG4gICAgICByZXR1cm4gJ2llJztcbiAgICB9XG5cbiAgICAvLyBFZGdlIDIwK1xuICAgIGlmICghIXdpbmRvdy5TdHlsZU1lZGlhKSB7XG4gICAgICByZXR1cm4gJ2VkZ2UnO1xuICAgIH1cblxuICAgIC8vIENocm9tZSAxK1xuICAgIGlmICghIXdpbmRvdy5jaHJvbWUgJiYgISF3aW5kb3cuY2hyb21lLndlYnN0b3JlKSB7XG4gICAgICByZXR1cm4gJ2Nocm9tZSc7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIERldGVybWluZSB0aGUgbW9iaWxlIG9wZXJhdGluZyBzeXN0ZW0uXG4gICAqIFRoaXMgZnVuY3Rpb24gcmV0dXJucyBvbmUgb2YgJ2lvcycsICdBbmRyb2lkJywgJ1dpbmRvd3MgUGhvbmUnLCBvciBmYWxzZS5cbiAgICpcbiAgICogQGxpbmsgaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9hLzIxNzQyMTA3LzE5Mzg5NzBcbiAgICpcbiAgICogQHJldHVybnMge1N0cmluZ3xib29sZWFufSAnd2luZG93c3xhbmRyb2lkfGlvc3xmYWxzZSdcbiAgICovXG4gIF9nZXRNb2JpbGVPUyAoKSB7XG4gICAgdmFyIHVzZXJBZ2VudCA9IG5hdmlnYXRvci51c2VyQWdlbnQgfHwgbmF2aWdhdG9yLnZlbmRvciB8fCB3aW5kb3cub3BlcmE7XG5cbiAgICAvLyBXaW5kb3dzIFBob25lIG11c3QgY29tZSBmaXJzdCBiZWNhdXNlIGl0cyBVQSBhbHNvIGNvbnRhaW5zIFwiQW5kcm9pZFwiXG4gICAgaWYgKC93aW5kb3dzIHBob25lL2kudGVzdCh1c2VyQWdlbnQpKSB7XG4gICAgICByZXR1cm4gJ3dpbmRvd3MnO1xuICAgIH1cblxuICAgIGlmICgvYW5kcm9pZC9pLnRlc3QodXNlckFnZW50KSkge1xuICAgICAgcmV0dXJuICdhbmRyb2lkJztcbiAgICB9XG5cbiAgICAvLyBpT1MgZGV0ZWN0aW9uIGZyb206IGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzkwMzk4ODUvMTc3NzEwXG4gICAgaWYgKC9pUGFkfGlQaG9uZXxpUG9kLy50ZXN0KHVzZXJBZ2VudCkgJiYgIXdpbmRvdy5NU1N0cmVhbSkge1xuICAgICAgcmV0dXJuICdpb3MnO1xuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgbm90aWZpY2F0aW9ucyBwZXJtaXNzaW9uc1xuICAgKlxuICAgKiBAcmV0dXJuIHtTdHJpbmd9ICdkZW5pZWR8Z3JhbnRlZHxkZWZhdWx0fHVuc3VwcG9ydGVkJ1xuICAgKi9cbiAgX2dldFBlcm1pc3Npb24gKCkge1xuICAgIGlmICh3aW5kb3cuTm90aWZpY2F0aW9uICYmIHdpbmRvdy5Ob3RpZmljYXRpb24ucGVybWlzc2lvbikge1xuICAgICAgcmV0dXJuIHdpbmRvdy5Ob3RpZmljYXRpb24ucGVybWlzc2lvbjtcbiAgICB9XG4gICAgcmV0dXJuICd1bnN1cHBvcnRlZCc7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHZpZXcgbmFtZVxuICAgKlxuICAgKiBWaWV3czpcbiAgICogJ2dyYW50ZWQnOiBOb3RpZmljYXRpb24gYXJlIGdyYW50ZWQgYWxyZWFkeSwgd2UgZG9uJ3QgYXNrIGFueXRoaW5nXG4gICAqICdyZXF1ZXN0JzogT24gQW5kcm9pZCBub3RpZmljYXRpb25zIGFyZSBkZW5pZWQgYnkgdGhlIHVzZXIsIHdlIGFzayB0byBlbmFibGUgdGhlbVxuICAgKiAncmVxdWVzdC1tb2JpbGUnOiBPbiBBbmRyb2lkIG5vdGlmaWNhdGlvbnMgYXJlIGRlbmllZCBieSB0aGUgdXNlciwgd2UgYXNrIHRvIGVuYWJsZSB0aGVtXG4gICAqICdhbGxvd2luZyc6IE9uIGRlc2t0b3Agbm90aWZpY2F0aW9ucyBhcmUgZGVuaWVkIGJ5IHRoZSB1c2VyLCB0aGUgYWxsb3cgYm94IGlzIG9wZW5lZFxuICAgKiAnYWxsb3dpbmctbW9iaWxlJzogT24gQW5kcm9pZCBub3RpZmljYXRpb25zIGFyZSBkZW5pZWQgYnkgdGhlIHVzZXIsIHRoZSBhbGxvdyBib3ggaXMgb3BlbmVkXG4gICAqICd0aGFua3MnOiBPbiBkZXNrdG9wIG5vdGlmaWNhdGlvbiBwZXJtaXNzaW9uIGhhcyBqdXN0IGJlZW4gZ3JhbnRlZCBieSB0aGUgdXNlclxuICAgKiAndGhhbmtzLW1vYmlsZSc6IE9uIEFuZHJvaWQgbm90aWZpY2F0aW9uIHBlcm1pc3Npb24gaGFzIGp1c3QgYmVlbiBncmFudGVkIGJ5IHRoZSB1c2VyXG4gICAqICdvdGhlcic6IERlc2t0b3AgYnJvd3NlciBvdGhlciB0aGFuIENocm9tZS4gRmlyZWZveCwgT3BlcmEsIG5vIG5vdGlmaWNhdGlvbnMgc3lzdGVtXG4gICAqICdvdGhlci1tb2JpbGUnOiBNb2JpbGUgYnJvd3NlciBvdGhlciB0aGFuIEFuZHJvaWQsIG5vIG5vdGlmaWNhdGlvbnMgc3lzdGVtXG4gICAqXG4gICAqIEBwYXJhbSAgez9TdHJpbmd9IHZpZXdGYW1pbHlcbiAgICogQHJldHVybiB7U3RyaW5nfVxuICAgKi9cbiAgIF9nZXRWaWV3TmFtZSAodmlld0ZhbWlseSkge1xuICAgIGlmICh2aWV3RmFtaWx5ID09PSAnYWxsb3dpbmcnKSB7XG4gICAgICByZXR1cm4gdGhpcy5fbW9iaWxlT1MgPyAnYWxsb3dpbmctbW9iaWxlJyA6ICdhbGxvd2luZyc7XG4gICAgfVxuICAgIGVsc2UgaWYgKHZpZXdGYW1pbHkgPT09ICd0aGFua3MnKSB7XG4gICAgICByZXR1cm4gdGhpcy5fbW9iaWxlT1MgPyAndGhhbmtzLW1vYmlsZScgOiAndGhhbmtzJztcbiAgICB9XG5cbiAgICAvLyBpZiAoWydjaHJvbWUnLCAnZmlyZWZveCcsICdvcGVyYSddLmluZGV4T2YodGhpcy5fYnJvd3NlcikgPT09IC0xKSB7XG4gICAgLy8gfVxuXG4gICAgaWYgKHRoaXMuX3Blcm1pc3Npb24gPT09ICd1bnN1cHBvcnRlZCcpIHtcbiAgICAgIHJldHVybiB0aGlzLl9tb2JpbGVPUyA/ICdvdGhlci1tb2JpbGUnIDogJ290aGVyJztcbiAgICB9XG4gICAgZWxzZSBpZiAodGhpcy5fcGVybWlzc2lvbiA9PT0gJ2RlZmF1bHQnKSB7XG4gICAgICByZXR1cm4gdGhpcy5fbW9iaWxlT1MgPyAncmVxdWVzdC1tb2JpbGUnIDogJ3JlcXVlc3QnO1xuICAgIH1cbiAgICBlbHNlIGlmICh0aGlzLl9wZXJtaXNzaW9uID09PSAnZGVuaWVkJykge1xuICAgICAgcmV0dXJuIHRoaXMuX21vYmlsZU9TID8gJ3JlcXVlc3QtbW9iaWxlJyA6ICdyZXF1ZXN0JztcbiAgICB9XG4gICAgZWxzZSBpZiAodGhpcy5fcGVybWlzc2lvbiA9PT0gJ2dyYW50ZWQnKSB7XG4gICAgICByZXR1cm4gJ2dyYW50ZWQnO1xuICAgIH1cblxuICAgIHJldHVybiAnbm9uZSc7XG4gIH1cblxuICAvKipcbiAgICogR2V0IGVudiBuYW1lXG4gICAqXG4gICAqIEByZXR1cm4ge1N0cmluZ31cbiAgICovXG4gIF9nZXRFbnZOYW1lICgpIHtcbiAgICByZXR1cm4gdGhpcy5fbW9iaWxlT1MgPT09ICdhbmRyb2lkJyA/ICdhbmRyb2lkJyA6IHRoaXMuX2Jyb3dzZXI7XG4gIH1cblxuICAvKipcbiAgICogU2V0IHZpZXcgb24gdGhlIFVJXG4gICAqXG4gICAqIEBwdWJsaWNcbiAgICogQHBhcmFtIHtTdHJpbmd9IHZpZXdcbiAgICovXG4gIHNldFZpZXcgKHZpZXcpIHtcbiAgICB0aGlzLl9fJGNvbnRhaW5lci5hdHRyKCdkYXRhLW5hc2stdmlldy1pcycsIHZpZXcpO1xuICAgIGNvbnNvbGUubG9nKGBOYXNrOiBzZXQgdmlldyBuYW1lIHRvIFwiJHt2aWV3fVwiYCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogU2V0IGVudmlyb25tZW50IG9uIHRoZSBVSVxuICAgKlxuICAgKiBAcHVibGljXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBlbnZcbiAgICovXG4gIHNldEVudiAoZW52KSB7XG4gICAgdGhpcy5fXyRjb250YWluZXIuYXR0cignZGF0YS1uYXNrLWVudi1pcycsIGVudik7XG4gICAgY29uc29sZS5sb2coYE5hc2s6IHNldCBlbnYgdG8gXCIke2Vudn1cImApO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIEFzayBmb3IgcGVybWlzc2lvblxuICAgKlxuICAgKiBAcGFyYW0gez9GdW5jdGlvbn0gY2FsbGJhY2tcbiAgICogQHB1YmxpY1xuICAgKlxuICAgKiBAcmV0dXJuIHt0aGlzfVxuICAgKi9cbiAgYXNrIChjYWxsYmFjaykge1xuICAgIGlmICh0aGlzLl9wZXJtaXNzaW9uID09PSAndW5zdXBwb3J0ZWQnKSB7XG4gICAgICBjb25zb2xlLmxvZyhgTmFzazogTm90aWZpY2F0aW9uIGFyZSBub3Qgc3VwcG9ydGVkYCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnNvbGUubG9nKGBOYXNrOiBhc2tpbmcgZm9yIHBlcm1pc3Npb25gKTtcblxuICAgIHRoaXMuc2V0Vmlldyh0aGlzLl9nZXRWaWV3TmFtZSgnYWxsb3dpbmcnKSk7XG5cbiAgICBOb3RpZmljYXRpb24ucmVxdWVzdFBlcm1pc3Npb24oKHBlcm1pc3Npb24pID0+IHtcbiAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICBjYWxsYmFjayhwZXJtaXNzaW9uKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHBlcm1pc3Npb24gPT09ICdncmFudGVkJykge1xuICAgICAgICAvLyBjb25zdCBub3RpZmljYXRpb24gPSBuZXcgTm90aWZpY2F0aW9uKCdUaGFua3MnKTtcbiAgICAgICAgdGhpcy5zZXRWaWV3KHRoaXMuX2dldFZpZXdOYW1lKCd0aGFua3MnKSk7XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChwZXJtaXNzaW9uID09PSAnZGVuaWVkJykge1xuICAgICAgICB0aGlzLnNldFZpZXcodGhpcy5fZ2V0Vmlld05hbWUoJ3JlcXVlc3QnKSk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxufVxuXG4vLyBleHBvcnQgdG8gcHVibGljIEFQSVxuYXBpWyduYXNrJ10gPSBuZXcgTmFzaygpO1xuXG5leHBvcnQgZGVmYXVsdCBOYXNrO1xuIiwiY2xhc3MgRmFxIHtcblxuICBjb25zdHJ1Y3RvciAoKSB7XG5cbiAgICAvLyBib290c3RyYXBcbiAgICB0aGlzLiRvbkluaXQoKTtcbiAgICAkKGRvY3VtZW50KS5yZWFkeSh0aGlzLiRvblJlYWR5LmJpbmQodGhpcykpO1xuICB9XG5cbiAgLyoqXG4gICAqIEluaXRcbiAgICovXG4gICRvbkluaXQgKCkge1xuICB9XG5cbiAgLyoqXG4gICAqIE9uIGRvY3VtZW50IHJlYWR5XG4gICAqL1xuICAkb25SZWFkeSAoKSB7XG4gICAgaWYgKCEkKCcjaHNGYXEnKS5sZW5ndGgpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCAkZXhwYW5kYWJsZXMgPSAkKCcuZXhwYW5kYWJsZV9fYm9keScpO1xuICAgIGNvbnN0ICRub1Jlc3VsdHMgPSAkKCcuaHNGYXFfX25vcmVzdWx0cycpO1xuICAgIGNvbnN0IGhpZ2hsaWdodE9wdHMgPSB7IGNsYXNzTmFtZTogJ2hzRmFxX19tYXJrJyB9O1xuXG4gICAgJGV4cGFuZGFibGVzLmNvbGxhcHNlKHtcbiAgICAgIHRvZ2dsZTogZmFsc2VcbiAgICB9KTtcblxuICAgICQoJyNoc0ZhcV9maWx0ZXJMaXN0JykubGl2ZUZpbHRlcignI2hzRmFxX2ZpbHRlcklucHV0JywgJy5leHBhbmRhYmxlJywge1xuICAgICAgYWZ0ZXI6IGZ1bmN0aW9uIChjb250YWlucywgY29udGFpbnNOb3QpIHtcbiAgICAgICAgY29uc3QgcXVlcnkgPSB0aGlzLnZhbHVlO1xuXG4gICAgICAgIGlmICghY29udGFpbnMubGVuZ3RoKSB7XG4gICAgICAgICAgJGV4cGFuZGFibGVzLnBhcmVudCgpLnBhcmVudCgpLnByZXYoKS5oaWRlKCk7XG4gICAgICAgICAgJG5vUmVzdWx0cy5zaG93KCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgJG5vUmVzdWx0cy5oaWRlKCk7XG4gICAgICAgICAgJGV4cGFuZGFibGVzLnBhcmVudCgpLnBhcmVudCgpLnByZXYoKS5zaG93KCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXF1ZXJ5KSB7XG4gICAgICAgICAgLy8gY29udGFpbnMuY29sbGFwc2UoJ2hpZGUnKS51bmhpZ2hsaWdodChoaWdobGlnaHRPcHRzKTtcbiAgICAgICAgICAvLyBjb250YWluc05vdC5jb2xsYXBzZSgnaGlkZScpLnVuaGlnaGxpZ2h0KGhpZ2hsaWdodE9wdHMpO1xuICAgICAgICAgICRleHBhbmRhYmxlcy5jb2xsYXBzZSgnaGlkZScpLnVuaGlnaGxpZ2h0KGhpZ2hsaWdodE9wdHMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb250YWlucy5maW5kKCcuZXhwYW5kYWJsZV9fYm9keScpLmNvbGxhcHNlKCdzaG93JylcbiAgICAgICAgICAgICAgLnVuaGlnaGxpZ2h0KGhpZ2hsaWdodE9wdHMpXG4gICAgICAgICAgICAgIC5oaWdobGlnaHQocXVlcnksIGhpZ2hsaWdodE9wdHMpO1xuXG4gICAgICAgICAgICBjb250YWluc05vdC5maW5kKCcuZXhwYW5kYWJsZV9fYm9keScpLmNvbGxhcHNlKCdoaWRlJylcbiAgICAgICAgICAgICAgLnVuaGlnaGxpZ2h0KGhpZ2hsaWdodE9wdHMpO1xuICAgICAgICAgIH0gY2F0Y2ggKGUpIHt9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcblxuICAgICQoJy5oc0ZhcV9fc2VhcmNoJykub24oJ3N1Ym1pdCcsIHRoaXMuX29uU2VhcmNoU3VibWl0KTtcbiAgICAkKCcjaHNGYXFfZmlsdGVyU3VibWl0Jykub24oJ2NsaWNrJywgdGhpcy5fb25TZWFyY2hTdWJtaXQpO1xuICB9XG5cbiAgLyoqXG4gICAqIE9uIHNlYXJjaCBzdWJtaXRcbiAgICpcbiAgICogQHBhcmFtICB7T2JqZWN0fSBlIEV2ZW50XG4gICAqL1xuICBfb25TZWFyY2hTdWJtaXQgKGUpIHtcbiAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgaWYgKCQod2luZG93KS53aWR0aCgpIDwgNjAwKSB7XG4gICAgICAvLyAkKCdodG1sLCBib2R5JykuYW5pbWF0ZSh7XG4gICAgICAvLyAgIHNjcm9sbFRvcDogJCgnLmhzRmFxX19tYXJrJykuZmlyc3QoKS5vZmZzZXQoKS50b3AgLSA3MFxuICAgICAgLy8gfSwgMzAwKTtcbiAgICAgICQoJ2h0bWwsIGJvZHknKS5zY3JvbGxUb3AoJCgnLmhzRmFxX19tYXJrJykuZmlyc3QoKS5vZmZzZXQoKS50b3AgLSA3MCk7XG4gICAgfVxuICB9XG59XG5cbm5ldyBGYXEoKTtcbiIsImltcG9ydCAkIGZyb20gJ2pxdWVyeSc7XG5pbXBvcnQgYXBpIGZyb20gJy4vYXBpJztcbi8vIGltcG9ydCAnc2xpY2stY2Fyb3VzZWwvc2xpY2svc2xpY2suanMnO1xuLy8gaW1wb3J0ICdzdGlja3kta2l0L2Rpc3Qvc3RpY2t5LWtpdCc7XG4vLyBpbXBvcnQgJ3N0aWNreS1qcy9kaXN0L3N0aWNreS5taW4nO1xuXG5jbGFzcyBJdGVtRGV0YWlsIHtcblxuICBjb25zdHJ1Y3RvciAoKSB7XG4gICAgdGhpcy4kb25Jbml0KCk7XG4gICAgJChkb2N1bWVudCkucmVhZHkodGhpcy4kb25SZWFkeS5iaW5kKHRoaXMpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJbml0XG4gICAqL1xuICAkb25Jbml0ICgpIHtcbiAgfVxuXG4gIC8qKlxuICAgKiBPbiBkb2N1bWVudCByZWFkeVxuICAgKi9cbiAgJG9uUmVhZHkgKCkge1xuICAgIHRoaXMuX18kdGh1bWJzID0gJCgnI2FwcEl0ZW1EZXRhaWxfX3RodW1icycpO1xuICAgIHRoaXMuX18kc2xpZGVyID0gJCgnI2FwcEl0ZW1EZXRhaWxfX3NsaWRlcicpO1xuICAgIHRoaXMuX18kc3RpY2t5ID0gJCgnI2FwcEl0ZW1EZXRhaWxfX21haW4tc3RpY2t5Jyk7XG5cbiAgICBpZiAodGhpcy5fXyRzbGlkZXIubGVuZ3RoICYmIHRoaXMuX18kdGh1bWJzLmxlbmd0aCkge1xuICAgICAgdGhpcy5faW5pdFNsaWRlclRodW1icygpO1xuICAgICAgdGhpcy5faW5pdFNsaWRlcigpO1xuICAgICAgJCh3aW5kb3cpLm9uKCdyZXNpemUnLCB0aGlzLl9vblJlc2l6ZVNsaWRlcnMuYmluZCh0aGlzKSk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX18kc3RpY2t5Lmxlbmd0aCkge1xuICAgICAgLy8gdGhpcy5fXyRzdGlja3kuc3RpY2tfaW5fcGFyZW50KCk7XG4gICAgICB0aGlzLl9pbml0U3RpY2t5KCk7XG4gICAgICAkKHdpbmRvdykub24oJ3Jlc2l6ZScsIHRoaXMuX29uUmVzaXplU3RpY2t5LmJpbmQodGhpcykpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBPbiByZXNpemUgc2xpZGVzIGJlaGF2aW91cnNcbiAgICovXG4gIF9vblJlc2l6ZVNsaWRlcnMgKCkge1xuICAgIC8vIG5vIHNsaWRlciBpZiB0aGVyZSBpcyBvbmx5IG9uZSBpbWFnZVxuICAgIGlmICh0aGlzLl9fJHNsaWRlci5maW5kKCdpbWcnKS5sZW5ndGggPT09IDEpIHtcbiAgICAgIHRoaXMuX18kc2xpZGVyLnNsaWNrKCd1bnNsaWNrJyk7XG4gICAgICB0aGlzLl9fJHRodW1icy5zbGljaygndW5zbGljaycpO1xuICAgIH0gZWxzZSB7XG5cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogT24gcmVzaXplIHN0aWNreSBiZWhhdmlvdXNcbiAgICovXG4gIF9vblJlc2l6ZVN0aWNreSAoKSB7XG4gICAgY29uc3Qgc2NyZWVuTGdWZXJzaW9uID0gJCh3aW5kb3cpLndpZHRoKCkgPj0gOTkyOyAvLyBAQHJlZiAkZ3JpZC1icmVha3BvaW50czogbGcsXG5cbiAgICBpZiAodGhpcy5fc3RpY2t5SW5pdGlhbGlzZWQgJiYgc2NyZWVuTGdWZXJzaW9uKSB7XG4gICAgICB0aGlzLl9fJHN0aWNreS51bnN0aWNrKCk7XG4gICAgICB0aGlzLl9zdGlja3lJbml0aWFsaXNlZCA9IGZhbHNlO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9pbml0U3RpY2t5KCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEluaXQgc3RpY2t5XG4gICAqL1xuICBfaW5pdFN0aWNreSAoKSB7XG4gICAgaWYgKHRoaXMuX3N0aWNreUluaXRpYWxpc2VkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuX18kc3RpY2t5LnN0aWNreSh7XG4gICAgICByZXNwb25zaXZlV2lkdGg6IHRydWUsXG4gICAgICBjbGFzc05hbWU6ICdpcy1zdGlja3knXG4gICAgfSk7XG4gICAgLy8gdGhpcy5fc3RpY2t5ID0gbmV3IFN0aWNreSgnI2FwcEl0ZW1EZXRhaWxfX21haW4tc3RpY2t5Jyk7XG4gICAgdGhpcy5fc3RpY2t5SW5pdGlhbGlzZWQgPSB0cnVlO1xuICB9XG5cbiAgLyoqXG4gICAqIEluaXQgc2xpZGVyIHRodW1ibmFpbHNcbiAgICovXG4gIF9pbml0U2xpZGVyVGh1bWJzICgpIHtcbiAgICBpZiAoIXRoaXMuX18kdGh1bWJzLmxlbmd0aCB8fCB0aGlzLl9zbGlkZXJUaHVtYnNJbml0aWFsaXNlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuX18kdGh1bWJzLnNsaWNrKHtcbiAgICAgIHZlcnRpY2FsOiB0cnVlLFxuICAgICAgLy8gdmVydGljYWxTd2lwaW5nOiB0cnVlLFxuICAgICAgLy8gY2VudGVyTW9kZTogc2NyZWVuTGdWZXJzaW9uLFxuICAgICAgc2xpZGVzVG9TaG93OiA4LFxuICAgICAgc2xpZGVzVG9TY3JvbGw6IDEsXG4gICAgICBhc05hdkZvcjogdGhpcy5fXyRzbGlkZXIsXG4gICAgICBmb2N1c09uU2VsZWN0OiB0cnVlLFxuICAgICAgYXJyb3dzOiBmYWxzZSxcbiAgICAgIC8vIGluZmluaXRlOiBmYWxzZSxcbiAgICAgIHJlc3BvbnNpdmU6IFt7XG4gICAgICAgIGJyZWFrcG9pbnQ6IDk5MiwgLy8gQEByZWYgJGdyaWQtYnJlYWtwb2ludHM6IGxnXG4gICAgICAgIHNldHRpbmdzOiB7XG4gICAgICAgICAgdmVydGljYWw6IGZhbHNlLFxuICAgICAgICAgIHNsaWRlc1RvU2hvdzogNSxcbiAgICAgICAgfVxuICAgICAgfV1cbiAgICB9KTtcblxuICAgIHRoaXMuX3NsaWRlclRodW1ic0luaXRpYWxpc2VkID0gdHJ1ZTtcblxuICAgIC8vIHJlbW92ZSBhY3RpdmUgY2xhc3MgZnJvbSBhbGwgdGh1bWJuYWlsIHNsaWRlc1xuICAgIHRoaXMuX18kdGh1bWJzLmZpbmQoJy5zbGljay1zbGlkZScpLnJlbW92ZUNsYXNzKCdzbGljay1hY3RpdmUnKTtcblxuICAgIC8vIHNldCBhY3RpdmUgY2xhc3MgdG8gZmlyc3QgdGh1bWJuYWlsIHNsaWRlc1xuICAgIHRoaXMuX18kdGh1bWJzLmZpbmQoJy5zbGljay1zbGlkZScpLmVxKDApLmFkZENsYXNzKCdzbGljay1hY3RpdmUnKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJbml0IHNsaWRlclxuICAgKi9cbiAgX2luaXRTbGlkZXIgKCkge1xuICAgIGlmICghdGhpcy5fXyRzbGlkZXIubGVuZ3RoIHx8ICF0aGlzLl9fJHRodW1icy5sZW5ndGggfHwgdGhpcy5fc2xpZGVySW5pdGlhbGlzZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLl9fJHNsaWRlci5zbGljayh7XG4gICAgICBzbGlkZXNUb1Nob3c6IDEsXG4gICAgICBzbGlkZXNUb1Njcm9sbDogMSxcbiAgICAgIGRvdHM6IGZhbHNlLFxuICAgICAgYXJyb3dzOiB0cnVlLFxuICAgICAgYXNOYXZGb3I6IHRoaXMuX18kdGh1bWJzXG4gICAgfSk7XG5cbiAgICB0aGlzLl9zbGlkZXJJbml0aWFsaXNlZCA9IHRydWU7XG5cbiAgICAvLyBvbiBiZWZvcmUgc2xpZGUgY2hhbmdlIG1hdGNoIGFjdGl2ZSB0aHVtYm5haWwgdG8gY3VycmVudCBzbGlkZVxuICAgIHRoaXMuX18kc2xpZGVyLm9uKCdiZWZvcmVDaGFuZ2UnLCAoZXZlbnQsIHNsaWNrLCBjdXJyZW50U2xpZGUsIG5leHRTbGlkZSkgPT4ge1xuICAgICAgdGhpcy5fXyR0aHVtYnMuZmluZCgnLnNsaWNrLXNsaWRlJykucmVtb3ZlQ2xhc3MoJ3NsaWNrLWFjdGl2ZScpO1xuICAgICAgdGhpcy5fXyR0aHVtYnMuZmluZCgnLnNsaWNrLXNsaWRlJykuZXEobmV4dFNsaWRlKS5hZGRDbGFzcygnc2xpY2stYWN0aXZlJyk7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogUmVpbml0IFVJXG4gICAqL1xuICByZWluaXRVSSAoKSB7XG4gICAgdGhpcy5faW5pdFNsaWRlcigpO1xuICAgIHRoaXMuX2luaXRTbGlkZXJUaHVtYnMoKTtcbiAgICB0aGlzLl9pbml0U3RpY2t5KCk7XG4gIH1cbn1cblxuLy8gZXhwb3J0IHRvIHB1YmxpYyBBUElcbmFwaVsnaXRlbURldGFpbCddID0gbmV3IEl0ZW1EZXRhaWwoKTtcblxuZXhwb3J0IGRlZmF1bHQgSXRlbURldGFpbDtcbiIsImltcG9ydCAkIGZyb20gJ2pxdWVyeSc7XG5cbmNvbnN0IGEgPSBuYXZpZ2F0b3IudXNlckFnZW50O1xuY29uc3QgcCA9IG5hdmlnYXRvci5wbGF0Zm9ybTtcblxuY29uc3QgYnJvd3NlcnMgPSB7XG4gICdzYWZhcmknOiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwod2luZG93LkhUTUxFbGVtZW50KS5pbmRleE9mKCdDb25zdHJ1Y3RvcicpID4gMCxcbiAgLy8gJ2Nocm9tZSc6ICEhd2luZG93LmNocm9tZSAmJiAhb3BlcmEsXG4gICdpZSc6IC8qQGNjX29uIUAqL2ZhbHNlIHx8ICEhZG9jdW1lbnQuZG9jdW1lbnRNb2RlLFxuICAvLyAnbWFjJzogcC50b1VwcGVyQ2FzZSgpLmluZGV4T2YoJ01BQycpID49IDAsXG4gIC8vICdtYWNMaWtlJzogcC5tYXRjaCgvKE1hY3xpUGhvbmV8aVBvZHxpUGFkKS9pKSA/IHRydWUgOiBmYWxzZSxcbiAgJ2lvcyc6IHAubWF0Y2goLyhpUGhvbmV8aVBvZHxpUGFkKS9pKSA/IHRydWUgOiBmYWxzZSxcbiAgLy8gJ3dpbmRvd3MnOiBwLnRvVXBwZXJDYXNlKCkuaW5kZXhPZignV0lOJykhPT0tMSxcbiAgLy8gJ2xpbnV4JzogcC50b1VwcGVyQ2FzZSgpLmluZGV4T2YoJ0xJTlVYJykhPT0tMSxcbiAgLy8gJ2FuZHJvaWQnOiAvQW5kcm9pZC9pLnRlc3QoYSksXG4gIC8vICdibGFja0JlcnJ5JzogL0JsYWNrQmVycnkvaS50ZXN0KGEpLFxuICAvLyAnaW9zJzogL2lQaG9uZXxpUGFkfGlQb2QvaS50ZXN0KGEpLFxufTtcblxuJChkb2N1bWVudCkucmVhZHkoZnVuY3Rpb24gKCkge1xuICB2YXIgJGh0bWwgPSAkKCdodG1sJyk7XG4gIGZvciAobmFtZSBpbiBicm93c2Vycykge1xuICAgIGxldCBpc0l0ID0gISFicm93c2Vyc1tuYW1lXTtcbiAgICAvLyBicm93c2Vyc1ticm93c2VyXTtcbiAgICAkaHRtbC50b2dnbGVDbGFzcyhuYW1lLCBpc0l0KTtcbiAgfVxufSk7XG5cbmV4cG9ydCBkZWZhdWx0IGJyb3dzZXJzO1xuIiwiLyoqXG4gICogdmVlLXZhbGlkYXRlIHYyLjAuMVxuICAqIChjKSAyMDE4IEFiZGVscmFobWFuIEF3YWRcbiAgKiBAbGljZW5zZSBNSVRcbiAgKi9cbi8vIFxuXG4vKipcbiAqIEdldHMgdGhlIGRhdGEgYXR0cmlidXRlLiB0aGUgbmFtZSBtdXN0IGJlIGtlYmFiLWNhc2UuXG4gKi9cbnZhciBnZXREYXRhQXR0cmlidXRlID0gZnVuY3Rpb24gKGVsLCBuYW1lKSB7IHJldHVybiBlbC5nZXRBdHRyaWJ1dGUoKFwiZGF0YS12di1cIiArIG5hbWUpKTsgfTtcblxuLyoqXG4gKiBDaGVja3MgaWYgdGhlIHZhbHVlIGlzIGVpdGhlciBudWxsIG9yIHVuZGVmaW5lZC5cbiAqL1xudmFyIGlzTnVsbE9yVW5kZWZpbmVkID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSA9PT0gbnVsbCB8fCB2YWx1ZSA9PT0gdW5kZWZpbmVkO1xufTtcblxuLyoqXG4gKiBTZXRzIHRoZSBkYXRhIGF0dHJpYnV0ZS5cbiAqL1xudmFyIHNldERhdGFBdHRyaWJ1dGUgPSBmdW5jdGlvbiAoZWwsIG5hbWUsIHZhbHVlKSB7IHJldHVybiBlbC5zZXRBdHRyaWJ1dGUoKFwiZGF0YS12di1cIiArIG5hbWUpLCB2YWx1ZSk7IH07XG5cbi8qKlxuICogQ3JlYXRlcyBhIHByb3h5IG9iamVjdCBpZiBhdmFpbGFibGUgaW4gdGhlIGVudmlyb25tZW50LlxuICovXG52YXIgY3JlYXRlUHJveHkgPSBmdW5jdGlvbiAodGFyZ2V0LCBoYW5kbGVyKSB7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gIGlmICh0eXBlb2YgUHJveHkgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuIHRhcmdldDtcbiAgfVxuXG4gIHJldHVybiBuZXcgUHJveHkodGFyZ2V0LCBoYW5kbGVyKTtcbn07XG5cbi8qKlxuICogQ3JlYXRlcyB0aGUgZGVmYXVsdCBmbGFncyBvYmplY3QuXG4gKi9cbnZhciBjcmVhdGVGbGFncyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICh7XG4gIHVudG91Y2hlZDogdHJ1ZSxcbiAgdG91Y2hlZDogZmFsc2UsXG4gIGRpcnR5OiBmYWxzZSxcbiAgcHJpc3RpbmU6IHRydWUsXG4gIHZhbGlkOiBudWxsLFxuICBpbnZhbGlkOiBudWxsLFxuICB2YWxpZGF0ZWQ6IGZhbHNlLFxuICBwZW5kaW5nOiBmYWxzZSxcbiAgcmVxdWlyZWQ6IGZhbHNlXG59KTsgfTtcblxuLyoqXG4gKiBTaGFsbG93IG9iamVjdCBjb21wYXJpc29uLlxuICovXG52YXIgaXNFcXVhbCA9IGZ1bmN0aW9uIChsaHMsIHJocykge1xuICBpZiAobGhzIGluc3RhbmNlb2YgUmVnRXhwICYmIHJocyBpbnN0YW5jZW9mIFJlZ0V4cCkge1xuICAgIHJldHVybiBpc0VxdWFsKGxocy5zb3VyY2UsIHJocy5zb3VyY2UpICYmIGlzRXF1YWwobGhzLmZsYWdzLCByaHMuZmxhZ3MpO1xuICB9XG5cbiAgaWYgKEFycmF5LmlzQXJyYXkobGhzKSAmJiBBcnJheS5pc0FycmF5KHJocykpIHtcbiAgICBpZiAobGhzLmxlbmd0aCAhPT0gcmhzLmxlbmd0aCkgeyByZXR1cm4gZmFsc2U7IH1cblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGhzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoIWlzRXF1YWwobGhzW2ldLCByaHNbaV0pKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8vIGlmIGJvdGggYXJlIG9iamVjdHMsIGNvbXBhcmUgZWFjaCBrZXkgcmVjdXJzaXZlbHkuXG4gIGlmIChpc09iamVjdChsaHMpICYmIGlzT2JqZWN0KHJocykpIHtcbiAgICByZXR1cm4gT2JqZWN0LmtleXMobGhzKS5ldmVyeShmdW5jdGlvbiAoa2V5KSB7XG4gICAgICByZXR1cm4gaXNFcXVhbChsaHNba2V5XSwgcmhzW2tleV0pO1xuICAgIH0pICYmIE9iamVjdC5rZXlzKHJocykuZXZlcnkoZnVuY3Rpb24gKGtleSkge1xuICAgICAgcmV0dXJuIGlzRXF1YWwobGhzW2tleV0sIHJoc1trZXldKTtcbiAgICB9KTtcbiAgfVxuXG4gIHJldHVybiBsaHMgPT09IHJocztcbn07XG5cbi8qKlxuICogRGV0ZXJtaW5lcyB0aGUgaW5wdXQgZmllbGQgc2NvcGUuXG4gKi9cbnZhciBnZXRTY29wZSA9IGZ1bmN0aW9uIChlbCkge1xuICB2YXIgc2NvcGUgPSBnZXREYXRhQXR0cmlidXRlKGVsLCAnc2NvcGUnKTtcbiAgaWYgKGlzTnVsbE9yVW5kZWZpbmVkKHNjb3BlKSAmJiBlbC5mb3JtKSB7XG4gICAgc2NvcGUgPSBnZXREYXRhQXR0cmlidXRlKGVsLmZvcm0sICdzY29wZScpO1xuICB9XG5cbiAgcmV0dXJuICFpc051bGxPclVuZGVmaW5lZChzY29wZSkgPyBzY29wZSA6IG51bGw7XG59O1xuXG4vKipcbiAqIEdldHMgdGhlIHZhbHVlIGluIGFuIG9iamVjdCBzYWZlbHkuXG4gKi9cbnZhciBnZXRQYXRoID0gZnVuY3Rpb24gKHBhdGgsIHRhcmdldCwgZGVmKSB7XG4gIGlmICggZGVmID09PSB2b2lkIDAgKSBkZWYgPSB1bmRlZmluZWQ7XG5cbiAgaWYgKCFwYXRoIHx8ICF0YXJnZXQpIHsgcmV0dXJuIGRlZjsgfVxuXG4gIHZhciB2YWx1ZSA9IHRhcmdldDtcbiAgcGF0aC5zcGxpdCgnLicpLmV2ZXJ5KGZ1bmN0aW9uIChwcm9wKSB7XG4gICAgaWYgKCEgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCBwcm9wKSAmJiB2YWx1ZVtwcm9wXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB2YWx1ZSA9IGRlZjtcblxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHZhbHVlID0gdmFsdWVbcHJvcF07XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSk7XG5cbiAgcmV0dXJuIHZhbHVlO1xufTtcblxuLyoqXG4gKiBDaGVja3MgaWYgcGF0aCBleGlzdHMgd2l0aGluIGFuIG9iamVjdC5cbiAqL1xudmFyIGhhc1BhdGggPSBmdW5jdGlvbiAocGF0aCwgdGFyZ2V0KSB7XG4gIHZhciBvYmogPSB0YXJnZXQ7XG4gIHJldHVybiBwYXRoLnNwbGl0KCcuJykuZXZlcnkoZnVuY3Rpb24gKHByb3ApIHtcbiAgICBpZiAoISBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBwcm9wKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIG9iaiA9IG9ialtwcm9wXTtcblxuICAgIHJldHVybiB0cnVlO1xuICB9KTtcbn07XG5cbi8qKlxuICogUGFyc2VzIGEgcnVsZSBzdHJpbmcgZXhwcmVzc2lvbi5cbiAqL1xudmFyIHBhcnNlUnVsZSA9IGZ1bmN0aW9uIChydWxlKSB7XG4gIHZhciBwYXJhbXMgPSBbXTtcbiAgdmFyIG5hbWUgPSBydWxlLnNwbGl0KCc6JylbMF07XG5cbiAgaWYgKH5ydWxlLmluZGV4T2YoJzonKSkge1xuICAgIHBhcmFtcyA9IHJ1bGUuc3BsaXQoJzonKS5zbGljZSgxKS5qb2luKCc6Jykuc3BsaXQoJywnKTtcbiAgfVxuXG4gIHJldHVybiB7IG5hbWU6IG5hbWUsIHBhcmFtczogcGFyYW1zIH07XG59O1xuXG4vKipcbiAqIERlYm91bmNlcyBhIGZ1bmN0aW9uLlxuICovXG52YXIgZGVib3VuY2UgPSBmdW5jdGlvbiAoZm4sIHdhaXQsIGltbWVkaWF0ZSkge1xuICBpZiAoIHdhaXQgPT09IHZvaWQgMCApIHdhaXQgPSAwO1xuICBpZiAoIGltbWVkaWF0ZSA9PT0gdm9pZCAwICkgaW1tZWRpYXRlID0gZmFsc2U7XG5cbiAgaWYgKHdhaXQgPT09IDApIHtcbiAgICByZXR1cm4gZm47XG4gIH1cblxuICB2YXIgdGltZW91dDtcblxuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHZhciBhcmdzID0gW10sIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgd2hpbGUgKCBsZW4tLSApIGFyZ3NbIGxlbiBdID0gYXJndW1lbnRzWyBsZW4gXTtcblxuICAgIHZhciBsYXRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRpbWVvdXQgPSBudWxsO1xuICAgICAgaWYgKCFpbW1lZGlhdGUpIHsgZm4uYXBwbHkodm9pZCAwLCBhcmdzKTsgfVxuICAgIH07XG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICB2YXIgY2FsbE5vdyA9IGltbWVkaWF0ZSAmJiAhdGltZW91dDtcbiAgICBjbGVhclRpbWVvdXQodGltZW91dCk7XG4gICAgdGltZW91dCA9IHNldFRpbWVvdXQobGF0ZXIsIHdhaXQpO1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgaWYgKGNhbGxOb3cpIHsgZm4uYXBwbHkodm9pZCAwLCBhcmdzKTsgfVxuICB9O1xufTtcblxuLyoqXG4gKiBOb3JtYWxpemVzIHRoZSBnaXZlbiBydWxlcyBleHByZXNzaW9uLlxuICovXG52YXIgbm9ybWFsaXplUnVsZXMgPSBmdW5jdGlvbiAocnVsZXMpIHtcbiAgLy8gaWYgZmFsc3kgdmFsdWUgcmV0dXJuIGFuIGVtcHR5IG9iamVjdC5cbiAgaWYgKCFydWxlcykge1xuICAgIHJldHVybiB7fTtcbiAgfVxuXG4gIGlmIChpc09iamVjdChydWxlcykpIHtcbiAgICAvLyAkRmxvd0ZpeE1lXG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKHJ1bGVzKS5yZWR1Y2UoZnVuY3Rpb24gKHByZXYsIGN1cnIpIHtcbiAgICAgIHZhciBwYXJhbXMgPSBbXTtcbiAgICAgIC8vICRGbG93Rml4TWVcbiAgICAgIGlmIChydWxlc1tjdXJyXSA9PT0gdHJ1ZSkge1xuICAgICAgICBwYXJhbXMgPSBbXTtcbiAgICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShydWxlc1tjdXJyXSkpIHtcbiAgICAgICAgcGFyYW1zID0gcnVsZXNbY3Vycl07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwYXJhbXMgPSBbcnVsZXNbY3Vycl1dO1xuICAgICAgfVxuXG4gICAgICAvLyAkRmxvd0ZpeE1lXG4gICAgICBpZiAocnVsZXNbY3Vycl0gIT09IGZhbHNlKSB7XG4gICAgICAgIHByZXZbY3Vycl0gPSBwYXJhbXM7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBwcmV2O1xuICAgIH0sIHt9KTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgcnVsZXMgIT09ICdzdHJpbmcnKSB7XG4gICAgd2FybigncnVsZXMgbXVzdCBiZSBlaXRoZXIgYSBzdHJpbmcgb3IgYW4gb2JqZWN0LicpO1xuICAgIHJldHVybiB7fTtcbiAgfVxuXG4gIHJldHVybiBydWxlcy5zcGxpdCgnfCcpLnJlZHVjZShmdW5jdGlvbiAocHJldiwgcnVsZSkge1xuICAgIHZhciBwYXJzZWRSdWxlID0gcGFyc2VSdWxlKHJ1bGUpO1xuICAgIGlmICghcGFyc2VkUnVsZS5uYW1lKSB7XG4gICAgICByZXR1cm4gcHJldjtcbiAgICB9XG5cbiAgICBwcmV2W3BhcnNlZFJ1bGUubmFtZV0gPSBwYXJzZWRSdWxlLnBhcmFtcztcbiAgICByZXR1cm4gcHJldjtcbiAgfSwge30pO1xufTtcblxuLyoqXG4gKiBFbWl0cyBhIHdhcm5pbmcgdG8gdGhlIGNvbnNvbGUuXG4gKi9cbnZhciB3YXJuID0gZnVuY3Rpb24gKG1lc3NhZ2UpIHtcbiAgY29uc29sZS53YXJuKChcIlt2ZWUtdmFsaWRhdGVdIFwiICsgbWVzc2FnZSkpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG59O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBicmFuZGVkIGVycm9yIG9iamVjdC5cbiAqL1xudmFyIGNyZWF0ZUVycm9yID0gZnVuY3Rpb24gKG1lc3NhZ2UpIHsgcmV0dXJuIG5ldyBFcnJvcigoXCJbdmVlLXZhbGlkYXRlXSBcIiArIG1lc3NhZ2UpKTsgfTtcblxuLyoqXG4gKiBDaGVja3MgaWYgdGhlIHZhbHVlIGlzIGFuIG9iamVjdC5cbiAqL1xudmFyIGlzT2JqZWN0ID0gZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gb2JqICE9PSBudWxsICYmIG9iaiAmJiB0eXBlb2Ygb2JqID09PSAnb2JqZWN0JyAmJiAhIEFycmF5LmlzQXJyYXkob2JqKTsgfTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYSBmdW5jdGlvbiBpcyBjYWxsYWJsZS5cbiAqL1xudmFyIGlzQ2FsbGFibGUgPSBmdW5jdGlvbiAoZnVuYykgeyByZXR1cm4gdHlwZW9mIGZ1bmMgPT09ICdmdW5jdGlvbic7IH07XG5cbi8qKlxuICogQ2hlY2sgaWYgZWxlbWVudCBoYXMgdGhlIGNzcyBjbGFzcyBvbiBpdC5cbiAqL1xudmFyIGhhc0NsYXNzID0gZnVuY3Rpb24gKGVsLCBjbGFzc05hbWUpIHtcbiAgaWYgKGVsLmNsYXNzTGlzdCkge1xuICAgIHJldHVybiBlbC5jbGFzc0xpc3QuY29udGFpbnMoY2xhc3NOYW1lKTtcbiAgfVxuXG4gIHJldHVybiAhIWVsLmNsYXNzTmFtZS5tYXRjaChuZXcgUmVnRXhwKChcIihcXFxcc3xeKVwiICsgY2xhc3NOYW1lICsgXCIoXFxcXHN8JClcIikpKTtcbn07XG5cbi8qKlxuICogQWRkcyB0aGUgcHJvdmlkZWQgY3NzIGNsYXNzTmFtZSB0byB0aGUgZWxlbWVudC5cbiAqL1xudmFyIGFkZENsYXNzID0gZnVuY3Rpb24gKGVsLCBjbGFzc05hbWUpIHtcbiAgaWYgKGVsLmNsYXNzTGlzdCkge1xuICAgIGVsLmNsYXNzTGlzdC5hZGQoY2xhc3NOYW1lKTtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAoIWhhc0NsYXNzKGVsLCBjbGFzc05hbWUpKSB7XG4gICAgZWwuY2xhc3NOYW1lICs9IFwiIFwiICsgY2xhc3NOYW1lO1xuICB9XG59O1xuXG4vKipcbiAqIFJlbW92ZSB0aGUgcHJvdmlkZWQgY3NzIGNsYXNzTmFtZSBmcm9tIHRoZSBlbGVtZW50LlxuICovXG52YXIgcmVtb3ZlQ2xhc3MgPSBmdW5jdGlvbiAoZWwsIGNsYXNzTmFtZSkge1xuICBpZiAoZWwuY2xhc3NMaXN0KSB7XG4gICAgZWwuY2xhc3NMaXN0LnJlbW92ZShjbGFzc05hbWUpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmIChoYXNDbGFzcyhlbCwgY2xhc3NOYW1lKSkge1xuICAgIHZhciByZWcgPSBuZXcgUmVnRXhwKChcIihcXFxcc3xeKVwiICsgY2xhc3NOYW1lICsgXCIoXFxcXHN8JClcIikpO1xuICAgIGVsLmNsYXNzTmFtZSA9IGVsLmNsYXNzTmFtZS5yZXBsYWNlKHJlZywgJyAnKTtcbiAgfVxufTtcblxuLyoqXG4gKiBBZGRzIG9yIHJlbW92ZXMgYSBjbGFzcyBuYW1lIG9uIHRoZSBpbnB1dCBkZXBlbmRpbmcgb24gdGhlIHN0YXR1cyBmbGFnLlxuICovXG52YXIgdG9nZ2xlQ2xhc3MgPSBmdW5jdGlvbiAoZWwsIGNsYXNzTmFtZSwgc3RhdHVzKSB7XG4gIGlmICghZWwgfHwgIWNsYXNzTmFtZSkgeyByZXR1cm47IH1cblxuICBpZiAoc3RhdHVzKSB7XG4gICAgcmV0dXJuIGFkZENsYXNzKGVsLCBjbGFzc05hbWUpO1xuICB9XG5cbiAgcmVtb3ZlQ2xhc3MoZWwsIGNsYXNzTmFtZSk7XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIGFuIGFycmF5LWxpa2Ugb2JqZWN0IHRvIGFycmF5LCBwcm92aWRlcyBhIHNpbXBsZSBwb2x5ZmlsbCBmb3IgQXJyYXkuZnJvbVxuICovXG52YXIgdG9BcnJheSA9IGZ1bmN0aW9uIChhcnJheUxpa2UpIHtcbiAgaWYgKGlzQ2FsbGFibGUoQXJyYXkuZnJvbSkpIHtcbiAgICByZXR1cm4gQXJyYXkuZnJvbShhcnJheUxpa2UpO1xuICB9XG5cbiAgdmFyIGFycmF5ID0gW107XG4gIHZhciBsZW5ndGggPSBhcnJheUxpa2UubGVuZ3RoO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgYXJyYXkucHVzaChhcnJheUxpa2VbaV0pO1xuICB9XG5cbiAgcmV0dXJuIGFycmF5O1xufTtcblxuLyoqXG4gKiBBc3NpZ24gcG9seWZpbGwgZnJvbSB0aGUgbWRuLlxuICovXG52YXIgYXNzaWduID0gZnVuY3Rpb24gKHRhcmdldCkge1xuICB2YXIgb3RoZXJzID0gW10sIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGggLSAxO1xuICB3aGlsZSAoIGxlbi0tID4gMCApIG90aGVyc1sgbGVuIF0gPSBhcmd1bWVudHNbIGxlbiArIDEgXTtcblxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICBpZiAoaXNDYWxsYWJsZShPYmplY3QuYXNzaWduKSkge1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduLmFwcGx5KE9iamVjdCwgWyB0YXJnZXQgXS5jb25jYXQoIG90aGVycyApKTtcbiAgfVxuXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gIGlmICh0YXJnZXQgPT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0Nhbm5vdCBjb252ZXJ0IHVuZGVmaW5lZCBvciBudWxsIHRvIG9iamVjdCcpO1xuICB9XG5cbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgdmFyIHRvID0gT2JqZWN0KHRhcmdldCk7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gIG90aGVycy5mb3JFYWNoKGZ1bmN0aW9uIChhcmcpIHtcbiAgICAvLyBTa2lwIG92ZXIgaWYgdW5kZWZpbmVkIG9yIG51bGxcbiAgICBpZiAoYXJnICE9IG51bGwpIHtcbiAgICAgIE9iamVjdC5rZXlzKGFyZykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIHRvW2tleV0gPSBhcmdba2V5XTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSk7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gIHJldHVybiB0bztcbn07XG5cbnZhciBpZCA9IDA7XG52YXIgaWRUZW1wbGF0ZSA9ICd7aWR9JztcblxuLyoqXG4gKiBHZW5lcmF0ZXMgYSB1bmlxdWUgaWQuXG4gKi9cbnZhciB1bmlxSWQgPSBmdW5jdGlvbiAoKSB7XG4gIC8vIGhhbmRsZSB0b28gbWFueSB1c2VzIG9mIHVuaXFJZCwgYWx0aG91Z2ggdW5saWtlbHkuXG4gIGlmIChpZCA+PSA5OTk5KSB7XG4gICAgaWQgPSAwO1xuICAgIC8vIHNoaWZ0IHRoZSB0ZW1wbGF0ZS5cbiAgICBpZFRlbXBsYXRlID0gaWRUZW1wbGF0ZS5yZXBsYWNlKCd7aWR9JywgJ197aWR9Jyk7XG4gIH1cblxuICBpZCsrO1xuICB2YXIgbmV3SWQgPSBpZFRlbXBsYXRlLnJlcGxhY2UoJ3tpZH0nLCBTdHJpbmcoaWQpKTtcblxuICByZXR1cm4gbmV3SWQ7XG59O1xuXG4vKipcbiAqIGZpbmRzIHRoZSBmaXJzdCBlbGVtZW50IHRoYXQgc2F0aXNmaWVzIHRoZSBwcmVkaWNhdGUgY2FsbGJhY2ssIHBvbHlmaWxscyBhcnJheS5maW5kXG4gKi9cbnZhciBmaW5kID0gZnVuY3Rpb24gKGFycmF5TGlrZSwgcHJlZGljYXRlKSB7XG4gIHZhciBhcnJheSA9IEFycmF5LmlzQXJyYXkoYXJyYXlMaWtlKSA/IGFycmF5TGlrZSA6IHRvQXJyYXkoYXJyYXlMaWtlKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnJheS5sZW5ndGg7IGkrKykge1xuICAgIGlmIChwcmVkaWNhdGUoYXJyYXlbaV0pKSB7XG4gICAgICByZXR1cm4gYXJyYXlbaV07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHVuZGVmaW5lZDtcbn07XG5cbi8qKlxuICogUmV0dXJucyBhIHN1aXRhYmxlIGV2ZW50IG5hbWUgZm9yIHRoZSBpbnB1dCBlbGVtZW50LlxuICovXG52YXIgZ2V0SW5wdXRFdmVudE5hbWUgPSBmdW5jdGlvbiAoZWwpIHtcbiAgaWYgKGVsICYmIChlbC50YWdOYW1lID09PSAnU0VMRUNUJyB8fCB+WydyYWRpbycsICdjaGVja2JveCcsICdmaWxlJ10uaW5kZXhPZihlbC50eXBlKSkpIHtcbiAgICByZXR1cm4gJ2NoYW5nZSc7XG4gIH1cblxuICByZXR1cm4gJ2lucHV0Jztcbn07XG5cbnZhciBpc0J1aWx0SW5Db21wb25lbnQgPSBmdW5jdGlvbiAodm5vZGUpIHtcbiAgaWYgKCF2bm9kZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHZhciB0YWcgPSB2bm9kZS5jb21wb25lbnRPcHRpb25zLnRhZztcblxuICByZXR1cm4gL2tlZXAtYWxpdmV8dHJhbnNpdGlvbnx0cmFuc2l0aW9uLWdyb3VwLy50ZXN0KHRhZyk7XG59O1xuXG52YXIgbWFrZUV2ZW50c0FycmF5ID0gZnVuY3Rpb24gKGV2ZW50cykge1xuICByZXR1cm4gKHR5cGVvZiBldmVudHMgPT09ICdzdHJpbmcnICYmIGV2ZW50cy5sZW5ndGgpID8gZXZlbnRzLnNwbGl0KCd8JykgOiBbXTtcbn07XG5cbnZhciBtYWtlRGVsYXlPYmplY3QgPSBmdW5jdGlvbiAoZXZlbnRzLCBkZWxheSwgZGVsYXlDb25maWcpIHtcbiAgaWYgKHR5cGVvZiBkZWxheSA9PT0gJ251bWJlcicpIHtcbiAgICByZXR1cm4gZXZlbnRzLnJlZHVjZShmdW5jdGlvbiAocHJldiwgZSkge1xuICAgICAgcHJldltlXSA9IGRlbGF5O1xuICAgICAgcmV0dXJuIHByZXY7XG4gICAgfSwge30pO1xuICB9XG5cbiAgcmV0dXJuIGV2ZW50cy5yZWR1Y2UoZnVuY3Rpb24gKHByZXYsIGUpIHtcbiAgICBpZiAodHlwZW9mIGRlbGF5ID09PSAnb2JqZWN0JyAmJiBlIGluIGRlbGF5KSB7XG4gICAgICBwcmV2W2VdID0gZGVsYXlbZV07XG4gICAgICByZXR1cm4gcHJldjtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGRlbGF5Q29uZmlnID09PSAnbnVtYmVyJykge1xuICAgICAgcHJldltlXSA9IGRlbGF5Q29uZmlnO1xuICAgICAgcmV0dXJuIHByZXY7XG4gICAgfVxuXG4gICAgcHJldltlXSA9IChkZWxheUNvbmZpZyAmJiBkZWxheUNvbmZpZ1tlXSkgfHwgMDtcblxuICAgIHJldHVybiBwcmV2O1xuICB9LCB7fSk7XG59O1xuXG52YXIgZGVlcFBhcnNlSW50ID0gZnVuY3Rpb24gKGlucHV0KSB7XG4gIGlmICh0eXBlb2YgaW5wdXQgPT09ICdudW1iZXInKSB7IHJldHVybiBpbnB1dDsgfVxuXG4gIGlmICh0eXBlb2YgaW5wdXQgPT09ICdzdHJpbmcnKSB7IHJldHVybiBwYXJzZUludChpbnB1dCk7IH1cblxuICB2YXIgbWFwID0ge307XG4gIGZvciAodmFyIGVsZW1lbnQgaW4gaW5wdXQpIHtcbiAgICBtYXBbZWxlbWVudF0gPSBwYXJzZUludChpbnB1dFtlbGVtZW50XSk7XG4gIH1cblxuICByZXR1cm4gbWFwO1xufTtcblxudmFyIG1lcmdlID0gZnVuY3Rpb24gKHRhcmdldCwgc291cmNlKSB7XG4gIGlmICghIChpc09iamVjdCh0YXJnZXQpICYmIGlzT2JqZWN0KHNvdXJjZSkpKSB7XG4gICAgcmV0dXJuIHRhcmdldDtcbiAgfVxuXG4gIE9iamVjdC5rZXlzKHNvdXJjZSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgaWYgKGlzT2JqZWN0KHNvdXJjZVtrZXldKSkge1xuICAgICAgaWYgKCEgdGFyZ2V0W2tleV0pIHtcbiAgICAgICAgYXNzaWduKHRhcmdldCwgKCBvYmogPSB7fSwgb2JqW2tleV0gPSB7fSwgb2JqICkpO1xuICAgICAgICB2YXIgb2JqO1xuICAgICAgfVxuXG4gICAgICBtZXJnZSh0YXJnZXRba2V5XSwgc291cmNlW2tleV0pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGFzc2lnbih0YXJnZXQsICggb2JqJDEgPSB7fSwgb2JqJDFba2V5XSA9IHNvdXJjZVtrZXldLCBvYmokMSApKTtcbiAgICB2YXIgb2JqJDE7XG4gIH0pO1xuXG4gIHJldHVybiB0YXJnZXQ7XG59O1xuXG4vLyBcblxudmFyIEVycm9yQmFnID0gZnVuY3Rpb24gRXJyb3JCYWcgKCkge1xuICB0aGlzLml0ZW1zID0gW107XG59O1xuXG4vKipcbiAqIEFkZHMgYW4gZXJyb3IgdG8gdGhlIGludGVybmFsIGFycmF5LlxuICovXG5FcnJvckJhZy5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gYWRkIChlcnJvcikge1xuICAvLyBoYW5kbGUgb2xkIHNpZ25hdHVyZS5cbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgZXJyb3IgPSB7XG4gICAgICBmaWVsZDogYXJndW1lbnRzWzBdLFxuICAgICAgbXNnOiBhcmd1bWVudHNbMV0sXG4gICAgICBydWxlOiBhcmd1bWVudHNbMl0sXG4gICAgICBzY29wZTogIWlzTnVsbE9yVW5kZWZpbmVkKGFyZ3VtZW50c1szXSkgPyBhcmd1bWVudHNbM10gOiBudWxsLFxuICAgICAgcmVnZW5lcmF0ZTogbnVsbFxuICAgIH07XG4gIH1cblxuICBlcnJvci5zY29wZSA9ICFpc051bGxPclVuZGVmaW5lZChlcnJvci5zY29wZSkgPyBlcnJvci5zY29wZSA6IG51bGw7XG4gIHRoaXMuaXRlbXMucHVzaChlcnJvcik7XG59O1xuXG4vKipcbiAqIFJlZ2VucmF0ZXMgZXJyb3IgbWVzc2FnZXMgaWYgdGhleSBoYXZlIGEgZ2VuZXJhdG9yIGZ1bmN0aW9uLlxuICovXG5FcnJvckJhZy5wcm90b3R5cGUucmVnZW5lcmF0ZSA9IGZ1bmN0aW9uIHJlZ2VuZXJhdGUgKCkge1xuICB0aGlzLml0ZW1zLmZvckVhY2goZnVuY3Rpb24gKGkpIHtcbiAgICBpLm1zZyA9IGlzQ2FsbGFibGUoaS5yZWdlbmVyYXRlKSA/IGkucmVnZW5lcmF0ZSgpIDogaS5tc2c7XG4gIH0pO1xufTtcblxuLyoqXG4gKiBVcGRhdGVzIGEgZmllbGQgZXJyb3Igd2l0aCB0aGUgbmV3IGZpZWxkIHNjb3BlLlxuICovXG5FcnJvckJhZy5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gdXBkYXRlIChpZCwgZXJyb3IpIHtcbiAgdmFyIGl0ZW0gPSBmaW5kKHRoaXMuaXRlbXMsIGZ1bmN0aW9uIChpKSB7IHJldHVybiBpLmlkID09PSBpZDsgfSk7XG4gIGlmICghaXRlbSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBpZHggPSB0aGlzLml0ZW1zLmluZGV4T2YoaXRlbSk7XG4gIHRoaXMuaXRlbXMuc3BsaWNlKGlkeCwgMSk7XG4gIGl0ZW0uc2NvcGUgPSBlcnJvci5zY29wZTtcbiAgdGhpcy5pdGVtcy5wdXNoKGl0ZW0pO1xufTtcblxuLyoqXG4gKiBHZXRzIGFsbCBlcnJvciBtZXNzYWdlcyBmcm9tIHRoZSBpbnRlcm5hbCBhcnJheS5cbiAqL1xuRXJyb3JCYWcucHJvdG90eXBlLmFsbCA9IGZ1bmN0aW9uIGFsbCAoc2NvcGUpIHtcbiAgaWYgKGlzTnVsbE9yVW5kZWZpbmVkKHNjb3BlKSkge1xuICAgIHJldHVybiB0aGlzLml0ZW1zLm1hcChmdW5jdGlvbiAoZSkgeyByZXR1cm4gZS5tc2c7IH0pO1xuICB9XG5cbiAgcmV0dXJuIHRoaXMuaXRlbXMuZmlsdGVyKGZ1bmN0aW9uIChlKSB7IHJldHVybiBlLnNjb3BlID09PSBzY29wZTsgfSkubWFwKGZ1bmN0aW9uIChlKSB7IHJldHVybiBlLm1zZzsgfSk7XG59O1xuXG4vKipcbiAqIENoZWNrcyBpZiB0aGVyZSBhcmUgYW55IGVycm9ycyBpbiB0aGUgaW50ZXJuYWwgYXJyYXkuXG4gKi9cbkVycm9yQmFnLnByb3RvdHlwZS5hbnkgPSBmdW5jdGlvbiBhbnkgKHNjb3BlKSB7XG4gIGlmIChpc051bGxPclVuZGVmaW5lZChzY29wZSkpIHtcbiAgICByZXR1cm4gISF0aGlzLml0ZW1zLmxlbmd0aDtcbiAgfVxuXG4gIHJldHVybiAhIXRoaXMuaXRlbXMuZmlsdGVyKGZ1bmN0aW9uIChlKSB7IHJldHVybiBlLnNjb3BlID09PSBzY29wZTsgfSkubGVuZ3RoO1xufTtcblxuLyoqXG4gKiBSZW1vdmVzIGFsbCBpdGVtcyBmcm9tIHRoZSBpbnRlcm5hbCBhcnJheS5cbiAqL1xuRXJyb3JCYWcucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24gY2xlYXIgKHNjb3BlKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgaWYgKGlzTnVsbE9yVW5kZWZpbmVkKHNjb3BlKSkge1xuICAgIHNjb3BlID0gbnVsbDtcbiAgfVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5pdGVtcy5sZW5ndGg7ICsraSkge1xuICAgIGlmICh0aGlzJDEuaXRlbXNbaV0uc2NvcGUgPT09IHNjb3BlKSB7XG4gICAgICB0aGlzJDEuaXRlbXMuc3BsaWNlKGksIDEpO1xuICAgICAgLS1pO1xuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiBDb2xsZWN0cyBlcnJvcnMgaW50byBncm91cHMgb3IgZm9yIGEgc3BlY2lmaWMgZmllbGQuXG4gKi9cbkVycm9yQmFnLnByb3RvdHlwZS5jb2xsZWN0ID0gZnVuY3Rpb24gY29sbGVjdCAoZmllbGQsIHNjb3BlLCBtYXApIHtcbiAgICBpZiAoIG1hcCA9PT0gdm9pZCAwICkgbWFwID0gdHJ1ZTtcblxuICBpZiAoIWZpZWxkKSB7XG4gICAgdmFyIGNvbGxlY3Rpb24gPSB7fTtcbiAgICB0aGlzLml0ZW1zLmZvckVhY2goZnVuY3Rpb24gKGUpIHtcbiAgICAgIGlmICghIGNvbGxlY3Rpb25bZS5maWVsZF0pIHtcbiAgICAgICAgY29sbGVjdGlvbltlLmZpZWxkXSA9IFtdO1xuICAgICAgfVxuXG4gICAgICBjb2xsZWN0aW9uW2UuZmllbGRdLnB1c2gobWFwID8gZS5tc2cgOiBlKTtcbiAgICB9KTtcblxuICAgIHJldHVybiBjb2xsZWN0aW9uO1xuICB9XG5cbiAgZmllbGQgPSAhaXNOdWxsT3JVbmRlZmluZWQoZmllbGQpID8gU3RyaW5nKGZpZWxkKSA6IGZpZWxkO1xuICBpZiAoaXNOdWxsT3JVbmRlZmluZWQoc2NvcGUpKSB7XG4gICAgcmV0dXJuIHRoaXMuaXRlbXMuZmlsdGVyKGZ1bmN0aW9uIChlKSB7IHJldHVybiBlLmZpZWxkID09PSBmaWVsZDsgfSkubWFwKGZ1bmN0aW9uIChlKSB7IHJldHVybiAobWFwID8gZS5tc2cgOiBlKTsgfSk7XG4gIH1cblxuICByZXR1cm4gdGhpcy5pdGVtcy5maWx0ZXIoZnVuY3Rpb24gKGUpIHsgcmV0dXJuIGUuZmllbGQgPT09IGZpZWxkICYmIGUuc2NvcGUgPT09IHNjb3BlOyB9KVxuICAgIC5tYXAoZnVuY3Rpb24gKGUpIHsgcmV0dXJuIChtYXAgPyBlLm1zZyA6IGUpOyB9KTtcbn07XG4vKipcbiAqIEdldHMgdGhlIGludGVybmFsIGFycmF5IGxlbmd0aC5cbiAqL1xuRXJyb3JCYWcucHJvdG90eXBlLmNvdW50ID0gZnVuY3Rpb24gY291bnQgKCkge1xuICByZXR1cm4gdGhpcy5pdGVtcy5sZW5ndGg7XG59O1xuXG4vKipcbiAqIEZpbmRzIGFuZCBmZXRjaGVzIHRoZSBmaXJzdCBlcnJvciBtZXNzYWdlIGZvciB0aGUgc3BlY2lmaWVkIGZpZWxkIGlkLlxuICovXG5FcnJvckJhZy5wcm90b3R5cGUuZmlyc3RCeUlkID0gZnVuY3Rpb24gZmlyc3RCeUlkIChpZCkge1xuICB2YXIgZXJyb3IgPSBmaW5kKHRoaXMuaXRlbXMsIGZ1bmN0aW9uIChpKSB7IHJldHVybiBpLmlkID09PSBpZDsgfSk7XG5cbiAgcmV0dXJuIGVycm9yID8gZXJyb3IubXNnIDogbnVsbDtcbn07XG5cbi8qKlxuICogR2V0cyB0aGUgZmlyc3QgZXJyb3IgbWVzc2FnZSBmb3IgYSBzcGVjaWZpYyBmaWVsZC5cbiAqL1xuRXJyb3JCYWcucHJvdG90eXBlLmZpcnN0ID0gZnVuY3Rpb24gZmlyc3QgKGZpZWxkLCBzY29wZSkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuICAgIGlmICggc2NvcGUgPT09IHZvaWQgMCApIHNjb3BlID0gbnVsbDtcblxuICBmaWVsZCA9ICFpc051bGxPclVuZGVmaW5lZChmaWVsZCkgPyBTdHJpbmcoZmllbGQpIDogZmllbGQ7XG4gIHZhciBzZWxlY3RvciA9IHRoaXMuX3NlbGVjdG9yKGZpZWxkKTtcbiAgdmFyIHNjb3BlZCA9IHRoaXMuX3Njb3BlKGZpZWxkKTtcblxuICBpZiAoc2NvcGVkKSB7XG4gICAgdmFyIHJlc3VsdCA9IHRoaXMuZmlyc3Qoc2NvcGVkLm5hbWUsIHNjb3BlZC5zY29wZSk7XG4gICAgLy8gaWYgc3VjaCByZXN1bHQgZXhpc3QsIHJldHVybiBpdC4gb3RoZXJ3aXNlIGl0IGNvdWxkIGJlIGEgZmllbGQuXG4gICAgLy8gd2l0aCBkb3QgaW4gaXRzIG5hbWUuXG4gICAgaWYgKHJlc3VsdCkge1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gIH1cblxuICBpZiAoc2VsZWN0b3IpIHtcbiAgICByZXR1cm4gdGhpcy5maXJzdEJ5UnVsZShzZWxlY3Rvci5uYW1lLCBzZWxlY3Rvci5ydWxlLCBzY29wZSk7XG4gIH1cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuaXRlbXMubGVuZ3RoOyArK2kpIHtcbiAgICBpZiAodGhpcyQxLml0ZW1zW2ldLmZpZWxkID09PSBmaWVsZCAmJiAodGhpcyQxLml0ZW1zW2ldLnNjb3BlID09PSBzY29wZSkpIHtcbiAgICAgIHJldHVybiB0aGlzJDEuaXRlbXNbaV0ubXNnO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBudWxsO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBmaXJzdCBlcnJvciBydWxlIGZvciB0aGUgc3BlY2lmaWVkIGZpZWxkXG4gKi9cbkVycm9yQmFnLnByb3RvdHlwZS5maXJzdFJ1bGUgPSBmdW5jdGlvbiBmaXJzdFJ1bGUgKGZpZWxkLCBzY29wZSkge1xuICB2YXIgZXJyb3JzID0gdGhpcy5jb2xsZWN0KGZpZWxkLCBzY29wZSwgZmFsc2UpO1xuXG4gIHJldHVybiAoZXJyb3JzLmxlbmd0aCAmJiBlcnJvcnNbMF0ucnVsZSkgfHwgbnVsbDtcbn07XG5cbi8qKlxuICogQ2hlY2tzIGlmIHRoZSBpbnRlcm5hbCBhcnJheSBoYXMgYXQgbGVhc3Qgb25lIGVycm9yIGZvciB0aGUgc3BlY2lmaWVkIGZpZWxkLlxuICovXG5FcnJvckJhZy5wcm90b3R5cGUuaGFzID0gZnVuY3Rpb24gaGFzIChmaWVsZCwgc2NvcGUpIHtcbiAgICBpZiAoIHNjb3BlID09PSB2b2lkIDAgKSBzY29wZSA9IG51bGw7XG5cbiAgcmV0dXJuICEhdGhpcy5maXJzdChmaWVsZCwgc2NvcGUpO1xufTtcblxuLyoqXG4gKiBHZXRzIHRoZSBmaXJzdCBlcnJvciBtZXNzYWdlIGZvciBhIHNwZWNpZmljIGZpZWxkIGFuZCBhIHJ1bGUuXG4gKi9cbkVycm9yQmFnLnByb3RvdHlwZS5maXJzdEJ5UnVsZSA9IGZ1bmN0aW9uIGZpcnN0QnlSdWxlIChuYW1lLCBydWxlLCBzY29wZSkge1xuICAgIGlmICggc2NvcGUgPT09IHZvaWQgMCApIHNjb3BlID0gbnVsbDtcblxuICB2YXIgZXJyb3IgPSB0aGlzLmNvbGxlY3QobmFtZSwgc2NvcGUsIGZhbHNlKS5maWx0ZXIoZnVuY3Rpb24gKGUpIHsgcmV0dXJuIGUucnVsZSA9PT0gcnVsZTsgfSlbMF07XG5cbiAgcmV0dXJuIChlcnJvciAmJiBlcnJvci5tc2cpIHx8IG51bGw7XG59O1xuXG4vKipcbiAqIEdldHMgdGhlIGZpcnN0IGVycm9yIG1lc3NhZ2UgZm9yIGEgc3BlY2lmaWMgZmllbGQgdGhhdCBub3QgbWF0Y2ggdGhlIHJ1bGUuXG4gKi9cbkVycm9yQmFnLnByb3RvdHlwZS5maXJzdE5vdCA9IGZ1bmN0aW9uIGZpcnN0Tm90IChuYW1lLCBydWxlLCBzY29wZSkge1xuICAgIGlmICggcnVsZSA9PT0gdm9pZCAwICkgcnVsZSA9ICdyZXF1aXJlZCc7XG4gICAgaWYgKCBzY29wZSA9PT0gdm9pZCAwICkgc2NvcGUgPSBudWxsO1xuXG4gIHZhciBlcnJvciA9IHRoaXMuY29sbGVjdChuYW1lLCBzY29wZSwgZmFsc2UpLmZpbHRlcihmdW5jdGlvbiAoZSkgeyByZXR1cm4gZS5ydWxlICE9PSBydWxlOyB9KVswXTtcblxuICByZXR1cm4gKGVycm9yICYmIGVycm9yLm1zZykgfHwgbnVsbDtcbn07XG5cbi8qKlxuICogUmVtb3ZlcyBlcnJvcnMgYnkgbWF0Y2hpbmcgYWdhaW5zdCB0aGUgaWQuXG4gKi9cbkVycm9yQmFnLnByb3RvdHlwZS5yZW1vdmVCeUlkID0gZnVuY3Rpb24gcmVtb3ZlQnlJZCAoaWQpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuaXRlbXMubGVuZ3RoOyArK2kpIHtcbiAgICBpZiAodGhpcyQxLml0ZW1zW2ldLmlkID09PSBpZCkge1xuICAgICAgdGhpcyQxLml0ZW1zLnNwbGljZShpLCAxKTtcbiAgICAgIC0taTtcbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogUmVtb3ZlcyBhbGwgZXJyb3IgbWVzc2FnZXMgYXNzb2NpYXRlZCB3aXRoIGEgc3BlY2lmaWMgZmllbGQuXG4gKi9cbkVycm9yQmFnLnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbiByZW1vdmUgKGZpZWxkLCBzY29wZSwgaWQpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICBmaWVsZCA9ICFpc051bGxPclVuZGVmaW5lZChmaWVsZCkgPyBTdHJpbmcoZmllbGQpIDogZmllbGQ7XG4gIHZhciByZW1vdmVDb25kaXRpb24gPSBmdW5jdGlvbiAoZSkge1xuICAgIGlmIChlLmlkICYmIGlkKSB7XG4gICAgICByZXR1cm4gZS5pZCA9PT0gaWQ7XG4gICAgfVxuXG4gICAgaWYgKCFpc051bGxPclVuZGVmaW5lZChzY29wZSkpIHtcbiAgICAgIHJldHVybiBlLmZpZWxkID09PSBmaWVsZCAmJiBlLnNjb3BlID09PSBzY29wZTtcbiAgICB9XG5cbiAgICByZXR1cm4gZS5maWVsZCA9PT0gZmllbGQgJiYgZS5zY29wZSA9PT0gbnVsbDtcbiAgfTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuaXRlbXMubGVuZ3RoOyArK2kpIHtcbiAgICBpZiAocmVtb3ZlQ29uZGl0aW9uKHRoaXMkMS5pdGVtc1tpXSkpIHtcbiAgICAgIHRoaXMkMS5pdGVtcy5zcGxpY2UoaSwgMSk7XG4gICAgICAtLWk7XG4gICAgfVxuICB9XG59O1xuXG4vKipcbiAqIEdldCB0aGUgZmllbGQgYXR0cmlidXRlcyBpZiB0aGVyZSdzIGEgcnVsZSBzZWxlY3Rvci5cbiAqL1xuRXJyb3JCYWcucHJvdG90eXBlLl9zZWxlY3RvciA9IGZ1bmN0aW9uIF9zZWxlY3RvciAoZmllbGQpIHtcbiAgaWYgKGZpZWxkLmluZGV4T2YoJzonKSA+IC0xKSB7XG4gICAgdmFyIHJlZiA9IGZpZWxkLnNwbGl0KCc6Jyk7XG4gICAgICB2YXIgbmFtZSA9IHJlZlswXTtcbiAgICAgIHZhciBydWxlID0gcmVmWzFdO1xuXG4gICAgcmV0dXJuIHsgbmFtZTogbmFtZSwgcnVsZTogcnVsZSB9O1xuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59O1xuXG4vKipcbiAqIEdldCB0aGUgZmllbGQgc2NvcGUgaWYgc3BlY2lmaWVkIHVzaW5nIGRvdCBub3RhdGlvbi5cbiAqL1xuRXJyb3JCYWcucHJvdG90eXBlLl9zY29wZSA9IGZ1bmN0aW9uIF9zY29wZSAoZmllbGQpIHtcbiAgaWYgKGZpZWxkLmluZGV4T2YoJy4nKSA+IC0xKSB7XG4gICAgdmFyIHJlZiA9IGZpZWxkLnNwbGl0KCcuJyk7XG4gICAgICB2YXIgc2NvcGUgPSByZWZbMF07XG4gICAgICB2YXIgbmFtZSA9IHJlZi5zbGljZSgxKTtcblxuICAgIHJldHVybiB7IG5hbWU6IG5hbWUuam9pbignLicpLCBzY29wZTogc2NvcGUgfTtcbiAgfVxuXG4gIHJldHVybiBudWxsO1xufTtcblxuLy8gXG5cbnZhciBMT0NBTEUgPSAnZW4nO1xuXG52YXIgRGljdGlvbmFyeSA9IGZ1bmN0aW9uIERpY3Rpb25hcnkgKGRpY3Rpb25hcnkpIHtcbiAgaWYgKCBkaWN0aW9uYXJ5ID09PSB2b2lkIDAgKSBkaWN0aW9uYXJ5ID0ge307XG5cbiAgdGhpcy5jb250YWluZXIgPSB7fTtcbiAgdGhpcy5tZXJnZShkaWN0aW9uYXJ5KTtcbn07XG5cbnZhciBwcm90b3R5cGVBY2Nlc3NvcnMkMiA9IHsgbG9jYWxlOiB7fSB9O1xuXG5wcm90b3R5cGVBY2Nlc3NvcnMkMi5sb2NhbGUuZ2V0ID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gTE9DQUxFO1xufTtcblxucHJvdG90eXBlQWNjZXNzb3JzJDIubG9jYWxlLnNldCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICBMT0NBTEUgPSB2YWx1ZSB8fCAnZW4nO1xufTtcblxuRGljdGlvbmFyeS5wcm90b3R5cGUuaGFzTG9jYWxlID0gZnVuY3Rpb24gaGFzTG9jYWxlIChsb2NhbGUpIHtcbiAgcmV0dXJuICEhdGhpcy5jb250YWluZXJbbG9jYWxlXTtcbn07XG5cbkRpY3Rpb25hcnkucHJvdG90eXBlLnNldERhdGVGb3JtYXQgPSBmdW5jdGlvbiBzZXREYXRlRm9ybWF0IChsb2NhbGUsIGZvcm1hdCkge1xuICBpZiAoIXRoaXMuY29udGFpbmVyW2xvY2FsZV0pIHtcbiAgICB0aGlzLmNvbnRhaW5lcltsb2NhbGVdID0ge307XG4gIH1cblxuICB0aGlzLmNvbnRhaW5lcltsb2NhbGVdLmRhdGVGb3JtYXQgPSBmb3JtYXQ7XG59O1xuXG5EaWN0aW9uYXJ5LnByb3RvdHlwZS5nZXREYXRlRm9ybWF0ID0gZnVuY3Rpb24gZ2V0RGF0ZUZvcm1hdCAobG9jYWxlKSB7XG4gIGlmICghdGhpcy5jb250YWluZXJbbG9jYWxlXSB8fCAhdGhpcy5jb250YWluZXJbbG9jYWxlXS5kYXRlRm9ybWF0KSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICByZXR1cm4gdGhpcy5jb250YWluZXJbbG9jYWxlXS5kYXRlRm9ybWF0O1xufTtcblxuRGljdGlvbmFyeS5wcm90b3R5cGUuZ2V0TWVzc2FnZSA9IGZ1bmN0aW9uIGdldE1lc3NhZ2UgKGxvY2FsZSwga2V5LCBkYXRhKSB7XG4gIHZhciBtZXNzYWdlID0gbnVsbDtcbiAgaWYgKCF0aGlzLmhhc01lc3NhZ2UobG9jYWxlLCBrZXkpKSB7XG4gICAgbWVzc2FnZSA9IHRoaXMuX2dldERlZmF1bHRNZXNzYWdlKGxvY2FsZSk7XG4gIH0gZWxzZSB7XG4gICAgbWVzc2FnZSA9IHRoaXMuY29udGFpbmVyW2xvY2FsZV0ubWVzc2FnZXNba2V5XTtcbiAgfVxuXG4gIHJldHVybiBpc0NhbGxhYmxlKG1lc3NhZ2UpID8gbWVzc2FnZS5hcHBseSh2b2lkIDAsIGRhdGEpIDogbWVzc2FnZTtcbn07XG5cbi8qKlxuICogR2V0cyBhIHNwZWNpZmljIG1lc3NhZ2UgZm9yIGZpZWxkLiBmYWxscyBiYWNrIHRvIHRoZSBydWxlIG1lc3NhZ2UuXG4gKi9cbkRpY3Rpb25hcnkucHJvdG90eXBlLmdldEZpZWxkTWVzc2FnZSA9IGZ1bmN0aW9uIGdldEZpZWxkTWVzc2FnZSAobG9jYWxlLCBmaWVsZCwga2V5LCBkYXRhKSB7XG4gIGlmICghdGhpcy5oYXNMb2NhbGUobG9jYWxlKSkge1xuICAgIHJldHVybiB0aGlzLmdldE1lc3NhZ2UobG9jYWxlLCBrZXksIGRhdGEpO1xuICB9XG5cbiAgdmFyIGRpY3QgPSB0aGlzLmNvbnRhaW5lcltsb2NhbGVdLmN1c3RvbSAmJiB0aGlzLmNvbnRhaW5lcltsb2NhbGVdLmN1c3RvbVtmaWVsZF07XG4gIGlmICghZGljdCB8fCAhZGljdFtrZXldKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0TWVzc2FnZShsb2NhbGUsIGtleSwgZGF0YSk7XG4gIH1cblxuICB2YXIgbWVzc2FnZSA9IGRpY3Rba2V5XTtcbiAgcmV0dXJuIGlzQ2FsbGFibGUobWVzc2FnZSkgPyBtZXNzYWdlLmFwcGx5KHZvaWQgMCwgZGF0YSkgOiBtZXNzYWdlO1xufTtcblxuRGljdGlvbmFyeS5wcm90b3R5cGUuX2dldERlZmF1bHRNZXNzYWdlID0gZnVuY3Rpb24gX2dldERlZmF1bHRNZXNzYWdlIChsb2NhbGUpIHtcbiAgaWYgKHRoaXMuaGFzTWVzc2FnZShsb2NhbGUsICdfZGVmYXVsdCcpKSB7XG4gICAgcmV0dXJuIHRoaXMuY29udGFpbmVyW2xvY2FsZV0ubWVzc2FnZXMuX2RlZmF1bHQ7XG4gIH1cblxuICByZXR1cm4gdGhpcy5jb250YWluZXIuZW4ubWVzc2FnZXMuX2RlZmF1bHQ7XG59O1xuXG5EaWN0aW9uYXJ5LnByb3RvdHlwZS5nZXRBdHRyaWJ1dGUgPSBmdW5jdGlvbiBnZXRBdHRyaWJ1dGUgKGxvY2FsZSwga2V5LCBmYWxsYmFjaykge1xuICAgIGlmICggZmFsbGJhY2sgPT09IHZvaWQgMCApIGZhbGxiYWNrID0gJyc7XG5cbiAgaWYgKCF0aGlzLmhhc0F0dHJpYnV0ZShsb2NhbGUsIGtleSkpIHtcbiAgICByZXR1cm4gZmFsbGJhY2s7XG4gIH1cblxuICByZXR1cm4gdGhpcy5jb250YWluZXJbbG9jYWxlXS5hdHRyaWJ1dGVzW2tleV07XG59O1xuXG5EaWN0aW9uYXJ5LnByb3RvdHlwZS5oYXNNZXNzYWdlID0gZnVuY3Rpb24gaGFzTWVzc2FnZSAobG9jYWxlLCBrZXkpIHtcbiAgcmV0dXJuICEhIChcbiAgICB0aGlzLmhhc0xvY2FsZShsb2NhbGUpICYmXG4gICAgICAgICAgdGhpcy5jb250YWluZXJbbG9jYWxlXS5tZXNzYWdlcyAmJlxuICAgICAgICAgIHRoaXMuY29udGFpbmVyW2xvY2FsZV0ubWVzc2FnZXNba2V5XVxuICApO1xufTtcblxuRGljdGlvbmFyeS5wcm90b3R5cGUuaGFzQXR0cmlidXRlID0gZnVuY3Rpb24gaGFzQXR0cmlidXRlIChsb2NhbGUsIGtleSkge1xuICByZXR1cm4gISEgKFxuICAgIHRoaXMuaGFzTG9jYWxlKGxvY2FsZSkgJiZcbiAgICAgICAgICB0aGlzLmNvbnRhaW5lcltsb2NhbGVdLmF0dHJpYnV0ZXMgJiZcbiAgICAgICAgICB0aGlzLmNvbnRhaW5lcltsb2NhbGVdLmF0dHJpYnV0ZXNba2V5XVxuICApO1xufTtcblxuRGljdGlvbmFyeS5wcm90b3R5cGUubWVyZ2UgPSBmdW5jdGlvbiBtZXJnZSQxIChkaWN0aW9uYXJ5KSB7XG4gIG1lcmdlKHRoaXMuY29udGFpbmVyLCBkaWN0aW9uYXJ5KTtcbn07XG5cbkRpY3Rpb25hcnkucHJvdG90eXBlLnNldE1lc3NhZ2UgPSBmdW5jdGlvbiBzZXRNZXNzYWdlIChsb2NhbGUsIGtleSwgbWVzc2FnZSkge1xuICBpZiAoISB0aGlzLmhhc0xvY2FsZShsb2NhbGUpKSB7XG4gICAgdGhpcy5jb250YWluZXJbbG9jYWxlXSA9IHtcbiAgICAgIG1lc3NhZ2VzOiB7fSxcbiAgICAgIGF0dHJpYnV0ZXM6IHt9XG4gICAgfTtcbiAgfVxuXG4gIHRoaXMuY29udGFpbmVyW2xvY2FsZV0ubWVzc2FnZXNba2V5XSA9IG1lc3NhZ2U7XG59O1xuXG5EaWN0aW9uYXJ5LnByb3RvdHlwZS5zZXRBdHRyaWJ1dGUgPSBmdW5jdGlvbiBzZXRBdHRyaWJ1dGUgKGxvY2FsZSwga2V5LCBhdHRyaWJ1dGUpIHtcbiAgaWYgKCEgdGhpcy5oYXNMb2NhbGUobG9jYWxlKSkge1xuICAgIHRoaXMuY29udGFpbmVyW2xvY2FsZV0gPSB7XG4gICAgICBtZXNzYWdlczoge30sXG4gICAgICBhdHRyaWJ1dGVzOiB7fVxuICAgIH07XG4gIH1cblxuICB0aGlzLmNvbnRhaW5lcltsb2NhbGVdLmF0dHJpYnV0ZXNba2V5XSA9IGF0dHJpYnV0ZTtcbn07XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKCBEaWN0aW9uYXJ5LnByb3RvdHlwZSwgcHJvdG90eXBlQWNjZXNzb3JzJDIgKTtcblxuLy8gXG5cbnZhciBub3JtYWxpemVWYWx1ZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICBpZiAoaXNPYmplY3QodmFsdWUpKSB7XG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKHZhbHVlKS5yZWR1Y2UoZnVuY3Rpb24gKHByZXYsIGtleSkge1xuICAgICAgcHJldltrZXldID0gbm9ybWFsaXplVmFsdWUodmFsdWVba2V5XSk7XG5cbiAgICAgIHJldHVybiBwcmV2O1xuICAgIH0sIHt9KTtcbiAgfVxuXG4gIGlmIChpc0NhbGxhYmxlKHZhbHVlKSkge1xuICAgIHJldHVybiB2YWx1ZSgnezB9JywgWyd7MX0nLCAnezJ9JywgJ3szfSddKTtcbiAgfVxuXG4gIHJldHVybiB2YWx1ZTtcbn07XG5cbnZhciBub3JtYWxpemVGb3JtYXQgPSBmdW5jdGlvbiAobG9jYWxlKSB7XG4gIC8vIG5vcm1hbGl6ZSBtZXNzYWdlc1xuICB2YXIgbWVzc2FnZXMgPSBub3JtYWxpemVWYWx1ZShsb2NhbGUubWVzc2FnZXMpO1xuICB2YXIgY3VzdG9tID0gbm9ybWFsaXplVmFsdWUobG9jYWxlLmN1c3RvbSk7XG5cbiAgcmV0dXJuIHtcbiAgICBtZXNzYWdlczogbWVzc2FnZXMsXG4gICAgY3VzdG9tOiBjdXN0b20sXG4gICAgYXR0cmlidXRlczogbG9jYWxlLmF0dHJpYnV0ZXMsXG4gICAgZGF0ZUZvcm1hdDogbG9jYWxlLmRhdGVGb3JtYXRcbiAgfTtcbn07XG5cbnZhciBJMThuRGljdGlvbmFyeSA9IGZ1bmN0aW9uIEkxOG5EaWN0aW9uYXJ5IChpMThuLCByb290S2V5KSB7XG4gIHRoaXMuaTE4biA9IGkxOG47XG4gIHRoaXMucm9vdEtleSA9IHJvb3RLZXk7XG59O1xuXG52YXIgcHJvdG90eXBlQWNjZXNzb3JzJDMgPSB7IGxvY2FsZToge30gfTtcblxucHJvdG90eXBlQWNjZXNzb3JzJDMubG9jYWxlLmdldCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuaTE4bi5sb2NhbGU7XG59O1xuXG5wcm90b3R5cGVBY2Nlc3NvcnMkMy5sb2NhbGUuc2V0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gIHdhcm4oJ0Nhbm5vdCBzZXQgbG9jYWxlIGZyb20gdGhlIHZhbGlkYXRvciB3aGVuIHVzaW5nIHZ1ZS1pMThuLCB1c2UgaTE4bi5sb2NhbGUgc2V0dGVyIGluc3RlYWQnKTtcbn07XG5cbkkxOG5EaWN0aW9uYXJ5LnByb3RvdHlwZS5nZXREYXRlRm9ybWF0ID0gZnVuY3Rpb24gZ2V0RGF0ZUZvcm1hdCAobG9jYWxlKSB7XG4gIHJldHVybiB0aGlzLmkxOG4uZ2V0RGF0ZVRpbWVGb3JtYXQobG9jYWxlIHx8IHRoaXMubG9jYWxlKTtcbn07XG5cbkkxOG5EaWN0aW9uYXJ5LnByb3RvdHlwZS5zZXREYXRlRm9ybWF0ID0gZnVuY3Rpb24gc2V0RGF0ZUZvcm1hdCAobG9jYWxlLCB2YWx1ZSkge1xuICB0aGlzLmkxOG4uc2V0RGF0ZVRpbWVGb3JtYXQobG9jYWxlIHx8IHRoaXMubG9jYWxlLCB2YWx1ZSk7XG59O1xuXG5JMThuRGljdGlvbmFyeS5wcm90b3R5cGUuZ2V0TWVzc2FnZSA9IGZ1bmN0aW9uIGdldE1lc3NhZ2UgKGxvY2FsZSwga2V5LCBkYXRhKSB7XG4gIHZhciBwYXRoID0gKHRoaXMucm9vdEtleSkgKyBcIi5tZXNzYWdlcy5cIiArIGtleTtcbiAgaWYgKCF0aGlzLmkxOG4udGUocGF0aCkpIHtcbiAgICByZXR1cm4gdGhpcy5pMThuLnQoKCh0aGlzLnJvb3RLZXkpICsgXCIubWVzc2FnZXMuX2RlZmF1bHRcIiksIGxvY2FsZSwgZGF0YSk7XG4gIH1cblxuICByZXR1cm4gdGhpcy5pMThuLnQocGF0aCwgbG9jYWxlLCBkYXRhKTtcbn07XG5cbkkxOG5EaWN0aW9uYXJ5LnByb3RvdHlwZS5nZXRBdHRyaWJ1dGUgPSBmdW5jdGlvbiBnZXRBdHRyaWJ1dGUgKGxvY2FsZSwga2V5LCBmYWxsYmFjaykge1xuICAgIGlmICggZmFsbGJhY2sgPT09IHZvaWQgMCApIGZhbGxiYWNrID0gJyc7XG5cbiAgdmFyIHBhdGggPSAodGhpcy5yb290S2V5KSArIFwiLmF0dHJpYnV0ZXMuXCIgKyBrZXk7XG4gIGlmICghdGhpcy5pMThuLnRlKHBhdGgpKSB7XG4gICAgcmV0dXJuIGZhbGxiYWNrO1xuICB9XG5cbiAgcmV0dXJuIHRoaXMuaTE4bi50KHBhdGgsIGxvY2FsZSk7XG59O1xuXG5JMThuRGljdGlvbmFyeS5wcm90b3R5cGUuZ2V0RmllbGRNZXNzYWdlID0gZnVuY3Rpb24gZ2V0RmllbGRNZXNzYWdlIChsb2NhbGUsIGZpZWxkLCBrZXksIGRhdGEpIHtcbiAgdmFyIHBhdGggPSAodGhpcy5yb290S2V5KSArIFwiLmN1c3RvbS5cIiArIGZpZWxkICsgXCIuXCIgKyBrZXk7XG4gIGlmICh0aGlzLmkxOG4udGUocGF0aCkpIHtcbiAgICByZXR1cm4gdGhpcy5pMThuLnQocGF0aCk7XG4gIH1cblxuICByZXR1cm4gdGhpcy5nZXRNZXNzYWdlKGxvY2FsZSwga2V5LCBkYXRhKTtcbn07XG5cbkkxOG5EaWN0aW9uYXJ5LnByb3RvdHlwZS5tZXJnZSA9IGZ1bmN0aW9uIG1lcmdlJDEgKGRpY3Rpb25hcnkpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICBPYmplY3Qua2V5cyhkaWN0aW9uYXJ5KS5mb3JFYWNoKGZ1bmN0aW9uIChsb2NhbGVLZXkpIHtcbiAgICAvLyBpMThuIGRvZXNuJ3QgZGVlcCBtZXJnZVxuICAgIC8vIGZpcnN0IGNsb25lIHRoZSBleGlzdGluZyBsb2NhbGUgKGF2b2lkIG11dGF0aW9ucyB0byBsb2NhbGUpXG4gICAgdmFyIGNsb25lID0gbWVyZ2Uoe30sIGdldFBhdGgoKGxvY2FsZUtleSArIFwiLlwiICsgKHRoaXMkMS5yb290S2V5KSksIHRoaXMkMS5pMThuLm1lc3NhZ2VzLCB7fSkpO1xuICAgIC8vIE1lcmdlIGNsb25lZCBsb2NhbGUgd2l0aCBuZXcgb25lXG4gICAgdmFyIGxvY2FsZSA9IG1lcmdlKGNsb25lLCBub3JtYWxpemVGb3JtYXQoZGljdGlvbmFyeVtsb2NhbGVLZXldKSk7XG4gICAgdGhpcyQxLmkxOG4ubWVyZ2VMb2NhbGVNZXNzYWdlKGxvY2FsZUtleSwgKCBvYmogPSB7fSwgb2JqW3RoaXMkMS5yb290S2V5XSA9IGxvY2FsZSwgb2JqICkpO1xuICAgICAgdmFyIG9iajtcbiAgICBpZiAobG9jYWxlLmRhdGVGb3JtYXQpIHtcbiAgICAgIHRoaXMkMS5pMThuLnNldERhdGVUaW1lRm9ybWF0KGxvY2FsZUtleSwgbG9jYWxlLmRhdGVGb3JtYXQpO1xuICAgIH1cbiAgfSk7XG59O1xuXG5JMThuRGljdGlvbmFyeS5wcm90b3R5cGUuc2V0TWVzc2FnZSA9IGZ1bmN0aW9uIHNldE1lc3NhZ2UgKGxvY2FsZSwga2V5LCB2YWx1ZSkge1xuICB0aGlzLm1lcmdlKCggb2JqJDEgPSB7fSwgb2JqJDFbbG9jYWxlXSA9IHtcbiAgICAgIG1lc3NhZ2VzOiAoIG9iaiA9IHt9LCBvYmpba2V5XSA9IHZhbHVlLCBvYmogKVxuICAgIH0sIG9iaiQxICkpO1xuICAgIHZhciBvYmo7XG4gICAgdmFyIG9iaiQxO1xufTtcblxuSTE4bkRpY3Rpb25hcnkucHJvdG90eXBlLnNldEF0dHJpYnV0ZSA9IGZ1bmN0aW9uIHNldEF0dHJpYnV0ZSAobG9jYWxlLCBrZXksIHZhbHVlKSB7XG4gIHRoaXMubWVyZ2UoKCBvYmokMSA9IHt9LCBvYmokMVtsb2NhbGVdID0ge1xuICAgICAgYXR0cmlidXRlczogKCBvYmogPSB7fSwgb2JqW2tleV0gPSB2YWx1ZSwgb2JqIClcbiAgICB9LCBvYmokMSApKTtcbiAgICB2YXIgb2JqO1xuICAgIHZhciBvYmokMTtcbn07XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKCBJMThuRGljdGlvbmFyeS5wcm90b3R5cGUsIHByb3RvdHlwZUFjY2Vzc29ycyQzICk7XG5cbi8vIFxuXG52YXIgZGVmYXVsdENvbmZpZyA9IHtcbiAgbG9jYWxlOiAnZW4nLFxuICBkZWxheTogMCxcbiAgZXJyb3JCYWdOYW1lOiAnZXJyb3JzJyxcbiAgZGljdGlvbmFyeTogbnVsbCxcbiAgc3RyaWN0OiB0cnVlLFxuICBmaWVsZHNCYWdOYW1lOiAnZmllbGRzJyxcbiAgY2xhc3NlczogZmFsc2UsXG4gIGNsYXNzTmFtZXM6IG51bGwsXG4gIGV2ZW50czogJ2lucHV0fGJsdXInLFxuICBpbmplY3Q6IHRydWUsXG4gIGZhc3RFeGl0OiB0cnVlLFxuICBhcmlhOiB0cnVlLFxuICB2YWxpZGl0eTogZmFsc2UsXG4gIGkxOG46IG51bGwsXG4gIGkxOG5Sb290S2V5OiAndmFsaWRhdGlvbidcbn07XG5cbnZhciBjdXJyZW50Q29uZmlnID0gYXNzaWduKHt9LCBkZWZhdWx0Q29uZmlnKTtcbnZhciBkZXBlbmRlbmNpZXMgPSB7XG4gIGRpY3Rpb25hcnk6IG5ldyBEaWN0aW9uYXJ5KHtcbiAgICBlbjoge1xuICAgICAgbWVzc2FnZXM6IHt9LFxuICAgICAgYXR0cmlidXRlczoge30sXG4gICAgICBjdXN0b206IHt9XG4gICAgfVxuICB9KVxufTtcblxudmFyIENvbmZpZyA9IGZ1bmN0aW9uIENvbmZpZyAoKSB7fTtcblxudmFyIHN0YXRpY0FjY2Vzc29ycyQxID0geyBkZWZhdWx0OiB7fSxjdXJyZW50OiB7fSB9O1xuXG5zdGF0aWNBY2Nlc3NvcnMkMS5kZWZhdWx0LmdldCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIGRlZmF1bHRDb25maWc7XG59O1xuXG5zdGF0aWNBY2Nlc3NvcnMkMS5jdXJyZW50LmdldCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIGN1cnJlbnRDb25maWc7XG59O1xuXG5Db25maWcuZGVwZW5kZW5jeSA9IGZ1bmN0aW9uIGRlcGVuZGVuY3kgKGtleSkge1xuICByZXR1cm4gZGVwZW5kZW5jaWVzW2tleV07XG59O1xuXG4vKipcbiAqIE1lcmdlcyB0aGUgY29uZmlnIHdpdGggYSBuZXcgb25lLlxuICovXG5Db25maWcubWVyZ2UgPSBmdW5jdGlvbiBtZXJnZSQkMSAoY29uZmlnKSB7XG4gIGN1cnJlbnRDb25maWcgPSBhc3NpZ24oe30sIGN1cnJlbnRDb25maWcsIGNvbmZpZyk7XG4gIGlmIChjdXJyZW50Q29uZmlnLmkxOG4pIHtcbiAgICBDb25maWcucmVnaXN0ZXIoJ2RpY3Rpb25hcnknLCBuZXcgSTE4bkRpY3Rpb25hcnkoY3VycmVudENvbmZpZy5pMThuLCBjdXJyZW50Q29uZmlnLmkxOG5Sb290S2V5KSk7XG4gIH1cbn07XG5cbi8qKlxuICogUmVnaXN0ZXJzIGEgZGVwZW5kZW5jeS5cbiAqL1xuQ29uZmlnLnJlZ2lzdGVyID0gZnVuY3Rpb24gcmVnaXN0ZXIgKGtleSwgdmFsdWUpIHtcbiAgZGVwZW5kZW5jaWVzW2tleV0gPSB2YWx1ZTtcbn07XG5cbi8qKlxuICogUmVzb2x2ZXMgdGhlIHdvcmtpbmcgY29uZmlnIGZyb20gYSBWdWUgaW5zdGFuY2UuXG4gKi9cbkNvbmZpZy5yZXNvbHZlID0gZnVuY3Rpb24gcmVzb2x2ZSAoY29udGV4dCkge1xuICB2YXIgc2VsZkNvbmZpZyA9IGdldFBhdGgoJyRvcHRpb25zLiRfdmVlVmFsaWRhdGUnLCBjb250ZXh0LCB7fSk7XG5cbiAgcmV0dXJuIGFzc2lnbih7fSwgQ29uZmlnLmN1cnJlbnQsIHNlbGZDb25maWcpO1xufTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoIENvbmZpZywgc3RhdGljQWNjZXNzb3JzJDEgKTtcblxuLyoqXG4gKiBHZW5lcmF0ZXMgdGhlIG9wdGlvbnMgcmVxdWlyZWQgdG8gY29uc3RydWN0IGEgZmllbGQuXG4gKi9cbnZhciBHZW5lcmF0b3IgPSBmdW5jdGlvbiBHZW5lcmF0b3IgKCkge307XG5cbkdlbmVyYXRvci5nZW5lcmF0ZSA9IGZ1bmN0aW9uIGdlbmVyYXRlIChlbCwgYmluZGluZywgdm5vZGUpIHtcbiAgdmFyIG1vZGVsID0gR2VuZXJhdG9yLnJlc29sdmVNb2RlbChiaW5kaW5nLCB2bm9kZSk7XG4gIHZhciBvcHRpb25zID0gQ29uZmlnLnJlc29sdmUodm5vZGUuY29udGV4dCk7XG5cbiAgcmV0dXJuIHtcbiAgICBuYW1lOiBHZW5lcmF0b3IucmVzb2x2ZU5hbWUoZWwsIHZub2RlKSxcbiAgICBlbDogZWwsXG4gICAgbGlzdGVuOiAhYmluZGluZy5tb2RpZmllcnMuZGlzYWJsZSxcbiAgICBzY29wZTogR2VuZXJhdG9yLnJlc29sdmVTY29wZShlbCwgYmluZGluZywgdm5vZGUpLFxuICAgIHZtOiBHZW5lcmF0b3IubWFrZVZNKHZub2RlLmNvbnRleHQpLFxuICAgIGV4cHJlc3Npb246IGJpbmRpbmcudmFsdWUsXG4gICAgY29tcG9uZW50OiB2bm9kZS5jaGlsZCxcbiAgICBjbGFzc2VzOiBvcHRpb25zLmNsYXNzZXMsXG4gICAgY2xhc3NOYW1lczogb3B0aW9ucy5jbGFzc05hbWVzLFxuICAgIGdldHRlcjogR2VuZXJhdG9yLnJlc29sdmVHZXR0ZXIoZWwsIHZub2RlLCBtb2RlbCksXG4gICAgZXZlbnRzOiBHZW5lcmF0b3IucmVzb2x2ZUV2ZW50cyhlbCwgdm5vZGUpIHx8IG9wdGlvbnMuZXZlbnRzLFxuICAgIG1vZGVsOiBtb2RlbCxcbiAgICBkZWxheTogR2VuZXJhdG9yLnJlc29sdmVEZWxheShlbCwgdm5vZGUsIG9wdGlvbnMpLFxuICAgIHJ1bGVzOiBHZW5lcmF0b3IucmVzb2x2ZVJ1bGVzKGVsLCBiaW5kaW5nKSxcbiAgICBpbml0aWFsOiAhIWJpbmRpbmcubW9kaWZpZXJzLmluaXRpYWwsXG4gICAgdmFsaWRpdHk6IG9wdGlvbnMudmFsaWRpdHksXG4gICAgYXJpYTogb3B0aW9ucy5hcmlhLFxuICAgIGluaXRpYWxWYWx1ZTogR2VuZXJhdG9yLnJlc29sdmVJbml0aWFsVmFsdWUodm5vZGUpXG4gIH07XG59O1xuXG5HZW5lcmF0b3IuZ2V0Q3RvckNvbmZpZyA9IGZ1bmN0aW9uIGdldEN0b3JDb25maWcgKHZub2RlKSB7XG4gIGlmICghdm5vZGUuY2hpbGQpIHsgcmV0dXJuIG51bGw7IH1cblxuICB2YXIgY29uZmlnID0gZ2V0UGF0aCgnY2hpbGQuJG9wdGlvbnMuJF92ZWVWYWxpZGF0ZScsIHZub2RlKTtcblxuICByZXR1cm4gY29uZmlnO1xufTtcblxuLyoqXG4gKiBSZXNvbHZlcyB0aGUgcnVsZXMgZGVmaW5lZCBvbiBhbiBlbGVtZW50LlxuICovXG5HZW5lcmF0b3IucmVzb2x2ZVJ1bGVzID0gZnVuY3Rpb24gcmVzb2x2ZVJ1bGVzIChlbCwgYmluZGluZykge1xuICBpZiAoIWJpbmRpbmcudmFsdWUgJiYgKCFiaW5kaW5nIHx8ICFiaW5kaW5nLmV4cHJlc3Npb24pKSB7XG4gICAgcmV0dXJuIGdldERhdGFBdHRyaWJ1dGUoZWwsICdydWxlcycpO1xuICB9XG5cbiAgaWYgKH5bJ3N0cmluZycsICdvYmplY3QnXS5pbmRleE9mKHR5cGVvZiBiaW5kaW5nLnZhbHVlLnJ1bGVzKSkge1xuICAgIHJldHVybiBiaW5kaW5nLnZhbHVlLnJ1bGVzO1xuICB9XG5cbiAgcmV0dXJuIGJpbmRpbmcudmFsdWU7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7Kn0gdm5vZGVcbiAqL1xuR2VuZXJhdG9yLnJlc29sdmVJbml0aWFsVmFsdWUgPSBmdW5jdGlvbiByZXNvbHZlSW5pdGlhbFZhbHVlICh2bm9kZSkge1xuICB2YXIgbW9kZWwgPSB2bm9kZS5kYXRhLm1vZGVsIHx8IGZpbmQodm5vZGUuZGF0YS5kaXJlY3RpdmVzLCBmdW5jdGlvbiAoZCkgeyByZXR1cm4gZC5uYW1lID09PSAnbW9kZWwnOyB9KTtcblxuICByZXR1cm4gbW9kZWwgJiYgbW9kZWwudmFsdWU7XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBub24tY2lyY3VsYXIgcGFydGlhbCBWTSBpbnN0YW5jZSBmcm9tIGEgVnVlIGluc3RhbmNlLlxuICogQHBhcmFtIHsqfSB2bVxuICovXG5HZW5lcmF0b3IubWFrZVZNID0gZnVuY3Rpb24gbWFrZVZNICh2bSkge1xuICByZXR1cm4ge1xuICAgIGdldCAkZWwgKCkge1xuICAgICAgcmV0dXJuIHZtLiRlbDtcbiAgICB9LFxuICAgIGdldCAkcmVmcyAoKSB7XG4gICAgICByZXR1cm4gdm0uJHJlZnM7XG4gICAgfSxcbiAgICAkd2F0Y2g6IHZtLiR3YXRjaCA/IHZtLiR3YXRjaC5iaW5kKHZtKSA6IGZ1bmN0aW9uICgpIHt9LFxuICAgICR2YWxpZGF0b3I6IHZtLiR2YWxpZGF0b3IgPyB7XG4gICAgICBlcnJvcnM6IHZtLiR2YWxpZGF0b3IuZXJyb3JzLFxuICAgICAgdmFsaWRhdGU6IHZtLiR2YWxpZGF0b3IudmFsaWRhdGUuYmluZCh2bS4kdmFsaWRhdG9yKSxcbiAgICAgIHVwZGF0ZTogdm0uJHZhbGlkYXRvci51cGRhdGUuYmluZCh2bS4kdmFsaWRhdG9yKVxuICAgIH0gOiBudWxsXG4gIH07XG59O1xuXG4vKipcbiAqIFJlc29sdmVzIHRoZSBkZWxheSB2YWx1ZS5cbiAqIEBwYXJhbSB7Kn0gZWxcbiAqIEBwYXJhbSB7Kn0gdm5vZGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKi9cbkdlbmVyYXRvci5yZXNvbHZlRGVsYXkgPSBmdW5jdGlvbiByZXNvbHZlRGVsYXkgKGVsLCB2bm9kZSwgb3B0aW9ucykge1xuICB2YXIgZGVsYXkgPSBnZXREYXRhQXR0cmlidXRlKGVsLCAnZGVsYXknKTtcbiAgdmFyIGdsb2JhbERlbGF5ID0gKG9wdGlvbnMgJiYgJ2RlbGF5JyBpbiBvcHRpb25zKSA/IG9wdGlvbnMuZGVsYXkgOiAwO1xuXG4gIGlmICghZGVsYXkgJiYgdm5vZGUuY2hpbGQgJiYgdm5vZGUuY2hpbGQuJGF0dHJzKSB7XG4gICAgZGVsYXkgPSB2bm9kZS5jaGlsZC4kYXR0cnNbJ2RhdGEtdnYtZGVsYXknXTtcbiAgfVxuXG4gIGlmICghaXNPYmplY3QoZ2xvYmFsRGVsYXkpKSB7XG4gICAgcmV0dXJuIGRlZXBQYXJzZUludChkZWxheSB8fCBnbG9iYWxEZWxheSk7XG4gIH1cblxuICBnbG9iYWxEZWxheS5pbnB1dCA9IGRlbGF5IHx8IDA7XG5cbiAgcmV0dXJuIGRlZXBQYXJzZUludChnbG9iYWxEZWxheSk7XG59O1xuXG4vKipcbiAqIFJlc29sdmVzIHRoZSBldmVudHMgdG8gdmFsaWRhdGUgaW4gcmVzcG9uc2UgdG8uXG4gKiBAcGFyYW0geyp9IGVsXG4gKiBAcGFyYW0geyp9IHZub2RlXG4gKi9cbkdlbmVyYXRvci5yZXNvbHZlRXZlbnRzID0gZnVuY3Rpb24gcmVzb2x2ZUV2ZW50cyAoZWwsIHZub2RlKSB7XG4gIHZhciBldmVudHMgPSBnZXREYXRhQXR0cmlidXRlKGVsLCAndmFsaWRhdGUtb24nKTtcblxuICBpZiAoIWV2ZW50cyAmJiB2bm9kZS5jaGlsZCAmJiB2bm9kZS5jaGlsZC4kYXR0cnMpIHtcbiAgICBldmVudHMgPSB2bm9kZS5jaGlsZC4kYXR0cnNbJ2RhdGEtdnYtdmFsaWRhdGUtb24nXTtcbiAgfVxuXG4gIGlmICghZXZlbnRzICYmIHZub2RlLmNoaWxkKSB7XG4gICAgdmFyIGNvbmZpZyA9IEdlbmVyYXRvci5nZXRDdG9yQ29uZmlnKHZub2RlKTtcbiAgICBldmVudHMgPSBjb25maWcgJiYgY29uZmlnLmV2ZW50cztcbiAgfVxuXG4gIHJldHVybiBldmVudHM7XG59O1xuXG4vKipcbiAqIFJlc29sdmVzIHRoZSBzY29wZSBmb3IgdGhlIGZpZWxkLlxuICogQHBhcmFtIHsqfSBlbFxuICogQHBhcmFtIHsqfSBiaW5kaW5nXG4gKi9cbkdlbmVyYXRvci5yZXNvbHZlU2NvcGUgPSBmdW5jdGlvbiByZXNvbHZlU2NvcGUgKGVsLCBiaW5kaW5nLCB2bm9kZSkge1xuICAgIGlmICggdm5vZGUgPT09IHZvaWQgMCApIHZub2RlID0ge307XG5cbiAgdmFyIHNjb3BlID0gbnVsbDtcbiAgaWYgKHZub2RlLmNoaWxkICYmIGlzTnVsbE9yVW5kZWZpbmVkKHNjb3BlKSkge1xuICAgIHNjb3BlID0gdm5vZGUuY2hpbGQuJGF0dHJzICYmIHZub2RlLmNoaWxkLiRhdHRyc1snZGF0YS12di1zY29wZSddO1xuICB9XG5cbiAgcmV0dXJuICFpc051bGxPclVuZGVmaW5lZChzY29wZSkgPyBzY29wZSA6IGdldFNjb3BlKGVsKTtcbn07XG5cbi8qKlxuICogQ2hlY2tzIGlmIHRoZSBub2RlIGRpcmVjdGl2ZXMgY29udGFpbnMgYSB2LW1vZGVsIG9yIGEgc3BlY2lmaWVkIGFyZy5cbiAqIEFyZ3MgdGFrZSBwcmlvcml0eSBvdmVyIG1vZGVscy5cbiAqXG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKi9cbkdlbmVyYXRvci5yZXNvbHZlTW9kZWwgPSBmdW5jdGlvbiByZXNvbHZlTW9kZWwgKGJpbmRpbmcsIHZub2RlKSB7XG4gIGlmIChiaW5kaW5nLmFyZykge1xuICAgIHJldHVybiBiaW5kaW5nLmFyZztcbiAgfVxuXG4gIHZhciBtb2RlbCA9IHZub2RlLmRhdGEubW9kZWwgfHwgZmluZCh2bm9kZS5kYXRhLmRpcmVjdGl2ZXMsIGZ1bmN0aW9uIChkKSB7IHJldHVybiBkLm5hbWUgPT09ICdtb2RlbCc7IH0pO1xuICBpZiAoIW1vZGVsKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICB2YXIgd2F0Y2hhYmxlID0gL15bYS16X10rWzAtOV0qKFxcdypcXC5bYS16X11cXHcqKSokL2kudGVzdChtb2RlbC5leHByZXNzaW9uKSAmJiBoYXNQYXRoKG1vZGVsLmV4cHJlc3Npb24sIHZub2RlLmNvbnRleHQpO1xuICBpZiAoIXdhdGNoYWJsZSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgcmV0dXJuIG1vZGVsLmV4cHJlc3Npb247XG59O1xuXG4vKipcbiAgICogUmVzb2x2ZXMgdGhlIGZpZWxkIG5hbWUgdG8gdHJpZ2dlciB2YWxpZGF0aW9ucy5cbiAgICogQHJldHVybiB7U3RyaW5nfSBUaGUgZmllbGQgbmFtZS5cbiAgICovXG5HZW5lcmF0b3IucmVzb2x2ZU5hbWUgPSBmdW5jdGlvbiByZXNvbHZlTmFtZSAoZWwsIHZub2RlKSB7XG4gIHZhciBuYW1lID0gZ2V0RGF0YUF0dHJpYnV0ZShlbCwgJ25hbWUnKTtcblxuICBpZiAoIW5hbWUgJiYgIXZub2RlLmNoaWxkKSB7XG4gICAgcmV0dXJuIGVsLm5hbWU7XG4gIH1cblxuICBpZiAoIW5hbWUgJiYgdm5vZGUuY2hpbGQgJiYgdm5vZGUuY2hpbGQuJGF0dHJzKSB7XG4gICAgbmFtZSA9IHZub2RlLmNoaWxkLiRhdHRyc1snZGF0YS12di1uYW1lJ10gfHwgdm5vZGUuY2hpbGQuJGF0dHJzWyduYW1lJ107XG4gIH1cblxuICBpZiAoIW5hbWUgJiYgdm5vZGUuY2hpbGQpIHtcbiAgICB2YXIgY29uZmlnID0gR2VuZXJhdG9yLmdldEN0b3JDb25maWcodm5vZGUpO1xuICAgIGlmIChjb25maWcgJiYgaXNDYWxsYWJsZShjb25maWcubmFtZSkpIHtcbiAgICAgIHZhciBib3VuZEdldHRlciA9IGNvbmZpZy5uYW1lLmJpbmQodm5vZGUuY2hpbGQpO1xuXG4gICAgICByZXR1cm4gYm91bmRHZXR0ZXIoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdm5vZGUuY2hpbGQubmFtZTtcbiAgfVxuXG4gIHJldHVybiBuYW1lO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIGEgdmFsdWUgZ2V0dGVyIGlucHV0IHR5cGUuXG4gKi9cbkdlbmVyYXRvci5yZXNvbHZlR2V0dGVyID0gZnVuY3Rpb24gcmVzb2x2ZUdldHRlciAoZWwsIHZub2RlLCBtb2RlbCkge1xuICBpZiAobW9kZWwpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIGdldFBhdGgobW9kZWwsIHZub2RlLmNvbnRleHQpO1xuICAgIH07XG4gIH1cblxuICBpZiAodm5vZGUuY2hpbGQpIHtcbiAgICB2YXIgcGF0aCA9IGdldERhdGFBdHRyaWJ1dGUoZWwsICd2YWx1ZS1wYXRoJykgfHwgKHZub2RlLmNoaWxkLiRhdHRycyAmJiB2bm9kZS5jaGlsZC4kYXR0cnNbJ2RhdGEtdnYtdmFsdWUtcGF0aCddKTtcbiAgICBpZiAocGF0aCkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGdldFBhdGgocGF0aCwgdm5vZGUuY2hpbGQpO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICB2YXIgY29uZmlnID0gR2VuZXJhdG9yLmdldEN0b3JDb25maWcodm5vZGUpO1xuICAgIGlmIChjb25maWcgJiYgaXNDYWxsYWJsZShjb25maWcudmFsdWUpKSB7XG4gICAgICB2YXIgYm91bmRHZXR0ZXIgPSBjb25maWcudmFsdWUuYmluZCh2bm9kZS5jaGlsZCk7XG5cbiAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBib3VuZEdldHRlcigpO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHZub2RlLmNoaWxkLnZhbHVlO1xuICAgIH07XG4gIH1cblxuICBzd2l0Y2ggKGVsLnR5cGUpIHtcbiAgY2FzZSAnY2hlY2tib3gnOiByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHZhciBlbHMgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKChcImlucHV0W25hbWU9XFxcIlwiICsgKGVsLm5hbWUpICsgXCJcXFwiXVwiKSk7XG5cbiAgICBlbHMgPSB0b0FycmF5KGVscykuZmlsdGVyKGZ1bmN0aW9uIChlbCkgeyByZXR1cm4gZWwuY2hlY2tlZDsgfSk7XG4gICAgaWYgKCFlbHMubGVuZ3RoKSB7IHJldHVybiB1bmRlZmluZWQ7IH1cblxuICAgIHJldHVybiBlbHMubWFwKGZ1bmN0aW9uIChjaGVja2JveCkgeyByZXR1cm4gY2hlY2tib3gudmFsdWU7IH0pO1xuICB9O1xuICBjYXNlICdyYWRpbyc6IHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGVscyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoKFwiaW5wdXRbbmFtZT1cXFwiXCIgKyAoZWwubmFtZSkgKyBcIlxcXCJdXCIpKTtcbiAgICB2YXIgZWxtID0gZmluZChlbHMsIGZ1bmN0aW9uIChlbCkgeyByZXR1cm4gZWwuY2hlY2tlZDsgfSk7XG5cbiAgICByZXR1cm4gZWxtICYmIGVsbS52YWx1ZTtcbiAgfTtcbiAgY2FzZSAnZmlsZSc6IHJldHVybiBmdW5jdGlvbiAoY29udGV4dCkge1xuICAgIHJldHVybiB0b0FycmF5KGVsLmZpbGVzKTtcbiAgfTtcbiAgY2FzZSAnc2VsZWN0LW11bHRpcGxlJzogcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdG9BcnJheShlbC5vcHRpb25zKS5maWx0ZXIoZnVuY3Rpb24gKG9wdCkgeyByZXR1cm4gb3B0LnNlbGVjdGVkOyB9KS5tYXAoZnVuY3Rpb24gKG9wdCkgeyByZXR1cm4gb3B0LnZhbHVlOyB9KTtcbiAgfTtcbiAgZGVmYXVsdDogcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gZWwgJiYgZWwudmFsdWU7XG4gIH07XG4gIH1cbn07XG5cbi8vIFxuXG52YXIgREVGQVVMVF9PUFRJT05TID0ge1xuICB0YXJnZXRPZjogbnVsbCxcbiAgaW5pdGlhbDogZmFsc2UsXG4gIHNjb3BlOiBudWxsLFxuICBsaXN0ZW46IHRydWUsXG4gIG5hbWU6IG51bGwsXG4gIHJ1bGVzOiB7fSxcbiAgdm06IG51bGwsXG4gIGNsYXNzZXM6IGZhbHNlLFxuICB2YWxpZGl0eTogdHJ1ZSxcbiAgYXJpYTogdHJ1ZSxcbiAgZXZlbnRzOiAnaW5wdXR8Ymx1cicsXG4gIGRlbGF5OiAwLFxuICBjbGFzc05hbWVzOiB7XG4gICAgdG91Y2hlZDogJ3RvdWNoZWQnLCAvLyB0aGUgY29udHJvbCBoYXMgYmVlbiBibHVycmVkXG4gICAgdW50b3VjaGVkOiAndW50b3VjaGVkJywgLy8gdGhlIGNvbnRyb2wgaGFzbid0IGJlZW4gYmx1cnJlZFxuICAgIHZhbGlkOiAndmFsaWQnLCAvLyBtb2RlbCBpcyB2YWxpZFxuICAgIGludmFsaWQ6ICdpbnZhbGlkJywgLy8gbW9kZWwgaXMgaW52YWxpZFxuICAgIHByaXN0aW5lOiAncHJpc3RpbmUnLCAvLyBjb250cm9sIGhhcyBub3QgYmVlbiBpbnRlcmFjdGVkIHdpdGhcbiAgICBkaXJ0eTogJ2RpcnR5JyAvLyBjb250cm9sIGhhcyBiZWVuIGludGVyYWN0ZWQgd2l0aFxuICB9XG59O1xuXG52YXIgRmllbGQgPSBmdW5jdGlvbiBGaWVsZCAoZWwsIG9wdGlvbnMpIHtcbiAgaWYgKCBvcHRpb25zID09PSB2b2lkIDAgKSBvcHRpb25zID0ge307XG5cbiAgdGhpcy5pZCA9IHVuaXFJZCgpO1xuICB0aGlzLmVsID0gZWw7XG4gIHRoaXMudXBkYXRlZCA9IGZhbHNlO1xuICB0aGlzLmRlcGVuZGVuY2llcyA9IFtdO1xuICB0aGlzLndhdGNoZXJzID0gW107XG4gIHRoaXMuZXZlbnRzID0gW107XG4gIHRoaXMuZGVsYXkgPSAwO1xuICB0aGlzLnJ1bGVzID0ge307XG4gIHRoaXMuX2NhY2hlSWQob3B0aW9ucyk7XG4gIHRoaXMuY2xhc3NOYW1lcyA9IGFzc2lnbih7fSwgREVGQVVMVF9PUFRJT05TLmNsYXNzTmFtZXMpO1xuICBvcHRpb25zID0gYXNzaWduKHt9LCBERUZBVUxUX09QVElPTlMsIG9wdGlvbnMpO1xuICB0aGlzLl9kZWxheSA9ICFpc051bGxPclVuZGVmaW5lZChvcHRpb25zLmRlbGF5KSA/IG9wdGlvbnMuZGVsYXkgOiAwOyAvLyBjYWNoZSBpbml0aWFsIGRlbGF5XG4gIHRoaXMudmFsaWRpdHkgPSBvcHRpb25zLnZhbGlkaXR5O1xuICB0aGlzLmFyaWEgPSBvcHRpb25zLmFyaWE7XG4gIHRoaXMuZmxhZ3MgPSBjcmVhdGVGbGFncygpO1xuICB0aGlzLnZtID0gb3B0aW9ucy52bTtcbiAgdGhpcy5jb21wb25lbnQgPSBvcHRpb25zLmNvbXBvbmVudDtcbiAgdGhpcy5jdG9yQ29uZmlnID0gdGhpcy5jb21wb25lbnQgPyBnZXRQYXRoKCckb3B0aW9ucy4kX3ZlZVZhbGlkYXRlJywgdGhpcy5jb21wb25lbnQpIDogdW5kZWZpbmVkO1xuICB0aGlzLnVwZGF0ZShvcHRpb25zKTtcbiAgdGhpcy51cGRhdGVkID0gZmFsc2U7XG59O1xuXG52YXIgcHJvdG90eXBlQWNjZXNzb3JzJDEgPSB7IHZhbGlkYXRvcjoge30saXNSZXF1aXJlZDoge30saXNEaXNhYmxlZDoge30sYWxpYXM6IHt9LHZhbHVlOiB7fSxyZWplY3RzRmFsc2U6IHt9IH07XG5cbnByb3RvdHlwZUFjY2Vzc29ycyQxLnZhbGlkYXRvci5nZXQgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICghdGhpcy52bSB8fCAhdGhpcy52bS4kdmFsaWRhdG9yKSB7XG4gICAgd2FybignTm8gdmFsaWRhdG9yIGluc3RhbmNlIGRldGVjdGVkLicpO1xuICAgIHJldHVybiB7IHZhbGlkYXRlOiBmdW5jdGlvbiAoKSB7fSB9O1xuICB9XG5cbiAgcmV0dXJuIHRoaXMudm0uJHZhbGlkYXRvcjtcbn07XG5cbnByb3RvdHlwZUFjY2Vzc29ycyQxLmlzUmVxdWlyZWQuZ2V0ID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gISF0aGlzLnJ1bGVzLnJlcXVpcmVkO1xufTtcblxucHJvdG90eXBlQWNjZXNzb3JzJDEuaXNEaXNhYmxlZC5nZXQgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiAhISh0aGlzLmNvbXBvbmVudCAmJiB0aGlzLmNvbXBvbmVudC5kaXNhYmxlZCkgfHwgISEodGhpcy5lbCAmJiB0aGlzLmVsLmRpc2FibGVkKTtcbn07XG5cbi8qKlxuICogR2V0cyB0aGUgZGlzcGxheSBuYW1lICh1c2VyLWZyaWVuZGx5IG5hbWUpLlxuICovXG5wcm90b3R5cGVBY2Nlc3NvcnMkMS5hbGlhcy5nZXQgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICh0aGlzLl9hbGlhcykge1xuICAgIHJldHVybiB0aGlzLl9hbGlhcztcbiAgfVxuXG4gIHZhciBhbGlhcyA9IG51bGw7XG4gIGlmICh0aGlzLmVsKSB7XG4gICAgYWxpYXMgPSBnZXREYXRhQXR0cmlidXRlKHRoaXMuZWwsICdhcycpO1xuICB9XG5cbiAgaWYgKCFhbGlhcyAmJiB0aGlzLmNvbXBvbmVudCkge1xuICAgIHJldHVybiB0aGlzLmNvbXBvbmVudC4kYXR0cnMgJiYgdGhpcy5jb21wb25lbnQuJGF0dHJzWydkYXRhLXZ2LWFzJ107XG4gIH1cblxuICByZXR1cm4gYWxpYXM7XG59O1xuXG4vKipcbiAqIEdldHMgdGhlIGlucHV0IHZhbHVlLlxuICovXG5cbnByb3RvdHlwZUFjY2Vzc29ycyQxLnZhbHVlLmdldCA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKCFpc0NhbGxhYmxlKHRoaXMuZ2V0dGVyKSkge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cblxuICByZXR1cm4gdGhpcy5nZXR0ZXIoKTtcbn07XG5cbi8qKlxuICogSWYgdGhlIGZpZWxkIHJlamVjdHMgZmFsc2UgYXMgYSB2YWxpZCB2YWx1ZSBmb3IgdGhlIHJlcXVpcmVkIHJ1bGUuXG4gKi9cblxucHJvdG90eXBlQWNjZXNzb3JzJDEucmVqZWN0c0ZhbHNlLmdldCA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKHRoaXMuY29tcG9uZW50ICYmIHRoaXMuY3RvckNvbmZpZykge1xuICAgIHJldHVybiAhIXRoaXMuY3RvckNvbmZpZy5yZWplY3RzRmFsc2U7XG4gIH1cblxuICBpZiAoIXRoaXMuZWwpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gdGhpcy5lbC50eXBlID09PSAnY2hlY2tib3gnO1xufTtcblxuLyoqXG4gKiBEZXRlcm1pbmVzIGlmIHRoZSBpbnN0YW5jZSBtYXRjaGVzIHRoZSBvcHRpb25zIHByb3ZpZGVkLlxuICovXG5GaWVsZC5wcm90b3R5cGUubWF0Y2hlcyA9IGZ1bmN0aW9uIG1hdGNoZXMgKG9wdGlvbnMpIHtcbiAgaWYgKG9wdGlvbnMuaWQpIHtcbiAgICByZXR1cm4gdGhpcy5pZCA9PT0gb3B0aW9ucy5pZDtcbiAgfVxuXG4gIGlmIChvcHRpb25zLm5hbWUgPT09IHVuZGVmaW5lZCAmJiBvcHRpb25zLnNjb3BlID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGlmIChvcHRpb25zLnNjb3BlID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gdGhpcy5uYW1lID09PSBvcHRpb25zLm5hbWU7XG4gIH1cblxuICBpZiAob3B0aW9ucy5uYW1lID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gdGhpcy5zY29wZSA9PT0gb3B0aW9ucy5zY29wZTtcbiAgfVxuXG4gIHJldHVybiBvcHRpb25zLm5hbWUgPT09IHRoaXMubmFtZSAmJiBvcHRpb25zLnNjb3BlID09PSB0aGlzLnNjb3BlO1xufTtcblxuLyoqXG4gKiBDYWNoZXMgdGhlIGZpZWxkIGlkLlxuICovXG5GaWVsZC5wcm90b3R5cGUuX2NhY2hlSWQgPSBmdW5jdGlvbiBfY2FjaGVJZCAob3B0aW9ucykge1xuICBpZiAodGhpcy5lbCAmJiAhb3B0aW9ucy50YXJnZXRPZikge1xuICAgIHNldERhdGFBdHRyaWJ1dGUodGhpcy5lbCwgJ2lkJywgdGhpcy5pZCk7IC8vIGNhY2hlIGZpZWxkIGlkIGlmIGl0IGlzIGluZGVwZW5kZW50IGFuZCBoYXMgYSByb290IGVsZW1lbnQuXG4gIH1cbn07XG5cbi8qKlxuICogVXBkYXRlcyB0aGUgZmllbGQgd2l0aCBjaGFuZ2VkIGRhdGEuXG4gKi9cbkZpZWxkLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiB1cGRhdGUgKG9wdGlvbnMpIHtcbiAgdGhpcy50YXJnZXRPZiA9IG9wdGlvbnMudGFyZ2V0T2YgfHwgbnVsbDtcbiAgdGhpcy5pbml0aWFsID0gb3B0aW9ucy5pbml0aWFsIHx8IHRoaXMuaW5pdGlhbCB8fCBmYWxzZTtcblxuICAvLyB1cGRhdGUgZXJyb3JzIHNjb3BlIGlmIHRoZSBmaWVsZCBzY29wZSB3YXMgY2hhbmdlZC5cbiAgaWYgKCFpc051bGxPclVuZGVmaW5lZChvcHRpb25zLnNjb3BlKSAmJiBvcHRpb25zLnNjb3BlICE9PSB0aGlzLnNjb3BlICYmIGlzQ2FsbGFibGUodGhpcy52YWxpZGF0b3IudXBkYXRlKSkge1xuICAgIHRoaXMudmFsaWRhdG9yLnVwZGF0ZSh0aGlzLmlkLCB7IHNjb3BlOiBvcHRpb25zLnNjb3BlIH0pO1xuICB9XG4gIHRoaXMuc2NvcGUgPSAhaXNOdWxsT3JVbmRlZmluZWQob3B0aW9ucy5zY29wZSkgPyBvcHRpb25zLnNjb3BlXG4gICAgOiAhaXNOdWxsT3JVbmRlZmluZWQodGhpcy5zY29wZSkgPyB0aGlzLnNjb3BlIDogbnVsbDtcbiAgdGhpcy5uYW1lID0gKCFpc051bGxPclVuZGVmaW5lZChvcHRpb25zLm5hbWUpID8gU3RyaW5nKG9wdGlvbnMubmFtZSkgOiBvcHRpb25zLm5hbWUpIHx8IHRoaXMubmFtZSB8fCBudWxsO1xuICB0aGlzLnJ1bGVzID0gb3B0aW9ucy5ydWxlcyAhPT0gdW5kZWZpbmVkID8gbm9ybWFsaXplUnVsZXMob3B0aW9ucy5ydWxlcykgOiB0aGlzLnJ1bGVzO1xuICB0aGlzLm1vZGVsID0gb3B0aW9ucy5tb2RlbCB8fCB0aGlzLm1vZGVsO1xuICB0aGlzLmxpc3RlbiA9IG9wdGlvbnMubGlzdGVuICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmxpc3RlbiA6IHRoaXMubGlzdGVuO1xuICB0aGlzLmNsYXNzZXMgPSAob3B0aW9ucy5jbGFzc2VzIHx8IHRoaXMuY2xhc3NlcyB8fCBmYWxzZSkgJiYgIXRoaXMuY29tcG9uZW50O1xuICB0aGlzLmNsYXNzTmFtZXMgPSBpc09iamVjdChvcHRpb25zLmNsYXNzTmFtZXMpID8gbWVyZ2UodGhpcy5jbGFzc05hbWVzLCBvcHRpb25zLmNsYXNzTmFtZXMpIDogdGhpcy5jbGFzc05hbWVzO1xuICB0aGlzLmdldHRlciA9IGlzQ2FsbGFibGUob3B0aW9ucy5nZXR0ZXIpID8gb3B0aW9ucy5nZXR0ZXIgOiB0aGlzLmdldHRlcjtcbiAgdGhpcy5fYWxpYXMgPSBvcHRpb25zLmFsaWFzIHx8IHRoaXMuX2FsaWFzO1xuICB0aGlzLmV2ZW50cyA9IChvcHRpb25zLmV2ZW50cykgPyBtYWtlRXZlbnRzQXJyYXkob3B0aW9ucy5ldmVudHMpIDogdGhpcy5ldmVudHM7XG4gIHRoaXMuZGVsYXkgPSAob3B0aW9ucy5kZWxheSkgPyBtYWtlRGVsYXlPYmplY3QodGhpcy5ldmVudHMsIG9wdGlvbnMuZGVsYXksIHRoaXMuX2RlbGF5KSA6IG1ha2VEZWxheU9iamVjdCh0aGlzLmV2ZW50cywgdGhpcy5kZWxheSwgdGhpcy5fZGVsYXkpO1xuICB0aGlzLnVwZGF0ZURlcGVuZGVuY2llcygpO1xuICB0aGlzLmFkZEFjdGlvbkxpc3RlbmVycygpO1xuXG4gIC8vIHVwZGF0ZSByZXF1aXJlZCBmbGFnIGZsYWdzXG4gIGlmIChvcHRpb25zLnJ1bGVzICE9PSB1bmRlZmluZWQpIHtcbiAgICB0aGlzLmZsYWdzLnJlcXVpcmVkID0gdGhpcy5pc1JlcXVpcmVkO1xuICB9XG5cbiAgLy8gdmFsaWRhdGUgaWYgaXQgd2FzIHZhbGlkYXRlZCBiZWZvcmUgYW5kIGZpZWxkIHdhcyB1cGRhdGVkIGFuZCB0aGVyZSB3YXMgYSBydWxlcyBtdXRhdGlvbi5cbiAgaWYgKHRoaXMuZmxhZ3MudmFsaWRhdGVkICYmIG9wdGlvbnMucnVsZXMgIT09IHVuZGVmaW5lZCAmJiB0aGlzLnVwZGF0ZWQpIHtcbiAgICB0aGlzLnZhbGlkYXRvci52YWxpZGF0ZSgoXCIjXCIgKyAodGhpcy5pZCkpKTtcbiAgfVxuXG4gIHRoaXMudXBkYXRlZCA9IHRydWU7XG4gIHRoaXMuYWRkVmFsdWVMaXN0ZW5lcnMoKTtcblxuICAvLyBubyBuZWVkIHRvIGNvbnRpbnVlLlxuICBpZiAoIXRoaXMuZWwpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB0aGlzLnVwZGF0ZUNsYXNzZXMoKTtcbiAgdGhpcy51cGRhdGVBcmlhQXR0cnMoKTtcbn07XG5cbi8qKlxuICogUmVzZXRzIGZpZWxkIGZsYWdzIGFuZCBlcnJvcnMuXG4gKi9cbkZpZWxkLnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uIHJlc2V0ICgpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICB2YXIgZGVmYXVsdHMgPSBjcmVhdGVGbGFncygpO1xuICBPYmplY3Qua2V5cyh0aGlzLmZsYWdzKS5maWx0ZXIoZnVuY3Rpb24gKGZsYWcpIHsgcmV0dXJuIGZsYWcgIT09ICdyZXF1aXJlZCc7IH0pLmZvckVhY2goZnVuY3Rpb24gKGZsYWcpIHtcbiAgICB0aGlzJDEuZmxhZ3NbZmxhZ10gPSBkZWZhdWx0c1tmbGFnXTtcbiAgfSk7XG5cbiAgdGhpcy5hZGRBY3Rpb25MaXN0ZW5lcnMoKTtcbiAgdGhpcy51cGRhdGVDbGFzc2VzKCk7XG4gIHRoaXMudXBkYXRlQXJpYUF0dHJzKCk7XG4gIHRoaXMudXBkYXRlQ3VzdG9tVmFsaWRpdHkoKTtcbn07XG5cbi8qKlxuICogU2V0cyB0aGUgZmxhZ3MgYW5kIHRoZWlyIG5lZ2F0ZWQgY291bnRlcnBhcnRzLCBhbmQgdXBkYXRlcyB0aGUgY2xhc3NlcyBhbmQgcmUtYWRkcyBhY3Rpb24gbGlzdGVuZXJzLlxuICovXG5GaWVsZC5wcm90b3R5cGUuc2V0RmxhZ3MgPSBmdW5jdGlvbiBzZXRGbGFncyAoZmxhZ3MpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICB2YXIgbmVnYXRlZCA9IHtcbiAgICBwcmlzdGluZTogJ2RpcnR5JyxcbiAgICBkaXJ0eTogJ3ByaXN0aW5lJyxcbiAgICB2YWxpZDogJ2ludmFsaWQnLFxuICAgIGludmFsaWQ6ICd2YWxpZCcsXG4gICAgdG91Y2hlZDogJ3VudG91Y2hlZCcsXG4gICAgdW50b3VjaGVkOiAndG91Y2hlZCdcbiAgfTtcblxuICBPYmplY3Qua2V5cyhmbGFncykuZm9yRWFjaChmdW5jdGlvbiAoZmxhZykge1xuICAgIHRoaXMkMS5mbGFnc1tmbGFnXSA9IGZsYWdzW2ZsYWddO1xuICAgIC8vIGlmIGl0IGhhcyBhIG5lZ2F0aW9uIGFuZCB3YXMgbm90IHNwZWNpZmllZCwgc2V0IGl0IGFzIHdlbGwuXG4gICAgaWYgKG5lZ2F0ZWRbZmxhZ10gJiYgZmxhZ3NbbmVnYXRlZFtmbGFnXV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcyQxLmZsYWdzW25lZ2F0ZWRbZmxhZ11dID0gIWZsYWdzW2ZsYWddO1xuICAgIH1cbiAgfSk7XG5cbiAgaWYgKFxuICAgIGZsYWdzLnVudG91Y2hlZCAhPT0gdW5kZWZpbmVkIHx8XG4gICAgZmxhZ3MudG91Y2hlZCAhPT0gdW5kZWZpbmVkIHx8XG4gICAgZmxhZ3MuZGlydHkgIT09IHVuZGVmaW5lZCB8fFxuICAgIGZsYWdzLnByaXN0aW5lICE9PSB1bmRlZmluZWRcbiAgKSB7XG4gICAgdGhpcy5hZGRBY3Rpb25MaXN0ZW5lcnMoKTtcbiAgfVxuICB0aGlzLnVwZGF0ZUNsYXNzZXMoKTtcbiAgdGhpcy51cGRhdGVBcmlhQXR0cnMoKTtcbiAgdGhpcy51cGRhdGVDdXN0b21WYWxpZGl0eSgpO1xufTtcblxuLyoqXG4gKiBEZXRlcm1pbmVzIGlmIHRoZSBmaWVsZCByZXF1aXJlcyByZWZlcmVuY2VzIHRvIHRhcmdldCBmaWVsZHMuXG4qL1xuRmllbGQucHJvdG90eXBlLnVwZGF0ZURlcGVuZGVuY2llcyA9IGZ1bmN0aW9uIHVwZGF0ZURlcGVuZGVuY2llcyAoKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgLy8gcmVzZXQgZGVwZW5kZW5jaWVzLlxuICB0aGlzLmRlcGVuZGVuY2llcy5mb3JFYWNoKGZ1bmN0aW9uIChkKSB7IHJldHVybiBkLmZpZWxkLmRlc3Ryb3koKTsgfSk7XG4gIHRoaXMuZGVwZW5kZW5jaWVzID0gW107XG5cbiAgLy8gd2UgZ2V0IHRoZSBzZWxlY3RvcnMgZm9yIGVhY2ggZmllbGQuXG4gIHZhciBmaWVsZHMgPSBPYmplY3Qua2V5cyh0aGlzLnJ1bGVzKS5yZWR1Y2UoZnVuY3Rpb24gKHByZXYsIHIpIHtcbiAgICBpZiAoVmFsaWRhdG9yLmlzVGFyZ2V0UnVsZShyKSkge1xuICAgICAgdmFyIHNlbGVjdG9yID0gdGhpcyQxLnJ1bGVzW3JdWzBdO1xuICAgICAgaWYgKHIgPT09ICdjb25maXJtZWQnICYmICFzZWxlY3Rvcikge1xuICAgICAgICBzZWxlY3RvciA9ICh0aGlzJDEubmFtZSkgKyBcIl9jb25maXJtYXRpb25cIjtcbiAgICAgIH1cblxuICAgICAgcHJldi5wdXNoKHsgc2VsZWN0b3I6IHNlbGVjdG9yLCBuYW1lOiByIH0pO1xuICAgIH1cblxuICAgIHJldHVybiBwcmV2O1xuICB9LCBbXSk7XG5cbiAgaWYgKCFmaWVsZHMubGVuZ3RoIHx8ICF0aGlzLnZtIHx8ICF0aGlzLnZtLiRlbCkgeyByZXR1cm47IH1cblxuICAvLyBtdXN0IGJlIGNvbnRhaW5lZCB3aXRoaW4gdGhlIHNhbWUgY29tcG9uZW50LCBzbyB3ZSB1c2UgdGhlIHZtIHJvb3QgZWxlbWVudCBjb25zdHJhaW4gb3VyIGRvbSBzZWFyY2guXG4gIGZpZWxkcy5mb3JFYWNoKGZ1bmN0aW9uIChyZWYpIHtcbiAgICAgIHZhciBzZWxlY3RvciA9IHJlZi5zZWxlY3RvcjtcbiAgICAgIHZhciBuYW1lID0gcmVmLm5hbWU7XG5cbiAgICB2YXIgZWwgPSBudWxsO1xuICAgIC8vIHZ1ZSByZWYgc2VsZWN0b3IuXG4gICAgaWYgKHNlbGVjdG9yWzBdID09PSAnJCcpIHtcbiAgICAgIGVsID0gdGhpcyQxLnZtLiRyZWZzW3NlbGVjdG9yLnNsaWNlKDEpXTtcbiAgICB9IGVsc2Uge1xuICAgICAgdHJ5IHtcbiAgICAgICAgLy8gdHJ5IHF1ZXJ5IHNlbGVjdG9yXG4gICAgICAgIGVsID0gdGhpcyQxLnZtLiRlbC5xdWVyeVNlbGVjdG9yKHNlbGVjdG9yKTtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBlbCA9IG51bGw7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCFlbCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgZWwgPSB0aGlzJDEudm0uJGVsLnF1ZXJ5U2VsZWN0b3IoKFwiaW5wdXRbbmFtZT1cXFwiXCIgKyBzZWxlY3RvciArIFwiXFxcIl1cIikpO1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGVsID0gbnVsbDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIWVsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIG9wdGlvbnMgPSB7XG4gICAgICB2bTogdGhpcyQxLnZtLFxuICAgICAgY2xhc3NlczogdGhpcyQxLmNsYXNzZXMsXG4gICAgICBjbGFzc05hbWVzOiB0aGlzJDEuY2xhc3NOYW1lcyxcbiAgICAgIGRlbGF5OiB0aGlzJDEuZGVsYXksXG4gICAgICBzY29wZTogdGhpcyQxLnNjb3BlLFxuICAgICAgZXZlbnRzOiB0aGlzJDEuZXZlbnRzLmpvaW4oJ3wnKSxcbiAgICAgIGluaXRpYWw6IHRoaXMkMS5pbml0aWFsLFxuICAgICAgdGFyZ2V0T2Y6IHRoaXMkMS5pZFxuICAgIH07XG5cbiAgICAvLyBwcm9iYWJseSBhIGNvbXBvbmVudC5cbiAgICBpZiAoaXNDYWxsYWJsZShlbC4kd2F0Y2gpKSB7XG4gICAgICBvcHRpb25zLmNvbXBvbmVudCA9IGVsO1xuICAgICAgb3B0aW9ucy5lbCA9IGVsLiRlbDtcbiAgICAgIG9wdGlvbnMuZ2V0dGVyID0gR2VuZXJhdG9yLnJlc29sdmVHZXR0ZXIoZWwuJGVsLCB7IGNoaWxkOiBlbCB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgb3B0aW9ucy5lbCA9IGVsO1xuICAgICAgb3B0aW9ucy5nZXR0ZXIgPSBHZW5lcmF0b3IucmVzb2x2ZUdldHRlcihlbCwge30pO1xuICAgIH1cblxuICAgIHRoaXMkMS5kZXBlbmRlbmNpZXMucHVzaCh7IG5hbWU6IG5hbWUsIGZpZWxkOiBuZXcgRmllbGQob3B0aW9ucy5lbCwgb3B0aW9ucykgfSk7XG4gIH0pO1xufTtcblxuLyoqXG4gKiBSZW1vdmVzIGxpc3RlbmVycy5cbiAqL1xuRmllbGQucHJvdG90eXBlLnVud2F0Y2ggPSBmdW5jdGlvbiB1bndhdGNoICh0YWcpIHtcbiAgICBpZiAoIHRhZyA9PT0gdm9pZCAwICkgdGFnID0gbnVsbDtcblxuICBpZiAoIXRhZykge1xuICAgIHRoaXMud2F0Y2hlcnMuZm9yRWFjaChmdW5jdGlvbiAodykgeyByZXR1cm4gdy51bndhdGNoKCk7IH0pO1xuICAgIHRoaXMud2F0Y2hlcnMgPSBbXTtcbiAgICByZXR1cm47XG4gIH1cblxuICB0aGlzLndhdGNoZXJzLmZpbHRlcihmdW5jdGlvbiAodykgeyByZXR1cm4gdGFnLnRlc3Qody50YWcpOyB9KS5mb3JFYWNoKGZ1bmN0aW9uICh3KSB7IHJldHVybiB3LnVud2F0Y2goKTsgfSk7XG4gIHRoaXMud2F0Y2hlcnMgPSB0aGlzLndhdGNoZXJzLmZpbHRlcihmdW5jdGlvbiAodykgeyByZXR1cm4gIXRhZy50ZXN0KHcudGFnKTsgfSk7XG59O1xuXG4vKipcbiAqIFVwZGF0ZXMgdGhlIGVsZW1lbnQgY2xhc3NlcyBkZXBlbmRpbmcgb24gZWFjaCBmaWVsZCBmbGFnIHN0YXR1cy5cbiAqL1xuRmllbGQucHJvdG90eXBlLnVwZGF0ZUNsYXNzZXMgPSBmdW5jdGlvbiB1cGRhdGVDbGFzc2VzICgpIHtcbiAgaWYgKCF0aGlzLmNsYXNzZXMgfHwgdGhpcy5pc0Rpc2FibGVkKSB7IHJldHVybjsgfVxuXG4gIHRvZ2dsZUNsYXNzKHRoaXMuZWwsIHRoaXMuY2xhc3NOYW1lcy5kaXJ0eSwgdGhpcy5mbGFncy5kaXJ0eSk7XG4gIHRvZ2dsZUNsYXNzKHRoaXMuZWwsIHRoaXMuY2xhc3NOYW1lcy5wcmlzdGluZSwgdGhpcy5mbGFncy5wcmlzdGluZSk7XG4gIHRvZ2dsZUNsYXNzKHRoaXMuZWwsIHRoaXMuY2xhc3NOYW1lcy50b3VjaGVkLCB0aGlzLmZsYWdzLnRvdWNoZWQpO1xuICB0b2dnbGVDbGFzcyh0aGlzLmVsLCB0aGlzLmNsYXNzTmFtZXMudW50b3VjaGVkLCB0aGlzLmZsYWdzLnVudG91Y2hlZCk7XG4gIC8vIG1ha2Ugc3VyZSB3ZSBkb24ndCBzZXQgYW55IGNsYXNzZXMgaWYgdGhlIHN0YXRlIGlzIHVuZGV0ZXJtaW5lZC5cbiAgaWYgKCFpc051bGxPclVuZGVmaW5lZCh0aGlzLmZsYWdzLnZhbGlkKSAmJiB0aGlzLmZsYWdzLnZhbGlkYXRlZCkge1xuICAgIHRvZ2dsZUNsYXNzKHRoaXMuZWwsIHRoaXMuY2xhc3NOYW1lcy52YWxpZCwgdGhpcy5mbGFncy52YWxpZCk7XG4gIH1cblxuICBpZiAoIWlzTnVsbE9yVW5kZWZpbmVkKHRoaXMuZmxhZ3MuaW52YWxpZCkgJiYgdGhpcy5mbGFncy52YWxpZGF0ZWQpIHtcbiAgICB0b2dnbGVDbGFzcyh0aGlzLmVsLCB0aGlzLmNsYXNzTmFtZXMuaW52YWxpZCwgdGhpcy5mbGFncy5pbnZhbGlkKTtcbiAgfVxufTtcblxuLyoqXG4gKiBBZGRzIHRoZSBsaXN0ZW5lcnMgcmVxdWlyZWQgZm9yIGF1dG9tYXRpYyBjbGFzc2VzIGFuZCBzb21lIGZsYWdzLlxuICovXG5GaWVsZC5wcm90b3R5cGUuYWRkQWN0aW9uTGlzdGVuZXJzID0gZnVuY3Rpb24gYWRkQWN0aW9uTGlzdGVuZXJzICgpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAvLyByZW1vdmUgcHJldmlvdXMgbGlzdGVuZXJzLlxuICB0aGlzLnVud2F0Y2goL2NsYXNzLyk7XG5cbiAgdmFyIG9uQmx1ciA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzJDEuZmxhZ3MudG91Y2hlZCA9IHRydWU7XG4gICAgdGhpcyQxLmZsYWdzLnVudG91Y2hlZCA9IGZhbHNlO1xuICAgIGlmICh0aGlzJDEuY2xhc3Nlcykge1xuICAgICAgdG9nZ2xlQ2xhc3ModGhpcyQxLmVsLCB0aGlzJDEuY2xhc3NOYW1lcy50b3VjaGVkLCB0cnVlKTtcbiAgICAgIHRvZ2dsZUNsYXNzKHRoaXMkMS5lbCwgdGhpcyQxLmNsYXNzTmFtZXMudW50b3VjaGVkLCBmYWxzZSk7XG4gICAgfVxuXG4gICAgLy8gb25seSBuZWVkZWQgb25jZS5cbiAgICB0aGlzJDEudW53YXRjaCgvXmNsYXNzX2JsdXIkLyk7XG4gIH07XG5cbiAgdmFyIGlucHV0RXZlbnQgPSBnZXRJbnB1dEV2ZW50TmFtZSh0aGlzLmVsKTtcbiAgdmFyIG9uSW5wdXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcyQxLmZsYWdzLmRpcnR5ID0gdHJ1ZTtcbiAgICB0aGlzJDEuZmxhZ3MucHJpc3RpbmUgPSBmYWxzZTtcbiAgICBpZiAodGhpcyQxLmNsYXNzZXMpIHtcbiAgICAgIHRvZ2dsZUNsYXNzKHRoaXMkMS5lbCwgdGhpcyQxLmNsYXNzTmFtZXMucHJpc3RpbmUsIGZhbHNlKTtcbiAgICAgIHRvZ2dsZUNsYXNzKHRoaXMkMS5lbCwgdGhpcyQxLmNsYXNzTmFtZXMuZGlydHksIHRydWUpO1xuICAgIH1cblxuICAgIC8vIG9ubHkgbmVlZGVkIG9uY2UuXG4gICAgdGhpcyQxLnVud2F0Y2goL15jbGFzc19pbnB1dCQvKTtcbiAgfTtcblxuICBpZiAodGhpcy5jb21wb25lbnQgJiYgaXNDYWxsYWJsZSh0aGlzLmNvbXBvbmVudC4kb25jZSkpIHtcbiAgICB0aGlzLmNvbXBvbmVudC4kb25jZSgnaW5wdXQnLCBvbklucHV0KTtcbiAgICB0aGlzLmNvbXBvbmVudC4kb25jZSgnYmx1cicsIG9uQmx1cik7XG4gICAgdGhpcy53YXRjaGVycy5wdXNoKHtcbiAgICAgIHRhZzogJ2NsYXNzX2lucHV0JyxcbiAgICAgIHVud2F0Y2g6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcyQxLmNvbXBvbmVudC4kb2ZmKCdpbnB1dCcsIG9uSW5wdXQpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHRoaXMud2F0Y2hlcnMucHVzaCh7XG4gICAgICB0YWc6ICdjbGFzc19ibHVyJyxcbiAgICAgIHVud2F0Y2g6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcyQxLmNvbXBvbmVudC4kb2ZmKCdibHVyJywgb25CbHVyKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAoIXRoaXMuZWwpIHsgcmV0dXJuOyB9XG5cbiAgdGhpcy5lbC5hZGRFdmVudExpc3RlbmVyKGlucHV0RXZlbnQsIG9uSW5wdXQpO1xuICAvLyBDaGVja2JveGVzIGFuZCByYWRpbyBidXR0b25zIG9uIE1hYyBkb24ndCBlbWl0IGJsdXIgbmF0dXJhbGx5LCBzbyB3ZSBsaXN0ZW4gb24gY2xpY2sgaW5zdGVhZC5cbiAgdmFyIGJsdXJFdmVudCA9IFsncmFkaW8nLCAnY2hlY2tib3gnXS5pbmRleE9mKHRoaXMuZWwudHlwZSkgPT09IC0xID8gJ2JsdXInIDogJ2NsaWNrJztcbiAgdGhpcy5lbC5hZGRFdmVudExpc3RlbmVyKGJsdXJFdmVudCwgb25CbHVyKTtcbiAgdGhpcy53YXRjaGVycy5wdXNoKHtcbiAgICB0YWc6ICdjbGFzc19pbnB1dCcsXG4gICAgdW53YXRjaDogZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcyQxLmVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoaW5wdXRFdmVudCwgb25JbnB1dCk7XG4gICAgfVxuICB9KTtcblxuICB0aGlzLndhdGNoZXJzLnB1c2goe1xuICAgIHRhZzogJ2NsYXNzX2JsdXInLFxuICAgIHVud2F0Y2g6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMkMS5lbC5yZW1vdmVFdmVudExpc3RlbmVyKGJsdXJFdmVudCwgb25CbHVyKTtcbiAgICB9XG4gIH0pO1xufTtcblxuLyoqXG4gKiBBZGRzIHRoZSBsaXN0ZW5lcnMgcmVxdWlyZWQgZm9yIHZhbGlkYXRpb24uXG4gKi9cbkZpZWxkLnByb3RvdHlwZS5hZGRWYWx1ZUxpc3RlbmVycyA9IGZ1bmN0aW9uIGFkZFZhbHVlTGlzdGVuZXJzICgpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICB0aGlzLnVud2F0Y2goL15pbnB1dF8uKy8pO1xuICBpZiAoIXRoaXMubGlzdGVuKSB7IHJldHVybjsgfVxuXG4gIHZhciBmbiA9IHRoaXMudGFyZ2V0T2YgPyBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcyQxLnZhbGlkYXRvci52YWxpZGF0ZSgoXCIjXCIgKyAodGhpcyQxLnRhcmdldE9mKSkpO1xuICB9IDogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGFyZ3MgPSBbXSwgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICAgIHdoaWxlICggbGVuLS0gKSBhcmdzWyBsZW4gXSA9IGFyZ3VtZW50c1sgbGVuIF07XG5cbiAgICAvLyBpZiBpdHMgYSBET00gZXZlbnQsIHJlc29sdmUgdGhlIHZhbHVlLCBvdGhlcndpc2UgdXNlIHRoZSBmaXJzdCBwYXJhbWV0ZXIgYXMgdGhlIHZhbHVlLlxuICAgIGlmIChhcmdzLmxlbmd0aCA9PT0gMCB8fCAoaXNDYWxsYWJsZShFdmVudCkgJiYgYXJnc1swXSBpbnN0YW5jZW9mIEV2ZW50KSB8fCAoYXJnc1swXSAmJiBhcmdzWzBdLnNyY0VsZW1lbnQpKSB7XG4gICAgICBhcmdzWzBdID0gdGhpcyQxLnZhbHVlO1xuICAgIH1cbiAgICB0aGlzJDEudmFsaWRhdG9yLnZhbGlkYXRlKChcIiNcIiArICh0aGlzJDEuaWQpKSwgYXJnc1swXSk7XG4gIH07XG5cbiAgdmFyIGlucHV0RXZlbnQgPSBnZXRJbnB1dEV2ZW50TmFtZSh0aGlzLmVsKTtcbiAgLy8gcmVwbGFjZSBpbnB1dCBldmVudCB3aXRoIHN1aXRhYmxlIG9uZS5cbiAgdmFyIGV2ZW50cyA9IHRoaXMuZXZlbnRzLm1hcChmdW5jdGlvbiAoZSkge1xuICAgIHJldHVybiBlID09PSAnaW5wdXQnID8gaW5wdXRFdmVudCA6IGU7XG4gIH0pO1xuXG4gIC8vIGlmIHRoZXJlIGlzIGEgd2F0Y2hhYmxlIG1vZGVsIGFuZCBhbiBvbiBpbnB1dCB2YWxpZGF0aW9uIGlzIHJlcXVlc3RlZC5cbiAgaWYgKHRoaXMubW9kZWwgJiYgZXZlbnRzLmluZGV4T2YoaW5wdXRFdmVudCkgIT09IC0xKSB7XG4gICAgdmFyIGRlYm91bmNlZEZuID0gZGVib3VuY2UoZm4sIHRoaXMuZGVsYXlbaW5wdXRFdmVudF0pO1xuICAgIHZhciB1bndhdGNoID0gdGhpcy52bS4kd2F0Y2godGhpcy5tb2RlbCwgZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYXJncyA9IFtdLCBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgICAgICB3aGlsZSAoIGxlbi0tICkgYXJnc1sgbGVuIF0gPSBhcmd1bWVudHNbIGxlbiBdO1xuXG4gICAgICB0aGlzJDEuZmxhZ3MucGVuZGluZyA9IHRydWU7XG4gICAgICBkZWJvdW5jZWRGbi5hcHBseSh2b2lkIDAsIGFyZ3MpO1xuICAgIH0pO1xuICAgIHRoaXMud2F0Y2hlcnMucHVzaCh7XG4gICAgICB0YWc6ICdpbnB1dF9tb2RlbCcsXG4gICAgICB1bndhdGNoOiB1bndhdGNoXG4gICAgfSk7XG4gICAgLy8gZmlsdGVyIG91dCBpbnB1dCBldmVudCBhcyBpdCBpcyBhbHJlYWR5IGhhbmRsZWQgYnkgdGhlIHdhdGNoZXIgQVBJLlxuICAgIGV2ZW50cyA9IGV2ZW50cy5maWx0ZXIoZnVuY3Rpb24gKGUpIHsgcmV0dXJuIGUgIT09IGlucHV0RXZlbnQ7IH0pO1xuICB9XG5cbiAgLy8gQWRkIGV2ZW50cy5cbiAgZXZlbnRzLmZvckVhY2goZnVuY3Rpb24gKGUpIHtcbiAgICB2YXIgZGVib3VuY2VkRm4gPSBkZWJvdW5jZShmbiwgdGhpcyQxLmRlbGF5W2VdKTtcbiAgICB2YXIgdmFsaWRhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBhcmdzID0gW10sIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgICAgIHdoaWxlICggbGVuLS0gKSBhcmdzWyBsZW4gXSA9IGFyZ3VtZW50c1sgbGVuIF07XG5cbiAgICAgIHRoaXMkMS5mbGFncy5wZW5kaW5nID0gdHJ1ZTtcbiAgICAgIGRlYm91bmNlZEZuLmFwcGx5KHZvaWQgMCwgYXJncyk7XG4gICAgfTtcblxuICAgIHRoaXMkMS5fYWRkQ29tcG9uZW50RXZlbnRMaXN0ZW5lcihlLCB2YWxpZGF0ZSk7XG4gICAgdGhpcyQxLl9hZGRIVE1MRXZlbnRMaXN0ZW5lcihlLCB2YWxpZGF0ZSk7XG4gIH0pO1xufTtcblxuRmllbGQucHJvdG90eXBlLl9hZGRDb21wb25lbnRFdmVudExpc3RlbmVyID0gZnVuY3Rpb24gX2FkZENvbXBvbmVudEV2ZW50TGlzdGVuZXIgKGV2dCwgdmFsaWRhdGUpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICBpZiAoIXRoaXMuY29tcG9uZW50KSB7IHJldHVybjsgfVxuXG4gIHRoaXMuY29tcG9uZW50LiRvbihldnQsIHZhbGlkYXRlKTtcbiAgdGhpcy53YXRjaGVycy5wdXNoKHtcbiAgICB0YWc6ICdpbnB1dF92dWUnLFxuICAgIHVud2F0Y2g6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMkMS5jb21wb25lbnQuJG9mZihldnQsIHZhbGlkYXRlKTtcbiAgICB9XG4gIH0pO1xufTtcblxuRmllbGQucHJvdG90eXBlLl9hZGRIVE1MRXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uIF9hZGRIVE1MRXZlbnRMaXN0ZW5lciAoZXZ0LCB2YWxpZGF0ZSkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gIGlmICghdGhpcy5lbCkgeyByZXR1cm47IH1cblxuICBpZiAoflsncmFkaW8nLCAnY2hlY2tib3gnXS5pbmRleE9mKHRoaXMuZWwudHlwZSkpIHtcbiAgICB2YXIgZWxzID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgoXCJpbnB1dFtuYW1lPVxcXCJcIiArICh0aGlzLmVsLm5hbWUpICsgXCJcXFwiXVwiKSk7XG4gICAgdG9BcnJheShlbHMpLmZvckVhY2goZnVuY3Rpb24gKGVsKSB7XG4gICAgICBlbC5hZGRFdmVudExpc3RlbmVyKGV2dCwgdmFsaWRhdGUpO1xuICAgICAgdGhpcyQxLndhdGNoZXJzLnB1c2goe1xuICAgICAgICB0YWc6ICdpbnB1dF9uYXRpdmUnLFxuICAgICAgICB1bndhdGNoOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcihldnQsIHZhbGlkYXRlKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICByZXR1cm47XG4gIH1cblxuICB0aGlzLmVsLmFkZEV2ZW50TGlzdGVuZXIoZXZ0LCB2YWxpZGF0ZSk7XG4gIHRoaXMud2F0Y2hlcnMucHVzaCh7XG4gICAgdGFnOiAnaW5wdXRfbmF0aXZlJyxcbiAgICB1bndhdGNoOiBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzJDEuZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcihldnQsIHZhbGlkYXRlKTtcbiAgICB9XG4gIH0pO1xufTtcblxuLyoqXG4gKiBVcGRhdGVzIGFyaWEgYXR0cmlidXRlcyBvbiB0aGUgZWxlbWVudC5cbiAqL1xuRmllbGQucHJvdG90eXBlLnVwZGF0ZUFyaWFBdHRycyA9IGZ1bmN0aW9uIHVwZGF0ZUFyaWFBdHRycyAoKSB7XG4gIGlmICghdGhpcy5hcmlhIHx8ICF0aGlzLmVsIHx8ICFpc0NhbGxhYmxlKHRoaXMuZWwuc2V0QXR0cmlidXRlKSkgeyByZXR1cm47IH1cblxuICB0aGlzLmVsLnNldEF0dHJpYnV0ZSgnYXJpYS1yZXF1aXJlZCcsIHRoaXMuaXNSZXF1aXJlZCA/ICd0cnVlJyA6ICdmYWxzZScpO1xuICB0aGlzLmVsLnNldEF0dHJpYnV0ZSgnYXJpYS1pbnZhbGlkJywgdGhpcy5mbGFncy5pbnZhbGlkID8gJ3RydWUnIDogJ2ZhbHNlJyk7XG59O1xuXG4vKipcbiAqIFVwZGF0ZXMgdGhlIGN1c3RvbSB2YWxpZGl0eSBmb3IgdGhlIGZpZWxkLlxuICovXG5GaWVsZC5wcm90b3R5cGUudXBkYXRlQ3VzdG9tVmFsaWRpdHkgPSBmdW5jdGlvbiB1cGRhdGVDdXN0b21WYWxpZGl0eSAoKSB7XG4gIGlmICghdGhpcy52YWxpZGl0eSB8fCAhdGhpcy5lbCB8fCAhaXNDYWxsYWJsZSh0aGlzLmVsLnNldEN1c3RvbVZhbGlkaXR5KSkgeyByZXR1cm47IH1cblxuICB0aGlzLmVsLnNldEN1c3RvbVZhbGlkaXR5KHRoaXMuZmxhZ3MudmFsaWQgPyAnJyA6ICh0aGlzLnZhbGlkYXRvci5lcnJvcnMuZmlyc3RCeUlkKHRoaXMuaWQpIHx8ICcnKSk7XG59O1xuXG4vKipcbiAqIFJlbW92ZXMgYWxsIGxpc3RlbmVycy5cbiAqL1xuRmllbGQucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiBkZXN0cm95ICgpIHtcbiAgdGhpcy51bndhdGNoKCk7XG4gIHRoaXMuZGVwZW5kZW5jaWVzLmZvckVhY2goZnVuY3Rpb24gKGQpIHsgcmV0dXJuIGQuZmllbGQuZGVzdHJveSgpOyB9KTtcbiAgdGhpcy5kZXBlbmRlbmNpZXMgPSBbXTtcbn07XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKCBGaWVsZC5wcm90b3R5cGUsIHByb3RvdHlwZUFjY2Vzc29ycyQxICk7XG5cbi8vIFxuXG52YXIgRmllbGRCYWcgPSBmdW5jdGlvbiBGaWVsZEJhZyAoKSB7XG4gIHRoaXMuaXRlbXMgPSBbXTtcbn07XG5cbnZhciBwcm90b3R5cGVBY2Nlc3NvcnMkNCA9IHsgbGVuZ3RoOiB7fSB9O1xuXG4vKipcbiAqIEdldHMgdGhlIGN1cnJlbnQgaXRlbXMgbGVuZ3RoLlxuICovXG5cbnByb3RvdHlwZUFjY2Vzc29ycyQ0Lmxlbmd0aC5nZXQgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLml0ZW1zLmxlbmd0aDtcbn07XG5cbi8qKlxuICogRmluZHMgdGhlIGZpcnN0IGZpZWxkIHRoYXQgbWF0Y2hlcyB0aGUgcHJvdmlkZWQgbWF0Y2hlciBvYmplY3QuXG4gKi9cbkZpZWxkQmFnLnByb3RvdHlwZS5maW5kID0gZnVuY3Rpb24gZmluZCQxIChtYXRjaGVyKSB7XG4gIHJldHVybiBmaW5kKHRoaXMuaXRlbXMsIGZ1bmN0aW9uIChpdGVtKSB7IHJldHVybiBpdGVtLm1hdGNoZXMobWF0Y2hlcik7IH0pO1xufTtcblxuLyoqXG4gKiBGaWx0ZXJzIHRoZSBpdGVtcyBkb3duIHRvIHRoZSBtYXRjaGVkIGZpZWxkcy5cbiAqL1xuRmllbGRCYWcucHJvdG90eXBlLmZpbHRlciA9IGZ1bmN0aW9uIGZpbHRlciAobWF0Y2hlcikge1xuICAvLyBtdWx0aXBsZSBtYXRjaGVycyB0byBiZSB0cmllZC5cbiAgaWYgKEFycmF5LmlzQXJyYXkobWF0Y2hlcikpIHtcbiAgICByZXR1cm4gdGhpcy5pdGVtcy5maWx0ZXIoZnVuY3Rpb24gKGl0ZW0pIHsgcmV0dXJuIG1hdGNoZXIuc29tZShmdW5jdGlvbiAobSkgeyByZXR1cm4gaXRlbS5tYXRjaGVzKG0pOyB9KTsgfSk7XG4gIH1cblxuICByZXR1cm4gdGhpcy5pdGVtcy5maWx0ZXIoZnVuY3Rpb24gKGl0ZW0pIHsgcmV0dXJuIGl0ZW0ubWF0Y2hlcyhtYXRjaGVyKTsgfSk7XG59O1xuXG4vKipcbiAqIE1hcHMgdGhlIGZpZWxkIGl0ZW1zIHVzaW5nIHRoZSBtYXBwaW5nIGZ1bmN0aW9uLlxuICovXG5GaWVsZEJhZy5wcm90b3R5cGUubWFwID0gZnVuY3Rpb24gbWFwIChtYXBwZXIpIHtcbiAgcmV0dXJuIHRoaXMuaXRlbXMubWFwKG1hcHBlcik7XG59O1xuXG4vKipcbiAqIEZpbmRzIGFuZCByZW1vdmVzIHRoZSBmaXJzdCBmaWVsZCB0aGF0IG1hdGNoZXMgdGhlIHByb3ZpZGVkIG1hdGNoZXIgb2JqZWN0LCByZXR1cm5zIHRoZSByZW1vdmVkIGl0ZW0uXG4gKi9cbkZpZWxkQmFnLnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbiByZW1vdmUgKG1hdGNoZXIpIHtcbiAgdmFyIGl0ZW0gPSBudWxsO1xuICBpZiAobWF0Y2hlciBpbnN0YW5jZW9mIEZpZWxkKSB7XG4gICAgaXRlbSA9IG1hdGNoZXI7XG4gIH0gZWxzZSB7XG4gICAgaXRlbSA9IHRoaXMuZmluZChtYXRjaGVyKTtcbiAgfVxuXG4gIGlmICghaXRlbSkgeyByZXR1cm4gbnVsbDsgfVxuXG4gIHZhciBpbmRleCA9IHRoaXMuaXRlbXMuaW5kZXhPZihpdGVtKTtcbiAgdGhpcy5pdGVtcy5zcGxpY2UoaW5kZXgsIDEpO1xuXG4gIHJldHVybiBpdGVtO1xufTtcblxuLyoqXG4gKiBBZGRzIGEgZmllbGQgaXRlbSB0byB0aGUgbGlzdC5cbiAqL1xuRmllbGRCYWcucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbiBwdXNoIChpdGVtKSB7XG4gIGlmICghIChpdGVtIGluc3RhbmNlb2YgRmllbGQpKSB7XG4gICAgdGhyb3cgY3JlYXRlRXJyb3IoJ0ZpZWxkQmFnIG9ubHkgYWNjZXB0cyBpbnN0YW5jZXMgb2YgRmllbGQgdGhhdCBoYXMgYW4gaWQgZGVmaW5lZC4nKTtcbiAgfVxuXG4gIGlmICghaXRlbS5pZCkge1xuICAgIHRocm93IGNyZWF0ZUVycm9yKCdGaWVsZCBpZCBtdXN0IGJlIGRlZmluZWQuJyk7XG4gIH1cblxuICBpZiAodGhpcy5maW5kKHsgaWQ6IGl0ZW0uaWQgfSkpIHtcbiAgICB0aHJvdyBjcmVhdGVFcnJvcigoXCJGaWVsZCB3aXRoIGlkIFwiICsgKGl0ZW0uaWQpICsgXCIgaXMgYWxyZWFkeSBhZGRlZC5cIikpO1xuICB9XG5cbiAgdGhpcy5pdGVtcy5wdXNoKGl0ZW0pO1xufTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoIEZpZWxkQmFnLnByb3RvdHlwZSwgcHJvdG90eXBlQWNjZXNzb3JzJDQgKTtcblxuLy8gXG5cbnZhciBSVUxFUyA9IHt9O1xudmFyIFNUUklDVF9NT0RFID0gdHJ1ZTtcbnZhciBUQVJHRVRfUlVMRVMgPSBbJ2NvbmZpcm1lZCcsICdhZnRlcicsICdiZWZvcmUnXTtcbnZhciBFUlJPUlMgPSBbXTsgLy8gSE9MRCBlcnJvcnMgcmVmZXJlbmNlcyB0byB0cmlnZ2VyIHJlZ2VuZXJhdGlvbi5cblxudmFyIFZhbGlkYXRvciA9IGZ1bmN0aW9uIFZhbGlkYXRvciAodmFsaWRhdGlvbnMsIG9wdGlvbnMpIHtcbiAgdmFyIHRoaXMkMSA9IHRoaXM7XG4gIGlmICggb3B0aW9ucyA9PT0gdm9pZCAwICkgb3B0aW9ucyA9IHsgdm06IG51bGwsIGZhc3RFeGl0OiB0cnVlIH07XG5cbiAgdGhpcy5zdHJpY3QgPSBTVFJJQ1RfTU9ERTtcbiAgdGhpcy5lcnJvcnMgPSBuZXcgRXJyb3JCYWcoKTtcbiAgRVJST1JTLnB1c2godGhpcy5lcnJvcnMpO1xuICB0aGlzLmZpZWxkcyA9IG5ldyBGaWVsZEJhZygpO1xuICB0aGlzLmZsYWdzID0ge307XG4gIHRoaXMuX2NyZWF0ZUZpZWxkcyh2YWxpZGF0aW9ucyk7XG4gIHRoaXMucGF1c2VkID0gZmFsc2U7XG4gIHRoaXMuZmFzdEV4aXQgPSBvcHRpb25zLmZhc3RFeGl0IHx8IGZhbHNlO1xuICB0aGlzLm93bmVySWQgPSBvcHRpb25zLnZtICYmIG9wdGlvbnMudm0uX3VpZDtcbiAgLy8gY3JlYXRlIGl0IHN0YXRpY2FsbHkgc2luY2Ugd2UgZG9uJ3QgbmVlZCBjb25zdGFudCBhY2Nlc3MgdG8gdGhlIHZtLlxuICB0aGlzLnJlc2V0ID0gb3B0aW9ucy52bSAmJiBpc0NhbGxhYmxlKG9wdGlvbnMudm0uJG5leHRUaWNrKSA/IGZ1bmN0aW9uIChtYXRjaGVyKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlKSB7XG4gICAgICBvcHRpb25zLnZtLiRuZXh0VGljayhmdW5jdGlvbiAoKSB7XG4gICAgICAgIG9wdGlvbnMudm0uJG5leHRUaWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXNvbHZlKHRoaXMkMS5fcmVzZXQobWF0Y2hlcikpO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9IDogdGhpcy5fcmVzZXQ7XG59O1xuXG52YXIgcHJvdG90eXBlQWNjZXNzb3JzID0geyBkaWN0aW9uYXJ5OiB7fSxsb2NhbGU6IHt9LHJ1bGVzOiB7fSB9O1xudmFyIHN0YXRpY0FjY2Vzc29ycyA9IHsgZGljdGlvbmFyeToge30sbG9jYWxlOiB7fSxydWxlczoge30gfTtcblxuLyoqXG4gKiBHZXR0ZXIgZm9yIHRoZSBkaWN0aW9uYXJ5LlxuICovXG5wcm90b3R5cGVBY2Nlc3NvcnMuZGljdGlvbmFyeS5nZXQgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBDb25maWcuZGVwZW5kZW5jeSgnZGljdGlvbmFyeScpO1xufTtcblxuLyoqXG4gKiBTdGF0aWMgR2V0dGVyIGZvciB0aGUgZGljdGlvbmFyeS5cbiAqL1xuc3RhdGljQWNjZXNzb3JzLmRpY3Rpb25hcnkuZ2V0ID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gQ29uZmlnLmRlcGVuZGVuY3koJ2RpY3Rpb25hcnknKTtcbn07XG5cbi8qKlxuICogR2V0dGVyIGZvciB0aGUgY3VycmVudCBsb2NhbGUuXG4gKi9cbnByb3RvdHlwZUFjY2Vzc29ycy5sb2NhbGUuZ2V0ID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5kaWN0aW9uYXJ5LmxvY2FsZTtcbn07XG5cbi8qKlxuICogU2V0dGVyIGZvciB0aGUgdmFsaWRhdG9yIGxvY2FsZS5cbiAqL1xucHJvdG90eXBlQWNjZXNzb3JzLmxvY2FsZS5zZXQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgVmFsaWRhdG9yLmxvY2FsZSA9IHZhbHVlO1xufTtcblxuLyoqXG4qIFN0YXRpYyBnZXR0ZXIgZm9yIHRoZSB2YWxpZGF0b3IgbG9jYWxlLlxuKi9cbnN0YXRpY0FjY2Vzc29ycy5sb2NhbGUuZ2V0ID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gVmFsaWRhdG9yLmRpY3Rpb25hcnkubG9jYWxlO1xufTtcblxuLyoqXG4gKiBTdGF0aWMgc2V0dGVyIGZvciB0aGUgdmFsaWRhdG9yIGxvY2FsZS5cbiAqL1xuc3RhdGljQWNjZXNzb3JzLmxvY2FsZS5zZXQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgdmFyIGhhc0NoYW5nZWQgPSB2YWx1ZSAhPT0gVmFsaWRhdG9yLmRpY3Rpb25hcnkubG9jYWxlO1xuICBWYWxpZGF0b3IuZGljdGlvbmFyeS5sb2NhbGUgPSB2YWx1ZTtcbiAgaWYgKGhhc0NoYW5nZWQpIHtcbiAgICBWYWxpZGF0b3IucmVnZW5lcmF0ZSgpO1xuICB9XG59O1xuXG4vKipcbiAqIEdldHRlciBmb3IgdGhlIHJ1bGVzIG9iamVjdC5cbiAqL1xucHJvdG90eXBlQWNjZXNzb3JzLnJ1bGVzLmdldCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIFJVTEVTO1xufTtcblxuLyoqXG4gKiBTdGF0aWMgR2V0dGVyIGZvciB0aGUgcnVsZXMgb2JqZWN0LlxuICovXG5zdGF0aWNBY2Nlc3NvcnMucnVsZXMuZ2V0ID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gUlVMRVM7XG59O1xuXG4vKipcbiAqIFN0YXRpYyBjb25zdHJ1Y3Rvci5cbiAqL1xuVmFsaWRhdG9yLmNyZWF0ZSA9IGZ1bmN0aW9uIGNyZWF0ZSAodmFsaWRhdGlvbnMsIG9wdGlvbnMpIHtcbiAgcmV0dXJuIG5ldyBWYWxpZGF0b3IodmFsaWRhdGlvbnMsIG9wdGlvbnMpO1xufTtcblxuLyoqXG4gKiBBZGRzIGEgY3VzdG9tIHZhbGlkYXRvciB0byB0aGUgbGlzdCBvZiB2YWxpZGF0aW9uIHJ1bGVzLlxuICovXG5WYWxpZGF0b3IuZXh0ZW5kID0gZnVuY3Rpb24gZXh0ZW5kIChuYW1lLCB2YWxpZGF0b3IsIG9wdGlvbnMpIHtcbiAgICBpZiAoIG9wdGlvbnMgPT09IHZvaWQgMCApIG9wdGlvbnMgPSB7fTtcblxuICBWYWxpZGF0b3IuX2d1YXJkRXh0ZW5kKG5hbWUsIHZhbGlkYXRvcik7XG4gIFZhbGlkYXRvci5fbWVyZ2UobmFtZSwgdmFsaWRhdG9yKTtcbiAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5oYXNUYXJnZXQpIHtcbiAgICBUQVJHRVRfUlVMRVMucHVzaChuYW1lKTtcbiAgfVxufTtcblxuLyoqXG4gKiBSZWdlbmVyYXRlcyBlcnJvciBtZXNzYWdlcyBhY3Jvc3MgYWxsIHZhbGlkYXRvcnMuXG4gKi9cblZhbGlkYXRvci5yZWdlbmVyYXRlID0gZnVuY3Rpb24gcmVnZW5lcmF0ZSAoKSB7XG4gIEVSUk9SUy5mb3JFYWNoKGZ1bmN0aW9uIChlcnJvckJhZykgeyByZXR1cm4gZXJyb3JCYWcucmVnZW5lcmF0ZSgpOyB9KTtcbn07XG5cbi8qKlxuICogUmVtb3ZlcyBhIHJ1bGUgZnJvbSB0aGUgbGlzdCBvZiB2YWxpZGF0b3JzLlxuICovXG5WYWxpZGF0b3IucmVtb3ZlID0gZnVuY3Rpb24gcmVtb3ZlIChuYW1lKSB7XG4gIGRlbGV0ZSBSVUxFU1tuYW1lXTtcbiAgdmFyIGlkeCA9IFRBUkdFVF9SVUxFUy5pbmRleE9mKG5hbWUpO1xuICBpZiAoaWR4ID09PSAtMSkgeyByZXR1cm47IH1cblxuICBUQVJHRVRfUlVMRVMuc3BsaWNlKGlkeCwgMSk7XG59O1xuXG4vKipcbiAqIENoZWNrcyBpZiB0aGUgZ2l2ZW4gcnVsZSBuYW1lIGlzIGEgcnVsZSB0aGF0IHRhcmdldHMgb3RoZXIgZmllbGRzLlxuICovXG5WYWxpZGF0b3IuaXNUYXJnZXRSdWxlID0gZnVuY3Rpb24gaXNUYXJnZXRSdWxlIChuYW1lKSB7XG4gIHJldHVybiBUQVJHRVRfUlVMRVMuaW5kZXhPZihuYW1lKSAhPT0gLTE7XG59O1xuXG4vKipcbiAqIFNldHMgdGhlIG9wZXJhdGluZyBtb2RlIGZvciBhbGwgbmV3bHkgY3JlYXRlZCB2YWxpZGF0b3JzLlxuICogc3RyaWN0TW9kZSA9IHRydWU6IFZhbHVlcyB3aXRob3V0IGEgcnVsZSBhcmUgaW52YWxpZCBhbmQgY2F1c2UgZmFpbHVyZS5cbiAqIHN0cmljdE1vZGUgPSBmYWxzZTogVmFsdWVzIHdpdGhvdXQgYSBydWxlIGFyZSB2YWxpZCBhbmQgYXJlIHNraXBwZWQuXG4gKi9cblZhbGlkYXRvci5zZXRTdHJpY3RNb2RlID0gZnVuY3Rpb24gc2V0U3RyaWN0TW9kZSAoc3RyaWN0TW9kZSkge1xuICAgIGlmICggc3RyaWN0TW9kZSA9PT0gdm9pZCAwICkgc3RyaWN0TW9kZSA9IHRydWU7XG5cbiAgU1RSSUNUX01PREUgPSBzdHJpY3RNb2RlO1xufTtcblxuLyoqXG4gKiBBZGRzIGFuZCBzZXRzIHRoZSBjdXJyZW50IGxvY2FsZSBmb3IgdGhlIHZhbGlkYXRvci5cbiAqL1xuVmFsaWRhdG9yLnByb3RvdHlwZS5sb2NhbGl6ZSA9IGZ1bmN0aW9uIGxvY2FsaXplIChsYW5nLCBkaWN0aW9uYXJ5KSB7XG4gIFZhbGlkYXRvci5sb2NhbGl6ZShsYW5nLCBkaWN0aW9uYXJ5KTtcbn07XG5cbi8qKlxuICogQWRkcyBhbmQgc2V0cyB0aGUgY3VycmVudCBsb2NhbGUgZm9yIHRoZSB2YWxpZGF0b3IuXG4gKi9cblZhbGlkYXRvci5sb2NhbGl6ZSA9IGZ1bmN0aW9uIGxvY2FsaXplIChsYW5nLCBkaWN0aW9uYXJ5KSB7XG4gIGlmIChpc09iamVjdChsYW5nKSkge1xuICAgIFZhbGlkYXRvci5kaWN0aW9uYXJ5Lm1lcmdlKGxhbmcpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIG1lcmdlIHRoZSBkaWN0aW9uYXJ5LlxuICBpZiAoZGljdGlvbmFyeSkge1xuICAgIHZhciBsb2NhbGUgPSBsYW5nIHx8IGRpY3Rpb25hcnkubmFtZTtcbiAgICBkaWN0aW9uYXJ5ID0gYXNzaWduKHt9LCBkaWN0aW9uYXJ5KTtcbiAgICBWYWxpZGF0b3IuZGljdGlvbmFyeS5tZXJnZSgoIG9iaiA9IHt9LCBvYmpbbG9jYWxlXSA9IGRpY3Rpb25hcnksIG9iaiApKTtcbiAgICAgIHZhciBvYmo7XG4gIH1cblxuICBpZiAobGFuZykge1xuICAgIC8vIHNldCB0aGUgbG9jYWxlLlxuICAgIFZhbGlkYXRvci5sb2NhbGUgPSBsYW5nO1xuICB9XG59O1xuXG4vKipcbiAqIFJlZ2lzdGVycyBhIGZpZWxkIHRvIGJlIHZhbGlkYXRlZC5cbiAqL1xuVmFsaWRhdG9yLnByb3RvdHlwZS5hdHRhY2ggPSBmdW5jdGlvbiBhdHRhY2ggKGZpZWxkKSB7XG4gIC8vIGRlcHJlY2F0ZTogaGFuZGxlIG9sZCBzaWduYXR1cmUuXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgIHdhcm4oJ1RoaXMgc2lnbmF0dXJlIG9mIHRoZSBhdHRhY2ggbWV0aG9kIGhhcyBiZWVuIGRlcHJlY2F0ZWQsIHBsZWFzZSBjb25zdWx0IHRoZSBkb2NzLicpO1xuICAgIGZpZWxkID0gYXNzaWduKHt9LCB7XG4gICAgICBuYW1lOiBhcmd1bWVudHNbMF0sXG4gICAgICBydWxlczogYXJndW1lbnRzWzFdXG4gICAgfSwgYXJndW1lbnRzWzJdIHx8IHsgdm06IHsgJHZhbGlkYXRvcjogdGhpcyB9IH0pO1xuICB9XG5cbiAgLy8gZml4ZXMgaW5pdGlhbCB2YWx1ZSBkZXRlY3Rpb24gd2l0aCB2LW1vZGVsIGFuZCBzZWxlY3QgZWxlbWVudHMuXG4gIHZhciB2YWx1ZSA9IGZpZWxkLmluaXRpYWxWYWx1ZTtcbiAgaWYgKCEoZmllbGQgaW5zdGFuY2VvZiBGaWVsZCkpIHtcbiAgICBmaWVsZCA9IG5ldyBGaWVsZChmaWVsZC5lbCB8fCBudWxsLCBmaWVsZCk7XG4gIH1cblxuICB0aGlzLmZpZWxkcy5wdXNoKGZpZWxkKTtcblxuICAvLyB2YWxpZGF0ZSB0aGUgZmllbGQgaW5pdGlhbGx5XG4gIGlmIChmaWVsZC5pbml0aWFsKSB7XG4gICAgdGhpcy52YWxpZGF0ZSgoXCIjXCIgKyAoZmllbGQuaWQpKSwgdmFsdWUgfHwgZmllbGQudmFsdWUpO1xuICB9IGVsc2Uge1xuICAgIHRoaXMuX3ZhbGlkYXRlKGZpZWxkLCB2YWx1ZSB8fCBmaWVsZC52YWx1ZSwgdHJ1ZSkudGhlbihmdW5jdGlvbiAocmVzdWx0KSB7XG4gICAgICBmaWVsZC5mbGFncy52YWxpZCA9IHJlc3VsdC52YWxpZDtcbiAgICAgIGZpZWxkLmZsYWdzLmludmFsaWQgPSAhcmVzdWx0LnZhbGlkO1xuICAgIH0pO1xuICB9XG5cbiAgdGhpcy5fYWRkRmxhZyhmaWVsZCwgZmllbGQuc2NvcGUpO1xuICByZXR1cm4gZmllbGQ7XG59O1xuXG4vKipcbiAqIFNldHMgdGhlIGZsYWdzIG9uIGEgZmllbGQuXG4gKi9cblZhbGlkYXRvci5wcm90b3R5cGUuZmxhZyA9IGZ1bmN0aW9uIGZsYWcgKG5hbWUsIGZsYWdzKSB7XG4gIHZhciBmaWVsZCA9IHRoaXMuX3Jlc29sdmVGaWVsZChuYW1lKTtcbiAgaWYgKCEgZmllbGQgfHwgIWZsYWdzKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgZmllbGQuc2V0RmxhZ3MoZmxhZ3MpO1xufTtcblxuLyoqXG4gKiBSZW1vdmVzIGEgZmllbGQgZnJvbSB0aGUgdmFsaWRhdG9yLlxuICovXG5WYWxpZGF0b3IucHJvdG90eXBlLmRldGFjaCA9IGZ1bmN0aW9uIGRldGFjaCAobmFtZSwgc2NvcGUpIHtcbiAgdmFyIGZpZWxkID0gbmFtZSBpbnN0YW5jZW9mIEZpZWxkID8gbmFtZSA6IHRoaXMuX3Jlc29sdmVGaWVsZChuYW1lLCBzY29wZSk7XG4gIGlmICghZmllbGQpIHsgcmV0dXJuOyB9XG5cbiAgZmllbGQuZGVzdHJveSgpO1xuICB0aGlzLmVycm9ycy5yZW1vdmUoZmllbGQubmFtZSwgZmllbGQuc2NvcGUsIGZpZWxkLmlkKTtcbiAgdGhpcy5maWVsZHMucmVtb3ZlKGZpZWxkKTtcbiAgdmFyIGZsYWdzID0gdGhpcy5mbGFncztcbiAgaWYgKCFpc051bGxPclVuZGVmaW5lZChmaWVsZC5zY29wZSkgJiYgZmxhZ3NbKFwiJFwiICsgKGZpZWxkLnNjb3BlKSldKSB7XG4gICAgZGVsZXRlIGZsYWdzWyhcIiRcIiArIChmaWVsZC5zY29wZSkpXVtmaWVsZC5uYW1lXTtcbiAgfSBlbHNlIGlmIChpc051bGxPclVuZGVmaW5lZChmaWVsZC5zY29wZSkpIHtcbiAgICBkZWxldGUgZmxhZ3NbZmllbGQubmFtZV07XG4gIH1cblxuICB0aGlzLmZsYWdzID0gYXNzaWduKHt9LCBmbGFncyk7XG59O1xuXG4vKipcbiAqIEFkZHMgYSBjdXN0b20gdmFsaWRhdG9yIHRvIHRoZSBsaXN0IG9mIHZhbGlkYXRpb24gcnVsZXMuXG4gKi9cblZhbGlkYXRvci5wcm90b3R5cGUuZXh0ZW5kID0gZnVuY3Rpb24gZXh0ZW5kIChuYW1lLCB2YWxpZGF0b3IsIG9wdGlvbnMpIHtcbiAgICBpZiAoIG9wdGlvbnMgPT09IHZvaWQgMCApIG9wdGlvbnMgPSB7fTtcblxuICBWYWxpZGF0b3IuZXh0ZW5kKG5hbWUsIHZhbGlkYXRvciwgb3B0aW9ucyk7XG59O1xuXG4vKipcbiAqIFVwZGF0ZXMgYSBmaWVsZCwgdXBkYXRpbmcgYm90aCBlcnJvcnMgYW5kIGZsYWdzLlxuICovXG5WYWxpZGF0b3IucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIHVwZGF0ZSAoaWQsIHJlZikge1xuICAgIHZhciBzY29wZSA9IHJlZi5zY29wZTtcblxuICB2YXIgZmllbGQgPSB0aGlzLl9yZXNvbHZlRmllbGQoKFwiI1wiICsgaWQpKTtcbiAgaWYgKCFmaWVsZCkgeyByZXR1cm47IH1cblxuICAvLyByZW1vdmUgb2xkIHNjb3BlLlxuICB0aGlzLmVycm9ycy51cGRhdGUoaWQsIHsgc2NvcGU6IHNjb3BlIH0pO1xuICBpZiAoIWlzTnVsbE9yVW5kZWZpbmVkKGZpZWxkLnNjb3BlKSAmJiB0aGlzLmZsYWdzWyhcIiRcIiArIChmaWVsZC5zY29wZSkpXSkge1xuICAgIGRlbGV0ZSB0aGlzLmZsYWdzWyhcIiRcIiArIChmaWVsZC5zY29wZSkpXVtmaWVsZC5uYW1lXTtcbiAgfSBlbHNlIGlmIChpc051bGxPclVuZGVmaW5lZChmaWVsZC5zY29wZSkpIHtcbiAgICBkZWxldGUgdGhpcy5mbGFnc1tmaWVsZC5uYW1lXTtcbiAgfVxuXG4gIHRoaXMuX2FkZEZsYWcoZmllbGQsIHNjb3BlKTtcbn07XG5cbi8qKlxuICogUmVtb3ZlcyBhIHJ1bGUgZnJvbSB0aGUgbGlzdCBvZiB2YWxpZGF0b3JzLlxuICovXG5WYWxpZGF0b3IucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uIHJlbW92ZSAobmFtZSkge1xuICBWYWxpZGF0b3IucmVtb3ZlKG5hbWUpO1xufTtcblxuLyoqXG4gKiBWYWxpZGF0ZXMgYSB2YWx1ZSBhZ2FpbnN0IGEgcmVnaXN0ZXJlZCBmaWVsZCB2YWxpZGF0aW9ucy5cbiAqL1xuVmFsaWRhdG9yLnByb3RvdHlwZS52YWxpZGF0ZSA9IGZ1bmN0aW9uIHZhbGlkYXRlIChuYW1lLCB2YWx1ZSwgc2NvcGUpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcbiAgICBpZiAoIHNjb3BlID09PSB2b2lkIDAgKSBzY29wZSA9IG51bGw7XG5cbiAgaWYgKHRoaXMucGF1c2VkKSB7IHJldHVybiBQcm9taXNlLnJlc29sdmUodHJ1ZSk7IH1cblxuICAvLyBvdmVybG9hZCB0byB2YWxpZGF0ZSBhbGwuXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIHRoaXMudmFsaWRhdGVTY29wZXMoKTtcbiAgfVxuXG4gIC8vIG92ZXJsb2FkIHRvIHZhbGlkYXRlIHNjb3BlLWxlc3MgZmllbGRzLlxuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSAmJiBhcmd1bWVudHNbMF0gPT09ICcqJykge1xuICAgIHJldHVybiB0aGlzLnZhbGlkYXRlQWxsKCk7XG4gIH1cblxuICAvLyBvdmVybG9hZCB0byB2YWxpZGF0ZSBhIHNjb3BlLlxuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSAmJiB0eXBlb2YgYXJndW1lbnRzWzBdID09PSAnc3RyaW5nJyAmJiAvXiguKylcXC5cXCokLy50ZXN0KGFyZ3VtZW50c1swXSkpIHtcbiAgICB2YXIgbWF0Y2hlZCA9IGFyZ3VtZW50c1swXS5tYXRjaCgvXiguKylcXC5cXCokLylbMV07XG4gICAgcmV0dXJuIHRoaXMudmFsaWRhdGVBbGwobWF0Y2hlZCk7XG4gIH1cblxuICB2YXIgZmllbGQgPSB0aGlzLl9yZXNvbHZlRmllbGQobmFtZSwgc2NvcGUpO1xuICBpZiAoIWZpZWxkKSB7XG4gICAgcmV0dXJuIHRoaXMuX2hhbmRsZUZpZWxkTm90Rm91bmQobmFtZSwgc2NvcGUpO1xuICB9XG5cbiAgZmllbGQuZmxhZ3MucGVuZGluZyA9IHRydWU7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgdmFsdWUgPSBmaWVsZC52YWx1ZTtcbiAgfVxuXG4gIHZhciBzaWxlbnRSdW4gPSBmaWVsZC5pc0Rpc2FibGVkO1xuXG4gIHJldHVybiB0aGlzLl92YWxpZGF0ZShmaWVsZCwgdmFsdWUsIHNpbGVudFJ1bikudGhlbihmdW5jdGlvbiAocmVzdWx0KSB7XG4gICAgdGhpcyQxLmVycm9ycy5yZW1vdmUoZmllbGQubmFtZSwgZmllbGQuc2NvcGUsIGZpZWxkLmlkKTtcbiAgICBpZiAoc2lsZW50UnVuKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHRydWUpO1xuICAgIH0gZWxzZSBpZiAocmVzdWx0LmVycm9ycykge1xuICAgICAgcmVzdWx0LmVycm9ycy5mb3JFYWNoKGZ1bmN0aW9uIChlKSB7IHJldHVybiB0aGlzJDEuZXJyb3JzLmFkZChlKTsgfSk7XG4gICAgfVxuXG4gICAgZmllbGQuc2V0RmxhZ3Moe1xuICAgICAgcGVuZGluZzogZmFsc2UsXG4gICAgICB2YWxpZDogcmVzdWx0LnZhbGlkLFxuICAgICAgdmFsaWRhdGVkOiB0cnVlXG4gICAgfSk7XG5cbiAgICByZXR1cm4gcmVzdWx0LnZhbGlkO1xuICB9KTtcbn07XG5cbi8qKlxuICogUGF1c2VzIHRoZSB2YWxpZGF0b3IuXG4gKi9cblZhbGlkYXRvci5wcm90b3R5cGUucGF1c2UgPSBmdW5jdGlvbiBwYXVzZSAoKSB7XG4gIHRoaXMucGF1c2VkID0gdHJ1ZTtcblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogUmVzdW1lcyB0aGUgdmFsaWRhdG9yLlxuICovXG5WYWxpZGF0b3IucHJvdG90eXBlLnJlc3VtZSA9IGZ1bmN0aW9uIHJlc3VtZSAoKSB7XG4gIHRoaXMucGF1c2VkID0gZmFsc2U7XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFZhbGlkYXRlcyBlYWNoIHZhbHVlIGFnYWluc3QgdGhlIGNvcnJlc3BvbmRpbmcgZmllbGQgdmFsaWRhdGlvbnMuXG4gKi9cblZhbGlkYXRvci5wcm90b3R5cGUudmFsaWRhdGVBbGwgPSBmdW5jdGlvbiB2YWxpZGF0ZUFsbCAodmFsdWVzKSB7XG4gICAgdmFyIGFyZ3VtZW50cyQxID0gYXJndW1lbnRzO1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gIGlmICh0aGlzLnBhdXNlZCkgeyByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHRydWUpOyB9XG5cbiAgdmFyIG1hdGNoZXIgPSBudWxsO1xuICB2YXIgcHJvdmlkZWRWYWx1ZXMgPSBmYWxzZTtcblxuICBpZiAodHlwZW9mIHZhbHVlcyA9PT0gJ3N0cmluZycpIHtcbiAgICBtYXRjaGVyID0geyBzY29wZTogdmFsdWVzIH07XG4gIH0gZWxzZSBpZiAoaXNPYmplY3QodmFsdWVzKSkge1xuICAgIG1hdGNoZXIgPSBPYmplY3Qua2V5cyh2YWx1ZXMpLm1hcChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICByZXR1cm4geyBuYW1lOiBrZXksIHNjb3BlOiBhcmd1bWVudHMkMVsxXSB8fCBudWxsIH07XG4gICAgfSk7XG4gICAgcHJvdmlkZWRWYWx1ZXMgPSB0cnVlO1xuICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICBtYXRjaGVyID0geyBzY29wZTogbnVsbCB9OyAvLyBnbG9iYWwgc2NvcGUuXG4gIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZXMpKSB7XG4gICAgbWF0Y2hlciA9IHZhbHVlcy5tYXAoZnVuY3Rpb24gKGtleSkge1xuICAgICAgcmV0dXJuIHsgbmFtZToga2V5LCBzY29wZTogYXJndW1lbnRzJDFbMV0gfHwgbnVsbCB9O1xuICAgIH0pO1xuICB9XG5cbiAgdmFyIHByb21pc2VzID0gdGhpcy5maWVsZHMuZmlsdGVyKG1hdGNoZXIpLm1hcChmdW5jdGlvbiAoZmllbGQpIHsgcmV0dXJuIHRoaXMkMS52YWxpZGF0ZShcbiAgICAoXCIjXCIgKyAoZmllbGQuaWQpKSxcbiAgICBwcm92aWRlZFZhbHVlcyA/IHZhbHVlc1tmaWVsZC5uYW1lXSA6IGZpZWxkLnZhbHVlXG4gICk7IH0pO1xuXG4gIHJldHVybiBQcm9taXNlLmFsbChwcm9taXNlcykudGhlbihmdW5jdGlvbiAocmVzdWx0cykgeyByZXR1cm4gcmVzdWx0cy5ldmVyeShmdW5jdGlvbiAodCkgeyByZXR1cm4gdDsgfSk7IH0pO1xufTtcblxuLyoqXG4gKiBWYWxpZGF0ZXMgYWxsIHNjb3Blcy5cbiAqL1xuVmFsaWRhdG9yLnByb3RvdHlwZS52YWxpZGF0ZVNjb3BlcyA9IGZ1bmN0aW9uIHZhbGlkYXRlU2NvcGVzICgpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICBpZiAodGhpcy5wYXVzZWQpIHsgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh0cnVlKTsgfVxuXG4gIHZhciBwcm9taXNlcyA9IHRoaXMuZmllbGRzLm1hcChmdW5jdGlvbiAoZmllbGQpIHsgcmV0dXJuIHRoaXMkMS52YWxpZGF0ZShcbiAgICAoXCIjXCIgKyAoZmllbGQuaWQpKSxcbiAgICBmaWVsZC52YWx1ZVxuICApOyB9KTtcblxuICByZXR1cm4gUHJvbWlzZS5hbGwocHJvbWlzZXMpLnRoZW4oZnVuY3Rpb24gKHJlc3VsdHMpIHsgcmV0dXJuIHJlc3VsdHMuZXZlcnkoZnVuY3Rpb24gKHQpIHsgcmV0dXJuIHQ7IH0pOyB9KTtcbn07XG5cbi8qKlxuICogUGVyZm9ybSBjbGVhbnVwLlxuICovXG5WYWxpZGF0b3IucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiBkZXN0cm95ICgpIHtcbiAgLy8gUmVtb3ZlIEVycm9yQmFnIGluc3RhbmNlLlxuICB2YXIgaWR4ID0gRVJST1JTLmluZGV4T2YodGhpcy5lcnJvcnMpO1xuICBpZiAoaWR4ID09PSAtMSkgeyByZXR1cm47IH1cblxuICBFUlJPUlMuc3BsaWNlKGlkeCwgMSk7XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgdGhlIGZpZWxkcyB0byBiZSB2YWxpZGF0ZWQuXG4gKi9cblZhbGlkYXRvci5wcm90b3R5cGUuX2NyZWF0ZUZpZWxkcyA9IGZ1bmN0aW9uIF9jcmVhdGVGaWVsZHMgKHZhbGlkYXRpb25zKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgaWYgKCF2YWxpZGF0aW9ucykgeyByZXR1cm47IH1cblxuICBPYmplY3Qua2V5cyh2YWxpZGF0aW9ucykuZm9yRWFjaChmdW5jdGlvbiAoZmllbGQpIHtcbiAgICB2YXIgb3B0aW9ucyA9IGFzc2lnbih7fSwgeyBuYW1lOiBmaWVsZCwgcnVsZXM6IHZhbGlkYXRpb25zW2ZpZWxkXSB9KTtcbiAgICB0aGlzJDEuYXR0YWNoKG9wdGlvbnMpO1xuICB9KTtcbn07XG5cbi8qKlxuICogRGF0ZSBydWxlcyBuZWVkIHRoZSBleGlzdGVuY2Ugb2YgYSBmb3JtYXQsIHNvIGRhdGVfZm9ybWF0IG11c3QgYmUgc3VwcGxpZWQuXG4gKi9cblZhbGlkYXRvci5wcm90b3R5cGUuX2dldERhdGVGb3JtYXQgPSBmdW5jdGlvbiBfZ2V0RGF0ZUZvcm1hdCAodmFsaWRhdGlvbnMpIHtcbiAgdmFyIGZvcm1hdCA9IG51bGw7XG4gIGlmICh2YWxpZGF0aW9ucy5kYXRlX2Zvcm1hdCAmJiBBcnJheS5pc0FycmF5KHZhbGlkYXRpb25zLmRhdGVfZm9ybWF0KSkge1xuICAgIGZvcm1hdCA9IHZhbGlkYXRpb25zLmRhdGVfZm9ybWF0WzBdO1xuICB9XG5cbiAgcmV0dXJuIGZvcm1hdCB8fCB0aGlzLmRpY3Rpb25hcnkuZ2V0RGF0ZUZvcm1hdCh0aGlzLmxvY2FsZSk7XG59O1xuXG4vKipcbiAqIENoZWNrcyBpZiB0aGUgcGFzc2VkIHJ1bGUgaXMgYSBkYXRlIHJ1bGUuXG4gKi9cblZhbGlkYXRvci5wcm90b3R5cGUuX2lzQURhdGVSdWxlID0gZnVuY3Rpb24gX2lzQURhdGVSdWxlIChydWxlKSB7XG4gIHJldHVybiAhISB+WydhZnRlcicsICdiZWZvcmUnLCAnZGF0ZV9iZXR3ZWVuJywgJ2RhdGVfZm9ybWF0J10uaW5kZXhPZihydWxlKTtcbn07XG5cbi8qKlxuICogRm9ybWF0cyBhbiBlcnJvciBtZXNzYWdlIGZvciBmaWVsZCBhbmQgYSBydWxlLlxuICovXG5WYWxpZGF0b3IucHJvdG90eXBlLl9mb3JtYXRFcnJvck1lc3NhZ2UgPSBmdW5jdGlvbiBfZm9ybWF0RXJyb3JNZXNzYWdlIChmaWVsZCwgcnVsZSwgZGF0YSwgdGFyZ2V0TmFtZSkge1xuICAgIGlmICggZGF0YSA9PT0gdm9pZCAwICkgZGF0YSA9IHt9O1xuICAgIGlmICggdGFyZ2V0TmFtZSA9PT0gdm9pZCAwICkgdGFyZ2V0TmFtZSA9IG51bGw7XG5cbiAgdmFyIG5hbWUgPSB0aGlzLl9nZXRGaWVsZERpc3BsYXlOYW1lKGZpZWxkKTtcbiAgdmFyIHBhcmFtcyA9IHRoaXMuX2dldExvY2FsaXplZFBhcmFtcyhydWxlLCB0YXJnZXROYW1lKTtcblxuICByZXR1cm4gdGhpcy5kaWN0aW9uYXJ5LmdldEZpZWxkTWVzc2FnZSh0aGlzLmxvY2FsZSwgZmllbGQubmFtZSwgcnVsZS5uYW1lLCBbbmFtZSwgcGFyYW1zLCBkYXRhXSk7XG59O1xuXG4vKipcbiAqIFRyYW5zbGF0ZXMgdGhlIHBhcmFtZXRlcnMgcGFzc2VkIHRvIHRoZSBydWxlIChtYWlubHkgZm9yIHRhcmdldCBmaWVsZHMpLlxuICovXG5WYWxpZGF0b3IucHJvdG90eXBlLl9nZXRMb2NhbGl6ZWRQYXJhbXMgPSBmdW5jdGlvbiBfZ2V0TG9jYWxpemVkUGFyYW1zIChydWxlLCB0YXJnZXROYW1lKSB7XG4gICAgaWYgKCB0YXJnZXROYW1lID09PSB2b2lkIDAgKSB0YXJnZXROYW1lID0gbnVsbDtcblxuICBpZiAoflRBUkdFVF9SVUxFUy5pbmRleE9mKHJ1bGUubmFtZSkgJiYgcnVsZS5wYXJhbXMgJiYgcnVsZS5wYXJhbXNbMF0pIHtcbiAgICB2YXIgbG9jYWxpemVkTmFtZSA9IHRhcmdldE5hbWUgfHwgdGhpcy5kaWN0aW9uYXJ5LmdldEF0dHJpYnV0ZSh0aGlzLmxvY2FsZSwgcnVsZS5wYXJhbXNbMF0sIHJ1bGUucGFyYW1zWzBdKTtcbiAgICByZXR1cm4gW2xvY2FsaXplZE5hbWVdLmNvbmNhdChydWxlLnBhcmFtcy5zbGljZSgxKSk7XG4gIH1cblxuICByZXR1cm4gcnVsZS5wYXJhbXM7XG59O1xuXG4vKipcbiAqIFJlc29sdmVzIGFuIGFwcHJvcHJpYXRlIGRpc3BsYXkgbmFtZSwgZmlyc3QgY2hlY2tpbmcgJ2RhdGEtYXMnIG9yIHRoZSByZWdpc3RlcmVkICdwcmV0dHlOYW1lJ1xuICovXG5WYWxpZGF0b3IucHJvdG90eXBlLl9nZXRGaWVsZERpc3BsYXlOYW1lID0gZnVuY3Rpb24gX2dldEZpZWxkRGlzcGxheU5hbWUgKGZpZWxkKSB7XG4gIHJldHVybiBmaWVsZC5hbGlhcyB8fCB0aGlzLmRpY3Rpb25hcnkuZ2V0QXR0cmlidXRlKHRoaXMubG9jYWxlLCBmaWVsZC5uYW1lLCBmaWVsZC5uYW1lKTtcbn07XG5cbi8qKlxuICogQWRkcyBhIGZpZWxkIGZsYWdzIHRvIHRoZSBmbGFncyBjb2xsZWN0aW9uLlxuICovXG5WYWxpZGF0b3IucHJvdG90eXBlLl9hZGRGbGFnID0gZnVuY3Rpb24gX2FkZEZsYWcgKGZpZWxkLCBzY29wZSkge1xuICAgIGlmICggc2NvcGUgPT09IHZvaWQgMCApIHNjb3BlID0gbnVsbDtcblxuICBpZiAoaXNOdWxsT3JVbmRlZmluZWQoc2NvcGUpKSB7XG4gICAgdGhpcy5mbGFncyA9IGFzc2lnbih7fSwgdGhpcy5mbGFncywgKCBvYmogPSB7fSwgb2JqWyhcIlwiICsgKGZpZWxkLm5hbWUpKV0gPSBmaWVsZC5mbGFncywgb2JqICkpO1xuICAgICAgdmFyIG9iajtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgc2NvcGVPYmogPSBhc3NpZ24oe30sIHRoaXMuZmxhZ3NbKFwiJFwiICsgc2NvcGUpXSB8fCB7fSwgKCBvYmokMSA9IHt9LCBvYmokMVsoXCJcIiArIChmaWVsZC5uYW1lKSldID0gZmllbGQuZmxhZ3MsIG9iaiQxICkpO1xuICAgIHZhciBvYmokMTtcbiAgdGhpcy5mbGFncyA9IGFzc2lnbih7fSwgdGhpcy5mbGFncywgKCBvYmokMiA9IHt9LCBvYmokMlsoXCIkXCIgKyBzY29wZSldID0gc2NvcGVPYmosIG9iaiQyICkpO1xuICAgIHZhciBvYmokMjtcbn07XG5cbi8qKlxuICogUmVzZXRzIGZpZWxkcyB0aGF0IG1hdGNoZXMgdGhlIG1hdGNoZXIgb3B0aW9ucyBvciBhbGwgZmllbGRzIGlmIG5vdCBzcGVjaWZpZWQuXG4gKi9cblZhbGlkYXRvci5wcm90b3R5cGUuX3Jlc2V0ID0gZnVuY3Rpb24gX3Jlc2V0IChtYXRjaGVyKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlKSB7XG4gICAgaWYgKG1hdGNoZXIpIHtcbiAgICAgIHRoaXMkMS5maWVsZHMuZmlsdGVyKG1hdGNoZXIpLmZvckVhY2goZnVuY3Rpb24gKGZpZWxkKSB7XG4gICAgICAgIGZpZWxkLnJlc2V0KCk7IC8vIHJlc2V0IGZpZWxkIGZsYWdzLlxuICAgICAgICB0aGlzJDEuZXJyb3JzLnJlbW92ZShmaWVsZC5uYW1lLCBmaWVsZC5zY29wZSwgZmllbGQuaWQpO1xuICAgICAgfSk7XG5cbiAgICAgIHJldHVybiByZXNvbHZlKCk7XG4gICAgfVxuXG4gICAgdGhpcyQxLmZpZWxkcy5pdGVtcy5mb3JFYWNoKGZ1bmN0aW9uIChpKSB7IHJldHVybiBpLnJlc2V0KCk7IH0pO1xuICAgIHRoaXMkMS5lcnJvcnMuY2xlYXIoKTtcbiAgICByZXNvbHZlKCk7XG4gIH0pO1xufTtcblxuLyoqXG4gKiBUZXN0cyBhIHNpbmdsZSBpbnB1dCB2YWx1ZSBhZ2FpbnN0IGEgcnVsZS5cbiAqL1xuVmFsaWRhdG9yLnByb3RvdHlwZS5fdGVzdCA9IGZ1bmN0aW9uIF90ZXN0IChmaWVsZCwgdmFsdWUsIHJ1bGUpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICB2YXIgdmFsaWRhdG9yID0gUlVMRVNbcnVsZS5uYW1lXTtcbiAgdmFyIHBhcmFtcyA9IEFycmF5LmlzQXJyYXkocnVsZS5wYXJhbXMpID8gdG9BcnJheShydWxlLnBhcmFtcykgOiBbXTtcbiAgdmFyIHRhcmdldE5hbWUgPSBudWxsO1xuICBpZiAoIXZhbGlkYXRvciB8fCB0eXBlb2YgdmFsaWRhdG9yICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgY3JlYXRlRXJyb3IoKFwiTm8gc3VjaCB2YWxpZGF0b3IgJ1wiICsgKHJ1bGUubmFtZSkgKyBcIicgZXhpc3RzLlwiKSk7XG4gIH1cblxuICAvLyBoYXMgZmllbGQgZGVwZW5kZW5jaWVzLlxuICBpZiAoVEFSR0VUX1JVTEVTLmluZGV4T2YocnVsZS5uYW1lKSAhPT0gLTEpIHtcbiAgICB2YXIgdGFyZ2V0ID0gZmluZChmaWVsZC5kZXBlbmRlbmNpZXMsIGZ1bmN0aW9uIChkKSB7IHJldHVybiBkLm5hbWUgPT09IHJ1bGUubmFtZTsgfSk7XG4gICAgaWYgKHRhcmdldCkge1xuICAgICAgdGFyZ2V0TmFtZSA9IHRhcmdldC5maWVsZC5hbGlhcztcbiAgICAgIHBhcmFtcyA9IFt0YXJnZXQuZmllbGQudmFsdWVdLmNvbmNhdChwYXJhbXMuc2xpY2UoMSkpO1xuICAgIH1cbiAgfSBlbHNlIGlmIChydWxlLm5hbWUgPT09ICdyZXF1aXJlZCcgJiYgZmllbGQucmVqZWN0c0ZhbHNlKSB7XG4gICAgLy8gaW52YWxpZGF0ZSBmYWxzZSBpZiBubyBhcmdzIHdlcmUgc3BlY2lmaWVkIGFuZCB0aGUgZmllbGQgcmVqZWN0cyBmYWxzZSBieSBkZWZhdWx0LlxuICAgIHBhcmFtcyA9IHBhcmFtcy5sZW5ndGggPyBwYXJhbXMgOiBbdHJ1ZV07XG4gIH1cblxuICBpZiAodGhpcy5faXNBRGF0ZVJ1bGUocnVsZS5uYW1lKSkge1xuICAgIHZhciBkYXRlRm9ybWF0ID0gdGhpcy5fZ2V0RGF0ZUZvcm1hdChmaWVsZC5ydWxlcyk7XG4gICAgaWYgKHJ1bGUubmFtZSAhPT0gJ2RhdGVfZm9ybWF0Jykge1xuICAgICAgcGFyYW1zLnB1c2goZGF0ZUZvcm1hdCk7XG4gICAgfVxuICB9XG5cbiAgdmFyIHJlc3VsdCA9IHZhbGlkYXRvcih2YWx1ZSwgcGFyYW1zKTtcblxuICAvLyBJZiBpdCBpcyBhIHByb21pc2UuXG4gIGlmIChpc0NhbGxhYmxlKHJlc3VsdC50aGVuKSkge1xuICAgIHJldHVybiByZXN1bHQudGhlbihmdW5jdGlvbiAodmFsdWVzKSB7XG4gICAgICB2YXIgYWxsVmFsaWQgPSB0cnVlO1xuICAgICAgdmFyIGRhdGEgPSB7fTtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlcykpIHtcbiAgICAgICAgYWxsVmFsaWQgPSB2YWx1ZXMuZXZlcnkoZnVuY3Rpb24gKHQpIHsgcmV0dXJuIChpc09iamVjdCh0KSA/IHQudmFsaWQgOiB0KTsgfSk7XG4gICAgICB9IGVsc2UgeyAvLyBJcyBhIHNpbmdsZSBvYmplY3QvYm9vbGVhbi5cbiAgICAgICAgYWxsVmFsaWQgPSBpc09iamVjdCh2YWx1ZXMpID8gdmFsdWVzLnZhbGlkIDogdmFsdWVzO1xuICAgICAgICBkYXRhID0gdmFsdWVzLmRhdGE7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHZhbGlkOiBhbGxWYWxpZCxcbiAgICAgICAgZXJyb3I6IGFsbFZhbGlkID8gdW5kZWZpbmVkIDogdGhpcyQxLl9jcmVhdGVGaWVsZEVycm9yKGZpZWxkLCBydWxlLCBkYXRhLCB0YXJnZXROYW1lKVxuICAgICAgfTtcbiAgICB9KTtcbiAgfVxuXG4gIGlmICghaXNPYmplY3QocmVzdWx0KSkge1xuICAgIHJlc3VsdCA9IHsgdmFsaWQ6IHJlc3VsdCwgZGF0YToge30gfTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgdmFsaWQ6IHJlc3VsdC52YWxpZCxcbiAgICBlcnJvcjogcmVzdWx0LnZhbGlkID8gdW5kZWZpbmVkIDogdGhpcy5fY3JlYXRlRmllbGRFcnJvcihmaWVsZCwgcnVsZSwgcmVzdWx0LmRhdGEsIHRhcmdldE5hbWUpXG4gIH07XG59O1xuXG4vKipcbiAqIE1lcmdlcyBhIHZhbGlkYXRvciBvYmplY3QgaW50byB0aGUgUlVMRVMgYW5kIE1lc3NhZ2VzLlxuICovXG5WYWxpZGF0b3IuX21lcmdlID0gZnVuY3Rpb24gX21lcmdlIChuYW1lLCB2YWxpZGF0b3IpIHtcbiAgaWYgKGlzQ2FsbGFibGUodmFsaWRhdG9yKSkge1xuICAgIFJVTEVTW25hbWVdID0gdmFsaWRhdG9yO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIFJVTEVTW25hbWVdID0gdmFsaWRhdG9yLnZhbGlkYXRlO1xuICBpZiAodmFsaWRhdG9yLmdldE1lc3NhZ2UpIHtcbiAgICBWYWxpZGF0b3IuZGljdGlvbmFyeS5zZXRNZXNzYWdlKHRoaXMubG9jYWxlLCBuYW1lLCB2YWxpZGF0b3IuZ2V0TWVzc2FnZSk7XG4gIH1cbn07XG5cbi8qKlxuICogR3VhcmRzIGZyb20gZXh0ZW5zaW9uIHZpb2xhdGlvbnMuXG4gKi9cblZhbGlkYXRvci5fZ3VhcmRFeHRlbmQgPSBmdW5jdGlvbiBfZ3VhcmRFeHRlbmQgKG5hbWUsIHZhbGlkYXRvcikge1xuICBpZiAoaXNDYWxsYWJsZSh2YWxpZGF0b3IpKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKCFpc0NhbGxhYmxlKHZhbGlkYXRvci52YWxpZGF0ZSkpIHtcbiAgICB0aHJvdyBjcmVhdGVFcnJvcihcbiAgICAgIChcIkV4dGVuc2lvbiBFcnJvcjogVGhlIHZhbGlkYXRvciAnXCIgKyBuYW1lICsgXCInIG11c3QgYmUgYSBmdW5jdGlvbiBvciBoYXZlIGEgJ3ZhbGlkYXRlJyBtZXRob2QuXCIpXG4gICAgKTtcbiAgfVxuXG4gIGlmICghaXNDYWxsYWJsZSh2YWxpZGF0b3IuZ2V0TWVzc2FnZSkgJiYgdHlwZW9mIHZhbGlkYXRvci5nZXRNZXNzYWdlICE9PSAnc3RyaW5nJykge1xuICAgIHRocm93IGNyZWF0ZUVycm9yKFxuICAgICAgKFwiRXh0ZW5zaW9uIEVycm9yOiBUaGUgdmFsaWRhdG9yICdcIiArIG5hbWUgKyBcIicgb2JqZWN0IG11c3QgaGF2ZSBhICdnZXRNZXNzYWdlJyBtZXRob2Qgb3Igc3RyaW5nLlwiKVxuICAgICk7XG4gIH1cbn07XG5cbi8qKlxuICogQ3JlYXRlcyBhIEZpZWxkIEVycm9yIE9iamVjdC5cbiAqL1xuVmFsaWRhdG9yLnByb3RvdHlwZS5fY3JlYXRlRmllbGRFcnJvciA9IGZ1bmN0aW9uIF9jcmVhdGVGaWVsZEVycm9yIChmaWVsZCwgcnVsZSwgZGF0YSwgdGFyZ2V0TmFtZSkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gIHJldHVybiB7XG4gICAgaWQ6IGZpZWxkLmlkLFxuICAgIGZpZWxkOiBmaWVsZC5uYW1lLFxuICAgIG1zZzogdGhpcy5fZm9ybWF0RXJyb3JNZXNzYWdlKGZpZWxkLCBydWxlLCBkYXRhLCB0YXJnZXROYW1lKSxcbiAgICBydWxlOiBydWxlLm5hbWUsXG4gICAgc2NvcGU6IGZpZWxkLnNjb3BlLFxuICAgIHJlZ2VuZXJhdGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzJDEuX2Zvcm1hdEVycm9yTWVzc2FnZShmaWVsZCwgcnVsZSwgZGF0YSwgdGFyZ2V0TmFtZSk7XG4gICAgfVxuICB9O1xufTtcblxuLyoqXG4gKiBUcmllcyBkaWZmZXJlbnQgc3RyYXRlZ2llcyB0byBmaW5kIGEgZmllbGQuXG4gKi9cblZhbGlkYXRvci5wcm90b3R5cGUuX3Jlc29sdmVGaWVsZCA9IGZ1bmN0aW9uIF9yZXNvbHZlRmllbGQgKG5hbWUsIHNjb3BlKSB7XG4gIGlmICghaXNOdWxsT3JVbmRlZmluZWQoc2NvcGUpKSB7XG4gICAgcmV0dXJuIHRoaXMuZmllbGRzLmZpbmQoeyBuYW1lOiBuYW1lLCBzY29wZTogc2NvcGUgfSk7XG4gIH1cblxuICBpZiAobmFtZVswXSA9PT0gJyMnKSB7XG4gICAgcmV0dXJuIHRoaXMuZmllbGRzLmZpbmQoeyBpZDogbmFtZS5zbGljZSgxKSB9KTtcbiAgfVxuXG4gIGlmIChuYW1lLmluZGV4T2YoJy4nKSA+IC0xKSB7XG4gICAgdmFyIHJlZiA9IG5hbWUuc3BsaXQoJy4nKTtcbiAgICAgIHZhciBmaWVsZFNjb3BlID0gcmVmWzBdO1xuICAgICAgdmFyIGZpZWxkTmFtZSA9IHJlZi5zbGljZSgxKTtcbiAgICB2YXIgZmllbGQgPSB0aGlzLmZpZWxkcy5maW5kKHsgbmFtZTogZmllbGROYW1lLmpvaW4oJy4nKSwgc2NvcGU6IGZpZWxkU2NvcGUgfSk7XG4gICAgaWYgKGZpZWxkKSB7XG4gICAgICByZXR1cm4gZmllbGQ7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRoaXMuZmllbGRzLmZpbmQoeyBuYW1lOiBuYW1lLCBzY29wZTogbnVsbCB9KTtcbn07XG5cbi8qKlxuICogSGFuZGxlcyB3aGVuIGEgZmllbGQgaXMgbm90IGZvdW5kIGRlcGVuZGluZyBvbiB0aGUgc3RyaWN0IGZsYWcuXG4gKi9cblZhbGlkYXRvci5wcm90b3R5cGUuX2hhbmRsZUZpZWxkTm90Rm91bmQgPSBmdW5jdGlvbiBfaGFuZGxlRmllbGROb3RGb3VuZCAobmFtZSwgc2NvcGUpIHtcbiAgaWYgKCF0aGlzLnN0cmljdCkgeyByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHRydWUpOyB9XG5cbiAgdmFyIGZ1bGxOYW1lID0gaXNOdWxsT3JVbmRlZmluZWQoc2NvcGUpID8gbmFtZSA6IChcIlwiICsgKCFpc051bGxPclVuZGVmaW5lZChzY29wZSkgPyBzY29wZSArICcuJyA6ICcnKSArIG5hbWUpO1xuICB0aHJvdyBjcmVhdGVFcnJvcihcbiAgICAoXCJWYWxpZGF0aW5nIGEgbm9uLWV4aXN0ZW50IGZpZWxkOiBcXFwiXCIgKyBmdWxsTmFtZSArIFwiXFxcIi4gVXNlIFxcXCJhdHRhY2goKVxcXCIgZmlyc3QuXCIpXG4gICk7XG59O1xuXG4vKipcbiAqIFN0YXJ0cyB0aGUgdmFsaWRhdGlvbiBwcm9jZXNzLlxuICovXG5WYWxpZGF0b3IucHJvdG90eXBlLl92YWxpZGF0ZSA9IGZ1bmN0aW9uIF92YWxpZGF0ZSAoZmllbGQsIHZhbHVlLCBzaWxlbnQpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcbiAgICBpZiAoIHNpbGVudCA9PT0gdm9pZCAwICkgc2lsZW50ID0gZmFsc2U7XG5cbiAgaWYgKCFmaWVsZC5pc1JlcXVpcmVkICYmIChpc051bGxPclVuZGVmaW5lZCh2YWx1ZSkgfHwgdmFsdWUgPT09ICcnKSkge1xuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoeyB2YWxpZDogdHJ1ZSB9KTtcbiAgfVxuXG4gIHZhciBwcm9taXNlcyA9IFtdO1xuICB2YXIgZXJyb3JzID0gW107XG4gIHZhciBpc0V4aXRFYXJseSA9IGZhbHNlO1xuICAvLyB1c2Ugb2YgJy5zb21lKCknIGlzIHRvIGJyZWFrIGl0ZXJhdGlvbiBpbiBtaWRkbGUgYnkgcmV0dXJuaW5nIHRydWVcbiAgT2JqZWN0LmtleXMoZmllbGQucnVsZXMpLnNvbWUoZnVuY3Rpb24gKHJ1bGUpIHtcbiAgICB2YXIgcmVzdWx0ID0gdGhpcyQxLl90ZXN0KGZpZWxkLCB2YWx1ZSwgeyBuYW1lOiBydWxlLCBwYXJhbXM6IGZpZWxkLnJ1bGVzW3J1bGVdIH0pO1xuICAgIGlmIChpc0NhbGxhYmxlKHJlc3VsdC50aGVuKSkge1xuICAgICAgcHJvbWlzZXMucHVzaChyZXN1bHQpO1xuICAgIH0gZWxzZSBpZiAodGhpcyQxLmZhc3RFeGl0ICYmICFyZXN1bHQudmFsaWQpIHtcbiAgICAgIGVycm9ycy5wdXNoKHJlc3VsdC5lcnJvcik7XG4gICAgICBpc0V4aXRFYXJseSA9IHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIHByb21pc2lmeSB0aGUgcmVzdWx0LlxuICAgICAgcHJvbWlzZXMucHVzaChuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSkge1xuICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICB9KSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGlzRXhpdEVhcmx5O1xuICB9KTtcblxuICBpZiAoaXNFeGl0RWFybHkpIHtcbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHtcbiAgICAgIHZhbGlkOiBmYWxzZSxcbiAgICAgIGVycm9yczogZXJyb3JzXG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4gUHJvbWlzZS5hbGwocHJvbWlzZXMpLnRoZW4oZnVuY3Rpb24gKHZhbHVlcykgeyByZXR1cm4gdmFsdWVzLm1hcChmdW5jdGlvbiAodikge1xuICAgIGlmICghdi52YWxpZCkge1xuICAgICAgZXJyb3JzLnB1c2godi5lcnJvcik7XG4gICAgfVxuXG4gICAgcmV0dXJuIHYudmFsaWQ7XG4gIH0pLmV2ZXJ5KGZ1bmN0aW9uICh0KSB7IHJldHVybiB0OyB9KTsgfVxuICApLnRoZW4oZnVuY3Rpb24gKHJlc3VsdCkge1xuICAgIHJldHVybiB7XG4gICAgICB2YWxpZDogcmVzdWx0LFxuICAgICAgZXJyb3JzOiBlcnJvcnNcbiAgICB9O1xuICB9KTtcbn07XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKCBWYWxpZGF0b3IucHJvdG90eXBlLCBwcm90b3R5cGVBY2Nlc3NvcnMgKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKCBWYWxpZGF0b3IsIHN0YXRpY0FjY2Vzc29ycyApO1xuXG4vLyBcblxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbnZhciBmYWtlRmxhZ3MgPSBjcmVhdGVQcm94eSh7fSwge1xuICBnZXQ6IGZ1bmN0aW9uIGdldCAodGFyZ2V0LCBrZXkpIHtcbiAgICAvLyBpcyBhIHNjb3BlXG4gICAgaWYgKFN0cmluZyhrZXkpLmluZGV4T2YoJyQnKSA9PT0gMCkge1xuICAgICAgcmV0dXJuIGZha2VGbGFncztcbiAgICB9XG5cbiAgICByZXR1cm4gY3JlYXRlRmxhZ3MoKTtcbiAgfVxufSk7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGEgcGFyZW50IHZhbGlkYXRvciBpbnN0YW5jZSB3YXMgcmVxdWVzdGVkLlxuICovXG52YXIgcmVxdWVzdHNWYWxpZGF0b3IgPSBmdW5jdGlvbiAoaW5qZWN0aW9ucykge1xuICBpZiAoaXNPYmplY3QoaW5qZWN0aW9ucykgJiYgaW5qZWN0aW9ucy4kdmFsaWRhdG9yKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgYSB2YWxpZGF0b3IgaW5zdGFuY2UuXG4gKi9cbnZhciBjcmVhdGVWYWxpZGF0b3IgPSBmdW5jdGlvbiAodm0sIG9wdGlvbnMpIHsgcmV0dXJuIG5ldyBWYWxpZGF0b3IobnVsbCwgeyB2bTogdm0sIGZhc3RFeGl0OiBvcHRpb25zLmZhc3RFeGl0IH0pOyB9O1xuXG52YXIgbWl4aW4gPSB7XG4gIHByb3ZpZGU6IGZ1bmN0aW9uIHByb3ZpZGUgKCkge1xuICAgIGlmICh0aGlzLiR2YWxpZGF0b3IgJiYgIWlzQnVpbHRJbkNvbXBvbmVudCh0aGlzLiR2bm9kZSkpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgICR2YWxpZGF0b3I6IHRoaXMuJHZhbGlkYXRvclxuICAgICAgfTtcbiAgICB9XG5cbiAgICByZXR1cm4ge307XG4gIH0sXG4gIGJlZm9yZUNyZWF0ZTogZnVuY3Rpb24gYmVmb3JlQ3JlYXRlICgpIHtcbiAgICAvLyBpZiBidWlsdCBpbiBkbyBub3RoaW5nLlxuICAgIGlmIChpc0J1aWx0SW5Db21wb25lbnQodGhpcy4kdm5vZGUpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gaWYgaXRzIGEgcm9vdCBpbnN0YW5jZSBzZXQgdGhlIGNvbmZpZyBpZiBpdCBleGlzdHMuXG4gICAgaWYgKCF0aGlzLiRwYXJlbnQpIHtcbiAgICAgIENvbmZpZy5tZXJnZSh0aGlzLiRvcHRpb25zLiRfdmVlVmFsaWRhdGUgfHwge30pO1xuICAgIH1cblxuICAgIHZhciBvcHRpb25zID0gQ29uZmlnLnJlc29sdmUodGhpcyk7XG4gICAgdmFyIFZ1ZSA9IHRoaXMuJG9wdGlvbnMuX2Jhc2U7IC8vIHRoZSB2dWUgY29uc3RydWN0b3IuXG4gICAgLy8gVE9ETzogRGVwcmVjYXRlXG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICBpZiAodGhpcy4kb3B0aW9ucy4kdmFsaWRhdGVzKSB7XG4gICAgICB3YXJuKCdUaGUgY3RvciAkdmFsaWRhdGVzIG9wdGlvbiBoYXMgYmVlbiBkZXByZWNhdGVkIHBsZWFzZSBzZXQgdGhlICRfdmVlVmFsaWRhdGUudmFsaWRhdG9yIG9wdGlvbiB0byBcIm5ld1wiIGluc3RlYWQnKTtcbiAgICAgIHRoaXMuJHZhbGlkYXRvciA9IGNyZWF0ZVZhbGlkYXRvcih0aGlzLCBvcHRpb25zKTtcbiAgICB9XG5cbiAgICAvLyBpZiBpdHMgYSByb290IGluc3RhbmNlLCBpbmplY3QgYW55d2F5cywgb3IgaWYgaXQgcmVxdWVzdGVkIGEgbmV3IGluc3RhbmNlLlxuICAgIGlmICghdGhpcy4kcGFyZW50IHx8ICh0aGlzLiRvcHRpb25zLiRfdmVlVmFsaWRhdGUgJiYgL25ldy8udGVzdCh0aGlzLiRvcHRpb25zLiRfdmVlVmFsaWRhdGUudmFsaWRhdG9yKSkpIHtcbiAgICAgIHRoaXMuJHZhbGlkYXRvciA9IGNyZWF0ZVZhbGlkYXRvcih0aGlzLCBvcHRpb25zKTtcbiAgICB9XG5cbiAgICB2YXIgcmVxdWVzdGVkID0gcmVxdWVzdHNWYWxpZGF0b3IodGhpcy4kb3B0aW9ucy5pbmplY3QpO1xuXG4gICAgLy8gaWYgYXV0b21hdGljIGluamVjdGlvbiBpcyBlbmFibGVkIGFuZCBubyBpbnN0YW5jZSB3YXMgcmVxdWVzdGVkLlxuICAgIGlmICghIHRoaXMuJHZhbGlkYXRvciAmJiBvcHRpb25zLmluamVjdCAmJiAhcmVxdWVzdGVkKSB7XG4gICAgICB0aGlzLiR2YWxpZGF0b3IgPSBjcmVhdGVWYWxpZGF0b3IodGhpcywgb3B0aW9ucyk7XG4gICAgfVxuXG4gICAgLy8gZG9uJ3QgaW5qZWN0IGVycm9ycyBvciBmaWVsZEJhZyBhcyBubyB2YWxpZGF0b3Igd2FzIHJlc29sdmVkLlxuICAgIGlmICghIHJlcXVlc3RlZCAmJiAhIHRoaXMuJHZhbGlkYXRvcikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIFRoZXJlIGlzIGEgdmFsaWRhdG9yIGJ1dCBpdCBpc24ndCBpbmplY3RlZCwgbWFyayBhcyByZWFjdGl2ZS5cbiAgICBpZiAoISByZXF1ZXN0ZWQgJiYgdGhpcy4kdmFsaWRhdG9yKSB7XG4gICAgICBWdWUudXRpbC5kZWZpbmVSZWFjdGl2ZSh0aGlzLiR2YWxpZGF0b3IsICdlcnJvcnMnLCB0aGlzLiR2YWxpZGF0b3IuZXJyb3JzKTtcbiAgICAgIFZ1ZS51dGlsLmRlZmluZVJlYWN0aXZlKHRoaXMuJHZhbGlkYXRvciwgJ2ZsYWdzJywgdGhpcy4kdmFsaWRhdG9yLmZsYWdzKTtcbiAgICB9XG5cbiAgICBpZiAoISB0aGlzLiRvcHRpb25zLmNvbXB1dGVkKSB7XG4gICAgICB0aGlzLiRvcHRpb25zLmNvbXB1dGVkID0ge307XG4gICAgfVxuXG4gICAgdGhpcy4kb3B0aW9ucy5jb21wdXRlZFtvcHRpb25zLmVycm9yQmFnTmFtZSB8fCAnZXJyb3JzJ10gPSBmdW5jdGlvbiBlcnJvckJhZ0dldHRlciAoKSB7XG4gICAgICByZXR1cm4gdGhpcy4kdmFsaWRhdG9yLmVycm9ycztcbiAgICB9O1xuICAgIHRoaXMuJG9wdGlvbnMuY29tcHV0ZWRbb3B0aW9ucy5maWVsZHNCYWdOYW1lIHx8ICdmaWVsZHMnXSA9IGZ1bmN0aW9uIGZpZWxkQmFnR2V0dGVyICgpIHtcbiAgICAgIGlmICghT2JqZWN0LmtleXModGhpcy4kdmFsaWRhdG9yLmZsYWdzKS5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIGZha2VGbGFncztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMuJHZhbGlkYXRvci5mbGFncztcbiAgICB9O1xuICB9LFxuICBiZWZvcmVEZXN0cm95OiBmdW5jdGlvbiBiZWZvcmVEZXN0cm95ICgpIHtcbiAgICBpZiAoaXNCdWlsdEluQ29tcG9uZW50KHRoaXMuJHZub2RlKSkgeyByZXR1cm47IH1cblxuICAgIC8vIG1hcmsgdGhlIHZhbGlkYXRvciBwYXVzZWQgdG8gcHJldmVudCBkZWxheWVkIHZhbGlkYXRpb24uXG4gICAgaWYgKHRoaXMuJHZhbGlkYXRvciAmJiB0aGlzLiR2YWxpZGF0b3Iub3duZXJJZCA9PT0gdGhpcy5fdWlkKSB7XG4gICAgICB0aGlzLiR2YWxpZGF0b3IucGF1c2UoKTtcbiAgICAgIHRoaXMuJHZhbGlkYXRvci5kZXN0cm95KCk7XG4gICAgfVxuICB9XG59O1xuXG4vLyBcblxuLyoqXG4gKiBGaW5kcyB0aGUgcmVxdWVzdGVkIGZpZWxkIGJ5IGlkIGZyb20gdGhlIGNvbnRleHQgb2JqZWN0LlxuICovXG52YXIgZmluZEZpZWxkID0gZnVuY3Rpb24gKGVsLCBjb250ZXh0KSB7XG4gIGlmICghY29udGV4dCB8fCAhY29udGV4dC4kdmFsaWRhdG9yKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICByZXR1cm4gY29udGV4dC4kdmFsaWRhdG9yLmZpZWxkcy5maW5kKHsgaWQ6IGdldERhdGFBdHRyaWJ1dGUoZWwsICdpZCcpIH0pO1xufTtcblxudmFyIGRpcmVjdGl2ZSA9IHtcbiAgYmluZDogZnVuY3Rpb24gYmluZCAoZWwsIGJpbmRpbmcsIHZub2RlKSB7XG4gICAgdmFyIHZhbGlkYXRvciA9IHZub2RlLmNvbnRleHQuJHZhbGlkYXRvcjtcbiAgICBpZiAoISB2YWxpZGF0b3IpIHtcbiAgICAgIHdhcm4oXCJObyB2YWxpZGF0b3IgaW5zdGFuY2UgaXMgcHJlc2VudCBvbiB2bSwgZGlkIHlvdSBmb3JnZXQgdG8gaW5qZWN0ICckdmFsaWRhdG9yJz9cIik7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGZpZWxkT3B0aW9ucyA9IEdlbmVyYXRvci5nZW5lcmF0ZShlbCwgYmluZGluZywgdm5vZGUpO1xuICAgIHZhbGlkYXRvci5hdHRhY2goZmllbGRPcHRpb25zKTtcbiAgfSxcbiAgaW5zZXJ0ZWQ6IGZ1bmN0aW9uIChlbCwgYmluZGluZywgdm5vZGUpIHtcbiAgICB2YXIgZmllbGQgPSBmaW5kRmllbGQoZWwsIHZub2RlLmNvbnRleHQpO1xuICAgIHZhciBzY29wZSA9IEdlbmVyYXRvci5yZXNvbHZlU2NvcGUoZWwsIGJpbmRpbmcsIHZub2RlKTtcblxuICAgIC8vIHNraXAgaWYgc2NvcGUgaGFzbid0IGNoYW5nZWQuXG4gICAgaWYgKCFmaWVsZCB8fCBzY29wZSA9PT0gZmllbGQuc2NvcGUpIHsgcmV0dXJuOyB9XG5cbiAgICAvLyBvbmx5IHVwZGF0ZSBzY29wZS5cbiAgICBmaWVsZC51cGRhdGUoeyBzY29wZTogc2NvcGUgfSk7XG5cbiAgICAvLyBhbGxvd3MgdGhlIGZpZWxkIHRvIHJlLWV2YWx1YXRlZCBvbmNlIG1vcmUgaW4gdGhlIHVwZGF0ZSBob29rLlxuICAgIGZpZWxkLnVwZGF0ZWQgPSBmYWxzZTtcbiAgfSxcbiAgdXBkYXRlOiBmdW5jdGlvbiAoZWwsIGJpbmRpbmcsIHZub2RlKSB7XG4gICAgdmFyIGZpZWxkID0gZmluZEZpZWxkKGVsLCB2bm9kZS5jb250ZXh0KTtcblxuICAgIC8vIG1ha2Ugc3VyZSB3ZSBkb24ndCBkbyB1bm5lY2Nhc2FyeSB3b3JrIGlmIG5vIGltcG9ydGFudCBjaGFuZ2Ugd2FzIGRvbmUuXG4gICAgaWYgKCFmaWVsZCB8fCAoZmllbGQudXBkYXRlZCAmJiBpc0VxdWFsKGJpbmRpbmcudmFsdWUsIGJpbmRpbmcub2xkVmFsdWUpKSkgeyByZXR1cm47IH1cbiAgICB2YXIgc2NvcGUgPSBHZW5lcmF0b3IucmVzb2x2ZVNjb3BlKGVsLCBiaW5kaW5nLCB2bm9kZSk7XG4gICAgdmFyIHJ1bGVzID0gR2VuZXJhdG9yLnJlc29sdmVSdWxlcyhlbCwgYmluZGluZyk7XG5cbiAgICBmaWVsZC51cGRhdGUoe1xuICAgICAgc2NvcGU6IHNjb3BlLFxuICAgICAgcnVsZXM6IHJ1bGVzXG4gICAgfSk7XG4gIH0sXG4gIHVuYmluZDogZnVuY3Rpb24gdW5iaW5kIChlbCwgYmluZGluZywgcmVmKSB7XG4gICAgdmFyIGNvbnRleHQgPSByZWYuY29udGV4dDtcblxuICAgIHZhciBmaWVsZCA9IGZpbmRGaWVsZChlbCwgY29udGV4dCk7XG4gICAgaWYgKCFmaWVsZCkgeyByZXR1cm47IH1cblxuICAgIGNvbnRleHQuJHZhbGlkYXRvci5kZXRhY2goZmllbGQpO1xuICB9XG59O1xuXG52YXIgVnVlO1xuXG5mdW5jdGlvbiBpbnN0YWxsIChfVnVlLCBvcHRpb25zKSB7XG4gIGlmICggb3B0aW9ucyA9PT0gdm9pZCAwICkgb3B0aW9ucyA9IHt9O1xuXG4gIGlmIChWdWUgJiYgX1Z1ZSA9PT0gVnVlKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHdhcm4oJ2FscmVhZHkgaW5zdGFsbGVkLCBWdWUudXNlKFZlZVZhbGlkYXRlKSBzaG91bGQgb25seSBiZSBjYWxsZWQgb25jZS4nKTtcbiAgICB9XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgVnVlID0gX1Z1ZTtcbiAgQ29uZmlnLm1lcmdlKG9wdGlvbnMpO1xuICB2YXIgcmVmID0gQ29uZmlnLmN1cnJlbnQ7XG4gIHZhciBkaWN0aW9uYXJ5ID0gcmVmLmRpY3Rpb25hcnk7XG4gIHZhciBpMThuID0gcmVmLmkxOG47XG5cbiAgaWYgKGRpY3Rpb25hcnkpIHtcbiAgICBWYWxpZGF0b3IubG9jYWxpemUoZGljdGlvbmFyeSk7IC8vIG1lcmdlIHRoZSBkaWN0aW9uYXJ5LlxuICB9XG5cbiAgLy8gdHJ5IHRvIHdhdGNoIGxvY2FsZSBjaGFuZ2VzLlxuICBpZiAoaTE4biAmJiBpMThuLl92bSAmJiBpc0NhbGxhYmxlKGkxOG4uX3ZtLiR3YXRjaCkpIHtcbiAgICBpMThuLl92bS4kd2F0Y2goJ2xvY2FsZScsIGZ1bmN0aW9uICgpIHtcbiAgICAgIFZhbGlkYXRvci5yZWdlbmVyYXRlKCk7XG4gICAgfSk7XG4gIH1cblxuICBpZiAoIWkxOG4gJiYgb3B0aW9ucy5sb2NhbGUpIHtcbiAgICBWYWxpZGF0b3IubG9jYWxpemUob3B0aW9ucy5sb2NhbGUpOyAvLyBzZXQgdGhlIGxvY2FsZVxuICB9XG5cbiAgVmFsaWRhdG9yLnNldFN0cmljdE1vZGUoQ29uZmlnLmN1cnJlbnQuc3RyaWN0KTtcblxuICBWdWUubWl4aW4obWl4aW4pO1xuICBWdWUuZGlyZWN0aXZlKCd2YWxpZGF0ZScsIGRpcmVjdGl2ZSk7XG59XG5cbi8qKlxuICogRm9ybWF0ZXMgZmlsZSBzaXplLlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfFN0cmluZ30gc2l6ZVxuICovXG52YXIgZm9ybWF0RmlsZVNpemUgPSBmdW5jdGlvbiAoc2l6ZSkge1xuICB2YXIgdW5pdHMgPSBbJ0J5dGUnLCAnS0InLCAnTUInLCAnR0InLCAnVEInLCAnUEInLCAnRUInLCAnWkInLCAnWUInXTtcbiAgdmFyIHRocmVzaG9sZCA9IDEwMjQ7XG4gIHNpemUgPSBOdW1iZXIoc2l6ZSkgKiB0aHJlc2hvbGQ7XG4gIHZhciBpID0gc2l6ZSA9PT0gMCA/IDAgOiBNYXRoLmZsb29yKE1hdGgubG9nKHNpemUpIC8gTWF0aC5sb2codGhyZXNob2xkKSk7XG4gIHJldHVybiAoKChzaXplIC8gTWF0aC5wb3codGhyZXNob2xkLCBpKSkudG9GaXhlZCgyKSAqIDEpICsgXCIgXCIgKyAodW5pdHNbaV0pKTtcbn07XG5cbi8qKlxuICogQ2hlY2tzIGlmIHZlZS12YWxpZGF0ZSBpcyBkZWZpbmVkIGdsb2JhbGx5LlxuICovXG52YXIgaXNEZWZpbmVkR2xvYmFsbHkgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0eXBlb2YgVmVlVmFsaWRhdGUgIT09ICd1bmRlZmluZWQnO1xufTtcblxudmFyIG1lc3NhZ2VzID0ge1xuICBfZGVmYXVsdDogZnVuY3Rpb24gKGZpZWxkKSB7IHJldHVybiAoXCJUaGUgXCIgKyBmaWVsZCArIFwiIHZhbHVlIGlzIG5vdCB2YWxpZC5cIik7IH0sXG4gIGFmdGVyOiBmdW5jdGlvbiAoZmllbGQsIHJlZikge1xuICAgIHZhciB0YXJnZXQgPSByZWZbMF07XG4gICAgdmFyIGluY2x1c2lvbiA9IHJlZlsxXTtcblxuICAgIHJldHVybiAoXCJUaGUgXCIgKyBmaWVsZCArIFwiIG11c3QgYmUgYWZ0ZXIgXCIgKyAoaW5jbHVzaW9uID8gJ29yIGVxdWFsIHRvICcgOiAnJykgKyB0YXJnZXQgKyBcIi5cIik7XG59LFxuICBhbHBoYV9kYXNoOiBmdW5jdGlvbiAoZmllbGQpIHsgcmV0dXJuIChcIlRoZSBcIiArIGZpZWxkICsgXCIgZmllbGQgbWF5IGNvbnRhaW4gYWxwaGEtbnVtZXJpYyBjaGFyYWN0ZXJzIGFzIHdlbGwgYXMgZGFzaGVzIGFuZCB1bmRlcnNjb3Jlcy5cIik7IH0sXG4gIGFscGhhX251bTogZnVuY3Rpb24gKGZpZWxkKSB7IHJldHVybiAoXCJUaGUgXCIgKyBmaWVsZCArIFwiIGZpZWxkIG1heSBvbmx5IGNvbnRhaW4gYWxwaGEtbnVtZXJpYyBjaGFyYWN0ZXJzLlwiKTsgfSxcbiAgYWxwaGFfc3BhY2VzOiBmdW5jdGlvbiAoZmllbGQpIHsgcmV0dXJuIChcIlRoZSBcIiArIGZpZWxkICsgXCIgZmllbGQgbWF5IG9ubHkgY29udGFpbiBhbHBoYWJldGljIGNoYXJhY3RlcnMgYXMgd2VsbCBhcyBzcGFjZXMuXCIpOyB9LFxuICBhbHBoYTogZnVuY3Rpb24gKGZpZWxkKSB7IHJldHVybiAoXCJUaGUgXCIgKyBmaWVsZCArIFwiIGZpZWxkIG1heSBvbmx5IGNvbnRhaW4gYWxwaGFiZXRpYyBjaGFyYWN0ZXJzLlwiKTsgfSxcbiAgYmVmb3JlOiBmdW5jdGlvbiAoZmllbGQsIHJlZikge1xuICAgIHZhciB0YXJnZXQgPSByZWZbMF07XG4gICAgdmFyIGluY2x1c2lvbiA9IHJlZlsxXTtcblxuICAgIHJldHVybiAoXCJUaGUgXCIgKyBmaWVsZCArIFwiIG11c3QgYmUgYmVmb3JlIFwiICsgKGluY2x1c2lvbiA/ICdvciBlcXVhbCB0byAnIDogJycpICsgdGFyZ2V0ICsgXCIuXCIpO1xufSxcbiAgYmV0d2VlbjogZnVuY3Rpb24gKGZpZWxkLCByZWYpIHtcbiAgICB2YXIgbWluID0gcmVmWzBdO1xuICAgIHZhciBtYXggPSByZWZbMV07XG5cbiAgICByZXR1cm4gKFwiVGhlIFwiICsgZmllbGQgKyBcIiBmaWVsZCBtdXN0IGJlIGJldHdlZW4gXCIgKyBtaW4gKyBcIiBhbmQgXCIgKyBtYXggKyBcIi5cIik7XG59LFxuICBjb25maXJtZWQ6IGZ1bmN0aW9uIChmaWVsZCkgeyByZXR1cm4gKFwiVGhlIFwiICsgZmllbGQgKyBcIiBjb25maXJtYXRpb24gZG9lcyBub3QgbWF0Y2guXCIpOyB9LFxuICBjcmVkaXRfY2FyZDogZnVuY3Rpb24gKGZpZWxkKSB7IHJldHVybiAoXCJUaGUgXCIgKyBmaWVsZCArIFwiIGZpZWxkIGlzIGludmFsaWQuXCIpOyB9LFxuICBkYXRlX2JldHdlZW46IGZ1bmN0aW9uIChmaWVsZCwgcmVmKSB7XG4gICAgdmFyIG1pbiA9IHJlZlswXTtcbiAgICB2YXIgbWF4ID0gcmVmWzFdO1xuXG4gICAgcmV0dXJuIChcIlRoZSBcIiArIGZpZWxkICsgXCIgbXVzdCBiZSBiZXR3ZWVuIFwiICsgbWluICsgXCIgYW5kIFwiICsgbWF4ICsgXCIuXCIpO1xufSxcbiAgZGF0ZV9mb3JtYXQ6IGZ1bmN0aW9uIChmaWVsZCwgcmVmKSB7XG4gICAgdmFyIGZvcm1hdCA9IHJlZlswXTtcblxuICAgIHJldHVybiAoXCJUaGUgXCIgKyBmaWVsZCArIFwiIG11c3QgYmUgaW4gdGhlIGZvcm1hdCBcIiArIGZvcm1hdCArIFwiLlwiKTtcbn0sXG4gIGRlY2ltYWw6IGZ1bmN0aW9uIChmaWVsZCwgcmVmKSB7XG4gICAgaWYgKCByZWYgPT09IHZvaWQgMCApIHJlZiA9IFtdO1xuICAgIHZhciBkZWNpbWFscyA9IHJlZlswXTsgaWYgKCBkZWNpbWFscyA9PT0gdm9pZCAwICkgZGVjaW1hbHMgPSAnKic7XG5cbiAgICByZXR1cm4gKFwiVGhlIFwiICsgZmllbGQgKyBcIiBmaWVsZCBtdXN0IGJlIG51bWVyaWMgYW5kIG1heSBjb250YWluIFwiICsgKCFkZWNpbWFscyB8fCBkZWNpbWFscyA9PT0gJyonID8gJycgOiBkZWNpbWFscykgKyBcIiBkZWNpbWFsIHBvaW50cy5cIik7XG59LFxuICBkaWdpdHM6IGZ1bmN0aW9uIChmaWVsZCwgcmVmKSB7XG4gICAgdmFyIGxlbmd0aCA9IHJlZlswXTtcblxuICAgIHJldHVybiAoXCJUaGUgXCIgKyBmaWVsZCArIFwiIGZpZWxkIG11c3QgYmUgbnVtZXJpYyBhbmQgZXhhY3RseSBjb250YWluIFwiICsgbGVuZ3RoICsgXCIgZGlnaXRzLlwiKTtcbn0sXG4gIGRpbWVuc2lvbnM6IGZ1bmN0aW9uIChmaWVsZCwgcmVmKSB7XG4gICAgdmFyIHdpZHRoID0gcmVmWzBdO1xuICAgIHZhciBoZWlnaHQgPSByZWZbMV07XG5cbiAgICByZXR1cm4gKFwiVGhlIFwiICsgZmllbGQgKyBcIiBmaWVsZCBtdXN0IGJlIFwiICsgd2lkdGggKyBcIiBwaXhlbHMgYnkgXCIgKyBoZWlnaHQgKyBcIiBwaXhlbHMuXCIpO1xufSxcbiAgZW1haWw6IGZ1bmN0aW9uIChmaWVsZCkgeyByZXR1cm4gKFwiVGhlIFwiICsgZmllbGQgKyBcIiBmaWVsZCBtdXN0IGJlIGEgdmFsaWQgZW1haWwuXCIpOyB9LFxuICBleHQ6IGZ1bmN0aW9uIChmaWVsZCkgeyByZXR1cm4gKFwiVGhlIFwiICsgZmllbGQgKyBcIiBmaWVsZCBtdXN0IGJlIGEgdmFsaWQgZmlsZS5cIik7IH0sXG4gIGltYWdlOiBmdW5jdGlvbiAoZmllbGQpIHsgcmV0dXJuIChcIlRoZSBcIiArIGZpZWxkICsgXCIgZmllbGQgbXVzdCBiZSBhbiBpbWFnZS5cIik7IH0sXG4gIGluOiBmdW5jdGlvbiAoZmllbGQpIHsgcmV0dXJuIChcIlRoZSBcIiArIGZpZWxkICsgXCIgZmllbGQgbXVzdCBiZSBhIHZhbGlkIHZhbHVlLlwiKTsgfSxcbiAgaW50ZWdlcjogZnVuY3Rpb24gKGZpZWxkKSB7IHJldHVybiAoXCJUaGUgXCIgKyBmaWVsZCArIFwiIGZpZWxkIG11c3QgYmUgYW4gaW50ZWdlci5cIik7IH0sXG4gIGlwOiBmdW5jdGlvbiAoZmllbGQpIHsgcmV0dXJuIChcIlRoZSBcIiArIGZpZWxkICsgXCIgZmllbGQgbXVzdCBiZSBhIHZhbGlkIGlwIGFkZHJlc3MuXCIpOyB9LFxuICBsZW5ndGg6IGZ1bmN0aW9uIChmaWVsZCwgcmVmKSB7XG4gICAgdmFyIGxlbmd0aCA9IHJlZlswXTtcbiAgICB2YXIgbWF4ID0gcmVmWzFdO1xuXG4gICAgaWYgKG1heCkge1xuICAgICAgcmV0dXJuIChcIlRoZSBcIiArIGZpZWxkICsgXCIgbGVuZ3RoIGJlIGJldHdlZW4gXCIgKyBsZW5ndGggKyBcIiBhbmQgXCIgKyBtYXggKyBcIi5cIik7XG4gICAgfVxuXG4gICAgcmV0dXJuIChcIlRoZSBcIiArIGZpZWxkICsgXCIgbGVuZ3RoIG11c3QgYmUgXCIgKyBsZW5ndGggKyBcIi5cIik7XG4gIH0sXG4gIG1heDogZnVuY3Rpb24gKGZpZWxkLCByZWYpIHtcbiAgICB2YXIgbGVuZ3RoID0gcmVmWzBdO1xuXG4gICAgcmV0dXJuIChcIlRoZSBcIiArIGZpZWxkICsgXCIgZmllbGQgbWF5IG5vdCBiZSBncmVhdGVyIHRoYW4gXCIgKyBsZW5ndGggKyBcIiBjaGFyYWN0ZXJzLlwiKTtcbn0sXG4gIG1heF92YWx1ZTogZnVuY3Rpb24gKGZpZWxkLCByZWYpIHtcbiAgICB2YXIgbWF4ID0gcmVmWzBdO1xuXG4gICAgcmV0dXJuIChcIlRoZSBcIiArIGZpZWxkICsgXCIgZmllbGQgbXVzdCBiZSBcIiArIG1heCArIFwiIG9yIGxlc3MuXCIpO1xufSxcbiAgbWltZXM6IGZ1bmN0aW9uIChmaWVsZCkgeyByZXR1cm4gKFwiVGhlIFwiICsgZmllbGQgKyBcIiBmaWVsZCBtdXN0IGhhdmUgYSB2YWxpZCBmaWxlIHR5cGUuXCIpOyB9LFxuICBtaW46IGZ1bmN0aW9uIChmaWVsZCwgcmVmKSB7XG4gICAgdmFyIGxlbmd0aCA9IHJlZlswXTtcblxuICAgIHJldHVybiAoXCJUaGUgXCIgKyBmaWVsZCArIFwiIGZpZWxkIG11c3QgYmUgYXQgbGVhc3QgXCIgKyBsZW5ndGggKyBcIiBjaGFyYWN0ZXJzLlwiKTtcbn0sXG4gIG1pbl92YWx1ZTogZnVuY3Rpb24gKGZpZWxkLCByZWYpIHtcbiAgICB2YXIgbWluID0gcmVmWzBdO1xuXG4gICAgcmV0dXJuIChcIlRoZSBcIiArIGZpZWxkICsgXCIgZmllbGQgbXVzdCBiZSBcIiArIG1pbiArIFwiIG9yIG1vcmUuXCIpO1xufSxcbiAgbm90X2luOiBmdW5jdGlvbiAoZmllbGQpIHsgcmV0dXJuIChcIlRoZSBcIiArIGZpZWxkICsgXCIgZmllbGQgbXVzdCBiZSBhIHZhbGlkIHZhbHVlLlwiKTsgfSxcbiAgbnVtZXJpYzogZnVuY3Rpb24gKGZpZWxkKSB7IHJldHVybiAoXCJUaGUgXCIgKyBmaWVsZCArIFwiIGZpZWxkIG1heSBvbmx5IGNvbnRhaW4gbnVtZXJpYyBjaGFyYWN0ZXJzLlwiKTsgfSxcbiAgcmVnZXg6IGZ1bmN0aW9uIChmaWVsZCkgeyByZXR1cm4gKFwiVGhlIFwiICsgZmllbGQgKyBcIiBmaWVsZCBmb3JtYXQgaXMgaW52YWxpZC5cIik7IH0sXG4gIHJlcXVpcmVkOiBmdW5jdGlvbiAoZmllbGQpIHsgcmV0dXJuIChcIlRoZSBcIiArIGZpZWxkICsgXCIgZmllbGQgaXMgcmVxdWlyZWQuXCIpOyB9LFxuICBzaXplOiBmdW5jdGlvbiAoZmllbGQsIHJlZikge1xuICAgIHZhciBzaXplID0gcmVmWzBdO1xuXG4gICAgcmV0dXJuIChcIlRoZSBcIiArIGZpZWxkICsgXCIgc2l6ZSBtdXN0IGJlIGxlc3MgdGhhbiBcIiArIChmb3JtYXRGaWxlU2l6ZShzaXplKSkgKyBcIi5cIik7XG59LFxuICB1cmw6IGZ1bmN0aW9uIChmaWVsZCkgeyByZXR1cm4gKFwiVGhlIFwiICsgZmllbGQgKyBcIiBmaWVsZCBpcyBub3QgYSB2YWxpZCBVUkwuXCIpOyB9XG59O1xuXG52YXIgbG9jYWxlID0ge1xuICBuYW1lOiAnZW4nLFxuICBtZXNzYWdlczogbWVzc2FnZXMsXG4gIGF0dHJpYnV0ZXM6IHt9XG59O1xuXG5pZiAoaXNEZWZpbmVkR2xvYmFsbHkoKSkge1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcbiAgVmVlVmFsaWRhdGUuVmFsaWRhdG9yLmxvY2FsaXplKCggb2JqID0ge30sIG9ialtsb2NhbGUubmFtZV0gPSBsb2NhbGUsIG9iaiApKTtcbiAgdmFyIG9iajtcbn1cblxuLy8gXG5cbmZ1bmN0aW9uIHVzZSAocGx1Z2luLCBvcHRpb25zKSB7XG4gIGlmICggb3B0aW9ucyA9PT0gdm9pZCAwICkgb3B0aW9ucyA9IHt9O1xuXG4gIGlmICghaXNDYWxsYWJsZShwbHVnaW4pKSB7XG4gICAgcmV0dXJuIHdhcm4oJ1RoZSBwbHVnaW4gbXVzdCBiZSBhIGNhbGxhYmxlIGZ1bmN0aW9uJyk7XG4gIH1cblxuICBwbHVnaW4oeyBWYWxpZGF0b3I6IFZhbGlkYXRvciwgRXJyb3JCYWc6IEVycm9yQmFnLCBSdWxlczogVmFsaWRhdG9yLnJ1bGVzIH0sIG9wdGlvbnMpO1xufVxuXG52YXIgTUlMTElTRUNPTkRTX0lOX0hPVVIgPSAzNjAwMDAwO1xudmFyIE1JTExJU0VDT05EU19JTl9NSU5VVEUgPSA2MDAwMDtcbnZhciBERUZBVUxUX0FERElUSU9OQUxfRElHSVRTID0gMjtcblxudmFyIHBhdHRlcm5zID0ge1xuICBkYXRlVGltZURlbGltZXRlcjogL1tUIF0vLFxuICBwbGFpblRpbWU6IC86LyxcblxuICAvLyB5ZWFyIHRva2Vuc1xuICBZWTogL14oXFxkezJ9KSQvLFxuICBZWVk6IFtcbiAgICAvXihbKy1dXFxkezJ9KSQvLCAvLyAwIGFkZGl0aW9uYWwgZGlnaXRzXG4gICAgL14oWystXVxcZHszfSkkLywgLy8gMSBhZGRpdGlvbmFsIGRpZ2l0XG4gICAgL14oWystXVxcZHs0fSkkLyAvLyAyIGFkZGl0aW9uYWwgZGlnaXRzXG4gIF0sXG4gIFlZWVk6IC9eKFxcZHs0fSkvLFxuICBZWVlZWTogW1xuICAgIC9eKFsrLV1cXGR7NH0pLywgLy8gMCBhZGRpdGlvbmFsIGRpZ2l0c1xuICAgIC9eKFsrLV1cXGR7NX0pLywgLy8gMSBhZGRpdGlvbmFsIGRpZ2l0XG4gICAgL14oWystXVxcZHs2fSkvIC8vIDIgYWRkaXRpb25hbCBkaWdpdHNcbiAgXSxcblxuICAvLyBkYXRlIHRva2Vuc1xuICBNTTogL14tKFxcZHsyfSkkLyxcbiAgREREOiAvXi0/KFxcZHszfSkkLyxcbiAgTU1ERDogL14tPyhcXGR7Mn0pLT8oXFxkezJ9KSQvLFxuICBXd3c6IC9eLT9XKFxcZHsyfSkkLyxcbiAgV3d3RDogL14tP1coXFxkezJ9KS0/KFxcZHsxfSkkLyxcblxuICBISDogL14oXFxkezJ9KFsuLF1cXGQqKT8pJC8sXG4gIEhITU06IC9eKFxcZHsyfSk6PyhcXGR7Mn0oWy4sXVxcZCopPykkLyxcbiAgSEhNTVNTOiAvXihcXGR7Mn0pOj8oXFxkezJ9KTo/KFxcZHsyfShbLixdXFxkKik/KSQvLFxuXG4gIC8vIHRpbWV6b25lIHRva2Vuc1xuICB0aW1lem9uZTogLyhbWistXS4qKSQvLFxuICB0aW1lem9uZVo6IC9eKFopJC8sXG4gIHRpbWV6b25lSEg6IC9eKFsrLV0pKFxcZHsyfSkkLyxcbiAgdGltZXpvbmVISE1NOiAvXihbKy1dKShcXGR7Mn0pOj8oXFxkezJ9KSQvXG59O1xuXG4vKipcbiAqIEBuYW1lIHRvRGF0ZVxuICogQGNhdGVnb3J5IENvbW1vbiBIZWxwZXJzXG4gKiBAc3VtbWFyeSBDb252ZXJ0IHRoZSBnaXZlbiBhcmd1bWVudCB0byBhbiBpbnN0YW5jZSBvZiBEYXRlLlxuICpcbiAqIEBkZXNjcmlwdGlvblxuICogQ29udmVydCB0aGUgZ2l2ZW4gYXJndW1lbnQgdG8gYW4gaW5zdGFuY2Ugb2YgRGF0ZS5cbiAqXG4gKiBJZiB0aGUgYXJndW1lbnQgaXMgYW4gaW5zdGFuY2Ugb2YgRGF0ZSwgdGhlIGZ1bmN0aW9uIHJldHVybnMgaXRzIGNsb25lLlxuICpcbiAqIElmIHRoZSBhcmd1bWVudCBpcyBhIG51bWJlciwgaXQgaXMgdHJlYXRlZCBhcyBhIHRpbWVzdGFtcC5cbiAqXG4gKiBJZiBhbiBhcmd1bWVudCBpcyBhIHN0cmluZywgdGhlIGZ1bmN0aW9uIHRyaWVzIHRvIHBhcnNlIGl0LlxuICogRnVuY3Rpb24gYWNjZXB0cyBjb21wbGV0ZSBJU08gODYwMSBmb3JtYXRzIGFzIHdlbGwgYXMgcGFydGlhbCBpbXBsZW1lbnRhdGlvbnMuXG4gKiBJU08gODYwMTogaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9JU09fODYwMVxuICpcbiAqIElmIHRoZSBhcmd1bWVudCBpcyBudWxsLCBpdCBpcyB0cmVhdGVkIGFzIGFuIGludmFsaWQgZGF0ZS5cbiAqXG4gKiBJZiBhbGwgYWJvdmUgZmFpbHMsIHRoZSBmdW5jdGlvbiBwYXNzZXMgdGhlIGdpdmVuIGFyZ3VtZW50IHRvIERhdGUgY29uc3RydWN0b3IuXG4gKlxuICogKipOb3RlKio6ICphbGwqIERhdGUgYXJndW1lbnRzIHBhc3NlZCB0byBhbnkgKmRhdGUtZm5zKiBmdW5jdGlvbiBpcyBwcm9jZXNzZWQgYnkgYHRvRGF0ZWAuXG4gKiBBbGwgKmRhdGUtZm5zKiBmdW5jdGlvbnMgd2lsbCB0aHJvdyBgUmFuZ2VFcnJvcmAgaWYgYG9wdGlvbnMuYWRkaXRpb25hbERpZ2l0c2AgaXMgbm90IDAsIDEsIDIgb3IgdW5kZWZpbmVkLlxuICpcbiAqIEBwYXJhbSB7Kn0gYXJndW1lbnQgLSB0aGUgdmFsdWUgdG8gY29udmVydFxuICogQHBhcmFtIHtPcHRpb25zfSBbb3B0aW9uc10gLSB0aGUgb2JqZWN0IHdpdGggb3B0aW9ucy4gU2VlIFtPcHRpb25zXXtAbGluayBodHRwczovL2RhdGUtZm5zLm9yZy9kb2NzL09wdGlvbnN9XG4gKiBAcGFyYW0gezB8MXwyfSBbb3B0aW9ucy5hZGRpdGlvbmFsRGlnaXRzPTJdIC0gdGhlIGFkZGl0aW9uYWwgbnVtYmVyIG9mIGRpZ2l0cyBpbiB0aGUgZXh0ZW5kZWQgeWVhciBmb3JtYXRcbiAqIEByZXR1cm5zIHtEYXRlfSB0aGUgcGFyc2VkIGRhdGUgaW4gdGhlIGxvY2FsIHRpbWUgem9uZVxuICogQHRocm93cyB7VHlwZUVycm9yfSAxIGFyZ3VtZW50IHJlcXVpcmVkXG4gKiBAdGhyb3dzIHtSYW5nZUVycm9yfSBgb3B0aW9ucy5hZGRpdGlvbmFsRGlnaXRzYCBtdXN0IGJlIDAsIDEgb3IgMlxuICpcbiAqIEBleGFtcGxlXG4gKiAvLyBDb252ZXJ0IHN0cmluZyAnMjAxNC0wMi0xMVQxMTozMDozMCcgdG8gZGF0ZTpcbiAqIHZhciByZXN1bHQgPSB0b0RhdGUoJzIwMTQtMDItMTFUMTE6MzA6MzAnKVxuICogLy89PiBUdWUgRmViIDExIDIwMTQgMTE6MzA6MzBcbiAqXG4gKiBAZXhhbXBsZVxuICogLy8gQ29udmVydCBzdHJpbmcgJyswMjAxNDEwMScgdG8gZGF0ZSxcbiAqIC8vIGlmIHRoZSBhZGRpdGlvbmFsIG51bWJlciBvZiBkaWdpdHMgaW4gdGhlIGV4dGVuZGVkIHllYXIgZm9ybWF0IGlzIDE6XG4gKiB2YXIgcmVzdWx0ID0gdG9EYXRlKCcrMDIwMTQxMDEnLCB7YWRkaXRpb25hbERpZ2l0czogMX0pXG4gKiAvLz0+IEZyaSBBcHIgMTEgMjAxNCAwMDowMDowMFxuICovXG5mdW5jdGlvbiB0b0RhdGUgKGFyZ3VtZW50LCBkaXJ0eU9wdGlvbnMpIHtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAxKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignMSBhcmd1bWVudCByZXF1aXJlZCwgYnV0IG9ubHkgJyArIGFyZ3VtZW50cy5sZW5ndGggKyAnIHByZXNlbnQnKVxuICB9XG5cbiAgaWYgKGFyZ3VtZW50ID09PSBudWxsKSB7XG4gICAgcmV0dXJuIG5ldyBEYXRlKE5hTilcbiAgfVxuXG4gIHZhciBvcHRpb25zID0gZGlydHlPcHRpb25zIHx8IHt9O1xuXG4gIHZhciBhZGRpdGlvbmFsRGlnaXRzID0gb3B0aW9ucy5hZGRpdGlvbmFsRGlnaXRzID09PSB1bmRlZmluZWQgPyBERUZBVUxUX0FERElUSU9OQUxfRElHSVRTIDogTnVtYmVyKG9wdGlvbnMuYWRkaXRpb25hbERpZ2l0cyk7XG4gIGlmIChhZGRpdGlvbmFsRGlnaXRzICE9PSAyICYmIGFkZGl0aW9uYWxEaWdpdHMgIT09IDEgJiYgYWRkaXRpb25hbERpZ2l0cyAhPT0gMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdhZGRpdGlvbmFsRGlnaXRzIG11c3QgYmUgMCwgMSBvciAyJylcbiAgfVxuXG4gIC8vIENsb25lIHRoZSBkYXRlXG4gIGlmIChhcmd1bWVudCBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICAvLyBQcmV2ZW50IHRoZSBkYXRlIHRvIGxvc2UgdGhlIG1pbGxpc2Vjb25kcyB3aGVuIHBhc3NlZCB0byBuZXcgRGF0ZSgpIGluIElFMTBcbiAgICByZXR1cm4gbmV3IERhdGUoYXJndW1lbnQuZ2V0VGltZSgpKVxuICB9IGVsc2UgaWYgKHR5cGVvZiBhcmd1bWVudCAhPT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gbmV3IERhdGUoYXJndW1lbnQpXG4gIH1cblxuICB2YXIgZGF0ZVN0cmluZ3MgPSBzcGxpdERhdGVTdHJpbmcoYXJndW1lbnQpO1xuXG4gIHZhciBwYXJzZVllYXJSZXN1bHQgPSBwYXJzZVllYXIoZGF0ZVN0cmluZ3MuZGF0ZSwgYWRkaXRpb25hbERpZ2l0cyk7XG4gIHZhciB5ZWFyID0gcGFyc2VZZWFyUmVzdWx0LnllYXI7XG4gIHZhciByZXN0RGF0ZVN0cmluZyA9IHBhcnNlWWVhclJlc3VsdC5yZXN0RGF0ZVN0cmluZztcblxuICB2YXIgZGF0ZSA9IHBhcnNlRGF0ZShyZXN0RGF0ZVN0cmluZywgeWVhcik7XG5cbiAgaWYgKGRhdGUpIHtcbiAgICB2YXIgdGltZXN0YW1wID0gZGF0ZS5nZXRUaW1lKCk7XG4gICAgdmFyIHRpbWUgPSAwO1xuICAgIHZhciBvZmZzZXQ7XG5cbiAgICBpZiAoZGF0ZVN0cmluZ3MudGltZSkge1xuICAgICAgdGltZSA9IHBhcnNlVGltZShkYXRlU3RyaW5ncy50aW1lKTtcbiAgICB9XG5cbiAgICBpZiAoZGF0ZVN0cmluZ3MudGltZXpvbmUpIHtcbiAgICAgIG9mZnNldCA9IHBhcnNlVGltZXpvbmUoZGF0ZVN0cmluZ3MudGltZXpvbmUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBnZXQgb2Zmc2V0IGFjY3VyYXRlIHRvIGhvdXIgaW4gdGltZXpvbmVzIHRoYXQgY2hhbmdlIG9mZnNldFxuICAgICAgb2Zmc2V0ID0gbmV3IERhdGUodGltZXN0YW1wICsgdGltZSkuZ2V0VGltZXpvbmVPZmZzZXQoKTtcbiAgICAgIG9mZnNldCA9IG5ldyBEYXRlKHRpbWVzdGFtcCArIHRpbWUgKyBvZmZzZXQgKiBNSUxMSVNFQ09ORFNfSU5fTUlOVVRFKS5nZXRUaW1lem9uZU9mZnNldCgpO1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgRGF0ZSh0aW1lc3RhbXAgKyB0aW1lICsgb2Zmc2V0ICogTUlMTElTRUNPTkRTX0lOX01JTlVURSlcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbmV3IERhdGUoYXJndW1lbnQpXG4gIH1cbn1cblxuZnVuY3Rpb24gc3BsaXREYXRlU3RyaW5nIChkYXRlU3RyaW5nKSB7XG4gIHZhciBkYXRlU3RyaW5ncyA9IHt9O1xuICB2YXIgYXJyYXkgPSBkYXRlU3RyaW5nLnNwbGl0KHBhdHRlcm5zLmRhdGVUaW1lRGVsaW1ldGVyKTtcbiAgdmFyIHRpbWVTdHJpbmc7XG5cbiAgaWYgKHBhdHRlcm5zLnBsYWluVGltZS50ZXN0KGFycmF5WzBdKSkge1xuICAgIGRhdGVTdHJpbmdzLmRhdGUgPSBudWxsO1xuICAgIHRpbWVTdHJpbmcgPSBhcnJheVswXTtcbiAgfSBlbHNlIHtcbiAgICBkYXRlU3RyaW5ncy5kYXRlID0gYXJyYXlbMF07XG4gICAgdGltZVN0cmluZyA9IGFycmF5WzFdO1xuICB9XG5cbiAgaWYgKHRpbWVTdHJpbmcpIHtcbiAgICB2YXIgdG9rZW4gPSBwYXR0ZXJucy50aW1lem9uZS5leGVjKHRpbWVTdHJpbmcpO1xuICAgIGlmICh0b2tlbikge1xuICAgICAgZGF0ZVN0cmluZ3MudGltZSA9IHRpbWVTdHJpbmcucmVwbGFjZSh0b2tlblsxXSwgJycpO1xuICAgICAgZGF0ZVN0cmluZ3MudGltZXpvbmUgPSB0b2tlblsxXTtcbiAgICB9IGVsc2Uge1xuICAgICAgZGF0ZVN0cmluZ3MudGltZSA9IHRpbWVTdHJpbmc7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGRhdGVTdHJpbmdzXG59XG5cbmZ1bmN0aW9uIHBhcnNlWWVhciAoZGF0ZVN0cmluZywgYWRkaXRpb25hbERpZ2l0cykge1xuICB2YXIgcGF0dGVybllZWSA9IHBhdHRlcm5zLllZWVthZGRpdGlvbmFsRGlnaXRzXTtcbiAgdmFyIHBhdHRlcm5ZWVlZWSA9IHBhdHRlcm5zLllZWVlZW2FkZGl0aW9uYWxEaWdpdHNdO1xuXG4gIHZhciB0b2tlbjtcblxuICAvLyBZWVlZIG9yIMKxWVlZWVlcbiAgdG9rZW4gPSBwYXR0ZXJucy5ZWVlZLmV4ZWMoZGF0ZVN0cmluZykgfHwgcGF0dGVybllZWVlZLmV4ZWMoZGF0ZVN0cmluZyk7XG4gIGlmICh0b2tlbikge1xuICAgIHZhciB5ZWFyU3RyaW5nID0gdG9rZW5bMV07XG4gICAgcmV0dXJuIHtcbiAgICAgIHllYXI6IHBhcnNlSW50KHllYXJTdHJpbmcsIDEwKSxcbiAgICAgIHJlc3REYXRlU3RyaW5nOiBkYXRlU3RyaW5nLnNsaWNlKHllYXJTdHJpbmcubGVuZ3RoKVxuICAgIH1cbiAgfVxuXG4gIC8vIFlZIG9yIMKxWVlZXG4gIHRva2VuID0gcGF0dGVybnMuWVkuZXhlYyhkYXRlU3RyaW5nKSB8fCBwYXR0ZXJuWVlZLmV4ZWMoZGF0ZVN0cmluZyk7XG4gIGlmICh0b2tlbikge1xuICAgIHZhciBjZW50dXJ5U3RyaW5nID0gdG9rZW5bMV07XG4gICAgcmV0dXJuIHtcbiAgICAgIHllYXI6IHBhcnNlSW50KGNlbnR1cnlTdHJpbmcsIDEwKSAqIDEwMCxcbiAgICAgIHJlc3REYXRlU3RyaW5nOiBkYXRlU3RyaW5nLnNsaWNlKGNlbnR1cnlTdHJpbmcubGVuZ3RoKVxuICAgIH1cbiAgfVxuXG4gIC8vIEludmFsaWQgSVNPLWZvcm1hdHRlZCB5ZWFyXG4gIHJldHVybiB7XG4gICAgeWVhcjogbnVsbFxuICB9XG59XG5cbmZ1bmN0aW9uIHBhcnNlRGF0ZSAoZGF0ZVN0cmluZywgeWVhcikge1xuICAvLyBJbnZhbGlkIElTTy1mb3JtYXR0ZWQgeWVhclxuICBpZiAoeWVhciA9PT0gbnVsbCkge1xuICAgIHJldHVybiBudWxsXG4gIH1cblxuICB2YXIgdG9rZW47XG4gIHZhciBkYXRlO1xuICB2YXIgbW9udGg7XG4gIHZhciB3ZWVrO1xuXG4gIC8vIFlZWVlcbiAgaWYgKGRhdGVTdHJpbmcubGVuZ3RoID09PSAwKSB7XG4gICAgZGF0ZSA9IG5ldyBEYXRlKDApO1xuICAgIGRhdGUuc2V0VVRDRnVsbFllYXIoeWVhcik7XG4gICAgcmV0dXJuIGRhdGVcbiAgfVxuXG4gIC8vIFlZWVktTU1cbiAgdG9rZW4gPSBwYXR0ZXJucy5NTS5leGVjKGRhdGVTdHJpbmcpO1xuICBpZiAodG9rZW4pIHtcbiAgICBkYXRlID0gbmV3IERhdGUoMCk7XG4gICAgbW9udGggPSBwYXJzZUludCh0b2tlblsxXSwgMTApIC0gMTtcbiAgICBkYXRlLnNldFVUQ0Z1bGxZZWFyKHllYXIsIG1vbnRoKTtcbiAgICByZXR1cm4gZGF0ZVxuICB9XG5cbiAgLy8gWVlZWS1EREQgb3IgWVlZWURERFxuICB0b2tlbiA9IHBhdHRlcm5zLkRERC5leGVjKGRhdGVTdHJpbmcpO1xuICBpZiAodG9rZW4pIHtcbiAgICBkYXRlID0gbmV3IERhdGUoMCk7XG4gICAgdmFyIGRheU9mWWVhciA9IHBhcnNlSW50KHRva2VuWzFdLCAxMCk7XG4gICAgZGF0ZS5zZXRVVENGdWxsWWVhcih5ZWFyLCAwLCBkYXlPZlllYXIpO1xuICAgIHJldHVybiBkYXRlXG4gIH1cblxuICAvLyBZWVlZLU1NLUREIG9yIFlZWVlNTUREXG4gIHRva2VuID0gcGF0dGVybnMuTU1ERC5leGVjKGRhdGVTdHJpbmcpO1xuICBpZiAodG9rZW4pIHtcbiAgICBkYXRlID0gbmV3IERhdGUoMCk7XG4gICAgbW9udGggPSBwYXJzZUludCh0b2tlblsxXSwgMTApIC0gMTtcbiAgICB2YXIgZGF5ID0gcGFyc2VJbnQodG9rZW5bMl0sIDEwKTtcbiAgICBkYXRlLnNldFVUQ0Z1bGxZZWFyKHllYXIsIG1vbnRoLCBkYXkpO1xuICAgIHJldHVybiBkYXRlXG4gIH1cblxuICAvLyBZWVlZLVd3dyBvciBZWVlZV3d3XG4gIHRva2VuID0gcGF0dGVybnMuV3d3LmV4ZWMoZGF0ZVN0cmluZyk7XG4gIGlmICh0b2tlbikge1xuICAgIHdlZWsgPSBwYXJzZUludCh0b2tlblsxXSwgMTApIC0gMTtcbiAgICByZXR1cm4gZGF5T2ZJU09ZZWFyKHllYXIsIHdlZWspXG4gIH1cblxuICAvLyBZWVlZLVd3dy1EIG9yIFlZWVlXd3dEXG4gIHRva2VuID0gcGF0dGVybnMuV3d3RC5leGVjKGRhdGVTdHJpbmcpO1xuICBpZiAodG9rZW4pIHtcbiAgICB3ZWVrID0gcGFyc2VJbnQodG9rZW5bMV0sIDEwKSAtIDE7XG4gICAgdmFyIGRheU9mV2VlayA9IHBhcnNlSW50KHRva2VuWzJdLCAxMCkgLSAxO1xuICAgIHJldHVybiBkYXlPZklTT1llYXIoeWVhciwgd2VlaywgZGF5T2ZXZWVrKVxuICB9XG5cbiAgLy8gSW52YWxpZCBJU08tZm9ybWF0dGVkIGRhdGVcbiAgcmV0dXJuIG51bGxcbn1cblxuZnVuY3Rpb24gcGFyc2VUaW1lICh0aW1lU3RyaW5nKSB7XG4gIHZhciB0b2tlbjtcbiAgdmFyIGhvdXJzO1xuICB2YXIgbWludXRlcztcblxuICAvLyBoaFxuICB0b2tlbiA9IHBhdHRlcm5zLkhILmV4ZWModGltZVN0cmluZyk7XG4gIGlmICh0b2tlbikge1xuICAgIGhvdXJzID0gcGFyc2VGbG9hdCh0b2tlblsxXS5yZXBsYWNlKCcsJywgJy4nKSk7XG4gICAgcmV0dXJuIChob3VycyAlIDI0KSAqIE1JTExJU0VDT05EU19JTl9IT1VSXG4gIH1cblxuICAvLyBoaDptbSBvciBoaG1tXG4gIHRva2VuID0gcGF0dGVybnMuSEhNTS5leGVjKHRpbWVTdHJpbmcpO1xuICBpZiAodG9rZW4pIHtcbiAgICBob3VycyA9IHBhcnNlSW50KHRva2VuWzFdLCAxMCk7XG4gICAgbWludXRlcyA9IHBhcnNlRmxvYXQodG9rZW5bMl0ucmVwbGFjZSgnLCcsICcuJykpO1xuICAgIHJldHVybiAoaG91cnMgJSAyNCkgKiBNSUxMSVNFQ09ORFNfSU5fSE9VUiArXG4gICAgICBtaW51dGVzICogTUlMTElTRUNPTkRTX0lOX01JTlVURVxuICB9XG5cbiAgLy8gaGg6bW06c3Mgb3IgaGhtbXNzXG4gIHRva2VuID0gcGF0dGVybnMuSEhNTVNTLmV4ZWModGltZVN0cmluZyk7XG4gIGlmICh0b2tlbikge1xuICAgIGhvdXJzID0gcGFyc2VJbnQodG9rZW5bMV0sIDEwKTtcbiAgICBtaW51dGVzID0gcGFyc2VJbnQodG9rZW5bMl0sIDEwKTtcbiAgICB2YXIgc2Vjb25kcyA9IHBhcnNlRmxvYXQodG9rZW5bM10ucmVwbGFjZSgnLCcsICcuJykpO1xuICAgIHJldHVybiAoaG91cnMgJSAyNCkgKiBNSUxMSVNFQ09ORFNfSU5fSE9VUiArXG4gICAgICBtaW51dGVzICogTUlMTElTRUNPTkRTX0lOX01JTlVURSArXG4gICAgICBzZWNvbmRzICogMTAwMFxuICB9XG5cbiAgLy8gSW52YWxpZCBJU08tZm9ybWF0dGVkIHRpbWVcbiAgcmV0dXJuIG51bGxcbn1cblxuZnVuY3Rpb24gcGFyc2VUaW1lem9uZSAodGltZXpvbmVTdHJpbmcpIHtcbiAgdmFyIHRva2VuO1xuICB2YXIgYWJzb2x1dGVPZmZzZXQ7XG5cbiAgLy8gWlxuICB0b2tlbiA9IHBhdHRlcm5zLnRpbWV6b25lWi5leGVjKHRpbWV6b25lU3RyaW5nKTtcbiAgaWYgKHRva2VuKSB7XG4gICAgcmV0dXJuIDBcbiAgfVxuXG4gIC8vIMKxaGhcbiAgdG9rZW4gPSBwYXR0ZXJucy50aW1lem9uZUhILmV4ZWModGltZXpvbmVTdHJpbmcpO1xuICBpZiAodG9rZW4pIHtcbiAgICBhYnNvbHV0ZU9mZnNldCA9IHBhcnNlSW50KHRva2VuWzJdLCAxMCkgKiA2MDtcbiAgICByZXR1cm4gKHRva2VuWzFdID09PSAnKycpID8gLWFic29sdXRlT2Zmc2V0IDogYWJzb2x1dGVPZmZzZXRcbiAgfVxuXG4gIC8vIMKxaGg6bW0gb3IgwrFoaG1tXG4gIHRva2VuID0gcGF0dGVybnMudGltZXpvbmVISE1NLmV4ZWModGltZXpvbmVTdHJpbmcpO1xuICBpZiAodG9rZW4pIHtcbiAgICBhYnNvbHV0ZU9mZnNldCA9IHBhcnNlSW50KHRva2VuWzJdLCAxMCkgKiA2MCArIHBhcnNlSW50KHRva2VuWzNdLCAxMCk7XG4gICAgcmV0dXJuICh0b2tlblsxXSA9PT0gJysnKSA/IC1hYnNvbHV0ZU9mZnNldCA6IGFic29sdXRlT2Zmc2V0XG4gIH1cblxuICByZXR1cm4gMFxufVxuXG5mdW5jdGlvbiBkYXlPZklTT1llYXIgKGlzb1llYXIsIHdlZWssIGRheSkge1xuICB3ZWVrID0gd2VlayB8fCAwO1xuICBkYXkgPSBkYXkgfHwgMDtcbiAgdmFyIGRhdGUgPSBuZXcgRGF0ZSgwKTtcbiAgZGF0ZS5zZXRVVENGdWxsWWVhcihpc29ZZWFyLCAwLCA0KTtcbiAgdmFyIGZvdXJ0aE9mSmFudWFyeURheSA9IGRhdGUuZ2V0VVRDRGF5KCkgfHwgNztcbiAgdmFyIGRpZmYgPSB3ZWVrICogNyArIGRheSArIDEgLSBmb3VydGhPZkphbnVhcnlEYXk7XG4gIGRhdGUuc2V0VVRDRGF0ZShkYXRlLmdldFVUQ0RhdGUoKSArIGRpZmYpO1xuICByZXR1cm4gZGF0ZVxufVxuXG4vKipcbiAqIEBuYW1lIGFkZE1pbGxpc2Vjb25kc1xuICogQGNhdGVnb3J5IE1pbGxpc2Vjb25kIEhlbHBlcnNcbiAqIEBzdW1tYXJ5IEFkZCB0aGUgc3BlY2lmaWVkIG51bWJlciBvZiBtaWxsaXNlY29uZHMgdG8gdGhlIGdpdmVuIGRhdGUuXG4gKlxuICogQGRlc2NyaXB0aW9uXG4gKiBBZGQgdGhlIHNwZWNpZmllZCBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIHRvIHRoZSBnaXZlbiBkYXRlLlxuICpcbiAqIEBwYXJhbSB7RGF0ZXxTdHJpbmd8TnVtYmVyfSBkYXRlIC0gdGhlIGRhdGUgdG8gYmUgY2hhbmdlZFxuICogQHBhcmFtIHtOdW1iZXJ9IGFtb3VudCAtIHRoZSBhbW91bnQgb2YgbWlsbGlzZWNvbmRzIHRvIGJlIGFkZGVkXG4gKiBAcGFyYW0ge09wdGlvbnN9IFtvcHRpb25zXSAtIHRoZSBvYmplY3Qgd2l0aCBvcHRpb25zLiBTZWUgW09wdGlvbnNde0BsaW5rIGh0dHBzOi8vZGF0ZS1mbnMub3JnL2RvY3MvT3B0aW9uc31cbiAqIEBwYXJhbSB7MHwxfDJ9IFtvcHRpb25zLmFkZGl0aW9uYWxEaWdpdHM9Ml0gLSBwYXNzZWQgdG8gYHRvRGF0ZWAuIFNlZSBbdG9EYXRlXXtAbGluayBodHRwczovL2RhdGUtZm5zLm9yZy9kb2NzL3RvRGF0ZX1cbiAqIEByZXR1cm5zIHtEYXRlfSB0aGUgbmV3IGRhdGUgd2l0aCB0aGUgbWlsbGlzZWNvbmRzIGFkZGVkXG4gKiBAdGhyb3dzIHtUeXBlRXJyb3J9IDIgYXJndW1lbnRzIHJlcXVpcmVkXG4gKiBAdGhyb3dzIHtSYW5nZUVycm9yfSBgb3B0aW9ucy5hZGRpdGlvbmFsRGlnaXRzYCBtdXN0IGJlIDAsIDEgb3IgMlxuICpcbiAqIEBleGFtcGxlXG4gKiAvLyBBZGQgNzUwIG1pbGxpc2Vjb25kcyB0byAxMCBKdWx5IDIwMTQgMTI6NDU6MzAuMDAwOlxuICogdmFyIHJlc3VsdCA9IGFkZE1pbGxpc2Vjb25kcyhuZXcgRGF0ZSgyMDE0LCA2LCAxMCwgMTIsIDQ1LCAzMCwgMCksIDc1MClcbiAqIC8vPT4gVGh1IEp1bCAxMCAyMDE0IDEyOjQ1OjMwLjc1MFxuICovXG5mdW5jdGlvbiBhZGRNaWxsaXNlY29uZHMgKGRpcnR5RGF0ZSwgZGlydHlBbW91bnQsIGRpcnR5T3B0aW9ucykge1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDIpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCcyIGFyZ3VtZW50cyByZXF1aXJlZCwgYnV0IG9ubHkgJyArIGFyZ3VtZW50cy5sZW5ndGggKyAnIHByZXNlbnQnKVxuICB9XG5cbiAgdmFyIHRpbWVzdGFtcCA9IHRvRGF0ZShkaXJ0eURhdGUsIGRpcnR5T3B0aW9ucykuZ2V0VGltZSgpO1xuICB2YXIgYW1vdW50ID0gTnVtYmVyKGRpcnR5QW1vdW50KTtcbiAgcmV0dXJuIG5ldyBEYXRlKHRpbWVzdGFtcCArIGFtb3VudClcbn1cblxuZnVuY3Rpb24gY2xvbmVPYmplY3QgKGRpcnR5T2JqZWN0KSB7XG4gIGRpcnR5T2JqZWN0ID0gZGlydHlPYmplY3QgfHwge307XG4gIHZhciBvYmplY3QgPSB7fTtcblxuICBmb3IgKHZhciBwcm9wZXJ0eSBpbiBkaXJ0eU9iamVjdCkge1xuICAgIGlmIChkaXJ0eU9iamVjdC5oYXNPd25Qcm9wZXJ0eShwcm9wZXJ0eSkpIHtcbiAgICAgIG9iamVjdFtwcm9wZXJ0eV0gPSBkaXJ0eU9iamVjdFtwcm9wZXJ0eV07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG9iamVjdFxufVxuXG52YXIgTUlMTElTRUNPTkRTX0lOX01JTlVURSQyID0gNjAwMDA7XG5cbi8qKlxuICogQG5hbWUgYWRkTWludXRlc1xuICogQGNhdGVnb3J5IE1pbnV0ZSBIZWxwZXJzXG4gKiBAc3VtbWFyeSBBZGQgdGhlIHNwZWNpZmllZCBudW1iZXIgb2YgbWludXRlcyB0byB0aGUgZ2l2ZW4gZGF0ZS5cbiAqXG4gKiBAZGVzY3JpcHRpb25cbiAqIEFkZCB0aGUgc3BlY2lmaWVkIG51bWJlciBvZiBtaW51dGVzIHRvIHRoZSBnaXZlbiBkYXRlLlxuICpcbiAqIEBwYXJhbSB7RGF0ZXxTdHJpbmd8TnVtYmVyfSBkYXRlIC0gdGhlIGRhdGUgdG8gYmUgY2hhbmdlZFxuICogQHBhcmFtIHtOdW1iZXJ9IGFtb3VudCAtIHRoZSBhbW91bnQgb2YgbWludXRlcyB0byBiZSBhZGRlZFxuICogQHBhcmFtIHtPcHRpb25zfSBbb3B0aW9uc10gLSB0aGUgb2JqZWN0IHdpdGggb3B0aW9ucy4gU2VlIFtPcHRpb25zXXtAbGluayBodHRwczovL2RhdGUtZm5zLm9yZy9kb2NzL09wdGlvbnN9XG4gKiBAcGFyYW0gezB8MXwyfSBbb3B0aW9ucy5hZGRpdGlvbmFsRGlnaXRzPTJdIC0gcGFzc2VkIHRvIGB0b0RhdGVgLiBTZWUgW3RvRGF0ZV17QGxpbmsgaHR0cHM6Ly9kYXRlLWZucy5vcmcvZG9jcy90b0RhdGV9XG4gKiBAcmV0dXJucyB7RGF0ZX0gdGhlIG5ldyBkYXRlIHdpdGggdGhlIG1pbnV0ZXMgYWRkZWRcbiAqIEB0aHJvd3Mge1R5cGVFcnJvcn0gMiBhcmd1bWVudHMgcmVxdWlyZWRcbiAqIEB0aHJvd3Mge1JhbmdlRXJyb3J9IGBvcHRpb25zLmFkZGl0aW9uYWxEaWdpdHNgIG11c3QgYmUgMCwgMSBvciAyXG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIEFkZCAzMCBtaW51dGVzIHRvIDEwIEp1bHkgMjAxNCAxMjowMDowMDpcbiAqIHZhciByZXN1bHQgPSBhZGRNaW51dGVzKG5ldyBEYXRlKDIwMTQsIDYsIDEwLCAxMiwgMCksIDMwKVxuICogLy89PiBUaHUgSnVsIDEwIDIwMTQgMTI6MzA6MDBcbiAqL1xuZnVuY3Rpb24gYWRkTWludXRlcyAoZGlydHlEYXRlLCBkaXJ0eUFtb3VudCwgZGlydHlPcHRpb25zKSB7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMikge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJzIgYXJndW1lbnRzIHJlcXVpcmVkLCBidXQgb25seSAnICsgYXJndW1lbnRzLmxlbmd0aCArICcgcHJlc2VudCcpXG4gIH1cblxuICB2YXIgYW1vdW50ID0gTnVtYmVyKGRpcnR5QW1vdW50KTtcbiAgcmV0dXJuIGFkZE1pbGxpc2Vjb25kcyhkaXJ0eURhdGUsIGFtb3VudCAqIE1JTExJU0VDT05EU19JTl9NSU5VVEUkMiwgZGlydHlPcHRpb25zKVxufVxuXG4vKipcbiAqIEBuYW1lIGlzVmFsaWRcbiAqIEBjYXRlZ29yeSBDb21tb24gSGVscGVyc1xuICogQHN1bW1hcnkgSXMgdGhlIGdpdmVuIGRhdGUgdmFsaWQ/XG4gKlxuICogQGRlc2NyaXB0aW9uXG4gKiBSZXR1cm5zIGZhbHNlIGlmIGFyZ3VtZW50IGlzIEludmFsaWQgRGF0ZSBhbmQgdHJ1ZSBvdGhlcndpc2UuXG4gKiBBcmd1bWVudCBpcyBjb252ZXJ0ZWQgdG8gRGF0ZSB1c2luZyBgdG9EYXRlYC4gU2VlIFt0b0RhdGVde0BsaW5rIGh0dHBzOi8vZGF0ZS1mbnMub3JnL2RvY3MvdG9EYXRlfVxuICogSW52YWxpZCBEYXRlIGlzIGEgRGF0ZSwgd2hvc2UgdGltZSB2YWx1ZSBpcyBOYU4uXG4gKlxuICogVGltZSB2YWx1ZSBvZiBEYXRlOiBodHRwOi8vZXM1LmdpdGh1Yi5pby8jeDE1LjkuMS4xXG4gKlxuICogQHBhcmFtIHsqfSBkYXRlIC0gdGhlIGRhdGUgdG8gY2hlY2tcbiAqIEBwYXJhbSB7T3B0aW9uc30gW29wdGlvbnNdIC0gdGhlIG9iamVjdCB3aXRoIG9wdGlvbnMuIFNlZSBbT3B0aW9uc117QGxpbmsgaHR0cHM6Ly9kYXRlLWZucy5vcmcvZG9jcy9PcHRpb25zfVxuICogQHBhcmFtIHswfDF8Mn0gW29wdGlvbnMuYWRkaXRpb25hbERpZ2l0cz0yXSAtIHBhc3NlZCB0byBgdG9EYXRlYC4gU2VlIFt0b0RhdGVde0BsaW5rIGh0dHBzOi8vZGF0ZS1mbnMub3JnL2RvY3MvdG9EYXRlfVxuICogQHJldHVybnMge0Jvb2xlYW59IHRoZSBkYXRlIGlzIHZhbGlkXG4gKiBAdGhyb3dzIHtUeXBlRXJyb3J9IDEgYXJndW1lbnQgcmVxdWlyZWRcbiAqIEB0aHJvd3Mge1JhbmdlRXJyb3J9IGBvcHRpb25zLmFkZGl0aW9uYWxEaWdpdHNgIG11c3QgYmUgMCwgMSBvciAyXG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIEZvciB0aGUgdmFsaWQgZGF0ZTpcbiAqIHZhciByZXN1bHQgPSBpc1ZhbGlkKG5ldyBEYXRlKDIwMTQsIDEsIDMxKSlcbiAqIC8vPT4gdHJ1ZVxuICpcbiAqIEBleGFtcGxlXG4gKiAvLyBGb3IgdGhlIHZhbHVlLCBjb252ZXJ0YWJsZSBpbnRvIGEgZGF0ZTpcbiAqIHZhciByZXN1bHQgPSBpc1ZhbGlkKCcyMDE0LTAyLTMxJylcbiAqIC8vPT4gdHJ1ZVxuICpcbiAqIEBleGFtcGxlXG4gKiAvLyBGb3IgdGhlIGludmFsaWQgZGF0ZTpcbiAqIHZhciByZXN1bHQgPSBpc1ZhbGlkKG5ldyBEYXRlKCcnKSlcbiAqIC8vPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNWYWxpZCAoZGlydHlEYXRlLCBkaXJ0eU9wdGlvbnMpIHtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAxKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignMSBhcmd1bWVudCByZXF1aXJlZCwgYnV0IG9ubHkgJyArIGFyZ3VtZW50cy5sZW5ndGggKyAnIHByZXNlbnQnKVxuICB9XG5cbiAgdmFyIGRhdGUgPSB0b0RhdGUoZGlydHlEYXRlLCBkaXJ0eU9wdGlvbnMpO1xuICByZXR1cm4gIWlzTmFOKGRhdGUpXG59XG5cbnZhciBmb3JtYXREaXN0YW5jZUxvY2FsZSA9IHtcbiAgbGVzc1RoYW5YU2Vjb25kczoge1xuICAgIG9uZTogJ2xlc3MgdGhhbiBhIHNlY29uZCcsXG4gICAgb3RoZXI6ICdsZXNzIHRoYW4ge3tjb3VudH19IHNlY29uZHMnXG4gIH0sXG5cbiAgeFNlY29uZHM6IHtcbiAgICBvbmU6ICcxIHNlY29uZCcsXG4gICAgb3RoZXI6ICd7e2NvdW50fX0gc2Vjb25kcydcbiAgfSxcblxuICBoYWxmQU1pbnV0ZTogJ2hhbGYgYSBtaW51dGUnLFxuXG4gIGxlc3NUaGFuWE1pbnV0ZXM6IHtcbiAgICBvbmU6ICdsZXNzIHRoYW4gYSBtaW51dGUnLFxuICAgIG90aGVyOiAnbGVzcyB0aGFuIHt7Y291bnR9fSBtaW51dGVzJ1xuICB9LFxuXG4gIHhNaW51dGVzOiB7XG4gICAgb25lOiAnMSBtaW51dGUnLFxuICAgIG90aGVyOiAne3tjb3VudH19IG1pbnV0ZXMnXG4gIH0sXG5cbiAgYWJvdXRYSG91cnM6IHtcbiAgICBvbmU6ICdhYm91dCAxIGhvdXInLFxuICAgIG90aGVyOiAnYWJvdXQge3tjb3VudH19IGhvdXJzJ1xuICB9LFxuXG4gIHhIb3Vyczoge1xuICAgIG9uZTogJzEgaG91cicsXG4gICAgb3RoZXI6ICd7e2NvdW50fX0gaG91cnMnXG4gIH0sXG5cbiAgeERheXM6IHtcbiAgICBvbmU6ICcxIGRheScsXG4gICAgb3RoZXI6ICd7e2NvdW50fX0gZGF5cydcbiAgfSxcblxuICBhYm91dFhNb250aHM6IHtcbiAgICBvbmU6ICdhYm91dCAxIG1vbnRoJyxcbiAgICBvdGhlcjogJ2Fib3V0IHt7Y291bnR9fSBtb250aHMnXG4gIH0sXG5cbiAgeE1vbnRoczoge1xuICAgIG9uZTogJzEgbW9udGgnLFxuICAgIG90aGVyOiAne3tjb3VudH19IG1vbnRocydcbiAgfSxcblxuICBhYm91dFhZZWFyczoge1xuICAgIG9uZTogJ2Fib3V0IDEgeWVhcicsXG4gICAgb3RoZXI6ICdhYm91dCB7e2NvdW50fX0geWVhcnMnXG4gIH0sXG5cbiAgeFllYXJzOiB7XG4gICAgb25lOiAnMSB5ZWFyJyxcbiAgICBvdGhlcjogJ3t7Y291bnR9fSB5ZWFycydcbiAgfSxcblxuICBvdmVyWFllYXJzOiB7XG4gICAgb25lOiAnb3ZlciAxIHllYXInLFxuICAgIG90aGVyOiAnb3ZlciB7e2NvdW50fX0geWVhcnMnXG4gIH0sXG5cbiAgYWxtb3N0WFllYXJzOiB7XG4gICAgb25lOiAnYWxtb3N0IDEgeWVhcicsXG4gICAgb3RoZXI6ICdhbG1vc3Qge3tjb3VudH19IHllYXJzJ1xuICB9XG59O1xuXG5mdW5jdGlvbiBmb3JtYXREaXN0YW5jZSAodG9rZW4sIGNvdW50LCBvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gIHZhciByZXN1bHQ7XG4gIGlmICh0eXBlb2YgZm9ybWF0RGlzdGFuY2VMb2NhbGVbdG9rZW5dID09PSAnc3RyaW5nJykge1xuICAgIHJlc3VsdCA9IGZvcm1hdERpc3RhbmNlTG9jYWxlW3Rva2VuXTtcbiAgfSBlbHNlIGlmIChjb3VudCA9PT0gMSkge1xuICAgIHJlc3VsdCA9IGZvcm1hdERpc3RhbmNlTG9jYWxlW3Rva2VuXS5vbmU7XG4gIH0gZWxzZSB7XG4gICAgcmVzdWx0ID0gZm9ybWF0RGlzdGFuY2VMb2NhbGVbdG9rZW5dLm90aGVyLnJlcGxhY2UoJ3t7Y291bnR9fScsIGNvdW50KTtcbiAgfVxuXG4gIGlmIChvcHRpb25zLmFkZFN1ZmZpeCkge1xuICAgIGlmIChvcHRpb25zLmNvbXBhcmlzb24gPiAwKSB7XG4gICAgICByZXR1cm4gJ2luICcgKyByZXN1bHRcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHJlc3VsdCArICcgYWdvJ1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZXN1bHRcbn1cblxudmFyIHRva2Vuc1RvQmVTaG9ydGVkUGF0dGVybiA9IC9NTU1NfE1NfEREfGRkZGQvZztcblxuZnVuY3Rpb24gYnVpbGRTaG9ydExvbmdGb3JtYXQgKGZvcm1hdCkge1xuICByZXR1cm4gZm9ybWF0LnJlcGxhY2UodG9rZW5zVG9CZVNob3J0ZWRQYXR0ZXJuLCBmdW5jdGlvbiAodG9rZW4pIHtcbiAgICByZXR1cm4gdG9rZW4uc2xpY2UoMSlcbiAgfSlcbn1cblxuLyoqXG4gKiBAbmFtZSBidWlsZEZvcm1hdExvbmdGblxuICogQGNhdGVnb3J5IExvY2FsZSBIZWxwZXJzXG4gKiBAc3VtbWFyeSBCdWlsZCBgZm9ybWF0TG9uZ2AgcHJvcGVydHkgZm9yIGxvY2FsZSB1c2VkIGJ5IGBmb3JtYXRgLCBgZm9ybWF0UmVsYXRpdmVgIGFuZCBgcGFyc2VgIGZ1bmN0aW9ucy5cbiAqXG4gKiBAZGVzY3JpcHRpb25cbiAqIEJ1aWxkIGBmb3JtYXRMb25nYCBwcm9wZXJ0eSBmb3IgbG9jYWxlIHVzZWQgYnkgYGZvcm1hdGAsIGBmb3JtYXRSZWxhdGl2ZWAgYW5kIGBwYXJzZWAgZnVuY3Rpb25zLlxuICogUmV0dXJucyBhIGZ1bmN0aW9uIHdoaWNoIHRha2VzIG9uZSBvZiB0aGUgZm9sbG93aW5nIHRva2VucyBhcyB0aGUgYXJndW1lbnQ6XG4gKiBgJ0xUUydgLCBgJ0xUJ2AsIGAnTCdgLCBgJ0xMJ2AsIGAnTExMJ2AsIGAnbCdgLCBgJ2xsJ2AsIGAnbGxsJ2AsIGAnbGxsbCdgXG4gKiBhbmQgcmV0dXJucyBhIGxvbmcgZm9ybWF0IHN0cmluZyB3cml0dGVuIGFzIGBmb3JtYXRgIHRva2VuIHN0cmluZ3MuXG4gKiBTZWUgW2Zvcm1hdF17QGxpbmsgaHR0cHM6Ly9kYXRlLWZucy5vcmcvZG9jcy9mb3JtYXR9XG4gKlxuICogYCdsJ2AsIGAnbGwnYCwgYCdsbGwnYCBhbmQgYCdsbGxsJ2AgZm9ybWF0cyBhcmUgYnVpbHQgYXV0b21hdGljYWxseVxuICogYnkgc2hvcnRlbmluZyBzb21lIG9mIHRoZSB0b2tlbnMgZnJvbSBjb3JyZXNwb25kaW5nIHVuc2hvcnRlbmVkIGZvcm1hdHNcbiAqIChlLmcuLCBpZiBgTExgIGlzIGAnTU1NTSBERCBZWVlZJ2AgdGhlbiBgbGxgIHdpbGwgYmUgYE1NTSBEIFlZWVlgKVxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmogLSB0aGUgb2JqZWN0IHdpdGggbG9uZyBmb3JtYXRzIHdyaXR0ZW4gYXMgYGZvcm1hdGAgdG9rZW4gc3RyaW5nc1xuICogQHBhcmFtIHtTdHJpbmd9IG9iai5MVCAtIHRpbWUgZm9ybWF0OiBob3VycyBhbmQgbWludXRlc1xuICogQHBhcmFtIHtTdHJpbmd9IG9iai5MVFMgLSB0aW1lIGZvcm1hdDogaG91cnMsIG1pbnV0ZXMgYW5kIHNlY29uZHNcbiAqIEBwYXJhbSB7U3RyaW5nfSBvYmouTCAtIHNob3J0IGRhdGUgZm9ybWF0OiBudW1lcmljIGRheSwgbW9udGggYW5kIHllYXJcbiAqIEBwYXJhbSB7U3RyaW5nfSBbb2JqLmxdIC0gc2hvcnQgZGF0ZSBmb3JtYXQ6IG51bWVyaWMgZGF5LCBtb250aCBhbmQgeWVhciAoc2hvcnRlbmVkKVxuICogQHBhcmFtIHtTdHJpbmd9IG9iai5MTCAtIGxvbmcgZGF0ZSBmb3JtYXQ6IGRheSwgbW9udGggaW4gd29yZHMsIGFuZCB5ZWFyXG4gKiBAcGFyYW0ge1N0cmluZ30gW29iai5sbF0gLSBsb25nIGRhdGUgZm9ybWF0OiBkYXksIG1vbnRoIGluIHdvcmRzLCBhbmQgeWVhciAoc2hvcnRlbmVkKVxuICogQHBhcmFtIHtTdHJpbmd9IG9iai5MTEwgLSBsb25nIGRhdGUgYW5kIHRpbWUgZm9ybWF0XG4gKiBAcGFyYW0ge1N0cmluZ30gW29iai5sbGxdIC0gbG9uZyBkYXRlIGFuZCB0aW1lIGZvcm1hdCAoc2hvcnRlbmVkKVxuICogQHBhcmFtIHtTdHJpbmd9IG9iai5MTExMIC0gbG9uZyBkYXRlLCB0aW1lIGFuZCB3ZWVrZGF5IGZvcm1hdFxuICogQHBhcmFtIHtTdHJpbmd9IFtvYmoubGxsbF0gLSBsb25nIGRhdGUsIHRpbWUgYW5kIHdlZWtkYXkgZm9ybWF0IChzaG9ydGVuZWQpXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IGBmb3JtYXRMb25nYCBwcm9wZXJ0eSBvZiB0aGUgbG9jYWxlXG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIEZvciBgZW4tVVNgIGxvY2FsZTpcbiAqIGxvY2FsZS5mb3JtYXRMb25nID0gYnVpbGRGb3JtYXRMb25nRm4oe1xuICogICBMVDogJ2g6bW0gYWEnLFxuICogICBMVFM6ICdoOm1tOnNzIGFhJyxcbiAqICAgTDogJ01NL0REL1lZWVknLFxuICogICBMTDogJ01NTU0gRCBZWVlZJyxcbiAqICAgTExMOiAnTU1NTSBEIFlZWVkgaDptbSBhYScsXG4gKiAgIExMTEw6ICdkZGRkLCBNTU1NIEQgWVlZWSBoOm1tIGFhJ1xuICogfSlcbiAqL1xuZnVuY3Rpb24gYnVpbGRGb3JtYXRMb25nRm4gKG9iaikge1xuICB2YXIgZm9ybWF0TG9uZ0xvY2FsZSA9IHtcbiAgICBMVFM6IG9iai5MVFMsXG4gICAgTFQ6IG9iai5MVCxcbiAgICBMOiBvYmouTCxcbiAgICBMTDogb2JqLkxMLFxuICAgIExMTDogb2JqLkxMTCxcbiAgICBMTExMOiBvYmouTExMTCxcbiAgICBsOiBvYmoubCB8fCBidWlsZFNob3J0TG9uZ0Zvcm1hdChvYmouTCksXG4gICAgbGw6IG9iai5sbCB8fCBidWlsZFNob3J0TG9uZ0Zvcm1hdChvYmouTEwpLFxuICAgIGxsbDogb2JqLmxsbCB8fCBidWlsZFNob3J0TG9uZ0Zvcm1hdChvYmouTExMKSxcbiAgICBsbGxsOiBvYmoubGxsbCB8fCBidWlsZFNob3J0TG9uZ0Zvcm1hdChvYmouTExMTClcbiAgfTtcblxuICByZXR1cm4gZnVuY3Rpb24gKHRva2VuKSB7XG4gICAgcmV0dXJuIGZvcm1hdExvbmdMb2NhbGVbdG9rZW5dXG4gIH1cbn1cblxudmFyIGZvcm1hdExvbmcgPSBidWlsZEZvcm1hdExvbmdGbih7XG4gIExUOiAnaDptbSBhYScsXG4gIExUUzogJ2g6bW06c3MgYWEnLFxuICBMOiAnTU0vREQvWVlZWScsXG4gIExMOiAnTU1NTSBEIFlZWVknLFxuICBMTEw6ICdNTU1NIEQgWVlZWSBoOm1tIGFhJyxcbiAgTExMTDogJ2RkZGQsIE1NTU0gRCBZWVlZIGg6bW0gYWEnXG59KTtcblxudmFyIGZvcm1hdFJlbGF0aXZlTG9jYWxlID0ge1xuICBsYXN0V2VlazogJ1tsYXN0XSBkZGRkIFthdF0gTFQnLFxuICB5ZXN0ZXJkYXk6ICdbeWVzdGVyZGF5IGF0XSBMVCcsXG4gIHRvZGF5OiAnW3RvZGF5IGF0XSBMVCcsXG4gIHRvbW9ycm93OiAnW3RvbW9ycm93IGF0XSBMVCcsXG4gIG5leHRXZWVrOiAnZGRkZCBbYXRdIExUJyxcbiAgb3RoZXI6ICdMJ1xufTtcblxuZnVuY3Rpb24gZm9ybWF0UmVsYXRpdmUgKHRva2VuLCBkYXRlLCBiYXNlRGF0ZSwgb3B0aW9ucykge1xuICByZXR1cm4gZm9ybWF0UmVsYXRpdmVMb2NhbGVbdG9rZW5dXG59XG5cbi8qKlxuICogQG5hbWUgYnVpbGRMb2NhbGl6ZUZuXG4gKiBAY2F0ZWdvcnkgTG9jYWxlIEhlbHBlcnNcbiAqIEBzdW1tYXJ5IEJ1aWxkIGBsb2NhbGl6ZS53ZWVrZGF5YCwgYGxvY2FsaXplLm1vbnRoYCBhbmQgYGxvY2FsaXplLnRpbWVPZkRheWAgcHJvcGVydGllcyBmb3IgdGhlIGxvY2FsZS5cbiAqXG4gKiBAZGVzY3JpcHRpb25cbiAqIEJ1aWxkIGBsb2NhbGl6ZS53ZWVrZGF5YCwgYGxvY2FsaXplLm1vbnRoYCBhbmQgYGxvY2FsaXplLnRpbWVPZkRheWAgcHJvcGVydGllcyBmb3IgdGhlIGxvY2FsZVxuICogdXNlZCBieSBgZm9ybWF0YCBmdW5jdGlvbi5cbiAqIElmIG5vIGB0eXBlYCBpcyBzdXBwbGllZCB0byB0aGUgb3B0aW9ucyBvZiB0aGUgcmVzdWx0aW5nIGZ1bmN0aW9uLCBgZGVmYXVsdFR5cGVgIHdpbGwgYmUgdXNlZCAoc2VlIGV4YW1wbGUpLlxuICpcbiAqIGBsb2NhbGl6ZS53ZWVrZGF5YCBmdW5jdGlvbiB0YWtlcyB0aGUgd2Vla2RheSBpbmRleCBhcyBhcmd1bWVudCAoMCAtIFN1bmRheSkuXG4gKiBgbG9jYWxpemUubW9udGhgIHRha2VzIHRoZSBtb250aCBpbmRleCAoMCAtIEphbnVhcnkpLlxuICogYGxvY2FsaXplLnRpbWVPZkRheWAgdGFrZXMgdGhlIGhvdXJzLiBVc2UgYGluZGV4Q2FsbGJhY2tgIHRvIGNvbnZlcnQgdGhlbSB0byBhbiBhcnJheSBpbmRleCAoc2VlIGV4YW1wbGUpLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWx1ZXMgLSB0aGUgb2JqZWN0IHdpdGggYXJyYXlzIG9mIHZhbHVlc1xuICogQHBhcmFtIHtTdHJpbmd9IGRlZmF1bHRUeXBlIC0gdGhlIGRlZmF1bHQgdHlwZSBmb3IgdGhlIGxvY2FsaXplIGZ1bmN0aW9uXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaW5kZXhDYWxsYmFja10gLSB0aGUgY2FsbGJhY2sgd2hpY2ggdGFrZXMgdGhlIHJlc3VsdGluZyBmdW5jdGlvbiBhcmd1bWVudFxuICogICBhbmQgY29udmVydHMgaXQgaW50byB2YWx1ZSBhcnJheSBpbmRleFxuICogQHJldHVybnMge0Z1bmN0aW9ufSB0aGUgcmVzdWx0aW5nIGZ1bmN0aW9uXG4gKlxuICogQGV4YW1wbGVcbiAqIHZhciB0aW1lT2ZEYXlWYWx1ZXMgPSB7XG4gKiAgIHVwcGVyY2FzZTogWydBTScsICdQTSddLFxuICogICBsb3dlcmNhc2U6IFsnYW0nLCAncG0nXSxcbiAqICAgbG9uZzogWydhLm0uJywgJ3AubS4nXVxuICogfVxuICogbG9jYWxlLmxvY2FsaXplLnRpbWVPZkRheSA9IGJ1aWxkTG9jYWxpemVGbih0aW1lT2ZEYXlWYWx1ZXMsICdsb25nJywgZnVuY3Rpb24gKGhvdXJzKSB7XG4gKiAgIC8vIDAgaXMgYS5tLiBhcnJheSBpbmRleCwgMSBpcyBwLm0uIGFycmF5IGluZGV4XG4gKiAgIHJldHVybiAoaG91cnMgLyAxMikgPj0gMSA/IDEgOiAwXG4gKiB9KVxuICogbG9jYWxlLmxvY2FsaXplLnRpbWVPZkRheSgxNiwge3R5cGU6ICd1cHBlcmNhc2UnfSkgLy89PiAnUE0nXG4gKiBsb2NhbGUubG9jYWxpemUudGltZU9mRGF5KDUpIC8vPT4gJ2EubS4nXG4gKi9cbmZ1bmN0aW9uIGJ1aWxkTG9jYWxpemVGbiAodmFsdWVzLCBkZWZhdWx0VHlwZSwgaW5kZXhDYWxsYmFjaykge1xuICByZXR1cm4gZnVuY3Rpb24gKGRpcnR5SW5kZXgsIGRpcnR5T3B0aW9ucykge1xuICAgIHZhciBvcHRpb25zID0gZGlydHlPcHRpb25zIHx8IHt9O1xuICAgIHZhciB0eXBlID0gb3B0aW9ucy50eXBlID8gU3RyaW5nKG9wdGlvbnMudHlwZSkgOiBkZWZhdWx0VHlwZTtcbiAgICB2YXIgdmFsdWVzQXJyYXkgPSB2YWx1ZXNbdHlwZV0gfHwgdmFsdWVzW2RlZmF1bHRUeXBlXTtcbiAgICB2YXIgaW5kZXggPSBpbmRleENhbGxiYWNrID8gaW5kZXhDYWxsYmFjayhOdW1iZXIoZGlydHlJbmRleCkpIDogTnVtYmVyKGRpcnR5SW5kZXgpO1xuICAgIHJldHVybiB2YWx1ZXNBcnJheVtpbmRleF1cbiAgfVxufVxuXG4vKipcbiAqIEBuYW1lIGJ1aWxkTG9jYWxpemVBcnJheUZuXG4gKiBAY2F0ZWdvcnkgTG9jYWxlIEhlbHBlcnNcbiAqIEBzdW1tYXJ5IEJ1aWxkIGBsb2NhbGl6ZS53ZWVrZGF5c2AsIGBsb2NhbGl6ZS5tb250aHNgIGFuZCBgbG9jYWxpemUudGltZXNPZkRheWAgcHJvcGVydGllcyBmb3IgdGhlIGxvY2FsZS5cbiAqXG4gKiBAZGVzY3JpcHRpb25cbiAqIEJ1aWxkIGBsb2NhbGl6ZS53ZWVrZGF5c2AsIGBsb2NhbGl6ZS5tb250aHNgIGFuZCBgbG9jYWxpemUudGltZXNPZkRheWAgcHJvcGVydGllcyBmb3IgdGhlIGxvY2FsZS5cbiAqIElmIG5vIGB0eXBlYCBpcyBzdXBwbGllZCB0byB0aGUgb3B0aW9ucyBvZiB0aGUgcmVzdWx0aW5nIGZ1bmN0aW9uLCBgZGVmYXVsdFR5cGVgIHdpbGwgYmUgdXNlZCAoc2VlIGV4YW1wbGUpLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWx1ZXMgLSB0aGUgb2JqZWN0IHdpdGggYXJyYXlzIG9mIHZhbHVlc1xuICogQHBhcmFtIHtTdHJpbmd9IGRlZmF1bHRUeXBlIC0gdGhlIGRlZmF1bHQgdHlwZSBmb3IgdGhlIGxvY2FsaXplIGZ1bmN0aW9uXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IHRoZSByZXN1bHRpbmcgZnVuY3Rpb25cbiAqXG4gKiBAZXhhbXBsZVxuICogdmFyIHdlZWtkYXlWYWx1ZXMgPSB7XG4gKiAgIG5hcnJvdzogWydTdScsICdNbycsICdUdScsICdXZScsICdUaCcsICdGcicsICdTYSddLFxuICogICBzaG9ydDogWydTdW4nLCAnTW9uJywgJ1R1ZScsICdXZWQnLCAnVGh1JywgJ0ZyaScsICdTYXQnXSxcbiAqICAgbG9uZzogWydTdW5kYXknLCAnTW9uZGF5JywgJ1R1ZXNkYXknLCAnV2VkbmVzZGF5JywgJ1RodXJzZGF5JywgJ0ZyaWRheScsICdTYXR1cmRheSddXG4gKiB9XG4gKiBsb2NhbGUubG9jYWxpemUud2Vla2RheXMgPSBidWlsZExvY2FsaXplQXJyYXlGbih3ZWVrZGF5VmFsdWVzLCAnbG9uZycpXG4gKiBsb2NhbGUubG9jYWxpemUud2Vla2RheXMoe3R5cGU6ICduYXJyb3cnfSkgLy89PiBbJ1N1JywgJ01vJywgLi4uXVxuICogbG9jYWxlLmxvY2FsaXplLndlZWtkYXlzKCkgLy89PiBbJ1N1bmRheScsICdNb25kYXknLCAuLi5dXG4gKi9cbmZ1bmN0aW9uIGJ1aWxkTG9jYWxpemVBcnJheUZuICh2YWx1ZXMsIGRlZmF1bHRUeXBlKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoZGlydHlPcHRpb25zKSB7XG4gICAgdmFyIG9wdGlvbnMgPSBkaXJ0eU9wdGlvbnMgfHwge307XG4gICAgdmFyIHR5cGUgPSBvcHRpb25zLnR5cGUgPyBTdHJpbmcob3B0aW9ucy50eXBlKSA6IGRlZmF1bHRUeXBlO1xuICAgIHJldHVybiB2YWx1ZXNbdHlwZV0gfHwgdmFsdWVzW2RlZmF1bHRUeXBlXVxuICB9XG59XG5cbi8vIE5vdGU6IGluIEVuZ2xpc2gsIHRoZSBuYW1lcyBvZiBkYXlzIG9mIHRoZSB3ZWVrIGFuZCBtb250aHMgYXJlIGNhcGl0YWxpemVkLlxuLy8gSWYgeW91IGFyZSBtYWtpbmcgYSBuZXcgbG9jYWxlIGJhc2VkIG9uIHRoaXMgb25lLCBjaGVjayBpZiB0aGUgc2FtZSBpcyB0cnVlIGZvciB0aGUgbGFuZ3VhZ2UgeW91J3JlIHdvcmtpbmcgb24uXG4vLyBHZW5lcmFsbHksIGZvcm1hdHRlZCBkYXRlcyBzaG91bGQgbG9vayBsaWtlIHRoZXkgYXJlIGluIHRoZSBtaWRkbGUgb2YgYSBzZW50ZW5jZSxcbi8vIGUuZy4gaW4gU3BhbmlzaCBsYW5ndWFnZSB0aGUgd2Vla2RheXMgYW5kIG1vbnRocyBzaG91bGQgYmUgaW4gdGhlIGxvd2VyY2FzZS5cbnZhciB3ZWVrZGF5VmFsdWVzID0ge1xuICBuYXJyb3c6IFsnU3UnLCAnTW8nLCAnVHUnLCAnV2UnLCAnVGgnLCAnRnInLCAnU2EnXSxcbiAgc2hvcnQ6IFsnU3VuJywgJ01vbicsICdUdWUnLCAnV2VkJywgJ1RodScsICdGcmknLCAnU2F0J10sXG4gIGxvbmc6IFsnU3VuZGF5JywgJ01vbmRheScsICdUdWVzZGF5JywgJ1dlZG5lc2RheScsICdUaHVyc2RheScsICdGcmlkYXknLCAnU2F0dXJkYXknXVxufTtcblxudmFyIG1vbnRoVmFsdWVzID0ge1xuICBzaG9ydDogWydKYW4nLCAnRmViJywgJ01hcicsICdBcHInLCAnTWF5JywgJ0p1bicsICdKdWwnLCAnQXVnJywgJ1NlcCcsICdPY3QnLCAnTm92JywgJ0RlYyddLFxuICBsb25nOiBbJ0phbnVhcnknLCAnRmVicnVhcnknLCAnTWFyY2gnLCAnQXByaWwnLCAnTWF5JywgJ0p1bmUnLCAnSnVseScsICdBdWd1c3QnLCAnU2VwdGVtYmVyJywgJ09jdG9iZXInLCAnTm92ZW1iZXInLCAnRGVjZW1iZXInXVxufTtcblxuLy8gYHRpbWVPZkRheWAgaXMgdXNlZCB0byBkZXNpZ25hdGUgd2hpY2ggcGFydCBvZiB0aGUgZGF5IGl0IGlzLCB3aGVuIHVzZWQgd2l0aCAxMi1ob3VyIGNsb2NrLlxuLy8gVXNlIHRoZSBzeXN0ZW0gd2hpY2ggaXMgdXNlZCB0aGUgbW9zdCBjb21tb25seSBpbiB0aGUgbG9jYWxlLlxuLy8gRm9yIGV4YW1wbGUsIGlmIHRoZSBjb3VudHJ5IGRvZXNuJ3QgdXNlIGEubS4vcC5tLiwgeW91IGNhbiB1c2UgYG5pZ2h0YC9gbW9ybmluZ2AvYGFmdGVybm9vbmAvYGV2ZW5pbmdgOlxuLy9cbi8vICAgdmFyIHRpbWVPZkRheVZhbHVlcyA9IHtcbi8vICAgICBhbnk6IFsnaW4gdGhlIG5pZ2h0JywgJ2luIHRoZSBtb3JuaW5nJywgJ2luIHRoZSBhZnRlcm5vb24nLCAnaW4gdGhlIGV2ZW5pbmcnXVxuLy8gICB9XG4vL1xuLy8gQW5kIGxhdGVyOlxuLy9cbi8vICAgdmFyIGxvY2FsaXplID0ge1xuLy8gICAgIC8vIFRoZSBjYWxsYmFjayB0YWtlcyB0aGUgaG91cnMgYXMgdGhlIGFyZ3VtZW50IGFuZCByZXR1cm5zIHRoZSBhcnJheSBpbmRleFxuLy8gICAgIHRpbWVPZkRheTogYnVpbGRMb2NhbGl6ZUZuKHRpbWVPZkRheVZhbHVlcywgJ2FueScsIGZ1bmN0aW9uIChob3Vycykge1xuLy8gICAgICAgaWYgKGhvdXJzID49IDE3KSB7XG4vLyAgICAgICAgIHJldHVybiAzXG4vLyAgICAgICB9IGVsc2UgaWYgKGhvdXJzID49IDEyKSB7XG4vLyAgICAgICAgIHJldHVybiAyXG4vLyAgICAgICB9IGVsc2UgaWYgKGhvdXJzID49IDQpIHtcbi8vICAgICAgICAgcmV0dXJuIDFcbi8vICAgICAgIH0gZWxzZSB7XG4vLyAgICAgICAgIHJldHVybiAwXG4vLyAgICAgICB9XG4vLyAgICAgfSksXG4vLyAgICAgdGltZXNPZkRheTogYnVpbGRMb2NhbGl6ZUFycmF5Rm4odGltZU9mRGF5VmFsdWVzLCAnYW55Jylcbi8vICAgfVxudmFyIHRpbWVPZkRheVZhbHVlcyA9IHtcbiAgdXBwZXJjYXNlOiBbJ0FNJywgJ1BNJ10sXG4gIGxvd2VyY2FzZTogWydhbScsICdwbSddLFxuICBsb25nOiBbJ2EubS4nLCAncC5tLiddXG59O1xuXG5mdW5jdGlvbiBvcmRpbmFsTnVtYmVyIChkaXJ0eU51bWJlciwgZGlydHlPcHRpb25zKSB7XG4gIHZhciBudW1iZXIgPSBOdW1iZXIoZGlydHlOdW1iZXIpO1xuXG4gIC8vIElmIG9yZGluYWwgbnVtYmVycyBkZXBlbmQgb24gY29udGV4dCwgZm9yIGV4YW1wbGUsXG4gIC8vIGlmIHRoZXkgYXJlIGRpZmZlcmVudCBmb3IgZGlmZmVyZW50IGdyYW1tYXRpY2FsIGdlbmRlcnMsXG4gIC8vIHVzZSBgb3B0aW9ucy51bml0YDpcbiAgLy9cbiAgLy8gICB2YXIgb3B0aW9ucyA9IGRpcnR5T3B0aW9ucyB8fCB7fVxuICAvLyAgIHZhciB1bml0ID0gU3RyaW5nKG9wdGlvbnMudW5pdClcbiAgLy9cbiAgLy8gd2hlcmUgYHVuaXRgIGNhbiBiZSAnbW9udGgnLCAncXVhcnRlcicsICd3ZWVrJywgJ2lzb1dlZWsnLCAnZGF5T2ZZZWFyJyxcbiAgLy8gJ2RheU9mTW9udGgnIG9yICdkYXlPZldlZWsnXG5cbiAgdmFyIHJlbTEwMCA9IG51bWJlciAlIDEwMDtcbiAgaWYgKHJlbTEwMCA+IDIwIHx8IHJlbTEwMCA8IDEwKSB7XG4gICAgc3dpdGNoIChyZW0xMDAgJSAxMCkge1xuICAgICAgY2FzZSAxOlxuICAgICAgICByZXR1cm4gbnVtYmVyICsgJ3N0J1xuICAgICAgY2FzZSAyOlxuICAgICAgICByZXR1cm4gbnVtYmVyICsgJ25kJ1xuICAgICAgY2FzZSAzOlxuICAgICAgICByZXR1cm4gbnVtYmVyICsgJ3JkJ1xuICAgIH1cbiAgfVxuICByZXR1cm4gbnVtYmVyICsgJ3RoJ1xufVxuXG52YXIgbG9jYWxpemUgPSB7XG4gIG9yZGluYWxOdW1iZXI6IG9yZGluYWxOdW1iZXIsXG4gIHdlZWtkYXk6IGJ1aWxkTG9jYWxpemVGbih3ZWVrZGF5VmFsdWVzLCAnbG9uZycpLFxuICB3ZWVrZGF5czogYnVpbGRMb2NhbGl6ZUFycmF5Rm4od2Vla2RheVZhbHVlcywgJ2xvbmcnKSxcbiAgbW9udGg6IGJ1aWxkTG9jYWxpemVGbihtb250aFZhbHVlcywgJ2xvbmcnKSxcbiAgbW9udGhzOiBidWlsZExvY2FsaXplQXJyYXlGbihtb250aFZhbHVlcywgJ2xvbmcnKSxcbiAgdGltZU9mRGF5OiBidWlsZExvY2FsaXplRm4odGltZU9mRGF5VmFsdWVzLCAnbG9uZycsIGZ1bmN0aW9uIChob3Vycykge1xuICAgIHJldHVybiAoaG91cnMgLyAxMikgPj0gMSA/IDEgOiAwXG4gIH0pLFxuICB0aW1lc09mRGF5OiBidWlsZExvY2FsaXplQXJyYXlGbih0aW1lT2ZEYXlWYWx1ZXMsICdsb25nJylcbn07XG5cbi8qKlxuICogQG5hbWUgYnVpbGRNYXRjaEZuXG4gKiBAY2F0ZWdvcnkgTG9jYWxlIEhlbHBlcnNcbiAqIEBzdW1tYXJ5IEJ1aWxkIGBtYXRjaC53ZWVrZGF5c2AsIGBtYXRjaC5tb250aHNgIGFuZCBgbWF0Y2gudGltZXNPZkRheWAgcHJvcGVydGllcyBmb3IgdGhlIGxvY2FsZS5cbiAqXG4gKiBAZGVzY3JpcHRpb25cbiAqIEJ1aWxkIGBtYXRjaC53ZWVrZGF5c2AsIGBtYXRjaC5tb250aHNgIGFuZCBgbWF0Y2gudGltZXNPZkRheWAgcHJvcGVydGllcyBmb3IgdGhlIGxvY2FsZSB1c2VkIGJ5IGBwYXJzZWAgZnVuY3Rpb24uXG4gKiBJZiBubyBgdHlwZWAgaXMgc3VwcGxpZWQgdG8gdGhlIG9wdGlvbnMgb2YgdGhlIHJlc3VsdGluZyBmdW5jdGlvbiwgYGRlZmF1bHRUeXBlYCB3aWxsIGJlIHVzZWQgKHNlZSBleGFtcGxlKS5cbiAqIFRoZSByZXN1bHQgb2YgdGhlIG1hdGNoIGZ1bmN0aW9uIHdpbGwgYmUgcGFzc2VkIGludG8gY29ycmVzcG9uZGluZyBwYXJzZXIgZnVuY3Rpb25cbiAqIChgbWF0Y2gud2Vla2RheWAsIGBtYXRjaC5tb250aGAgb3IgYG1hdGNoLnRpbWVPZkRheWAgcmVzcGVjdGl2ZWx5LiBTZWUgYGJ1aWxkUGFyc2VGbmApLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWx1ZXMgLSB0aGUgb2JqZWN0IHdpdGggUmVnRXhwc1xuICogQHBhcmFtIHtTdHJpbmd9IGRlZmF1bHRUeXBlIC0gdGhlIGRlZmF1bHQgdHlwZSBmb3IgdGhlIG1hdGNoIGZ1bmN0aW9uXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IHRoZSByZXN1bHRpbmcgZnVuY3Rpb25cbiAqXG4gKiBAZXhhbXBsZVxuICogdmFyIG1hdGNoV2Vla2RheXNQYXR0ZXJucyA9IHtcbiAqICAgbmFycm93OiAvXihzdXxtb3x0dXx3ZXx0aHxmcnxzYSkvaSxcbiAqICAgc2hvcnQ6IC9eKHN1bnxtb258dHVlfHdlZHx0aHV8ZnJpfHNhdCkvaSxcbiAqICAgbG9uZzogL14oc3VuZGF5fG1vbmRheXx0dWVzZGF5fHdlZG5lc2RheXx0aHVyc2RheXxmcmlkYXl8c2F0dXJkYXkpL2lcbiAqIH1cbiAqIGxvY2FsZS5tYXRjaC53ZWVrZGF5cyA9IGJ1aWxkTWF0Y2hGbihtYXRjaFdlZWtkYXlzUGF0dGVybnMsICdsb25nJylcbiAqIGxvY2FsZS5tYXRjaC53ZWVrZGF5cygnU3VuZGF5Jywge3R5cGU6ICduYXJyb3cnfSkgLy89PiBbJ1N1JywgJ1N1JywgLi4uXVxuICogbG9jYWxlLm1hdGNoLndlZWtkYXlzKCdTdW5kYXknKSAvLz0+IFsnU3VuZGF5JywgJ1N1bmRheScsIC4uLl1cbiAqL1xuZnVuY3Rpb24gYnVpbGRNYXRjaEZuIChwYXR0ZXJucywgZGVmYXVsdFR5cGUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIChkaXJ0eVN0cmluZywgZGlydHlPcHRpb25zKSB7XG4gICAgdmFyIG9wdGlvbnMgPSBkaXJ0eU9wdGlvbnMgfHwge307XG4gICAgdmFyIHR5cGUgPSBvcHRpb25zLnR5cGUgPyBTdHJpbmcob3B0aW9ucy50eXBlKSA6IGRlZmF1bHRUeXBlO1xuICAgIHZhciBwYXR0ZXJuID0gcGF0dGVybnNbdHlwZV0gfHwgcGF0dGVybnNbZGVmYXVsdFR5cGVdO1xuICAgIHZhciBzdHJpbmcgPSBTdHJpbmcoZGlydHlTdHJpbmcpO1xuICAgIHJldHVybiBzdHJpbmcubWF0Y2gocGF0dGVybilcbiAgfVxufVxuXG4vKipcbiAqIEBuYW1lIGJ1aWxkUGFyc2VGblxuICogQGNhdGVnb3J5IExvY2FsZSBIZWxwZXJzXG4gKiBAc3VtbWFyeSBCdWlsZCBgbWF0Y2gud2Vla2RheWAsIGBtYXRjaC5tb250aGAgYW5kIGBtYXRjaC50aW1lT2ZEYXlgIHByb3BlcnRpZXMgZm9yIHRoZSBsb2NhbGUuXG4gKlxuICogQGRlc2NyaXB0aW9uXG4gKiBCdWlsZCBgbWF0Y2gud2Vla2RheWAsIGBtYXRjaC5tb250aGAgYW5kIGBtYXRjaC50aW1lT2ZEYXlgIHByb3BlcnRpZXMgZm9yIHRoZSBsb2NhbGUgdXNlZCBieSBgcGFyc2VgIGZ1bmN0aW9uLlxuICogVGhlIGFyZ3VtZW50IG9mIHRoZSByZXN1bHRpbmcgZnVuY3Rpb24gaXMgdGhlIHJlc3VsdCBvZiB0aGUgY29ycmVzcG9uZGluZyBtYXRjaCBmdW5jdGlvblxuICogKGBtYXRjaC53ZWVrZGF5c2AsIGBtYXRjaC5tb250aHNgIG9yIGBtYXRjaC50aW1lc09mRGF5YCByZXNwZWN0aXZlbHkuIFNlZSBgYnVpbGRNYXRjaEZuYCkuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHZhbHVlcyAtIHRoZSBvYmplY3Qgd2l0aCBhcnJheXMgb2YgUmVnRXhwc1xuICogQHBhcmFtIHtTdHJpbmd9IGRlZmF1bHRUeXBlIC0gdGhlIGRlZmF1bHQgdHlwZSBmb3IgdGhlIHBhcnNlciBmdW5jdGlvblxuICogQHJldHVybnMge0Z1bmN0aW9ufSB0aGUgcmVzdWx0aW5nIGZ1bmN0aW9uXG4gKlxuICogQGV4YW1wbGVcbiAqIHZhciBwYXJzZVdlZWtkYXlQYXR0ZXJucyA9IHtcbiAqICAgYW55OiBbL15zdS9pLCAvXm0vaSwgL150dS9pLCAvXncvaSwgL150aC9pLCAvXmYvaSwgL15zYS9pXVxuICogfVxuICogbG9jYWxlLm1hdGNoLndlZWtkYXkgPSBidWlsZFBhcnNlRm4obWF0Y2hXZWVrZGF5c1BhdHRlcm5zLCAnbG9uZycpXG4gKiB2YXIgbWF0Y2hSZXN1bHQgPSBsb2NhbGUubWF0Y2gud2Vla2RheXMoJ0ZyaWRheScpXG4gKiBsb2NhbGUubWF0Y2gud2Vla2RheShtYXRjaFJlc3VsdCkgLy89PiA1XG4gKi9cbmZ1bmN0aW9uIGJ1aWxkUGFyc2VGbiAocGF0dGVybnMsIGRlZmF1bHRUeXBlKSB7XG4gIHJldHVybiBmdW5jdGlvbiAobWF0Y2hSZXN1bHQsIGRpcnR5T3B0aW9ucykge1xuICAgIHZhciBvcHRpb25zID0gZGlydHlPcHRpb25zIHx8IHt9O1xuICAgIHZhciB0eXBlID0gb3B0aW9ucy50eXBlID8gU3RyaW5nKG9wdGlvbnMudHlwZSkgOiBkZWZhdWx0VHlwZTtcbiAgICB2YXIgcGF0dGVybnNBcnJheSA9IHBhdHRlcm5zW3R5cGVdIHx8IHBhdHRlcm5zW2RlZmF1bHRUeXBlXTtcbiAgICB2YXIgc3RyaW5nID0gbWF0Y2hSZXN1bHRbMV07XG5cbiAgICByZXR1cm4gcGF0dGVybnNBcnJheS5maW5kSW5kZXgoZnVuY3Rpb24gKHBhdHRlcm4pIHtcbiAgICAgIHJldHVybiBwYXR0ZXJuLnRlc3Qoc3RyaW5nKVxuICAgIH0pXG4gIH1cbn1cblxuLyoqXG4gKiBAbmFtZSBidWlsZE1hdGNoUGF0dGVybkZuXG4gKiBAY2F0ZWdvcnkgTG9jYWxlIEhlbHBlcnNcbiAqIEBzdW1tYXJ5IEJ1aWxkIG1hdGNoIGZ1bmN0aW9uIGZyb20gYSBzaW5nbGUgUmVnRXhwLlxuICpcbiAqIEBkZXNjcmlwdGlvblxuICogQnVpbGQgbWF0Y2ggZnVuY3Rpb24gZnJvbSBhIHNpbmdsZSBSZWdFeHAuXG4gKiBVc3VhbGx5IHVzZWQgZm9yIGJ1aWxkaW5nIGBtYXRjaC5vcmRpbmFsTnVtYmVyc2AgcHJvcGVydHkgb2YgdGhlIGxvY2FsZS5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gcGF0dGVybiAtIHRoZSBSZWdFeHBcbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gdGhlIHJlc3VsdGluZyBmdW5jdGlvblxuICpcbiAqIEBleGFtcGxlXG4gKiBsb2NhbGUubWF0Y2gub3JkaW5hbE51bWJlcnMgPSBidWlsZE1hdGNoUGF0dGVybkZuKC9eKFxcZCspKHRofHN0fG5kfHJkKT8vaSlcbiAqIGxvY2FsZS5tYXRjaC5vcmRpbmFsTnVtYmVycygnM3JkJykgLy89PiBbJzNyZCcsICczJywgJ3JkJywgLi4uXVxuICovXG5mdW5jdGlvbiBidWlsZE1hdGNoUGF0dGVybkZuIChwYXR0ZXJuKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoZGlydHlTdHJpbmcpIHtcbiAgICB2YXIgc3RyaW5nID0gU3RyaW5nKGRpcnR5U3RyaW5nKTtcbiAgICByZXR1cm4gc3RyaW5nLm1hdGNoKHBhdHRlcm4pXG4gIH1cbn1cblxuLyoqXG4gKiBAbmFtZSBwYXJzZURlY2ltYWxcbiAqIEBjYXRlZ29yeSBMb2NhbGUgSGVscGVyc1xuICogQHN1bW1hcnkgUGFyc2VzIHRoZSBtYXRjaCByZXN1bHQgaW50byBkZWNpbWFsIG51bWJlci5cbiAqXG4gKiBAZGVzY3JpcHRpb25cbiAqIFBhcnNlcyB0aGUgbWF0Y2ggcmVzdWx0IGludG8gZGVjaW1hbCBudW1iZXIuXG4gKiBVc2VzIHRoZSBzdHJpbmcgbWF0Y2hlZCB3aXRoIHRoZSBmaXJzdCBzZXQgb2YgcGFyZW50aGVzZXMgb2YgbWF0Y2ggUmVnRXhwLlxuICpcbiAqIEBwYXJhbSB7QXJyYXl9IG1hdGNoUmVzdWx0IC0gdGhlIG9iamVjdCByZXR1cm5lZCBieSBtYXRjaGluZyBmdW5jdGlvblxuICogQHJldHVybnMge051bWJlcn0gdGhlIHBhcnNlZCB2YWx1ZVxuICpcbiAqIEBleGFtcGxlXG4gKiBsb2NhbGUubWF0Y2ggPSB7XG4gKiAgIG9yZGluYWxOdW1iZXJzOiAoZGlydHlTdHJpbmcpIHtcbiAqICAgICByZXR1cm4gU3RyaW5nKGRpcnR5U3RyaW5nKS5tYXRjaCgvXihcXGQrKSh0aHxzdHxuZHxyZCk/L2kpXG4gKiAgIH0sXG4gKiAgIG9yZGluYWxOdW1iZXI6IHBhcnNlRGVjaW1hbFxuICogfVxuICovXG5mdW5jdGlvbiBwYXJzZURlY2ltYWwgKG1hdGNoUmVzdWx0KSB7XG4gIHJldHVybiBwYXJzZUludChtYXRjaFJlc3VsdFsxXSwgMTApXG59XG5cbnZhciBtYXRjaE9yZGluYWxOdW1iZXJzUGF0dGVybiA9IC9eKFxcZCspKHRofHN0fG5kfHJkKT8vaTtcblxudmFyIG1hdGNoV2Vla2RheXNQYXR0ZXJucyA9IHtcbiAgbmFycm93OiAvXihzdXxtb3x0dXx3ZXx0aHxmcnxzYSkvaSxcbiAgc2hvcnQ6IC9eKHN1bnxtb258dHVlfHdlZHx0aHV8ZnJpfHNhdCkvaSxcbiAgbG9uZzogL14oc3VuZGF5fG1vbmRheXx0dWVzZGF5fHdlZG5lc2RheXx0aHVyc2RheXxmcmlkYXl8c2F0dXJkYXkpL2lcbn07XG5cbnZhciBwYXJzZVdlZWtkYXlQYXR0ZXJucyA9IHtcbiAgYW55OiBbL15zdS9pLCAvXm0vaSwgL150dS9pLCAvXncvaSwgL150aC9pLCAvXmYvaSwgL15zYS9pXVxufTtcblxudmFyIG1hdGNoTW9udGhzUGF0dGVybnMgPSB7XG4gIHNob3J0OiAvXihqYW58ZmVifG1hcnxhcHJ8bWF5fGp1bnxqdWx8YXVnfHNlcHxvY3R8bm92fGRlYykvaSxcbiAgbG9uZzogL14oamFudWFyeXxmZWJydWFyeXxtYXJjaHxhcHJpbHxtYXl8anVuZXxqdWx5fGF1Z3VzdHxzZXB0ZW1iZXJ8b2N0b2Jlcnxub3ZlbWJlcnxkZWNlbWJlcikvaVxufTtcblxudmFyIHBhcnNlTW9udGhQYXR0ZXJucyA9IHtcbiAgYW55OiBbL15qYS9pLCAvXmYvaSwgL15tYXIvaSwgL15hcC9pLCAvXm1heS9pLCAvXmp1bi9pLCAvXmp1bC9pLCAvXmF1L2ksIC9ecy9pLCAvXm8vaSwgL15uL2ksIC9eZC9pXVxufTtcblxuLy8gYHRpbWVPZkRheWAgaXMgdXNlZCB0byBkZXNpZ25hdGUgd2hpY2ggcGFydCBvZiB0aGUgZGF5IGl0IGlzLCB3aGVuIHVzZWQgd2l0aCAxMi1ob3VyIGNsb2NrLlxuLy8gVXNlIHRoZSBzeXN0ZW0gd2hpY2ggaXMgdXNlZCB0aGUgbW9zdCBjb21tb25seSBpbiB0aGUgbG9jYWxlLlxuLy8gRm9yIGV4YW1wbGUsIGlmIHRoZSBjb3VudHJ5IGRvZXNuJ3QgdXNlIGEubS4vcC5tLiwgeW91IGNhbiB1c2UgYG5pZ2h0YC9gbW9ybmluZ2AvYGFmdGVybm9vbmAvYGV2ZW5pbmdgOlxuLy9cbi8vICAgdmFyIG1hdGNoVGltZXNPZkRheVBhdHRlcm5zID0ge1xuLy8gICAgIGxvbmc6IC9eKChpbiB0aGUpPyAobmlnaHR8bW9ybmluZ3xhZnRlcm5vb258ZXZlbmluZz8pKS9pXG4vLyAgIH1cbi8vXG4vLyAgIHZhciBwYXJzZVRpbWVPZkRheVBhdHRlcm5zID0ge1xuLy8gICAgIGFueTogWy8obmlnaHR8bW9ybmluZykvaSwgLyhhZnRlcm5vb258ZXZlbmluZykvaV1cbi8vICAgfVxudmFyIG1hdGNoVGltZXNPZkRheVBhdHRlcm5zID0ge1xuICBzaG9ydDogL14oYW18cG0pL2ksXG4gIGxvbmc6IC9eKFthcF1cXC4/XFxzP21cXC4/KS9pXG59O1xuXG52YXIgcGFyc2VUaW1lT2ZEYXlQYXR0ZXJucyA9IHtcbiAgYW55OiBbL15hL2ksIC9ecC9pXVxufTtcblxudmFyIG1hdGNoID0ge1xuICBvcmRpbmFsTnVtYmVyczogYnVpbGRNYXRjaFBhdHRlcm5GbihtYXRjaE9yZGluYWxOdW1iZXJzUGF0dGVybiksXG4gIG9yZGluYWxOdW1iZXI6IHBhcnNlRGVjaW1hbCxcbiAgd2Vla2RheXM6IGJ1aWxkTWF0Y2hGbihtYXRjaFdlZWtkYXlzUGF0dGVybnMsICdsb25nJyksXG4gIHdlZWtkYXk6IGJ1aWxkUGFyc2VGbihwYXJzZVdlZWtkYXlQYXR0ZXJucywgJ2FueScpLFxuICBtb250aHM6IGJ1aWxkTWF0Y2hGbihtYXRjaE1vbnRoc1BhdHRlcm5zLCAnbG9uZycpLFxuICBtb250aDogYnVpbGRQYXJzZUZuKHBhcnNlTW9udGhQYXR0ZXJucywgJ2FueScpLFxuICB0aW1lc09mRGF5OiBidWlsZE1hdGNoRm4obWF0Y2hUaW1lc09mRGF5UGF0dGVybnMsICdsb25nJyksXG4gIHRpbWVPZkRheTogYnVpbGRQYXJzZUZuKHBhcnNlVGltZU9mRGF5UGF0dGVybnMsICdhbnknKVxufTtcblxuLyoqXG4gKiBAdHlwZSB7TG9jYWxlfVxuICogQGNhdGVnb3J5IExvY2FsZXNcbiAqIEBzdW1tYXJ5IEVuZ2xpc2ggbG9jYWxlIChVbml0ZWQgU3RhdGVzKS5cbiAqIEBsYW5ndWFnZSBFbmdsaXNoXG4gKiBAaXNvLTYzOS0yIGVuZ1xuICovXG52YXIgbG9jYWxlJDEgPSB7XG4gIGZvcm1hdERpc3RhbmNlOiBmb3JtYXREaXN0YW5jZSxcbiAgZm9ybWF0TG9uZzogZm9ybWF0TG9uZyxcbiAgZm9ybWF0UmVsYXRpdmU6IGZvcm1hdFJlbGF0aXZlLFxuICBsb2NhbGl6ZTogbG9jYWxpemUsXG4gIG1hdGNoOiBtYXRjaCxcbiAgb3B0aW9uczoge1xuICAgIHdlZWtTdGFydHNPbjogMCAvKiBTdW5kYXkgKi8sXG4gICAgZmlyc3RXZWVrQ29udGFpbnNEYXRlOiAxXG4gIH1cbn07XG5cbnZhciBNSUxMSVNFQ09ORFNfSU5fREFZJDEgPSA4NjQwMDAwMDtcblxuLy8gVGhpcyBmdW5jdGlvbiB3aWxsIGJlIGEgcGFydCBvZiBwdWJsaWMgQVBJIHdoZW4gVVRDIGZ1bmN0aW9uIHdpbGwgYmUgaW1wbGVtZW50ZWQuXG4vLyBTZWUgaXNzdWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9kYXRlLWZucy9kYXRlLWZucy9pc3N1ZXMvMzc2XG5mdW5jdGlvbiBnZXRVVENEYXlPZlllYXIgKGRpcnR5RGF0ZSwgZGlydHlPcHRpb25zKSB7XG4gIHZhciBkYXRlID0gdG9EYXRlKGRpcnR5RGF0ZSwgZGlydHlPcHRpb25zKTtcbiAgdmFyIHRpbWVzdGFtcCA9IGRhdGUuZ2V0VGltZSgpO1xuICBkYXRlLnNldFVUQ01vbnRoKDAsIDEpO1xuICBkYXRlLnNldFVUQ0hvdXJzKDAsIDAsIDAsIDApO1xuICB2YXIgc3RhcnRPZlllYXJUaW1lc3RhbXAgPSBkYXRlLmdldFRpbWUoKTtcbiAgdmFyIGRpZmZlcmVuY2UgPSB0aW1lc3RhbXAgLSBzdGFydE9mWWVhclRpbWVzdGFtcDtcbiAgcmV0dXJuIE1hdGguZmxvb3IoZGlmZmVyZW5jZSAvIE1JTExJU0VDT05EU19JTl9EQVkkMSkgKyAxXG59XG5cbi8vIFRoaXMgZnVuY3Rpb24gd2lsbCBiZSBhIHBhcnQgb2YgcHVibGljIEFQSSB3aGVuIFVUQyBmdW5jdGlvbiB3aWxsIGJlIGltcGxlbWVudGVkLlxuLy8gU2VlIGlzc3VlOiBodHRwczovL2dpdGh1Yi5jb20vZGF0ZS1mbnMvZGF0ZS1mbnMvaXNzdWVzLzM3NlxuZnVuY3Rpb24gc3RhcnRPZlVUQ0lTT1dlZWsgKGRpcnR5RGF0ZSwgZGlydHlPcHRpb25zKSB7XG4gIHZhciB3ZWVrU3RhcnRzT24gPSAxO1xuXG4gIHZhciBkYXRlID0gdG9EYXRlKGRpcnR5RGF0ZSwgZGlydHlPcHRpb25zKTtcbiAgdmFyIGRheSA9IGRhdGUuZ2V0VVRDRGF5KCk7XG4gIHZhciBkaWZmID0gKGRheSA8IHdlZWtTdGFydHNPbiA/IDcgOiAwKSArIGRheSAtIHdlZWtTdGFydHNPbjtcblxuICBkYXRlLnNldFVUQ0RhdGUoZGF0ZS5nZXRVVENEYXRlKCkgLSBkaWZmKTtcbiAgZGF0ZS5zZXRVVENIb3VycygwLCAwLCAwLCAwKTtcbiAgcmV0dXJuIGRhdGVcbn1cblxuLy8gVGhpcyBmdW5jdGlvbiB3aWxsIGJlIGEgcGFydCBvZiBwdWJsaWMgQVBJIHdoZW4gVVRDIGZ1bmN0aW9uIHdpbGwgYmUgaW1wbGVtZW50ZWQuXG4vLyBTZWUgaXNzdWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9kYXRlLWZucy9kYXRlLWZucy9pc3N1ZXMvMzc2XG5mdW5jdGlvbiBnZXRVVENJU09XZWVrWWVhciAoZGlydHlEYXRlLCBkaXJ0eU9wdGlvbnMpIHtcbiAgdmFyIGRhdGUgPSB0b0RhdGUoZGlydHlEYXRlLCBkaXJ0eU9wdGlvbnMpO1xuICB2YXIgeWVhciA9IGRhdGUuZ2V0VVRDRnVsbFllYXIoKTtcblxuICB2YXIgZm91cnRoT2ZKYW51YXJ5T2ZOZXh0WWVhciA9IG5ldyBEYXRlKDApO1xuICBmb3VydGhPZkphbnVhcnlPZk5leHRZZWFyLnNldFVUQ0Z1bGxZZWFyKHllYXIgKyAxLCAwLCA0KTtcbiAgZm91cnRoT2ZKYW51YXJ5T2ZOZXh0WWVhci5zZXRVVENIb3VycygwLCAwLCAwLCAwKTtcbiAgdmFyIHN0YXJ0T2ZOZXh0WWVhciA9IHN0YXJ0T2ZVVENJU09XZWVrKGZvdXJ0aE9mSmFudWFyeU9mTmV4dFllYXIsIGRpcnR5T3B0aW9ucyk7XG5cbiAgdmFyIGZvdXJ0aE9mSmFudWFyeU9mVGhpc1llYXIgPSBuZXcgRGF0ZSgwKTtcbiAgZm91cnRoT2ZKYW51YXJ5T2ZUaGlzWWVhci5zZXRVVENGdWxsWWVhcih5ZWFyLCAwLCA0KTtcbiAgZm91cnRoT2ZKYW51YXJ5T2ZUaGlzWWVhci5zZXRVVENIb3VycygwLCAwLCAwLCAwKTtcbiAgdmFyIHN0YXJ0T2ZUaGlzWWVhciA9IHN0YXJ0T2ZVVENJU09XZWVrKGZvdXJ0aE9mSmFudWFyeU9mVGhpc1llYXIsIGRpcnR5T3B0aW9ucyk7XG5cbiAgaWYgKGRhdGUuZ2V0VGltZSgpID49IHN0YXJ0T2ZOZXh0WWVhci5nZXRUaW1lKCkpIHtcbiAgICByZXR1cm4geWVhciArIDFcbiAgfSBlbHNlIGlmIChkYXRlLmdldFRpbWUoKSA+PSBzdGFydE9mVGhpc1llYXIuZ2V0VGltZSgpKSB7XG4gICAgcmV0dXJuIHllYXJcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4geWVhciAtIDFcbiAgfVxufVxuXG4vLyBUaGlzIGZ1bmN0aW9uIHdpbGwgYmUgYSBwYXJ0IG9mIHB1YmxpYyBBUEkgd2hlbiBVVEMgZnVuY3Rpb24gd2lsbCBiZSBpbXBsZW1lbnRlZC5cbi8vIFNlZSBpc3N1ZTogaHR0cHM6Ly9naXRodWIuY29tL2RhdGUtZm5zL2RhdGUtZm5zL2lzc3Vlcy8zNzZcbmZ1bmN0aW9uIHN0YXJ0T2ZVVENJU09XZWVrWWVhciAoZGlydHlEYXRlLCBkaXJ0eU9wdGlvbnMpIHtcbiAgdmFyIHllYXIgPSBnZXRVVENJU09XZWVrWWVhcihkaXJ0eURhdGUsIGRpcnR5T3B0aW9ucyk7XG4gIHZhciBmb3VydGhPZkphbnVhcnkgPSBuZXcgRGF0ZSgwKTtcbiAgZm91cnRoT2ZKYW51YXJ5LnNldFVUQ0Z1bGxZZWFyKHllYXIsIDAsIDQpO1xuICBmb3VydGhPZkphbnVhcnkuc2V0VVRDSG91cnMoMCwgMCwgMCwgMCk7XG4gIHZhciBkYXRlID0gc3RhcnRPZlVUQ0lTT1dlZWsoZm91cnRoT2ZKYW51YXJ5LCBkaXJ0eU9wdGlvbnMpO1xuICByZXR1cm4gZGF0ZVxufVxuXG52YXIgTUlMTElTRUNPTkRTX0lOX1dFRUskMiA9IDYwNDgwMDAwMDtcblxuLy8gVGhpcyBmdW5jdGlvbiB3aWxsIGJlIGEgcGFydCBvZiBwdWJsaWMgQVBJIHdoZW4gVVRDIGZ1bmN0aW9uIHdpbGwgYmUgaW1wbGVtZW50ZWQuXG4vLyBTZWUgaXNzdWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9kYXRlLWZucy9kYXRlLWZucy9pc3N1ZXMvMzc2XG5mdW5jdGlvbiBnZXRVVENJU09XZWVrIChkaXJ0eURhdGUsIGRpcnR5T3B0aW9ucykge1xuICB2YXIgZGF0ZSA9IHRvRGF0ZShkaXJ0eURhdGUsIGRpcnR5T3B0aW9ucyk7XG4gIHZhciBkaWZmID0gc3RhcnRPZlVUQ0lTT1dlZWsoZGF0ZSwgZGlydHlPcHRpb25zKS5nZXRUaW1lKCkgLSBzdGFydE9mVVRDSVNPV2Vla1llYXIoZGF0ZSwgZGlydHlPcHRpb25zKS5nZXRUaW1lKCk7XG5cbiAgLy8gUm91bmQgdGhlIG51bWJlciBvZiBkYXlzIHRvIHRoZSBuZWFyZXN0IGludGVnZXJcbiAgLy8gYmVjYXVzZSB0aGUgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyBpbiBhIHdlZWsgaXMgbm90IGNvbnN0YW50XG4gIC8vIChlLmcuIGl0J3MgZGlmZmVyZW50IGluIHRoZSB3ZWVrIG9mIHRoZSBkYXlsaWdodCBzYXZpbmcgdGltZSBjbG9jayBzaGlmdClcbiAgcmV0dXJuIE1hdGgucm91bmQoZGlmZiAvIE1JTExJU0VDT05EU19JTl9XRUVLJDIpICsgMVxufVxuXG52YXIgZm9ybWF0dGVycyA9IHtcbiAgLy8gTW9udGg6IDEsIDIsIC4uLiwgMTJcbiAgJ00nOiBmdW5jdGlvbiAoZGF0ZSkge1xuICAgIHJldHVybiBkYXRlLmdldFVUQ01vbnRoKCkgKyAxXG4gIH0sXG5cbiAgLy8gTW9udGg6IDFzdCwgMm5kLCAuLi4sIDEydGhcbiAgJ01vJzogZnVuY3Rpb24gKGRhdGUsIG9wdGlvbnMpIHtcbiAgICB2YXIgbW9udGggPSBkYXRlLmdldFVUQ01vbnRoKCkgKyAxO1xuICAgIHJldHVybiBvcHRpb25zLmxvY2FsZS5sb2NhbGl6ZS5vcmRpbmFsTnVtYmVyKG1vbnRoLCB7dW5pdDogJ21vbnRoJ30pXG4gIH0sXG5cbiAgLy8gTW9udGg6IDAxLCAwMiwgLi4uLCAxMlxuICAnTU0nOiBmdW5jdGlvbiAoZGF0ZSkge1xuICAgIHJldHVybiBhZGRMZWFkaW5nWmVyb3MoZGF0ZS5nZXRVVENNb250aCgpICsgMSwgMilcbiAgfSxcblxuICAvLyBNb250aDogSmFuLCBGZWIsIC4uLiwgRGVjXG4gICdNTU0nOiBmdW5jdGlvbiAoZGF0ZSwgb3B0aW9ucykge1xuICAgIHJldHVybiBvcHRpb25zLmxvY2FsZS5sb2NhbGl6ZS5tb250aChkYXRlLmdldFVUQ01vbnRoKCksIHt0eXBlOiAnc2hvcnQnfSlcbiAgfSxcblxuICAvLyBNb250aDogSmFudWFyeSwgRmVicnVhcnksIC4uLiwgRGVjZW1iZXJcbiAgJ01NTU0nOiBmdW5jdGlvbiAoZGF0ZSwgb3B0aW9ucykge1xuICAgIHJldHVybiBvcHRpb25zLmxvY2FsZS5sb2NhbGl6ZS5tb250aChkYXRlLmdldFVUQ01vbnRoKCksIHt0eXBlOiAnbG9uZyd9KVxuICB9LFxuXG4gIC8vIFF1YXJ0ZXI6IDEsIDIsIDMsIDRcbiAgJ1EnOiBmdW5jdGlvbiAoZGF0ZSkge1xuICAgIHJldHVybiBNYXRoLmNlaWwoKGRhdGUuZ2V0VVRDTW9udGgoKSArIDEpIC8gMylcbiAgfSxcblxuICAvLyBRdWFydGVyOiAxc3QsIDJuZCwgM3JkLCA0dGhcbiAgJ1FvJzogZnVuY3Rpb24gKGRhdGUsIG9wdGlvbnMpIHtcbiAgICB2YXIgcXVhcnRlciA9IE1hdGguY2VpbCgoZGF0ZS5nZXRVVENNb250aCgpICsgMSkgLyAzKTtcbiAgICByZXR1cm4gb3B0aW9ucy5sb2NhbGUubG9jYWxpemUub3JkaW5hbE51bWJlcihxdWFydGVyLCB7dW5pdDogJ3F1YXJ0ZXInfSlcbiAgfSxcblxuICAvLyBEYXkgb2YgbW9udGg6IDEsIDIsIC4uLiwgMzFcbiAgJ0QnOiBmdW5jdGlvbiAoZGF0ZSkge1xuICAgIHJldHVybiBkYXRlLmdldFVUQ0RhdGUoKVxuICB9LFxuXG4gIC8vIERheSBvZiBtb250aDogMXN0LCAybmQsIC4uLiwgMzFzdFxuICAnRG8nOiBmdW5jdGlvbiAoZGF0ZSwgb3B0aW9ucykge1xuICAgIHJldHVybiBvcHRpb25zLmxvY2FsZS5sb2NhbGl6ZS5vcmRpbmFsTnVtYmVyKGRhdGUuZ2V0VVRDRGF0ZSgpLCB7dW5pdDogJ2RheU9mTW9udGgnfSlcbiAgfSxcblxuICAvLyBEYXkgb2YgbW9udGg6IDAxLCAwMiwgLi4uLCAzMVxuICAnREQnOiBmdW5jdGlvbiAoZGF0ZSkge1xuICAgIHJldHVybiBhZGRMZWFkaW5nWmVyb3MoZGF0ZS5nZXRVVENEYXRlKCksIDIpXG4gIH0sXG5cbiAgLy8gRGF5IG9mIHllYXI6IDEsIDIsIC4uLiwgMzY2XG4gICdEREQnOiBmdW5jdGlvbiAoZGF0ZSkge1xuICAgIHJldHVybiBnZXRVVENEYXlPZlllYXIoZGF0ZSlcbiAgfSxcblxuICAvLyBEYXkgb2YgeWVhcjogMXN0LCAybmQsIC4uLiwgMzY2dGhcbiAgJ0RERG8nOiBmdW5jdGlvbiAoZGF0ZSwgb3B0aW9ucykge1xuICAgIHJldHVybiBvcHRpb25zLmxvY2FsZS5sb2NhbGl6ZS5vcmRpbmFsTnVtYmVyKGdldFVUQ0RheU9mWWVhcihkYXRlKSwge3VuaXQ6ICdkYXlPZlllYXInfSlcbiAgfSxcblxuICAvLyBEYXkgb2YgeWVhcjogMDAxLCAwMDIsIC4uLiwgMzY2XG4gICdEREREJzogZnVuY3Rpb24gKGRhdGUpIHtcbiAgICByZXR1cm4gYWRkTGVhZGluZ1plcm9zKGdldFVUQ0RheU9mWWVhcihkYXRlKSwgMylcbiAgfSxcblxuICAvLyBEYXkgb2Ygd2VlazogU3UsIE1vLCAuLi4sIFNhXG4gICdkZCc6IGZ1bmN0aW9uIChkYXRlLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIG9wdGlvbnMubG9jYWxlLmxvY2FsaXplLndlZWtkYXkoZGF0ZS5nZXRVVENEYXkoKSwge3R5cGU6ICduYXJyb3cnfSlcbiAgfSxcblxuICAvLyBEYXkgb2Ygd2VlazogU3VuLCBNb24sIC4uLiwgU2F0XG4gICdkZGQnOiBmdW5jdGlvbiAoZGF0ZSwgb3B0aW9ucykge1xuICAgIHJldHVybiBvcHRpb25zLmxvY2FsZS5sb2NhbGl6ZS53ZWVrZGF5KGRhdGUuZ2V0VVRDRGF5KCksIHt0eXBlOiAnc2hvcnQnfSlcbiAgfSxcblxuICAvLyBEYXkgb2Ygd2VlazogU3VuZGF5LCBNb25kYXksIC4uLiwgU2F0dXJkYXlcbiAgJ2RkZGQnOiBmdW5jdGlvbiAoZGF0ZSwgb3B0aW9ucykge1xuICAgIHJldHVybiBvcHRpb25zLmxvY2FsZS5sb2NhbGl6ZS53ZWVrZGF5KGRhdGUuZ2V0VVRDRGF5KCksIHt0eXBlOiAnbG9uZyd9KVxuICB9LFxuXG4gIC8vIERheSBvZiB3ZWVrOiAwLCAxLCAuLi4sIDZcbiAgJ2QnOiBmdW5jdGlvbiAoZGF0ZSkge1xuICAgIHJldHVybiBkYXRlLmdldFVUQ0RheSgpXG4gIH0sXG5cbiAgLy8gRGF5IG9mIHdlZWs6IDB0aCwgMXN0LCAybmQsIC4uLiwgNnRoXG4gICdkbyc6IGZ1bmN0aW9uIChkYXRlLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIG9wdGlvbnMubG9jYWxlLmxvY2FsaXplLm9yZGluYWxOdW1iZXIoZGF0ZS5nZXRVVENEYXkoKSwge3VuaXQ6ICdkYXlPZldlZWsnfSlcbiAgfSxcblxuICAvLyBEYXkgb2YgSVNPIHdlZWs6IDEsIDIsIC4uLiwgN1xuICAnRSc6IGZ1bmN0aW9uIChkYXRlKSB7XG4gICAgcmV0dXJuIGRhdGUuZ2V0VVRDRGF5KCkgfHwgN1xuICB9LFxuXG4gIC8vIElTTyB3ZWVrOiAxLCAyLCAuLi4sIDUzXG4gICdXJzogZnVuY3Rpb24gKGRhdGUpIHtcbiAgICByZXR1cm4gZ2V0VVRDSVNPV2VlayhkYXRlKVxuICB9LFxuXG4gIC8vIElTTyB3ZWVrOiAxc3QsIDJuZCwgLi4uLCA1M3RoXG4gICdXbyc6IGZ1bmN0aW9uIChkYXRlLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIG9wdGlvbnMubG9jYWxlLmxvY2FsaXplLm9yZGluYWxOdW1iZXIoZ2V0VVRDSVNPV2VlayhkYXRlKSwge3VuaXQ6ICdpc29XZWVrJ30pXG4gIH0sXG5cbiAgLy8gSVNPIHdlZWs6IDAxLCAwMiwgLi4uLCA1M1xuICAnV1cnOiBmdW5jdGlvbiAoZGF0ZSkge1xuICAgIHJldHVybiBhZGRMZWFkaW5nWmVyb3MoZ2V0VVRDSVNPV2VlayhkYXRlKSwgMilcbiAgfSxcblxuICAvLyBZZWFyOiAwMCwgMDEsIC4uLiwgOTlcbiAgJ1lZJzogZnVuY3Rpb24gKGRhdGUpIHtcbiAgICByZXR1cm4gYWRkTGVhZGluZ1plcm9zKGRhdGUuZ2V0VVRDRnVsbFllYXIoKSwgNCkuc3Vic3RyKDIpXG4gIH0sXG5cbiAgLy8gWWVhcjogMTkwMCwgMTkwMSwgLi4uLCAyMDk5XG4gICdZWVlZJzogZnVuY3Rpb24gKGRhdGUpIHtcbiAgICByZXR1cm4gYWRkTGVhZGluZ1plcm9zKGRhdGUuZ2V0VVRDRnVsbFllYXIoKSwgNClcbiAgfSxcblxuICAvLyBJU08gd2Vlay1udW1iZXJpbmcgeWVhcjogMDAsIDAxLCAuLi4sIDk5XG4gICdHRyc6IGZ1bmN0aW9uIChkYXRlKSB7XG4gICAgcmV0dXJuIFN0cmluZyhnZXRVVENJU09XZWVrWWVhcihkYXRlKSkuc3Vic3RyKDIpXG4gIH0sXG5cbiAgLy8gSVNPIHdlZWstbnVtYmVyaW5nIHllYXI6IDE5MDAsIDE5MDEsIC4uLiwgMjA5OVxuICAnR0dHRyc6IGZ1bmN0aW9uIChkYXRlKSB7XG4gICAgcmV0dXJuIGdldFVUQ0lTT1dlZWtZZWFyKGRhdGUpXG4gIH0sXG5cbiAgLy8gSG91cjogMCwgMSwgLi4uIDIzXG4gICdIJzogZnVuY3Rpb24gKGRhdGUpIHtcbiAgICByZXR1cm4gZGF0ZS5nZXRVVENIb3VycygpXG4gIH0sXG5cbiAgLy8gSG91cjogMDAsIDAxLCAuLi4sIDIzXG4gICdISCc6IGZ1bmN0aW9uIChkYXRlKSB7XG4gICAgcmV0dXJuIGFkZExlYWRpbmdaZXJvcyhkYXRlLmdldFVUQ0hvdXJzKCksIDIpXG4gIH0sXG5cbiAgLy8gSG91cjogMSwgMiwgLi4uLCAxMlxuICAnaCc6IGZ1bmN0aW9uIChkYXRlKSB7XG4gICAgdmFyIGhvdXJzID0gZGF0ZS5nZXRVVENIb3VycygpO1xuICAgIGlmIChob3VycyA9PT0gMCkge1xuICAgICAgcmV0dXJuIDEyXG4gICAgfSBlbHNlIGlmIChob3VycyA+IDEyKSB7XG4gICAgICByZXR1cm4gaG91cnMgJSAxMlxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gaG91cnNcbiAgICB9XG4gIH0sXG5cbiAgLy8gSG91cjogMDEsIDAyLCAuLi4sIDEyXG4gICdoaCc6IGZ1bmN0aW9uIChkYXRlKSB7XG4gICAgcmV0dXJuIGFkZExlYWRpbmdaZXJvcyhmb3JtYXR0ZXJzWydoJ10oZGF0ZSksIDIpXG4gIH0sXG5cbiAgLy8gTWludXRlOiAwLCAxLCAuLi4sIDU5XG4gICdtJzogZnVuY3Rpb24gKGRhdGUpIHtcbiAgICByZXR1cm4gZGF0ZS5nZXRVVENNaW51dGVzKClcbiAgfSxcblxuICAvLyBNaW51dGU6IDAwLCAwMSwgLi4uLCA1OVxuICAnbW0nOiBmdW5jdGlvbiAoZGF0ZSkge1xuICAgIHJldHVybiBhZGRMZWFkaW5nWmVyb3MoZGF0ZS5nZXRVVENNaW51dGVzKCksIDIpXG4gIH0sXG5cbiAgLy8gU2Vjb25kOiAwLCAxLCAuLi4sIDU5XG4gICdzJzogZnVuY3Rpb24gKGRhdGUpIHtcbiAgICByZXR1cm4gZGF0ZS5nZXRVVENTZWNvbmRzKClcbiAgfSxcblxuICAvLyBTZWNvbmQ6IDAwLCAwMSwgLi4uLCA1OVxuICAnc3MnOiBmdW5jdGlvbiAoZGF0ZSkge1xuICAgIHJldHVybiBhZGRMZWFkaW5nWmVyb3MoZGF0ZS5nZXRVVENTZWNvbmRzKCksIDIpXG4gIH0sXG5cbiAgLy8gMS8xMCBvZiBzZWNvbmQ6IDAsIDEsIC4uLiwgOVxuICAnUyc6IGZ1bmN0aW9uIChkYXRlKSB7XG4gICAgcmV0dXJuIE1hdGguZmxvb3IoZGF0ZS5nZXRVVENNaWxsaXNlY29uZHMoKSAvIDEwMClcbiAgfSxcblxuICAvLyAxLzEwMCBvZiBzZWNvbmQ6IDAwLCAwMSwgLi4uLCA5OVxuICAnU1MnOiBmdW5jdGlvbiAoZGF0ZSkge1xuICAgIHJldHVybiBhZGRMZWFkaW5nWmVyb3MoTWF0aC5mbG9vcihkYXRlLmdldFVUQ01pbGxpc2Vjb25kcygpIC8gMTApLCAyKVxuICB9LFxuXG4gIC8vIE1pbGxpc2Vjb25kOiAwMDAsIDAwMSwgLi4uLCA5OTlcbiAgJ1NTUyc6IGZ1bmN0aW9uIChkYXRlKSB7XG4gICAgcmV0dXJuIGFkZExlYWRpbmdaZXJvcyhkYXRlLmdldFVUQ01pbGxpc2Vjb25kcygpLCAzKVxuICB9LFxuXG4gIC8vIFRpbWV6b25lOiAtMDE6MDAsICswMDowMCwgLi4uICsxMjowMFxuICAnWic6IGZ1bmN0aW9uIChkYXRlLCBvcHRpb25zKSB7XG4gICAgdmFyIG9yaWdpbmFsRGF0ZSA9IG9wdGlvbnMuX29yaWdpbmFsRGF0ZSB8fCBkYXRlO1xuICAgIHJldHVybiBmb3JtYXRUaW1lem9uZShvcmlnaW5hbERhdGUuZ2V0VGltZXpvbmVPZmZzZXQoKSwgJzonKVxuICB9LFxuXG4gIC8vIFRpbWV6b25lOiAtMDEwMCwgKzAwMDAsIC4uLiArMTIwMFxuICAnWlonOiBmdW5jdGlvbiAoZGF0ZSwgb3B0aW9ucykge1xuICAgIHZhciBvcmlnaW5hbERhdGUgPSBvcHRpb25zLl9vcmlnaW5hbERhdGUgfHwgZGF0ZTtcbiAgICByZXR1cm4gZm9ybWF0VGltZXpvbmUob3JpZ2luYWxEYXRlLmdldFRpbWV6b25lT2Zmc2V0KCkpXG4gIH0sXG5cbiAgLy8gU2Vjb25kcyB0aW1lc3RhbXA6IDUxMjk2OTUyMFxuICAnWCc6IGZ1bmN0aW9uIChkYXRlLCBvcHRpb25zKSB7XG4gICAgdmFyIG9yaWdpbmFsRGF0ZSA9IG9wdGlvbnMuX29yaWdpbmFsRGF0ZSB8fCBkYXRlO1xuICAgIHJldHVybiBNYXRoLmZsb29yKG9yaWdpbmFsRGF0ZS5nZXRUaW1lKCkgLyAxMDAwKVxuICB9LFxuXG4gIC8vIE1pbGxpc2Vjb25kcyB0aW1lc3RhbXA6IDUxMjk2OTUyMDkwMFxuICAneCc6IGZ1bmN0aW9uIChkYXRlLCBvcHRpb25zKSB7XG4gICAgdmFyIG9yaWdpbmFsRGF0ZSA9IG9wdGlvbnMuX29yaWdpbmFsRGF0ZSB8fCBkYXRlO1xuICAgIHJldHVybiBvcmlnaW5hbERhdGUuZ2V0VGltZSgpXG4gIH0sXG5cbiAgLy8gQU0sIFBNXG4gICdBJzogZnVuY3Rpb24gKGRhdGUsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gb3B0aW9ucy5sb2NhbGUubG9jYWxpemUudGltZU9mRGF5KGRhdGUuZ2V0VVRDSG91cnMoKSwge3R5cGU6ICd1cHBlcmNhc2UnfSlcbiAgfSxcblxuICAvLyBhbSwgcG1cbiAgJ2EnOiBmdW5jdGlvbiAoZGF0ZSwgb3B0aW9ucykge1xuICAgIHJldHVybiBvcHRpb25zLmxvY2FsZS5sb2NhbGl6ZS50aW1lT2ZEYXkoZGF0ZS5nZXRVVENIb3VycygpLCB7dHlwZTogJ2xvd2VyY2FzZSd9KVxuICB9LFxuXG4gIC8vIGEubS4sIHAubS5cbiAgJ2FhJzogZnVuY3Rpb24gKGRhdGUsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gb3B0aW9ucy5sb2NhbGUubG9jYWxpemUudGltZU9mRGF5KGRhdGUuZ2V0VVRDSG91cnMoKSwge3R5cGU6ICdsb25nJ30pXG4gIH1cbn07XG5cbmZ1bmN0aW9uIGZvcm1hdFRpbWV6b25lIChvZmZzZXQsIGRlbGltZXRlcikge1xuICBkZWxpbWV0ZXIgPSBkZWxpbWV0ZXIgfHwgJyc7XG4gIHZhciBzaWduID0gb2Zmc2V0ID4gMCA/ICctJyA6ICcrJztcbiAgdmFyIGFic09mZnNldCA9IE1hdGguYWJzKG9mZnNldCk7XG4gIHZhciBob3VycyA9IE1hdGguZmxvb3IoYWJzT2Zmc2V0IC8gNjApO1xuICB2YXIgbWludXRlcyA9IGFic09mZnNldCAlIDYwO1xuICByZXR1cm4gc2lnbiArIGFkZExlYWRpbmdaZXJvcyhob3VycywgMikgKyBkZWxpbWV0ZXIgKyBhZGRMZWFkaW5nWmVyb3MobWludXRlcywgMilcbn1cblxuZnVuY3Rpb24gYWRkTGVhZGluZ1plcm9zIChudW1iZXIsIHRhcmdldExlbmd0aCkge1xuICB2YXIgb3V0cHV0ID0gTWF0aC5hYnMobnVtYmVyKS50b1N0cmluZygpO1xuICB3aGlsZSAob3V0cHV0Lmxlbmd0aCA8IHRhcmdldExlbmd0aCkge1xuICAgIG91dHB1dCA9ICcwJyArIG91dHB1dDtcbiAgfVxuICByZXR1cm4gb3V0cHV0XG59XG5cbi8vIFRoaXMgZnVuY3Rpb24gd2lsbCBiZSBhIHBhcnQgb2YgcHVibGljIEFQSSB3aGVuIFVUQyBmdW5jdGlvbiB3aWxsIGJlIGltcGxlbWVudGVkLlxuLy8gU2VlIGlzc3VlOiBodHRwczovL2dpdGh1Yi5jb20vZGF0ZS1mbnMvZGF0ZS1mbnMvaXNzdWVzLzM3NlxuZnVuY3Rpb24gYWRkVVRDTWludXRlcyAoZGlydHlEYXRlLCBkaXJ0eUFtb3VudCwgZGlydHlPcHRpb25zKSB7XG4gIHZhciBkYXRlID0gdG9EYXRlKGRpcnR5RGF0ZSwgZGlydHlPcHRpb25zKTtcbiAgdmFyIGFtb3VudCA9IE51bWJlcihkaXJ0eUFtb3VudCk7XG4gIGRhdGUuc2V0VVRDTWludXRlcyhkYXRlLmdldFVUQ01pbnV0ZXMoKSArIGFtb3VudCk7XG4gIHJldHVybiBkYXRlXG59XG5cbnZhciBsb25nRm9ybWF0dGluZ1Rva2Vuc1JlZ0V4cCA9IC8oXFxbW15bXSpdKXwoXFxcXCk/KExUU3xMVHxMTExMfExMTHxMTHxMfGxsbGx8bGxsfGxsfGwpL2c7XG52YXIgZGVmYXVsdEZvcm1hdHRpbmdUb2tlbnNSZWdFeHAgPSAvKFxcW1teW10qXSl8KFxcXFwpPyh4fHNzfHN8bW18bXxoaHxofGRvfGRkZGR8ZGRkfGRkfGR8YWF8YXxaWnxafFlZWVl8WVl8WHxXb3xXV3xXfFNTU3xTU3xTfFFvfFF8TW98TU1NTXxNTU18TU18TXxISHxIfEdHR0d8R0d8RXxEb3xERERvfERERER8REREfEREfER8QXwuKS9nO1xuXG4vKipcbiAqIEBuYW1lIGZvcm1hdFxuICogQGNhdGVnb3J5IENvbW1vbiBIZWxwZXJzXG4gKiBAc3VtbWFyeSBGb3JtYXQgdGhlIGRhdGUuXG4gKlxuICogQGRlc2NyaXB0aW9uXG4gKiBSZXR1cm4gdGhlIGZvcm1hdHRlZCBkYXRlIHN0cmluZyBpbiB0aGUgZ2l2ZW4gZm9ybWF0LlxuICpcbiAqIEFjY2VwdGVkIHRva2VuczpcbiAqIHwgVW5pdCAgICAgICAgICAgICAgICAgICAgfCBUb2tlbiB8IFJlc3VsdCBleGFtcGxlcyAgICAgICAgICAgICAgICAgIHxcbiAqIHwtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tfC0tLS0tLS18LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLXxcbiAqIHwgTW9udGggICAgICAgICAgICAgICAgICAgfCBNICAgICB8IDEsIDIsIC4uLiwgMTIgICAgICAgICAgICAgICAgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgfCBNbyAgICB8IDFzdCwgMm5kLCAuLi4sIDEydGggICAgICAgICAgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgfCBNTSAgICB8IDAxLCAwMiwgLi4uLCAxMiAgICAgICAgICAgICAgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgfCBNTU0gICB8IEphbiwgRmViLCAuLi4sIERlYyAgICAgICAgICAgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgfCBNTU1NICB8IEphbnVhcnksIEZlYnJ1YXJ5LCAuLi4sIERlY2VtYmVyIHxcbiAqIHwgUXVhcnRlciAgICAgICAgICAgICAgICAgfCBRICAgICB8IDEsIDIsIDMsIDQgICAgICAgICAgICAgICAgICAgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgfCBRbyAgICB8IDFzdCwgMm5kLCAzcmQsIDR0aCAgICAgICAgICAgICAgIHxcbiAqIHwgRGF5IG9mIG1vbnRoICAgICAgICAgICAgfCBEICAgICB8IDEsIDIsIC4uLiwgMzEgICAgICAgICAgICAgICAgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgfCBEbyAgICB8IDFzdCwgMm5kLCAuLi4sIDMxc3QgICAgICAgICAgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgfCBERCAgICB8IDAxLCAwMiwgLi4uLCAzMSAgICAgICAgICAgICAgICAgIHxcbiAqIHwgRGF5IG9mIHllYXIgICAgICAgICAgICAgfCBEREQgICB8IDEsIDIsIC4uLiwgMzY2ICAgICAgICAgICAgICAgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgfCBERERvICB8IDFzdCwgMm5kLCAuLi4sIDM2NnRoICAgICAgICAgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgfCBEREREICB8IDAwMSwgMDAyLCAuLi4sIDM2NiAgICAgICAgICAgICAgIHxcbiAqIHwgRGF5IG9mIHdlZWsgICAgICAgICAgICAgfCBkICAgICB8IDAsIDEsIC4uLiwgNiAgICAgICAgICAgICAgICAgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgfCBkbyAgICB8IDB0aCwgMXN0LCAuLi4sIDZ0aCAgICAgICAgICAgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgfCBkZCAgICB8IFN1LCBNbywgLi4uLCBTYSAgICAgICAgICAgICAgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgfCBkZGQgICB8IFN1biwgTW9uLCAuLi4sIFNhdCAgICAgICAgICAgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgfCBkZGRkICB8IFN1bmRheSwgTW9uZGF5LCAuLi4sIFNhdHVyZGF5ICAgIHxcbiAqIHwgRGF5IG9mIElTTyB3ZWVrICAgICAgICAgfCBFICAgICB8IDEsIDIsIC4uLiwgNyAgICAgICAgICAgICAgICAgICAgIHxcbiAqIHwgSVNPIHdlZWsgICAgICAgICAgICAgICAgfCBXICAgICB8IDEsIDIsIC4uLiwgNTMgICAgICAgICAgICAgICAgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgfCBXbyAgICB8IDFzdCwgMm5kLCAuLi4sIDUzcmQgICAgICAgICAgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgfCBXVyAgICB8IDAxLCAwMiwgLi4uLCA1MyAgICAgICAgICAgICAgICAgIHxcbiAqIHwgWWVhciAgICAgICAgICAgICAgICAgICAgfCBZWSAgICB8IDAwLCAwMSwgLi4uLCA5OSAgICAgICAgICAgICAgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgfCBZWVlZICB8IDE5MDAsIDE5MDEsIC4uLiwgMjA5OSAgICAgICAgICAgIHxcbiAqIHwgSVNPIHdlZWstbnVtYmVyaW5nIHllYXIgfCBHRyAgICB8IDAwLCAwMSwgLi4uLCA5OSAgICAgICAgICAgICAgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgfCBHR0dHICB8IDE5MDAsIDE5MDEsIC4uLiwgMjA5OSAgICAgICAgICAgIHxcbiAqIHwgQU0vUE0gICAgICAgICAgICAgICAgICAgfCBBICAgICB8IEFNLCBQTSAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgfCBhICAgICB8IGFtLCBwbSAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgfCBhYSAgICB8IGEubS4sIHAubS4gICAgICAgICAgICAgICAgICAgICAgIHxcbiAqIHwgSG91ciAgICAgICAgICAgICAgICAgICAgfCBIICAgICB8IDAsIDEsIC4uLiAyMyAgICAgICAgICAgICAgICAgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgfCBISCAgICB8IDAwLCAwMSwgLi4uIDIzICAgICAgICAgICAgICAgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgfCBoICAgICB8IDEsIDIsIC4uLiwgMTIgICAgICAgICAgICAgICAgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgfCBoaCAgICB8IDAxLCAwMiwgLi4uLCAxMiAgICAgICAgICAgICAgICAgIHxcbiAqIHwgTWludXRlICAgICAgICAgICAgICAgICAgfCBtICAgICB8IDAsIDEsIC4uLiwgNTkgICAgICAgICAgICAgICAgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgfCBtbSAgICB8IDAwLCAwMSwgLi4uLCA1OSAgICAgICAgICAgICAgICAgIHxcbiAqIHwgU2Vjb25kICAgICAgICAgICAgICAgICAgfCBzICAgICB8IDAsIDEsIC4uLiwgNTkgICAgICAgICAgICAgICAgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgfCBzcyAgICB8IDAwLCAwMSwgLi4uLCA1OSAgICAgICAgICAgICAgICAgIHxcbiAqIHwgMS8xMCBvZiBzZWNvbmQgICAgICAgICAgfCBTICAgICB8IDAsIDEsIC4uLiwgOSAgICAgICAgICAgICAgICAgICAgIHxcbiAqIHwgMS8xMDAgb2Ygc2Vjb25kICAgICAgICAgfCBTUyAgICB8IDAwLCAwMSwgLi4uLCA5OSAgICAgICAgICAgICAgICAgIHxcbiAqIHwgTWlsbGlzZWNvbmQgICAgICAgICAgICAgfCBTU1MgICB8IDAwMCwgMDAxLCAuLi4sIDk5OSAgICAgICAgICAgICAgIHxcbiAqIHwgVGltZXpvbmUgICAgICAgICAgICAgICAgfCBaICAgICB8IC0wMTowMCwgKzAwOjAwLCAuLi4gKzEyOjAwICAgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgfCBaWiAgICB8IC0wMTAwLCArMDAwMCwgLi4uLCArMTIwMCAgICAgICAgIHxcbiAqIHwgU2Vjb25kcyB0aW1lc3RhbXAgICAgICAgfCBYICAgICB8IDUxMjk2OTUyMCAgICAgICAgICAgICAgICAgICAgICAgIHxcbiAqIHwgTWlsbGlzZWNvbmRzIHRpbWVzdGFtcCAgfCB4ICAgICB8IDUxMjk2OTUyMDkwMCAgICAgICAgICAgICAgICAgICAgIHxcbiAqIHwgTG9uZyBmb3JtYXQgICAgICAgICAgICAgfCBMVCAgICB8IDA1OjMwIGEubS4gICAgICAgICAgICAgICAgICAgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgfCBMVFMgICB8IDA1OjMwOjE1IGEubS4gICAgICAgICAgICAgICAgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgfCBMICAgICB8IDA3LzAyLzE5OTUgICAgICAgICAgICAgICAgICAgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgfCBsICAgICB8IDcvMi8xOTk1ICAgICAgICAgICAgICAgICAgICAgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgfCBMTCAgICB8IEp1bHkgMiAxOTk1ICAgICAgICAgICAgICAgICAgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgfCBsbCAgICB8IEp1bCAyIDE5OTUgICAgICAgICAgICAgICAgICAgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgfCBMTEwgICB8IEp1bHkgMiAxOTk1IDA1OjMwIGEubS4gICAgICAgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgfCBsbGwgICB8IEp1bCAyIDE5OTUgMDU6MzAgYS5tLiAgICAgICAgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgfCBMTExMICB8IFN1bmRheSwgSnVseSAyIDE5OTUgMDU6MzAgYS5tLiAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgfCBsbGxsICB8IFN1biwgSnVsIDIgMTk5NSAwNTozMCBhLm0uICAgICAgIHxcbiAqXG4gKiBUaGUgY2hhcmFjdGVycyB3cmFwcGVkIGluIHNxdWFyZSBicmFja2V0cyBhcmUgZXNjYXBlZC5cbiAqXG4gKiBUaGUgcmVzdWx0IG1heSB2YXJ5IGJ5IGxvY2FsZS5cbiAqXG4gKiBAcGFyYW0ge0RhdGV8U3RyaW5nfE51bWJlcn0gZGF0ZSAtIHRoZSBvcmlnaW5hbCBkYXRlXG4gKiBAcGFyYW0ge1N0cmluZ30gZm9ybWF0IC0gdGhlIHN0cmluZyBvZiB0b2tlbnNcbiAqIEBwYXJhbSB7T3B0aW9uc30gW29wdGlvbnNdIC0gdGhlIG9iamVjdCB3aXRoIG9wdGlvbnMuIFNlZSBbT3B0aW9uc117QGxpbmsgaHR0cHM6Ly9kYXRlLWZucy5vcmcvZG9jcy9PcHRpb25zfVxuICogQHBhcmFtIHswfDF8Mn0gW29wdGlvbnMuYWRkaXRpb25hbERpZ2l0cz0yXSAtIHBhc3NlZCB0byBgdG9EYXRlYC4gU2VlIFt0b0RhdGVde0BsaW5rIGh0dHBzOi8vZGF0ZS1mbnMub3JnL2RvY3MvdG9EYXRlfVxuICogQHBhcmFtIHtMb2NhbGV9IFtvcHRpb25zLmxvY2FsZT1kZWZhdWx0TG9jYWxlXSAtIHRoZSBsb2NhbGUgb2JqZWN0LiBTZWUgW0xvY2FsZV17QGxpbmsgaHR0cHM6Ly9kYXRlLWZucy5vcmcvZG9jcy9Mb2NhbGV9XG4gKiBAcmV0dXJucyB7U3RyaW5nfSB0aGUgZm9ybWF0dGVkIGRhdGUgc3RyaW5nXG4gKiBAdGhyb3dzIHtUeXBlRXJyb3J9IDIgYXJndW1lbnRzIHJlcXVpcmVkXG4gKiBAdGhyb3dzIHtSYW5nZUVycm9yfSBgb3B0aW9ucy5hZGRpdGlvbmFsRGlnaXRzYCBtdXN0IGJlIDAsIDEgb3IgMlxuICogQHRocm93cyB7UmFuZ2VFcnJvcn0gYG9wdGlvbnMubG9jYWxlYCBtdXN0IGNvbnRhaW4gYGxvY2FsaXplYCBwcm9wZXJ0eVxuICogQHRocm93cyB7UmFuZ2VFcnJvcn0gYG9wdGlvbnMubG9jYWxlYCBtdXN0IGNvbnRhaW4gYGZvcm1hdExvbmdgIHByb3BlcnR5XG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIFJlcHJlc2VudCAxMSBGZWJydWFyeSAyMDE0IGluIG1pZGRsZS1lbmRpYW4gZm9ybWF0OlxuICogdmFyIHJlc3VsdCA9IGZvcm1hdChcbiAqICAgbmV3IERhdGUoMjAxNCwgMSwgMTEpLFxuICogICAnTU0vREQvWVlZWSdcbiAqIClcbiAqIC8vPT4gJzAyLzExLzIwMTQnXG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIFJlcHJlc2VudCAyIEp1bHkgMjAxNCBpbiBFc3BlcmFudG86XG4gKiBpbXBvcnQgeyBlb0xvY2FsZSB9IGZyb20gJ2RhdGUtZm5zL2xvY2FsZS9lbydcbiAqIHZhciByZXN1bHQgPSBmb3JtYXQoXG4gKiAgIG5ldyBEYXRlKDIwMTQsIDYsIDIpLFxuICogICAnRG8gW2RlXSBNTU1NIFlZWVknLFxuICogICB7bG9jYWxlOiBlb0xvY2FsZX1cbiAqIClcbiAqIC8vPT4gJzItYSBkZSBqdWxpbyAyMDE0J1xuICovXG5mdW5jdGlvbiBmb3JtYXQgKGRpcnR5RGF0ZSwgZGlydHlGb3JtYXRTdHIsIGRpcnR5T3B0aW9ucykge1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDIpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCcyIGFyZ3VtZW50cyByZXF1aXJlZCwgYnV0IG9ubHkgJyArIGFyZ3VtZW50cy5sZW5ndGggKyAnIHByZXNlbnQnKVxuICB9XG5cbiAgdmFyIGZvcm1hdFN0ciA9IFN0cmluZyhkaXJ0eUZvcm1hdFN0cik7XG4gIHZhciBvcHRpb25zID0gZGlydHlPcHRpb25zIHx8IHt9O1xuXG4gIHZhciBsb2NhbGUgPSBvcHRpb25zLmxvY2FsZSB8fCBsb2NhbGUkMTtcblxuICBpZiAoIWxvY2FsZS5sb2NhbGl6ZSkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdsb2NhbGUgbXVzdCBjb250YWluIGxvY2FsaXplIHByb3BlcnR5JylcbiAgfVxuXG4gIGlmICghbG9jYWxlLmZvcm1hdExvbmcpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignbG9jYWxlIG11c3QgY29udGFpbiBmb3JtYXRMb25nIHByb3BlcnR5JylcbiAgfVxuXG4gIHZhciBsb2NhbGVGb3JtYXR0ZXJzID0gbG9jYWxlLmZvcm1hdHRlcnMgfHwge307XG4gIHZhciBmb3JtYXR0aW5nVG9rZW5zUmVnRXhwID0gbG9jYWxlLmZvcm1hdHRpbmdUb2tlbnNSZWdFeHAgfHwgZGVmYXVsdEZvcm1hdHRpbmdUb2tlbnNSZWdFeHA7XG4gIHZhciBmb3JtYXRMb25nID0gbG9jYWxlLmZvcm1hdExvbmc7XG5cbiAgdmFyIG9yaWdpbmFsRGF0ZSA9IHRvRGF0ZShkaXJ0eURhdGUsIG9wdGlvbnMpO1xuXG4gIGlmICghaXNWYWxpZChvcmlnaW5hbERhdGUsIG9wdGlvbnMpKSB7XG4gICAgcmV0dXJuICdJbnZhbGlkIERhdGUnXG4gIH1cblxuICAvLyBDb252ZXJ0IHRoZSBkYXRlIGluIHN5c3RlbSB0aW1lem9uZSB0byB0aGUgc2FtZSBkYXRlIGluIFVUQyswMDowMCB0aW1lem9uZS5cbiAgLy8gVGhpcyBlbnN1cmVzIHRoYXQgd2hlbiBVVEMgZnVuY3Rpb25zIHdpbGwgYmUgaW1wbGVtZW50ZWQsIGxvY2FsZXMgd2lsbCBiZSBjb21wYXRpYmxlIHdpdGggdGhlbS5cbiAgLy8gU2VlIGFuIGlzc3VlIGFib3V0IFVUQyBmdW5jdGlvbnM6IGh0dHBzOi8vZ2l0aHViLmNvbS9kYXRlLWZucy9kYXRlLWZucy9pc3N1ZXMvMzc2XG4gIHZhciB0aW1lem9uZU9mZnNldCA9IG9yaWdpbmFsRGF0ZS5nZXRUaW1lem9uZU9mZnNldCgpO1xuICB2YXIgdXRjRGF0ZSA9IGFkZFVUQ01pbnV0ZXMob3JpZ2luYWxEYXRlLCAtdGltZXpvbmVPZmZzZXQsIG9wdGlvbnMpO1xuXG4gIHZhciBmb3JtYXR0ZXJPcHRpb25zID0gY2xvbmVPYmplY3Qob3B0aW9ucyk7XG4gIGZvcm1hdHRlck9wdGlvbnMubG9jYWxlID0gbG9jYWxlO1xuICBmb3JtYXR0ZXJPcHRpb25zLmZvcm1hdHRlcnMgPSBmb3JtYXR0ZXJzO1xuXG4gIC8vIFdoZW4gVVRDIGZ1bmN0aW9ucyB3aWxsIGJlIGltcGxlbWVudGVkLCBvcHRpb25zLl9vcmlnaW5hbERhdGUgd2lsbCBsaWtlbHkgYmUgYSBwYXJ0IG9mIHB1YmxpYyBBUEkuXG4gIC8vIFJpZ2h0IG5vdywgcGxlYXNlIGRvbid0IHVzZSBpdCBpbiBsb2NhbGVzLiBJZiB5b3UgaGF2ZSB0byB1c2UgYW4gb3JpZ2luYWwgZGF0ZSxcbiAgLy8gcGxlYXNlIHJlc3RvcmUgaXQgZnJvbSBgZGF0ZWAsIGFkZGluZyBhIHRpbWV6b25lIG9mZnNldCB0byBpdC5cbiAgZm9ybWF0dGVyT3B0aW9ucy5fb3JpZ2luYWxEYXRlID0gb3JpZ2luYWxEYXRlO1xuXG4gIHZhciByZXN1bHQgPSBmb3JtYXRTdHJcbiAgICAucmVwbGFjZShsb25nRm9ybWF0dGluZ1Rva2Vuc1JlZ0V4cCwgZnVuY3Rpb24gKHN1YnN0cmluZykge1xuICAgICAgaWYgKHN1YnN0cmluZ1swXSA9PT0gJ1snKSB7XG4gICAgICAgIHJldHVybiBzdWJzdHJpbmdcbiAgICAgIH1cblxuICAgICAgaWYgKHN1YnN0cmluZ1swXSA9PT0gJ1xcXFwnKSB7XG4gICAgICAgIHJldHVybiBjbGVhbkVzY2FwZWRTdHJpbmcoc3Vic3RyaW5nKVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gZm9ybWF0TG9uZyhzdWJzdHJpbmcpXG4gICAgfSlcbiAgICAucmVwbGFjZShmb3JtYXR0aW5nVG9rZW5zUmVnRXhwLCBmdW5jdGlvbiAoc3Vic3RyaW5nKSB7XG4gICAgICB2YXIgZm9ybWF0dGVyID0gbG9jYWxlRm9ybWF0dGVyc1tzdWJzdHJpbmddIHx8IGZvcm1hdHRlcnNbc3Vic3RyaW5nXTtcblxuICAgICAgaWYgKGZvcm1hdHRlcikge1xuICAgICAgICByZXR1cm4gZm9ybWF0dGVyKHV0Y0RhdGUsIGZvcm1hdHRlck9wdGlvbnMpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gY2xlYW5Fc2NhcGVkU3RyaW5nKHN1YnN0cmluZylcbiAgICAgIH1cbiAgICB9KTtcblxuICByZXR1cm4gcmVzdWx0XG59XG5cbmZ1bmN0aW9uIGNsZWFuRXNjYXBlZFN0cmluZyAoaW5wdXQpIHtcbiAgaWYgKGlucHV0Lm1hdGNoKC9cXFtbXFxzXFxTXS8pKSB7XG4gICAgcmV0dXJuIGlucHV0LnJlcGxhY2UoL15cXFt8XSQvZywgJycpXG4gIH1cbiAgcmV0dXJuIGlucHV0LnJlcGxhY2UoL1xcXFwvZywgJycpXG59XG5cbi8qKlxuICogQG5hbWUgc3ViTWludXRlc1xuICogQGNhdGVnb3J5IE1pbnV0ZSBIZWxwZXJzXG4gKiBAc3VtbWFyeSBTdWJ0cmFjdCB0aGUgc3BlY2lmaWVkIG51bWJlciBvZiBtaW51dGVzIGZyb20gdGhlIGdpdmVuIGRhdGUuXG4gKlxuICogQGRlc2NyaXB0aW9uXG4gKiBTdWJ0cmFjdCB0aGUgc3BlY2lmaWVkIG51bWJlciBvZiBtaW51dGVzIGZyb20gdGhlIGdpdmVuIGRhdGUuXG4gKlxuICogQHBhcmFtIHtEYXRlfFN0cmluZ3xOdW1iZXJ9IGRhdGUgLSB0aGUgZGF0ZSB0byBiZSBjaGFuZ2VkXG4gKiBAcGFyYW0ge051bWJlcn0gYW1vdW50IC0gdGhlIGFtb3VudCBvZiBtaW51dGVzIHRvIGJlIHN1YnRyYWN0ZWRcbiAqIEBwYXJhbSB7T3B0aW9uc30gW29wdGlvbnNdIC0gdGhlIG9iamVjdCB3aXRoIG9wdGlvbnMuIFNlZSBbT3B0aW9uc117QGxpbmsgaHR0cHM6Ly9kYXRlLWZucy5vcmcvZG9jcy9PcHRpb25zfVxuICogQHBhcmFtIHswfDF8Mn0gW29wdGlvbnMuYWRkaXRpb25hbERpZ2l0cz0yXSAtIHBhc3NlZCB0byBgdG9EYXRlYC4gU2VlIFt0b0RhdGVde0BsaW5rIGh0dHBzOi8vZGF0ZS1mbnMub3JnL2RvY3MvdG9EYXRlfVxuICogQHJldHVybnMge0RhdGV9IHRoZSBuZXcgZGF0ZSB3aXRoIHRoZSBtaW50dWVzIHN1YnRyYWN0ZWRcbiAqIEB0aHJvd3Mge1R5cGVFcnJvcn0gMiBhcmd1bWVudHMgcmVxdWlyZWRcbiAqIEB0aHJvd3Mge1JhbmdlRXJyb3J9IGBvcHRpb25zLmFkZGl0aW9uYWxEaWdpdHNgIG11c3QgYmUgMCwgMSBvciAyXG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIFN1YnRyYWN0IDMwIG1pbnV0ZXMgZnJvbSAxMCBKdWx5IDIwMTQgMTI6MDA6MDA6XG4gKiB2YXIgcmVzdWx0ID0gc3ViTWludXRlcyhuZXcgRGF0ZSgyMDE0LCA2LCAxMCwgMTIsIDApLCAzMClcbiAqIC8vPT4gVGh1IEp1bCAxMCAyMDE0IDExOjMwOjAwXG4gKi9cbmZ1bmN0aW9uIHN1Yk1pbnV0ZXMgKGRpcnR5RGF0ZSwgZGlydHlBbW91bnQsIGRpcnR5T3B0aW9ucykge1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDIpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCcyIGFyZ3VtZW50cyByZXF1aXJlZCwgYnV0IG9ubHkgJyArIGFyZ3VtZW50cy5sZW5ndGggKyAnIHByZXNlbnQnKVxuICB9XG5cbiAgdmFyIGFtb3VudCA9IE51bWJlcihkaXJ0eUFtb3VudCk7XG4gIHJldHVybiBhZGRNaW51dGVzKGRpcnR5RGF0ZSwgLWFtb3VudCwgZGlydHlPcHRpb25zKVxufVxuXG4vKipcbiAqIEBuYW1lIGlzQWZ0ZXJcbiAqIEBjYXRlZ29yeSBDb21tb24gSGVscGVyc1xuICogQHN1bW1hcnkgSXMgdGhlIGZpcnN0IGRhdGUgYWZ0ZXIgdGhlIHNlY29uZCBvbmU/XG4gKlxuICogQGRlc2NyaXB0aW9uXG4gKiBJcyB0aGUgZmlyc3QgZGF0ZSBhZnRlciB0aGUgc2Vjb25kIG9uZT9cbiAqXG4gKiBAcGFyYW0ge0RhdGV8U3RyaW5nfE51bWJlcn0gZGF0ZSAtIHRoZSBkYXRlIHRoYXQgc2hvdWxkIGJlIGFmdGVyIHRoZSBvdGhlciBvbmUgdG8gcmV0dXJuIHRydWVcbiAqIEBwYXJhbSB7RGF0ZXxTdHJpbmd8TnVtYmVyfSBkYXRlVG9Db21wYXJlIC0gdGhlIGRhdGUgdG8gY29tcGFyZSB3aXRoXG4gKiBAcGFyYW0ge09wdGlvbnN9IFtvcHRpb25zXSAtIHRoZSBvYmplY3Qgd2l0aCBvcHRpb25zLiBTZWUgW09wdGlvbnNde0BsaW5rIGh0dHBzOi8vZGF0ZS1mbnMub3JnL2RvY3MvT3B0aW9uc31cbiAqIEBwYXJhbSB7MHwxfDJ9IFtvcHRpb25zLmFkZGl0aW9uYWxEaWdpdHM9Ml0gLSBwYXNzZWQgdG8gYHRvRGF0ZWAuIFNlZSBbdG9EYXRlXXtAbGluayBodHRwczovL2RhdGUtZm5zLm9yZy9kb2NzL3RvRGF0ZX1cbiAqIEByZXR1cm5zIHtCb29sZWFufSB0aGUgZmlyc3QgZGF0ZSBpcyBhZnRlciB0aGUgc2Vjb25kIGRhdGVcbiAqIEB0aHJvd3Mge1R5cGVFcnJvcn0gMiBhcmd1bWVudHMgcmVxdWlyZWRcbiAqIEB0aHJvd3Mge1JhbmdlRXJyb3J9IGBvcHRpb25zLmFkZGl0aW9uYWxEaWdpdHNgIG11c3QgYmUgMCwgMSBvciAyXG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIElzIDEwIEp1bHkgMTk4OSBhZnRlciAxMSBGZWJydWFyeSAxOTg3P1xuICogdmFyIHJlc3VsdCA9IGlzQWZ0ZXIobmV3IERhdGUoMTk4OSwgNiwgMTApLCBuZXcgRGF0ZSgxOTg3LCAxLCAxMSkpXG4gKiAvLz0+IHRydWVcbiAqL1xuZnVuY3Rpb24gaXNBZnRlciAoZGlydHlEYXRlLCBkaXJ0eURhdGVUb0NvbXBhcmUsIGRpcnR5T3B0aW9ucykge1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDIpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCcyIGFyZ3VtZW50cyByZXF1aXJlZCwgYnV0IG9ubHkgJyArIGFyZ3VtZW50cy5sZW5ndGggKyAnIHByZXNlbnQnKVxuICB9XG5cbiAgdmFyIGRhdGUgPSB0b0RhdGUoZGlydHlEYXRlLCBkaXJ0eU9wdGlvbnMpO1xuICB2YXIgZGF0ZVRvQ29tcGFyZSA9IHRvRGF0ZShkaXJ0eURhdGVUb0NvbXBhcmUsIGRpcnR5T3B0aW9ucyk7XG4gIHJldHVybiBkYXRlLmdldFRpbWUoKSA+IGRhdGVUb0NvbXBhcmUuZ2V0VGltZSgpXG59XG5cbi8qKlxuICogQG5hbWUgaXNCZWZvcmVcbiAqIEBjYXRlZ29yeSBDb21tb24gSGVscGVyc1xuICogQHN1bW1hcnkgSXMgdGhlIGZpcnN0IGRhdGUgYmVmb3JlIHRoZSBzZWNvbmQgb25lP1xuICpcbiAqIEBkZXNjcmlwdGlvblxuICogSXMgdGhlIGZpcnN0IGRhdGUgYmVmb3JlIHRoZSBzZWNvbmQgb25lP1xuICpcbiAqIEBwYXJhbSB7RGF0ZXxTdHJpbmd8TnVtYmVyfSBkYXRlIC0gdGhlIGRhdGUgdGhhdCBzaG91bGQgYmUgYmVmb3JlIHRoZSBvdGhlciBvbmUgdG8gcmV0dXJuIHRydWVcbiAqIEBwYXJhbSB7RGF0ZXxTdHJpbmd8TnVtYmVyfSBkYXRlVG9Db21wYXJlIC0gdGhlIGRhdGUgdG8gY29tcGFyZSB3aXRoXG4gKiBAcGFyYW0ge09wdGlvbnN9IFtvcHRpb25zXSAtIHRoZSBvYmplY3Qgd2l0aCBvcHRpb25zLiBTZWUgW09wdGlvbnNde0BsaW5rIGh0dHBzOi8vZGF0ZS1mbnMub3JnL2RvY3MvT3B0aW9uc31cbiAqIEBwYXJhbSB7MHwxfDJ9IFtvcHRpb25zLmFkZGl0aW9uYWxEaWdpdHM9Ml0gLSBwYXNzZWQgdG8gYHRvRGF0ZWAuIFNlZSBbdG9EYXRlXXtAbGluayBodHRwczovL2RhdGUtZm5zLm9yZy9kb2NzL3RvRGF0ZX1cbiAqIEByZXR1cm5zIHtCb29sZWFufSB0aGUgZmlyc3QgZGF0ZSBpcyBiZWZvcmUgdGhlIHNlY29uZCBkYXRlXG4gKiBAdGhyb3dzIHtUeXBlRXJyb3J9IDIgYXJndW1lbnRzIHJlcXVpcmVkXG4gKiBAdGhyb3dzIHtSYW5nZUVycm9yfSBgb3B0aW9ucy5hZGRpdGlvbmFsRGlnaXRzYCBtdXN0IGJlIDAsIDEgb3IgMlxuICpcbiAqIEBleGFtcGxlXG4gKiAvLyBJcyAxMCBKdWx5IDE5ODkgYmVmb3JlIDExIEZlYnJ1YXJ5IDE5ODc/XG4gKiB2YXIgcmVzdWx0ID0gaXNCZWZvcmUobmV3IERhdGUoMTk4OSwgNiwgMTApLCBuZXcgRGF0ZSgxOTg3LCAxLCAxMSkpXG4gKiAvLz0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzQmVmb3JlIChkaXJ0eURhdGUsIGRpcnR5RGF0ZVRvQ29tcGFyZSwgZGlydHlPcHRpb25zKSB7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMikge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJzIgYXJndW1lbnRzIHJlcXVpcmVkLCBidXQgb25seSAnICsgYXJndW1lbnRzLmxlbmd0aCArICcgcHJlc2VudCcpXG4gIH1cblxuICB2YXIgZGF0ZSA9IHRvRGF0ZShkaXJ0eURhdGUsIGRpcnR5T3B0aW9ucyk7XG4gIHZhciBkYXRlVG9Db21wYXJlID0gdG9EYXRlKGRpcnR5RGF0ZVRvQ29tcGFyZSwgZGlydHlPcHRpb25zKTtcbiAgcmV0dXJuIGRhdGUuZ2V0VGltZSgpIDwgZGF0ZVRvQ29tcGFyZS5nZXRUaW1lKClcbn1cblxuLyoqXG4gKiBAbmFtZSBpc0VxdWFsXG4gKiBAY2F0ZWdvcnkgQ29tbW9uIEhlbHBlcnNcbiAqIEBzdW1tYXJ5IEFyZSB0aGUgZ2l2ZW4gZGF0ZXMgZXF1YWw/XG4gKlxuICogQGRlc2NyaXB0aW9uXG4gKiBBcmUgdGhlIGdpdmVuIGRhdGVzIGVxdWFsP1xuICpcbiAqIEBwYXJhbSB7RGF0ZXxTdHJpbmd8TnVtYmVyfSBkYXRlTGVmdCAtIHRoZSBmaXJzdCBkYXRlIHRvIGNvbXBhcmVcbiAqIEBwYXJhbSB7RGF0ZXxTdHJpbmd8TnVtYmVyfSBkYXRlUmlnaHQgLSB0aGUgc2Vjb25kIGRhdGUgdG8gY29tcGFyZVxuICogQHBhcmFtIHtPcHRpb25zfSBbb3B0aW9uc10gLSB0aGUgb2JqZWN0IHdpdGggb3B0aW9ucy4gU2VlIFtPcHRpb25zXXtAbGluayBodHRwczovL2RhdGUtZm5zLm9yZy9kb2NzL09wdGlvbnN9XG4gKiBAcGFyYW0gezB8MXwyfSBbb3B0aW9ucy5hZGRpdGlvbmFsRGlnaXRzPTJdIC0gcGFzc2VkIHRvIGB0b0RhdGVgLiBTZWUgW3RvRGF0ZV17QGxpbmsgaHR0cHM6Ly9kYXRlLWZucy5vcmcvZG9jcy90b0RhdGV9XG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gdGhlIGRhdGVzIGFyZSBlcXVhbFxuICogQHRocm93cyB7VHlwZUVycm9yfSAyIGFyZ3VtZW50cyByZXF1aXJlZFxuICogQHRocm93cyB7UmFuZ2VFcnJvcn0gYG9wdGlvbnMuYWRkaXRpb25hbERpZ2l0c2AgbXVzdCBiZSAwLCAxIG9yIDJcbiAqXG4gKiBAZXhhbXBsZVxuICogLy8gQXJlIDIgSnVseSAyMDE0IDA2OjMwOjQ1LjAwMCBhbmQgMiBKdWx5IDIwMTQgMDY6MzA6NDUuNTAwIGVxdWFsP1xuICogdmFyIHJlc3VsdCA9IGlzRXF1YWwoXG4gKiAgIG5ldyBEYXRlKDIwMTQsIDYsIDIsIDYsIDMwLCA0NSwgMClcbiAqICAgbmV3IERhdGUoMjAxNCwgNiwgMiwgNiwgMzAsIDQ1LCA1MDApXG4gKiApXG4gKiAvLz0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzRXF1YWwkMSAoZGlydHlMZWZ0RGF0ZSwgZGlydHlSaWdodERhdGUsIGRpcnR5T3B0aW9ucykge1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDIpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCcyIGFyZ3VtZW50cyByZXF1aXJlZCwgYnV0IG9ubHkgJyArIGFyZ3VtZW50cy5sZW5ndGggKyAnIHByZXNlbnQnKVxuICB9XG5cbiAgdmFyIGRhdGVMZWZ0ID0gdG9EYXRlKGRpcnR5TGVmdERhdGUsIGRpcnR5T3B0aW9ucyk7XG4gIHZhciBkYXRlUmlnaHQgPSB0b0RhdGUoZGlydHlSaWdodERhdGUsIGRpcnR5T3B0aW9ucyk7XG4gIHJldHVybiBkYXRlTGVmdC5nZXRUaW1lKCkgPT09IGRhdGVSaWdodC5nZXRUaW1lKClcbn1cblxudmFyIHBhdHRlcm5zJDEgPSB7XG4gICdNJzogL14oMVswLTJdfDA/XFxkKS8sIC8vIDAgdG8gMTJcbiAgJ0QnOiAvXigzWzAtMV18WzAtMl0/XFxkKS8sIC8vIDAgdG8gMzFcbiAgJ0RERCc6IC9eKDM2WzAtNl18M1swLTVdXFxkfFswLTJdP1xcZD9cXGQpLywgLy8gMCB0byAzNjZcbiAgJ1cnOiAvXig1WzAtM118WzAtNF0/XFxkKS8sIC8vIDAgdG8gNTNcbiAgJ1lZWVknOiAvXihcXGR7MSw0fSkvLCAvLyAwIHRvIDk5OTlcbiAgJ0gnOiAvXigyWzAtM118WzAtMV0/XFxkKS8sIC8vIDAgdG8gMjNcbiAgJ20nOiAvXihbMC01XT9cXGQpLywgLy8gMCB0byA1OVxuICAnWic6IC9eKFsrLV0pKFxcZHsyfSk6KFxcZHsyfSkvLFxuICAnWlonOiAvXihbKy1dKShcXGR7Mn0pKFxcZHsyfSkvLFxuICBzaW5nbGVEaWdpdDogL14oXFxkKS8sXG4gIHR3b0RpZ2l0czogL14oXFxkezJ9KS8sXG4gIHRocmVlRGlnaXRzOiAvXihcXGR7M30pLyxcbiAgZm91ckRpZ2l0czogL14oXFxkezR9KS8sXG4gIGFueURpZ2l0czogL14oXFxkKykvXG59O1xuXG5mdW5jdGlvbiBwYXJzZURlY2ltYWwkMSAobWF0Y2hSZXN1bHQpIHtcbiAgcmV0dXJuIHBhcnNlSW50KG1hdGNoUmVzdWx0WzFdLCAxMClcbn1cblxudmFyIHBhcnNlcnMgPSB7XG4gIC8vIFllYXI6IDAwLCAwMSwgLi4uLCA5OVxuICAnWVknOiB7XG4gICAgdW5pdDogJ3R3b0RpZ2l0WWVhcicsXG4gICAgbWF0Y2g6IHBhdHRlcm5zJDEudHdvRGlnaXRzLFxuICAgIHBhcnNlOiBmdW5jdGlvbiAobWF0Y2hSZXN1bHQpIHtcbiAgICAgIHJldHVybiBwYXJzZURlY2ltYWwkMShtYXRjaFJlc3VsdClcbiAgICB9XG4gIH0sXG5cbiAgLy8gWWVhcjogMTkwMCwgMTkwMSwgLi4uLCAyMDk5XG4gICdZWVlZJzoge1xuICAgIHVuaXQ6ICd5ZWFyJyxcbiAgICBtYXRjaDogcGF0dGVybnMkMS5ZWVlZLFxuICAgIHBhcnNlOiBwYXJzZURlY2ltYWwkMVxuICB9LFxuXG4gIC8vIElTTyB3ZWVrLW51bWJlcmluZyB5ZWFyOiAwMCwgMDEsIC4uLiwgOTlcbiAgJ0dHJzoge1xuICAgIHVuaXQ6ICdpc29ZZWFyJyxcbiAgICBtYXRjaDogcGF0dGVybnMkMS50d29EaWdpdHMsXG4gICAgcGFyc2U6IGZ1bmN0aW9uIChtYXRjaFJlc3VsdCkge1xuICAgICAgcmV0dXJuIHBhcnNlRGVjaW1hbCQxKG1hdGNoUmVzdWx0KSArIDE5MDBcbiAgICB9XG4gIH0sXG5cbiAgLy8gSVNPIHdlZWstbnVtYmVyaW5nIHllYXI6IDE5MDAsIDE5MDEsIC4uLiwgMjA5OVxuICAnR0dHRyc6IHtcbiAgICB1bml0OiAnaXNvWWVhcicsXG4gICAgbWF0Y2g6IHBhdHRlcm5zJDEuWVlZWSxcbiAgICBwYXJzZTogcGFyc2VEZWNpbWFsJDFcbiAgfSxcblxuICAvLyBRdWFydGVyOiAxLCAyLCAzLCA0XG4gICdRJzoge1xuICAgIHVuaXQ6ICdxdWFydGVyJyxcbiAgICBtYXRjaDogcGF0dGVybnMkMS5zaW5nbGVEaWdpdCxcbiAgICBwYXJzZTogcGFyc2VEZWNpbWFsJDFcbiAgfSxcblxuICAvLyBPcmRpbmFsIHF1YXJ0ZXJcbiAgJ1FvJzoge1xuICAgIHVuaXQ6ICdxdWFydGVyJyxcbiAgICBtYXRjaDogZnVuY3Rpb24gKHN0cmluZywgb3B0aW9ucykge1xuICAgICAgcmV0dXJuIG9wdGlvbnMubG9jYWxlLm1hdGNoLm9yZGluYWxOdW1iZXJzKHN0cmluZywge3VuaXQ6ICdxdWFydGVyJ30pXG4gICAgfSxcbiAgICBwYXJzZTogZnVuY3Rpb24gKG1hdGNoUmVzdWx0LCBvcHRpb25zKSB7XG4gICAgICByZXR1cm4gb3B0aW9ucy5sb2NhbGUubWF0Y2gub3JkaW5hbE51bWJlcihtYXRjaFJlc3VsdCwge3VuaXQ6ICdxdWFydGVyJ30pXG4gICAgfVxuICB9LFxuXG4gIC8vIE1vbnRoOiAxLCAyLCAuLi4sIDEyXG4gICdNJzoge1xuICAgIHVuaXQ6ICdtb250aCcsXG4gICAgbWF0Y2g6IHBhdHRlcm5zJDEuTSxcbiAgICBwYXJzZTogZnVuY3Rpb24gKG1hdGNoUmVzdWx0KSB7XG4gICAgICByZXR1cm4gcGFyc2VEZWNpbWFsJDEobWF0Y2hSZXN1bHQpIC0gMVxuICAgIH1cbiAgfSxcblxuICAvLyBPcmRpbmFsIG1vbnRoXG4gICdNbyc6IHtcbiAgICB1bml0OiAnbW9udGgnLFxuICAgIG1hdGNoOiBmdW5jdGlvbiAoc3RyaW5nLCBvcHRpb25zKSB7XG4gICAgICByZXR1cm4gb3B0aW9ucy5sb2NhbGUubWF0Y2gub3JkaW5hbE51bWJlcnMoc3RyaW5nLCB7dW5pdDogJ21vbnRoJ30pXG4gICAgfSxcbiAgICBwYXJzZTogZnVuY3Rpb24gKG1hdGNoUmVzdWx0LCBvcHRpb25zKSB7XG4gICAgICByZXR1cm4gb3B0aW9ucy5sb2NhbGUubWF0Y2gub3JkaW5hbE51bWJlcihtYXRjaFJlc3VsdCwge3VuaXQ6ICdtb250aCd9KSAtIDFcbiAgICB9XG4gIH0sXG5cbiAgLy8gTW9udGg6IDAxLCAwMiwgLi4uLCAxMlxuICAnTU0nOiB7XG4gICAgdW5pdDogJ21vbnRoJyxcbiAgICBtYXRjaDogcGF0dGVybnMkMS50d29EaWdpdHMsXG4gICAgcGFyc2U6IGZ1bmN0aW9uIChtYXRjaFJlc3VsdCkge1xuICAgICAgcmV0dXJuIHBhcnNlRGVjaW1hbCQxKG1hdGNoUmVzdWx0KSAtIDFcbiAgICB9XG4gIH0sXG5cbiAgLy8gTW9udGg6IEphbiwgRmViLCAuLi4sIERlY1xuICAnTU1NJzoge1xuICAgIHVuaXQ6ICdtb250aCcsXG4gICAgbWF0Y2g6IGZ1bmN0aW9uIChzdHJpbmcsIG9wdGlvbnMpIHtcbiAgICAgIHJldHVybiBvcHRpb25zLmxvY2FsZS5tYXRjaC5tb250aHMoc3RyaW5nLCB7dHlwZTogJ3Nob3J0J30pXG4gICAgfSxcbiAgICBwYXJzZTogZnVuY3Rpb24gKG1hdGNoUmVzdWx0LCBvcHRpb25zKSB7XG4gICAgICByZXR1cm4gb3B0aW9ucy5sb2NhbGUubWF0Y2gubW9udGgobWF0Y2hSZXN1bHQsIHt0eXBlOiAnc2hvcnQnfSlcbiAgICB9XG4gIH0sXG5cbiAgLy8gTW9udGg6IEphbnVhcnksIEZlYnJ1YXJ5LCAuLi4sIERlY2VtYmVyXG4gICdNTU1NJzoge1xuICAgIHVuaXQ6ICdtb250aCcsXG4gICAgbWF0Y2g6IGZ1bmN0aW9uIChzdHJpbmcsIG9wdGlvbnMpIHtcbiAgICAgIHJldHVybiBvcHRpb25zLmxvY2FsZS5tYXRjaC5tb250aHMoc3RyaW5nLCB7dHlwZTogJ2xvbmcnfSkgfHxcbiAgICAgICAgb3B0aW9ucy5sb2NhbGUubWF0Y2gubW9udGhzKHN0cmluZywge3R5cGU6ICdzaG9ydCd9KVxuICAgIH0sXG4gICAgcGFyc2U6IGZ1bmN0aW9uIChtYXRjaFJlc3VsdCwgb3B0aW9ucykge1xuICAgICAgdmFyIHBhcnNlUmVzdWx0ID0gb3B0aW9ucy5sb2NhbGUubWF0Y2gubW9udGgobWF0Y2hSZXN1bHQsIHt0eXBlOiAnbG9uZyd9KTtcblxuICAgICAgaWYgKHBhcnNlUmVzdWx0ID09IG51bGwpIHtcbiAgICAgICAgcGFyc2VSZXN1bHQgPSBvcHRpb25zLmxvY2FsZS5tYXRjaC5tb250aChtYXRjaFJlc3VsdCwge3R5cGU6ICdzaG9ydCd9KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHBhcnNlUmVzdWx0XG4gICAgfVxuICB9LFxuXG4gIC8vIElTTyB3ZWVrOiAxLCAyLCAuLi4sIDUzXG4gICdXJzoge1xuICAgIHVuaXQ6ICdpc29XZWVrJyxcbiAgICBtYXRjaDogcGF0dGVybnMkMS5XLFxuICAgIHBhcnNlOiBwYXJzZURlY2ltYWwkMVxuICB9LFxuXG4gIC8vIE9yZGluYWwgSVNPIHdlZWtcbiAgJ1dvJzoge1xuICAgIHVuaXQ6ICdpc29XZWVrJyxcbiAgICBtYXRjaDogZnVuY3Rpb24gKHN0cmluZywgb3B0aW9ucykge1xuICAgICAgcmV0dXJuIG9wdGlvbnMubG9jYWxlLm1hdGNoLm9yZGluYWxOdW1iZXJzKHN0cmluZywge3VuaXQ6ICdpc29XZWVrJ30pXG4gICAgfSxcbiAgICBwYXJzZTogZnVuY3Rpb24gKG1hdGNoUmVzdWx0LCBvcHRpb25zKSB7XG4gICAgICByZXR1cm4gb3B0aW9ucy5sb2NhbGUubWF0Y2gub3JkaW5hbE51bWJlcihtYXRjaFJlc3VsdCwge3VuaXQ6ICdpc29XZWVrJ30pXG4gICAgfVxuICB9LFxuXG4gIC8vIElTTyB3ZWVrOiAwMSwgMDIsIC4uLiwgNTNcbiAgJ1dXJzoge1xuICAgIHVuaXQ6ICdpc29XZWVrJyxcbiAgICBtYXRjaDogcGF0dGVybnMkMS50d29EaWdpdHMsXG4gICAgcGFyc2U6IHBhcnNlRGVjaW1hbCQxXG4gIH0sXG5cbiAgLy8gRGF5IG9mIHdlZWs6IDAsIDEsIC4uLiwgNlxuICAnZCc6IHtcbiAgICB1bml0OiAnZGF5T2ZXZWVrJyxcbiAgICBtYXRjaDogcGF0dGVybnMkMS5zaW5nbGVEaWdpdCxcbiAgICBwYXJzZTogcGFyc2VEZWNpbWFsJDFcbiAgfSxcblxuICAvLyBPcmRpbmFsIGRheSBvZiB3ZWVrXG4gICdkbyc6IHtcbiAgICB1bml0OiAnZGF5T2ZXZWVrJyxcbiAgICBtYXRjaDogZnVuY3Rpb24gKHN0cmluZywgb3B0aW9ucykge1xuICAgICAgcmV0dXJuIG9wdGlvbnMubG9jYWxlLm1hdGNoLm9yZGluYWxOdW1iZXJzKHN0cmluZywge3VuaXQ6ICdkYXlPZldlZWsnfSlcbiAgICB9LFxuICAgIHBhcnNlOiBmdW5jdGlvbiAobWF0Y2hSZXN1bHQsIG9wdGlvbnMpIHtcbiAgICAgIHJldHVybiBvcHRpb25zLmxvY2FsZS5tYXRjaC5vcmRpbmFsTnVtYmVyKG1hdGNoUmVzdWx0LCB7dW5pdDogJ2RheU9mV2Vlayd9KVxuICAgIH1cbiAgfSxcblxuICAvLyBEYXkgb2Ygd2VlazogU3UsIE1vLCAuLi4sIFNhXG4gICdkZCc6IHtcbiAgICB1bml0OiAnZGF5T2ZXZWVrJyxcbiAgICBtYXRjaDogZnVuY3Rpb24gKHN0cmluZywgb3B0aW9ucykge1xuICAgICAgcmV0dXJuIG9wdGlvbnMubG9jYWxlLm1hdGNoLndlZWtkYXlzKHN0cmluZywge3R5cGU6ICduYXJyb3cnfSlcbiAgICB9LFxuICAgIHBhcnNlOiBmdW5jdGlvbiAobWF0Y2hSZXN1bHQsIG9wdGlvbnMpIHtcbiAgICAgIHJldHVybiBvcHRpb25zLmxvY2FsZS5tYXRjaC53ZWVrZGF5KG1hdGNoUmVzdWx0LCB7dHlwZTogJ25hcnJvdyd9KVxuICAgIH1cbiAgfSxcblxuICAvLyBEYXkgb2Ygd2VlazogU3VuLCBNb24sIC4uLiwgU2F0XG4gICdkZGQnOiB7XG4gICAgdW5pdDogJ2RheU9mV2VlaycsXG4gICAgbWF0Y2g6IGZ1bmN0aW9uIChzdHJpbmcsIG9wdGlvbnMpIHtcbiAgICAgIHJldHVybiBvcHRpb25zLmxvY2FsZS5tYXRjaC53ZWVrZGF5cyhzdHJpbmcsIHt0eXBlOiAnc2hvcnQnfSkgfHxcbiAgICAgICAgb3B0aW9ucy5sb2NhbGUubWF0Y2gud2Vla2RheXMoc3RyaW5nLCB7dHlwZTogJ25hcnJvdyd9KVxuICAgIH0sXG4gICAgcGFyc2U6IGZ1bmN0aW9uIChtYXRjaFJlc3VsdCwgb3B0aW9ucykge1xuICAgICAgdmFyIHBhcnNlUmVzdWx0ID0gb3B0aW9ucy5sb2NhbGUubWF0Y2gud2Vla2RheShtYXRjaFJlc3VsdCwge3R5cGU6ICdzaG9ydCd9KTtcblxuICAgICAgaWYgKHBhcnNlUmVzdWx0ID09IG51bGwpIHtcbiAgICAgICAgcGFyc2VSZXN1bHQgPSBvcHRpb25zLmxvY2FsZS5tYXRjaC53ZWVrZGF5KG1hdGNoUmVzdWx0LCB7dHlwZTogJ25hcnJvdyd9KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHBhcnNlUmVzdWx0XG4gICAgfVxuICB9LFxuXG4gIC8vIERheSBvZiB3ZWVrOiBTdW5kYXksIE1vbmRheSwgLi4uLCBTYXR1cmRheVxuICAnZGRkZCc6IHtcbiAgICB1bml0OiAnZGF5T2ZXZWVrJyxcbiAgICBtYXRjaDogZnVuY3Rpb24gKHN0cmluZywgb3B0aW9ucykge1xuICAgICAgcmV0dXJuIG9wdGlvbnMubG9jYWxlLm1hdGNoLndlZWtkYXlzKHN0cmluZywge3R5cGU6ICdsb25nJ30pIHx8XG4gICAgICAgIG9wdGlvbnMubG9jYWxlLm1hdGNoLndlZWtkYXlzKHN0cmluZywge3R5cGU6ICdzaG9ydCd9KSB8fFxuICAgICAgICBvcHRpb25zLmxvY2FsZS5tYXRjaC53ZWVrZGF5cyhzdHJpbmcsIHt0eXBlOiAnbmFycm93J30pXG4gICAgfSxcbiAgICBwYXJzZTogZnVuY3Rpb24gKG1hdGNoUmVzdWx0LCBvcHRpb25zKSB7XG4gICAgICB2YXIgcGFyc2VSZXN1bHQgPSBvcHRpb25zLmxvY2FsZS5tYXRjaC53ZWVrZGF5KG1hdGNoUmVzdWx0LCB7dHlwZTogJ2xvbmcnfSk7XG5cbiAgICAgIGlmIChwYXJzZVJlc3VsdCA9PSBudWxsKSB7XG4gICAgICAgIHBhcnNlUmVzdWx0ID0gb3B0aW9ucy5sb2NhbGUubWF0Y2gud2Vla2RheShtYXRjaFJlc3VsdCwge3R5cGU6ICdzaG9ydCd9KTtcblxuICAgICAgICBpZiAocGFyc2VSZXN1bHQgPT0gbnVsbCkge1xuICAgICAgICAgIHBhcnNlUmVzdWx0ID0gb3B0aW9ucy5sb2NhbGUubWF0Y2gud2Vla2RheShtYXRjaFJlc3VsdCwge3R5cGU6ICduYXJyb3cnfSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHBhcnNlUmVzdWx0XG4gICAgfVxuICB9LFxuXG4gIC8vIERheSBvZiBJU08gd2VlazogMSwgMiwgLi4uLCA3XG4gICdFJzoge1xuICAgIHVuaXQ6ICdkYXlPZklTT1dlZWsnLFxuICAgIG1hdGNoOiBwYXR0ZXJucyQxLnNpbmdsZURpZ2l0LFxuICAgIHBhcnNlOiBmdW5jdGlvbiAobWF0Y2hSZXN1bHQpIHtcbiAgICAgIHJldHVybiBwYXJzZURlY2ltYWwkMShtYXRjaFJlc3VsdClcbiAgICB9XG4gIH0sXG5cbiAgLy8gRGF5IG9mIG1vbnRoOiAxLCAyLCAuLi4sIDMxXG4gICdEJzoge1xuICAgIHVuaXQ6ICdkYXlPZk1vbnRoJyxcbiAgICBtYXRjaDogcGF0dGVybnMkMS5ELFxuICAgIHBhcnNlOiBwYXJzZURlY2ltYWwkMVxuICB9LFxuXG4gIC8vIE9yZGluYWwgZGF5IG9mIG1vbnRoXG4gICdEbyc6IHtcbiAgICB1bml0OiAnZGF5T2ZNb250aCcsXG4gICAgbWF0Y2g6IGZ1bmN0aW9uIChzdHJpbmcsIG9wdGlvbnMpIHtcbiAgICAgIHJldHVybiBvcHRpb25zLmxvY2FsZS5tYXRjaC5vcmRpbmFsTnVtYmVycyhzdHJpbmcsIHt1bml0OiAnZGF5T2ZNb250aCd9KVxuICAgIH0sXG4gICAgcGFyc2U6IGZ1bmN0aW9uIChtYXRjaFJlc3VsdCwgb3B0aW9ucykge1xuICAgICAgcmV0dXJuIG9wdGlvbnMubG9jYWxlLm1hdGNoLm9yZGluYWxOdW1iZXIobWF0Y2hSZXN1bHQsIHt1bml0OiAnZGF5T2ZNb250aCd9KVxuICAgIH1cbiAgfSxcblxuICAvLyBEYXkgb2YgbW9udGg6IDAxLCAwMiwgLi4uLCAzMVxuICAnREQnOiB7XG4gICAgdW5pdDogJ2RheU9mTW9udGgnLFxuICAgIG1hdGNoOiBwYXR0ZXJucyQxLnR3b0RpZ2l0cyxcbiAgICBwYXJzZTogcGFyc2VEZWNpbWFsJDFcbiAgfSxcblxuICAvLyBEYXkgb2YgeWVhcjogMSwgMiwgLi4uLCAzNjZcbiAgJ0RERCc6IHtcbiAgICB1bml0OiAnZGF5T2ZZZWFyJyxcbiAgICBtYXRjaDogcGF0dGVybnMkMS5EREQsXG4gICAgcGFyc2U6IHBhcnNlRGVjaW1hbCQxXG4gIH0sXG5cbiAgLy8gT3JkaW5hbCBkYXkgb2YgeWVhclxuICAnREREbyc6IHtcbiAgICB1bml0OiAnZGF5T2ZZZWFyJyxcbiAgICBtYXRjaDogZnVuY3Rpb24gKHN0cmluZywgb3B0aW9ucykge1xuICAgICAgcmV0dXJuIG9wdGlvbnMubG9jYWxlLm1hdGNoLm9yZGluYWxOdW1iZXJzKHN0cmluZywge3VuaXQ6ICdkYXlPZlllYXInfSlcbiAgICB9LFxuICAgIHBhcnNlOiBmdW5jdGlvbiAobWF0Y2hSZXN1bHQsIG9wdGlvbnMpIHtcbiAgICAgIHJldHVybiBvcHRpb25zLmxvY2FsZS5tYXRjaC5vcmRpbmFsTnVtYmVyKG1hdGNoUmVzdWx0LCB7dW5pdDogJ2RheU9mWWVhcid9KVxuICAgIH1cbiAgfSxcblxuICAvLyBEYXkgb2YgeWVhcjogMDAxLCAwMDIsIC4uLiwgMzY2XG4gICdEREREJzoge1xuICAgIHVuaXQ6ICdkYXlPZlllYXInLFxuICAgIG1hdGNoOiBwYXR0ZXJucyQxLnRocmVlRGlnaXRzLFxuICAgIHBhcnNlOiBwYXJzZURlY2ltYWwkMVxuICB9LFxuXG4gIC8vIEFNLCBQTVxuICAnQSc6IHtcbiAgICB1bml0OiAndGltZU9mRGF5JyxcbiAgICBtYXRjaDogZnVuY3Rpb24gKHN0cmluZywgb3B0aW9ucykge1xuICAgICAgcmV0dXJuIG9wdGlvbnMubG9jYWxlLm1hdGNoLnRpbWVzT2ZEYXkoc3RyaW5nLCB7dHlwZTogJ3Nob3J0J30pXG4gICAgfSxcbiAgICBwYXJzZTogZnVuY3Rpb24gKG1hdGNoUmVzdWx0LCBvcHRpb25zKSB7XG4gICAgICByZXR1cm4gb3B0aW9ucy5sb2NhbGUubWF0Y2gudGltZU9mRGF5KG1hdGNoUmVzdWx0LCB7dHlwZTogJ3Nob3J0J30pXG4gICAgfVxuICB9LFxuXG4gIC8vIGEubS4sIHAubS5cbiAgJ2FhJzoge1xuICAgIHVuaXQ6ICd0aW1lT2ZEYXknLFxuICAgIG1hdGNoOiBmdW5jdGlvbiAoc3RyaW5nLCBvcHRpb25zKSB7XG4gICAgICByZXR1cm4gb3B0aW9ucy5sb2NhbGUubWF0Y2gudGltZXNPZkRheShzdHJpbmcsIHt0eXBlOiAnbG9uZyd9KSB8fFxuICAgICAgICBvcHRpb25zLmxvY2FsZS5tYXRjaC50aW1lc09mRGF5KHN0cmluZywge3R5cGU6ICdzaG9ydCd9KVxuICAgIH0sXG4gICAgcGFyc2U6IGZ1bmN0aW9uIChtYXRjaFJlc3VsdCwgb3B0aW9ucykge1xuICAgICAgdmFyIHBhcnNlUmVzdWx0ID0gb3B0aW9ucy5sb2NhbGUubWF0Y2gudGltZU9mRGF5KG1hdGNoUmVzdWx0LCB7dHlwZTogJ2xvbmcnfSk7XG5cbiAgICAgIGlmIChwYXJzZVJlc3VsdCA9PSBudWxsKSB7XG4gICAgICAgIHBhcnNlUmVzdWx0ID0gb3B0aW9ucy5sb2NhbGUubWF0Y2gudGltZU9mRGF5KG1hdGNoUmVzdWx0LCB7dHlwZTogJ3Nob3J0J30pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcGFyc2VSZXN1bHRcbiAgICB9XG4gIH0sXG5cbiAgLy8gSG91cjogMCwgMSwgLi4uIDIzXG4gICdIJzoge1xuICAgIHVuaXQ6ICdob3VycycsXG4gICAgbWF0Y2g6IHBhdHRlcm5zJDEuSCxcbiAgICBwYXJzZTogcGFyc2VEZWNpbWFsJDFcbiAgfSxcblxuICAvLyBIb3VyOiAwMCwgMDEsIC4uLiwgMjNcbiAgJ0hIJzoge1xuICAgIHVuaXQ6ICdob3VycycsXG4gICAgbWF0Y2g6IHBhdHRlcm5zJDEudHdvRGlnaXRzLFxuICAgIHBhcnNlOiBwYXJzZURlY2ltYWwkMVxuICB9LFxuXG4gIC8vIEhvdXI6IDEsIDIsIC4uLiwgMTJcbiAgJ2gnOiB7XG4gICAgdW5pdDogJ3RpbWVPZkRheUhvdXJzJyxcbiAgICBtYXRjaDogcGF0dGVybnMkMS5NLFxuICAgIHBhcnNlOiBwYXJzZURlY2ltYWwkMVxuICB9LFxuXG4gIC8vIEhvdXI6IDAxLCAwMiwgLi4uLCAxMlxuICAnaGgnOiB7XG4gICAgdW5pdDogJ3RpbWVPZkRheUhvdXJzJyxcbiAgICBtYXRjaDogcGF0dGVybnMkMS50d29EaWdpdHMsXG4gICAgcGFyc2U6IHBhcnNlRGVjaW1hbCQxXG4gIH0sXG5cbiAgLy8gTWludXRlOiAwLCAxLCAuLi4sIDU5XG4gICdtJzoge1xuICAgIHVuaXQ6ICdtaW51dGVzJyxcbiAgICBtYXRjaDogcGF0dGVybnMkMS5tLFxuICAgIHBhcnNlOiBwYXJzZURlY2ltYWwkMVxuICB9LFxuXG4gIC8vIE1pbnV0ZTogMDAsIDAxLCAuLi4sIDU5XG4gICdtbSc6IHtcbiAgICB1bml0OiAnbWludXRlcycsXG4gICAgbWF0Y2g6IHBhdHRlcm5zJDEudHdvRGlnaXRzLFxuICAgIHBhcnNlOiBwYXJzZURlY2ltYWwkMVxuICB9LFxuXG4gIC8vIFNlY29uZDogMCwgMSwgLi4uLCA1OVxuICAncyc6IHtcbiAgICB1bml0OiAnc2Vjb25kcycsXG4gICAgbWF0Y2g6IHBhdHRlcm5zJDEubSxcbiAgICBwYXJzZTogcGFyc2VEZWNpbWFsJDFcbiAgfSxcblxuICAvLyBTZWNvbmQ6IDAwLCAwMSwgLi4uLCA1OVxuICAnc3MnOiB7XG4gICAgdW5pdDogJ3NlY29uZHMnLFxuICAgIG1hdGNoOiBwYXR0ZXJucyQxLnR3b0RpZ2l0cyxcbiAgICBwYXJzZTogcGFyc2VEZWNpbWFsJDFcbiAgfSxcblxuICAvLyAxLzEwIG9mIHNlY29uZDogMCwgMSwgLi4uLCA5XG4gICdTJzoge1xuICAgIHVuaXQ6ICdtaWxsaXNlY29uZHMnLFxuICAgIG1hdGNoOiBwYXR0ZXJucyQxLnNpbmdsZURpZ2l0LFxuICAgIHBhcnNlOiBmdW5jdGlvbiAobWF0Y2hSZXN1bHQpIHtcbiAgICAgIHJldHVybiBwYXJzZURlY2ltYWwkMShtYXRjaFJlc3VsdCkgKiAxMDBcbiAgICB9XG4gIH0sXG5cbiAgLy8gMS8xMDAgb2Ygc2Vjb25kOiAwMCwgMDEsIC4uLiwgOTlcbiAgJ1NTJzoge1xuICAgIHVuaXQ6ICdtaWxsaXNlY29uZHMnLFxuICAgIG1hdGNoOiBwYXR0ZXJucyQxLnR3b0RpZ2l0cyxcbiAgICBwYXJzZTogZnVuY3Rpb24gKG1hdGNoUmVzdWx0KSB7XG4gICAgICByZXR1cm4gcGFyc2VEZWNpbWFsJDEobWF0Y2hSZXN1bHQpICogMTBcbiAgICB9XG4gIH0sXG5cbiAgLy8gTWlsbGlzZWNvbmQ6IDAwMCwgMDAxLCAuLi4sIDk5OVxuICAnU1NTJzoge1xuICAgIHVuaXQ6ICdtaWxsaXNlY29uZHMnLFxuICAgIG1hdGNoOiBwYXR0ZXJucyQxLnRocmVlRGlnaXRzLFxuICAgIHBhcnNlOiBwYXJzZURlY2ltYWwkMVxuICB9LFxuXG4gIC8vIFRpbWV6b25lOiAtMDE6MDAsICswMDowMCwgLi4uICsxMjowMFxuICAnWic6IHtcbiAgICB1bml0OiAndGltZXpvbmUnLFxuICAgIG1hdGNoOiBwYXR0ZXJucyQxLlosXG4gICAgcGFyc2U6IGZ1bmN0aW9uIChtYXRjaFJlc3VsdCkge1xuICAgICAgdmFyIHNpZ24gPSBtYXRjaFJlc3VsdFsxXTtcbiAgICAgIHZhciBob3VycyA9IHBhcnNlSW50KG1hdGNoUmVzdWx0WzJdLCAxMCk7XG4gICAgICB2YXIgbWludXRlcyA9IHBhcnNlSW50KG1hdGNoUmVzdWx0WzNdLCAxMCk7XG4gICAgICB2YXIgYWJzb2x1dGVPZmZzZXQgPSBob3VycyAqIDYwICsgbWludXRlcztcbiAgICAgIHJldHVybiAoc2lnbiA9PT0gJysnKSA/IGFic29sdXRlT2Zmc2V0IDogLWFic29sdXRlT2Zmc2V0XG4gICAgfVxuICB9LFxuXG4gIC8vIFRpbWV6b25lOiAtMDEwMCwgKzAwMDAsIC4uLiArMTIwMFxuICAnWlonOiB7XG4gICAgdW5pdDogJ3RpbWV6b25lJyxcbiAgICBtYXRjaDogcGF0dGVybnMkMS5aWixcbiAgICBwYXJzZTogZnVuY3Rpb24gKG1hdGNoUmVzdWx0KSB7XG4gICAgICB2YXIgc2lnbiA9IG1hdGNoUmVzdWx0WzFdO1xuICAgICAgdmFyIGhvdXJzID0gcGFyc2VJbnQobWF0Y2hSZXN1bHRbMl0sIDEwKTtcbiAgICAgIHZhciBtaW51dGVzID0gcGFyc2VJbnQobWF0Y2hSZXN1bHRbM10sIDEwKTtcbiAgICAgIHZhciBhYnNvbHV0ZU9mZnNldCA9IGhvdXJzICogNjAgKyBtaW51dGVzO1xuICAgICAgcmV0dXJuIChzaWduID09PSAnKycpID8gYWJzb2x1dGVPZmZzZXQgOiAtYWJzb2x1dGVPZmZzZXRcbiAgICB9XG4gIH0sXG5cbiAgLy8gU2Vjb25kcyB0aW1lc3RhbXA6IDUxMjk2OTUyMFxuICAnWCc6IHtcbiAgICB1bml0OiAndGltZXN0YW1wJyxcbiAgICBtYXRjaDogcGF0dGVybnMkMS5hbnlEaWdpdHMsXG4gICAgcGFyc2U6IGZ1bmN0aW9uIChtYXRjaFJlc3VsdCkge1xuICAgICAgcmV0dXJuIHBhcnNlRGVjaW1hbCQxKG1hdGNoUmVzdWx0KSAqIDEwMDBcbiAgICB9XG4gIH0sXG5cbiAgLy8gTWlsbGlzZWNvbmRzIHRpbWVzdGFtcDogNTEyOTY5NTIwOTAwXG4gICd4Jzoge1xuICAgIHVuaXQ6ICd0aW1lc3RhbXAnLFxuICAgIG1hdGNoOiBwYXR0ZXJucyQxLmFueURpZ2l0cyxcbiAgICBwYXJzZTogcGFyc2VEZWNpbWFsJDFcbiAgfVxufTtcblxucGFyc2Vyc1snYSddID0gcGFyc2Vyc1snQSddO1xuXG4vLyBUaGlzIGZ1bmN0aW9uIHdpbGwgYmUgYSBwYXJ0IG9mIHB1YmxpYyBBUEkgd2hlbiBVVEMgZnVuY3Rpb24gd2lsbCBiZSBpbXBsZW1lbnRlZC5cbi8vIFNlZSBpc3N1ZTogaHR0cHM6Ly9naXRodWIuY29tL2RhdGUtZm5zL2RhdGUtZm5zL2lzc3Vlcy8zNzZcbmZ1bmN0aW9uIHNldFVUQ0RheSAoZGlydHlEYXRlLCBkaXJ0eURheSwgZGlydHlPcHRpb25zKSB7XG4gIHZhciBvcHRpb25zID0gZGlydHlPcHRpb25zIHx8IHt9O1xuICB2YXIgbG9jYWxlID0gb3B0aW9ucy5sb2NhbGU7XG4gIHZhciBsb2NhbGVXZWVrU3RhcnRzT24gPSBsb2NhbGUgJiYgbG9jYWxlLm9wdGlvbnMgJiYgbG9jYWxlLm9wdGlvbnMud2Vla1N0YXJ0c09uO1xuICB2YXIgZGVmYXVsdFdlZWtTdGFydHNPbiA9IGxvY2FsZVdlZWtTdGFydHNPbiA9PT0gdW5kZWZpbmVkID8gMCA6IE51bWJlcihsb2NhbGVXZWVrU3RhcnRzT24pO1xuICB2YXIgd2Vla1N0YXJ0c09uID0gb3B0aW9ucy53ZWVrU3RhcnRzT24gPT09IHVuZGVmaW5lZCA/IGRlZmF1bHRXZWVrU3RhcnRzT24gOiBOdW1iZXIob3B0aW9ucy53ZWVrU3RhcnRzT24pO1xuXG4gIC8vIFRlc3QgaWYgd2Vla1N0YXJ0c09uIGlzIGJldHdlZW4gMCBhbmQgNiBfYW5kXyBpcyBub3QgTmFOXG4gIGlmICghKHdlZWtTdGFydHNPbiA+PSAwICYmIHdlZWtTdGFydHNPbiA8PSA2KSkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCd3ZWVrU3RhcnRzT24gbXVzdCBiZSBiZXR3ZWVuIDAgYW5kIDYgaW5jbHVzaXZlbHknKVxuICB9XG5cbiAgdmFyIGRhdGUgPSB0b0RhdGUoZGlydHlEYXRlLCBkaXJ0eU9wdGlvbnMpO1xuICB2YXIgZGF5ID0gTnVtYmVyKGRpcnR5RGF5KTtcblxuICB2YXIgY3VycmVudERheSA9IGRhdGUuZ2V0VVRDRGF5KCk7XG5cbiAgdmFyIHJlbWFpbmRlciA9IGRheSAlIDc7XG4gIHZhciBkYXlJbmRleCA9IChyZW1haW5kZXIgKyA3KSAlIDc7XG5cbiAgdmFyIGRpZmYgPSAoZGF5SW5kZXggPCB3ZWVrU3RhcnRzT24gPyA3IDogMCkgKyBkYXkgLSBjdXJyZW50RGF5O1xuXG4gIGRhdGUuc2V0VVRDRGF0ZShkYXRlLmdldFVUQ0RhdGUoKSArIGRpZmYpO1xuICByZXR1cm4gZGF0ZVxufVxuXG4vLyBUaGlzIGZ1bmN0aW9uIHdpbGwgYmUgYSBwYXJ0IG9mIHB1YmxpYyBBUEkgd2hlbiBVVEMgZnVuY3Rpb24gd2lsbCBiZSBpbXBsZW1lbnRlZC5cbi8vIFNlZSBpc3N1ZTogaHR0cHM6Ly9naXRodWIuY29tL2RhdGUtZm5zL2RhdGUtZm5zL2lzc3Vlcy8zNzZcbmZ1bmN0aW9uIHNldFVUQ0lTT0RheSAoZGlydHlEYXRlLCBkaXJ0eURheSwgZGlydHlPcHRpb25zKSB7XG4gIHZhciBkYXkgPSBOdW1iZXIoZGlydHlEYXkpO1xuXG4gIGlmIChkYXkgJSA3ID09PSAwKSB7XG4gICAgZGF5ID0gZGF5IC0gNztcbiAgfVxuXG4gIHZhciB3ZWVrU3RhcnRzT24gPSAxO1xuICB2YXIgZGF0ZSA9IHRvRGF0ZShkaXJ0eURhdGUsIGRpcnR5T3B0aW9ucyk7XG4gIHZhciBjdXJyZW50RGF5ID0gZGF0ZS5nZXRVVENEYXkoKTtcblxuICB2YXIgcmVtYWluZGVyID0gZGF5ICUgNztcbiAgdmFyIGRheUluZGV4ID0gKHJlbWFpbmRlciArIDcpICUgNztcblxuICB2YXIgZGlmZiA9IChkYXlJbmRleCA8IHdlZWtTdGFydHNPbiA/IDcgOiAwKSArIGRheSAtIGN1cnJlbnREYXk7XG5cbiAgZGF0ZS5zZXRVVENEYXRlKGRhdGUuZ2V0VVRDRGF0ZSgpICsgZGlmZik7XG4gIHJldHVybiBkYXRlXG59XG5cbi8vIFRoaXMgZnVuY3Rpb24gd2lsbCBiZSBhIHBhcnQgb2YgcHVibGljIEFQSSB3aGVuIFVUQyBmdW5jdGlvbiB3aWxsIGJlIGltcGxlbWVudGVkLlxuLy8gU2VlIGlzc3VlOiBodHRwczovL2dpdGh1Yi5jb20vZGF0ZS1mbnMvZGF0ZS1mbnMvaXNzdWVzLzM3NlxuZnVuY3Rpb24gc2V0VVRDSVNPV2VlayAoZGlydHlEYXRlLCBkaXJ0eUlTT1dlZWssIGRpcnR5T3B0aW9ucykge1xuICB2YXIgZGF0ZSA9IHRvRGF0ZShkaXJ0eURhdGUsIGRpcnR5T3B0aW9ucyk7XG4gIHZhciBpc29XZWVrID0gTnVtYmVyKGRpcnR5SVNPV2Vlayk7XG4gIHZhciBkaWZmID0gZ2V0VVRDSVNPV2VlayhkYXRlLCBkaXJ0eU9wdGlvbnMpIC0gaXNvV2VlaztcbiAgZGF0ZS5zZXRVVENEYXRlKGRhdGUuZ2V0VVRDRGF0ZSgpIC0gZGlmZiAqIDcpO1xuICByZXR1cm4gZGF0ZVxufVxuXG52YXIgTUlMTElTRUNPTkRTX0lOX0RBWSQzID0gODY0MDAwMDA7XG5cbi8vIFRoaXMgZnVuY3Rpb24gd2lsbCBiZSBhIHBhcnQgb2YgcHVibGljIEFQSSB3aGVuIFVUQyBmdW5jdGlvbiB3aWxsIGJlIGltcGxlbWVudGVkLlxuLy8gU2VlIGlzc3VlOiBodHRwczovL2dpdGh1Yi5jb20vZGF0ZS1mbnMvZGF0ZS1mbnMvaXNzdWVzLzM3NlxuZnVuY3Rpb24gc2V0VVRDSVNPV2Vla1llYXIgKGRpcnR5RGF0ZSwgZGlydHlJU09ZZWFyLCBkaXJ0eU9wdGlvbnMpIHtcbiAgdmFyIGRhdGUgPSB0b0RhdGUoZGlydHlEYXRlLCBkaXJ0eU9wdGlvbnMpO1xuICB2YXIgaXNvWWVhciA9IE51bWJlcihkaXJ0eUlTT1llYXIpO1xuICB2YXIgZGF0ZVN0YXJ0T2ZZZWFyID0gc3RhcnRPZlVUQ0lTT1dlZWtZZWFyKGRhdGUsIGRpcnR5T3B0aW9ucyk7XG4gIHZhciBkaWZmID0gTWF0aC5mbG9vcigoZGF0ZS5nZXRUaW1lKCkgLSBkYXRlU3RhcnRPZlllYXIuZ2V0VGltZSgpKSAvIE1JTExJU0VDT05EU19JTl9EQVkkMyk7XG4gIHZhciBmb3VydGhPZkphbnVhcnkgPSBuZXcgRGF0ZSgwKTtcbiAgZm91cnRoT2ZKYW51YXJ5LnNldFVUQ0Z1bGxZZWFyKGlzb1llYXIsIDAsIDQpO1xuICBmb3VydGhPZkphbnVhcnkuc2V0VVRDSG91cnMoMCwgMCwgMCwgMCk7XG4gIGRhdGUgPSBzdGFydE9mVVRDSVNPV2Vla1llYXIoZm91cnRoT2ZKYW51YXJ5LCBkaXJ0eU9wdGlvbnMpO1xuICBkYXRlLnNldFVUQ0RhdGUoZGF0ZS5nZXRVVENEYXRlKCkgKyBkaWZmKTtcbiAgcmV0dXJuIGRhdGVcbn1cblxudmFyIE1JTExJU0VDT05EU19JTl9NSU5VVEUkNyA9IDYwMDAwO1xuXG5mdW5jdGlvbiBzZXRUaW1lT2ZEYXkgKGhvdXJzLCB0aW1lT2ZEYXkpIHtcbiAgdmFyIGlzQU0gPSB0aW1lT2ZEYXkgPT09IDA7XG5cbiAgaWYgKGlzQU0pIHtcbiAgICBpZiAoaG91cnMgPT09IDEyKSB7XG4gICAgICByZXR1cm4gMFxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAoaG91cnMgIT09IDEyKSB7XG4gICAgICByZXR1cm4gMTIgKyBob3Vyc1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBob3Vyc1xufVxuXG52YXIgdW5pdHMgPSB7XG4gIHR3b0RpZ2l0WWVhcjoge1xuICAgIHByaW9yaXR5OiAxMCxcbiAgICBzZXQ6IGZ1bmN0aW9uIChkYXRlVmFsdWVzLCB2YWx1ZSkge1xuICAgICAgdmFyIGNlbnR1cnkgPSBNYXRoLmZsb29yKGRhdGVWYWx1ZXMuZGF0ZS5nZXRVVENGdWxsWWVhcigpIC8gMTAwKTtcbiAgICAgIHZhciB5ZWFyID0gY2VudHVyeSAqIDEwMCArIHZhbHVlO1xuICAgICAgZGF0ZVZhbHVlcy5kYXRlLnNldFVUQ0Z1bGxZZWFyKHllYXIsIDAsIDEpO1xuICAgICAgZGF0ZVZhbHVlcy5kYXRlLnNldFVUQ0hvdXJzKDAsIDAsIDAsIDApO1xuICAgICAgcmV0dXJuIGRhdGVWYWx1ZXNcbiAgICB9XG4gIH0sXG5cbiAgeWVhcjoge1xuICAgIHByaW9yaXR5OiAxMCxcbiAgICBzZXQ6IGZ1bmN0aW9uIChkYXRlVmFsdWVzLCB2YWx1ZSkge1xuICAgICAgZGF0ZVZhbHVlcy5kYXRlLnNldFVUQ0Z1bGxZZWFyKHZhbHVlLCAwLCAxKTtcbiAgICAgIGRhdGVWYWx1ZXMuZGF0ZS5zZXRVVENIb3VycygwLCAwLCAwLCAwKTtcbiAgICAgIHJldHVybiBkYXRlVmFsdWVzXG4gICAgfVxuICB9LFxuXG4gIGlzb1llYXI6IHtcbiAgICBwcmlvcml0eTogMTAsXG4gICAgc2V0OiBmdW5jdGlvbiAoZGF0ZVZhbHVlcywgdmFsdWUsIG9wdGlvbnMpIHtcbiAgICAgIGRhdGVWYWx1ZXMuZGF0ZSA9IHN0YXJ0T2ZVVENJU09XZWVrWWVhcihzZXRVVENJU09XZWVrWWVhcihkYXRlVmFsdWVzLmRhdGUsIHZhbHVlLCBvcHRpb25zKSwgb3B0aW9ucyk7XG4gICAgICByZXR1cm4gZGF0ZVZhbHVlc1xuICAgIH1cbiAgfSxcblxuICBxdWFydGVyOiB7XG4gICAgcHJpb3JpdHk6IDIwLFxuICAgIHNldDogZnVuY3Rpb24gKGRhdGVWYWx1ZXMsIHZhbHVlKSB7XG4gICAgICBkYXRlVmFsdWVzLmRhdGUuc2V0VVRDTW9udGgoKHZhbHVlIC0gMSkgKiAzLCAxKTtcbiAgICAgIGRhdGVWYWx1ZXMuZGF0ZS5zZXRVVENIb3VycygwLCAwLCAwLCAwKTtcbiAgICAgIHJldHVybiBkYXRlVmFsdWVzXG4gICAgfVxuICB9LFxuXG4gIG1vbnRoOiB7XG4gICAgcHJpb3JpdHk6IDMwLFxuICAgIHNldDogZnVuY3Rpb24gKGRhdGVWYWx1ZXMsIHZhbHVlKSB7XG4gICAgICBkYXRlVmFsdWVzLmRhdGUuc2V0VVRDTW9udGgodmFsdWUsIDEpO1xuICAgICAgZGF0ZVZhbHVlcy5kYXRlLnNldFVUQ0hvdXJzKDAsIDAsIDAsIDApO1xuICAgICAgcmV0dXJuIGRhdGVWYWx1ZXNcbiAgICB9XG4gIH0sXG5cbiAgaXNvV2Vlazoge1xuICAgIHByaW9yaXR5OiA0MCxcbiAgICBzZXQ6IGZ1bmN0aW9uIChkYXRlVmFsdWVzLCB2YWx1ZSwgb3B0aW9ucykge1xuICAgICAgZGF0ZVZhbHVlcy5kYXRlID0gc3RhcnRPZlVUQ0lTT1dlZWsoc2V0VVRDSVNPV2VlayhkYXRlVmFsdWVzLmRhdGUsIHZhbHVlLCBvcHRpb25zKSwgb3B0aW9ucyk7XG4gICAgICByZXR1cm4gZGF0ZVZhbHVlc1xuICAgIH1cbiAgfSxcblxuICBkYXlPZldlZWs6IHtcbiAgICBwcmlvcml0eTogNTAsXG4gICAgc2V0OiBmdW5jdGlvbiAoZGF0ZVZhbHVlcywgdmFsdWUsIG9wdGlvbnMpIHtcbiAgICAgIGRhdGVWYWx1ZXMuZGF0ZSA9IHNldFVUQ0RheShkYXRlVmFsdWVzLmRhdGUsIHZhbHVlLCBvcHRpb25zKTtcbiAgICAgIGRhdGVWYWx1ZXMuZGF0ZS5zZXRVVENIb3VycygwLCAwLCAwLCAwKTtcbiAgICAgIHJldHVybiBkYXRlVmFsdWVzXG4gICAgfVxuICB9LFxuXG4gIGRheU9mSVNPV2Vlazoge1xuICAgIHByaW9yaXR5OiA1MCxcbiAgICBzZXQ6IGZ1bmN0aW9uIChkYXRlVmFsdWVzLCB2YWx1ZSwgb3B0aW9ucykge1xuICAgICAgZGF0ZVZhbHVlcy5kYXRlID0gc2V0VVRDSVNPRGF5KGRhdGVWYWx1ZXMuZGF0ZSwgdmFsdWUsIG9wdGlvbnMpO1xuICAgICAgZGF0ZVZhbHVlcy5kYXRlLnNldFVUQ0hvdXJzKDAsIDAsIDAsIDApO1xuICAgICAgcmV0dXJuIGRhdGVWYWx1ZXNcbiAgICB9XG4gIH0sXG5cbiAgZGF5T2ZNb250aDoge1xuICAgIHByaW9yaXR5OiA1MCxcbiAgICBzZXQ6IGZ1bmN0aW9uIChkYXRlVmFsdWVzLCB2YWx1ZSkge1xuICAgICAgZGF0ZVZhbHVlcy5kYXRlLnNldFVUQ0RhdGUodmFsdWUpO1xuICAgICAgZGF0ZVZhbHVlcy5kYXRlLnNldFVUQ0hvdXJzKDAsIDAsIDAsIDApO1xuICAgICAgcmV0dXJuIGRhdGVWYWx1ZXNcbiAgICB9XG4gIH0sXG5cbiAgZGF5T2ZZZWFyOiB7XG4gICAgcHJpb3JpdHk6IDUwLFxuICAgIHNldDogZnVuY3Rpb24gKGRhdGVWYWx1ZXMsIHZhbHVlKSB7XG4gICAgICBkYXRlVmFsdWVzLmRhdGUuc2V0VVRDTW9udGgoMCwgdmFsdWUpO1xuICAgICAgZGF0ZVZhbHVlcy5kYXRlLnNldFVUQ0hvdXJzKDAsIDAsIDAsIDApO1xuICAgICAgcmV0dXJuIGRhdGVWYWx1ZXNcbiAgICB9XG4gIH0sXG5cbiAgdGltZU9mRGF5OiB7XG4gICAgcHJpb3JpdHk6IDYwLFxuICAgIHNldDogZnVuY3Rpb24gKGRhdGVWYWx1ZXMsIHZhbHVlLCBvcHRpb25zKSB7XG4gICAgICBkYXRlVmFsdWVzLnRpbWVPZkRheSA9IHZhbHVlO1xuICAgICAgcmV0dXJuIGRhdGVWYWx1ZXNcbiAgICB9XG4gIH0sXG5cbiAgaG91cnM6IHtcbiAgICBwcmlvcml0eTogNzAsXG4gICAgc2V0OiBmdW5jdGlvbiAoZGF0ZVZhbHVlcywgdmFsdWUsIG9wdGlvbnMpIHtcbiAgICAgIGRhdGVWYWx1ZXMuZGF0ZS5zZXRVVENIb3Vycyh2YWx1ZSwgMCwgMCwgMCk7XG4gICAgICByZXR1cm4gZGF0ZVZhbHVlc1xuICAgIH1cbiAgfSxcblxuICB0aW1lT2ZEYXlIb3Vyczoge1xuICAgIHByaW9yaXR5OiA3MCxcbiAgICBzZXQ6IGZ1bmN0aW9uIChkYXRlVmFsdWVzLCB2YWx1ZSwgb3B0aW9ucykge1xuICAgICAgdmFyIHRpbWVPZkRheSA9IGRhdGVWYWx1ZXMudGltZU9mRGF5O1xuICAgICAgaWYgKHRpbWVPZkRheSAhPSBudWxsKSB7XG4gICAgICAgIHZhbHVlID0gc2V0VGltZU9mRGF5KHZhbHVlLCB0aW1lT2ZEYXkpO1xuICAgICAgfVxuICAgICAgZGF0ZVZhbHVlcy5kYXRlLnNldFVUQ0hvdXJzKHZhbHVlLCAwLCAwLCAwKTtcbiAgICAgIHJldHVybiBkYXRlVmFsdWVzXG4gICAgfVxuICB9LFxuXG4gIG1pbnV0ZXM6IHtcbiAgICBwcmlvcml0eTogODAsXG4gICAgc2V0OiBmdW5jdGlvbiAoZGF0ZVZhbHVlcywgdmFsdWUpIHtcbiAgICAgIGRhdGVWYWx1ZXMuZGF0ZS5zZXRVVENNaW51dGVzKHZhbHVlLCAwLCAwKTtcbiAgICAgIHJldHVybiBkYXRlVmFsdWVzXG4gICAgfVxuICB9LFxuXG4gIHNlY29uZHM6IHtcbiAgICBwcmlvcml0eTogOTAsXG4gICAgc2V0OiBmdW5jdGlvbiAoZGF0ZVZhbHVlcywgdmFsdWUpIHtcbiAgICAgIGRhdGVWYWx1ZXMuZGF0ZS5zZXRVVENTZWNvbmRzKHZhbHVlLCAwKTtcbiAgICAgIHJldHVybiBkYXRlVmFsdWVzXG4gICAgfVxuICB9LFxuXG4gIG1pbGxpc2Vjb25kczoge1xuICAgIHByaW9yaXR5OiAxMDAsXG4gICAgc2V0OiBmdW5jdGlvbiAoZGF0ZVZhbHVlcywgdmFsdWUpIHtcbiAgICAgIGRhdGVWYWx1ZXMuZGF0ZS5zZXRVVENNaWxsaXNlY29uZHModmFsdWUpO1xuICAgICAgcmV0dXJuIGRhdGVWYWx1ZXNcbiAgICB9XG4gIH0sXG5cbiAgdGltZXpvbmU6IHtcbiAgICBwcmlvcml0eTogMTEwLFxuICAgIHNldDogZnVuY3Rpb24gKGRhdGVWYWx1ZXMsIHZhbHVlKSB7XG4gICAgICBkYXRlVmFsdWVzLmRhdGUgPSBuZXcgRGF0ZShkYXRlVmFsdWVzLmRhdGUuZ2V0VGltZSgpIC0gdmFsdWUgKiBNSUxMSVNFQ09ORFNfSU5fTUlOVVRFJDcpO1xuICAgICAgcmV0dXJuIGRhdGVWYWx1ZXNcbiAgICB9XG4gIH0sXG5cbiAgdGltZXN0YW1wOiB7XG4gICAgcHJpb3JpdHk6IDEyMCxcbiAgICBzZXQ6IGZ1bmN0aW9uIChkYXRlVmFsdWVzLCB2YWx1ZSkge1xuICAgICAgZGF0ZVZhbHVlcy5kYXRlID0gbmV3IERhdGUodmFsdWUpO1xuICAgICAgcmV0dXJuIGRhdGVWYWx1ZXNcbiAgICB9XG4gIH1cbn07XG5cbnZhciBUSU1FWk9ORV9VTklUX1BSSU9SSVRZID0gMTEwO1xudmFyIE1JTExJU0VDT05EU19JTl9NSU5VVEUkNiA9IDYwMDAwO1xuXG52YXIgbG9uZ0Zvcm1hdHRpbmdUb2tlbnNSZWdFeHAkMSA9IC8oXFxbW15bXSpdKXwoXFxcXCk/KExUU3xMVHxMTExMfExMTHxMTHxMfGxsbGx8bGxsfGxsfGwpL2c7XG52YXIgZGVmYXVsdFBhcnNpbmdUb2tlbnNSZWdFeHAgPSAvKFxcW1teW10qXSl8KFxcXFwpPyh4fHNzfHN8bW18bXxoaHxofGRvfGRkZGR8ZGRkfGRkfGR8YWF8YXxaWnxafFlZWVl8WVl8WHxXb3xXV3xXfFNTU3xTU3xTfFFvfFF8TW98TU1NTXxNTU18TU18TXxISHxIfEdHR0d8R0d8RXxEb3xERERvfERERER8REREfEREfER8QXwuKS9nO1xuXG4vKipcbiAqIEBuYW1lIHBhcnNlXG4gKiBAY2F0ZWdvcnkgQ29tbW9uIEhlbHBlcnNcbiAqIEBzdW1tYXJ5IFBhcnNlIHRoZSBkYXRlLlxuICpcbiAqIEBkZXNjcmlwdGlvblxuICogUmV0dXJuIHRoZSBkYXRlIHBhcnNlZCBmcm9tIHN0cmluZyB1c2luZyB0aGUgZ2l2ZW4gZm9ybWF0LlxuICpcbiAqIEFjY2VwdGVkIGZvcm1hdCB0b2tlbnM6XG4gKiB8IFVuaXQgICAgICAgICAgICAgICAgICAgIHwgUHJpb3JpdHkgfCBUb2tlbiB8IElucHV0IGV4YW1wbGVzICAgICAgICAgICAgICAgICAgIHxcbiAqIHwtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tfC0tLS0tLS0tLS18LS0tLS0tLXwtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tfFxuICogfCBZZWFyICAgICAgICAgICAgICAgICAgICB8IDEwICAgICAgIHwgWVkgICAgfCAwMCwgMDEsIC4uLiwgOTkgICAgICAgICAgICAgICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgICAgICAgfCBZWVlZICB8IDE5MDAsIDE5MDEsIC4uLiwgMjA5OSAgICAgICAgICAgIHxcbiAqIHwgSVNPIHdlZWstbnVtYmVyaW5nIHllYXIgfCAxMCAgICAgICB8IEdHICAgIHwgMDAsIDAxLCAuLi4sIDk5ICAgICAgICAgICAgICAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICAgICAgIHwgR0dHRyAgfCAxOTAwLCAxOTAxLCAuLi4sIDIwOTkgICAgICAgICAgICB8XG4gKiB8IFF1YXJ0ZXIgICAgICAgICAgICAgICAgIHwgMjAgICAgICAgfCBRICAgICB8IDEsIDIsIDMsIDQgICAgICAgICAgICAgICAgICAgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgICAgICB8IFFvICAgIHwgMXN0LCAybmQsIDNyZCwgNHRoICAgICAgICAgICAgICAgfFxuICogfCBNb250aCAgICAgICAgICAgICAgICAgICB8IDMwICAgICAgIHwgTSAgICAgfCAxLCAyLCAuLi4sIDEyICAgICAgICAgICAgICAgICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgICAgICAgfCBNbyAgICB8IDFzdCwgMm5kLCAuLi4sIDEydGggICAgICAgICAgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgICAgICB8IE1NICAgIHwgMDEsIDAyLCAuLi4sIDEyICAgICAgICAgICAgICAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICAgICAgIHwgTU1NICAgfCBKYW4sIEZlYiwgLi4uLCBEZWMgICAgICAgICAgICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgICAgICAgfCBNTU1NICB8IEphbnVhcnksIEZlYnJ1YXJ5LCAuLi4sIERlY2VtYmVyIHxcbiAqIHwgSVNPIHdlZWsgICAgICAgICAgICAgICAgfCA0MCAgICAgICB8IFcgICAgIHwgMSwgMiwgLi4uLCA1MyAgICAgICAgICAgICAgICAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICAgICAgIHwgV28gICAgfCAxc3QsIDJuZCwgLi4uLCA1M3JkICAgICAgICAgICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgICAgICAgfCBXVyAgICB8IDAxLCAwMiwgLi4uLCA1MyAgICAgICAgICAgICAgICAgIHxcbiAqIHwgRGF5IG9mIHdlZWsgICAgICAgICAgICAgfCA1MCAgICAgICB8IGQgICAgIHwgMCwgMSwgLi4uLCA2ICAgICAgICAgICAgICAgICAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICAgICAgIHwgZG8gICAgfCAwdGgsIDFzdCwgLi4uLCA2dGggICAgICAgICAgICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgICAgICAgfCBkZCAgICB8IFN1LCBNbywgLi4uLCBTYSAgICAgICAgICAgICAgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgICAgICB8IGRkZCAgIHwgU3VuLCBNb24sIC4uLiwgU2F0ICAgICAgICAgICAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICAgICAgIHwgZGRkZCAgfCBTdW5kYXksIE1vbmRheSwgLi4uLCBTYXR1cmRheSAgICB8XG4gKiB8IERheSBvZiBJU08gd2VlayAgICAgICAgIHwgNTAgICAgICAgfCBFICAgICB8IDEsIDIsIC4uLiwgNyAgICAgICAgICAgICAgICAgICAgIHxcbiAqIHwgRGF5IG9mIG1vbnRoICAgICAgICAgICAgfCA1MCAgICAgICB8IEQgICAgIHwgMSwgMiwgLi4uLCAzMSAgICAgICAgICAgICAgICAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICAgICAgIHwgRG8gICAgfCAxc3QsIDJuZCwgLi4uLCAzMXN0ICAgICAgICAgICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgICAgICAgfCBERCAgICB8IDAxLCAwMiwgLi4uLCAzMSAgICAgICAgICAgICAgICAgIHxcbiAqIHwgRGF5IG9mIHllYXIgICAgICAgICAgICAgfCA1MCAgICAgICB8IERERCAgIHwgMSwgMiwgLi4uLCAzNjYgICAgICAgICAgICAgICAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICAgICAgIHwgREREbyAgfCAxc3QsIDJuZCwgLi4uLCAzNjZ0aCAgICAgICAgICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgICAgICAgfCBEREREICB8IDAwMSwgMDAyLCAuLi4sIDM2NiAgICAgICAgICAgICAgIHxcbiAqIHwgVGltZSBvZiBkYXkgICAgICAgICAgICAgfCA2MCAgICAgICB8IEEgICAgIHwgQU0sIFBNICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICAgICAgIHwgYSAgICAgfCBhbSwgcG0gICAgICAgICAgICAgICAgICAgICAgICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgICAgICAgfCBhYSAgICB8IGEubS4sIHAubS4gICAgICAgICAgICAgICAgICAgICAgIHxcbiAqIHwgSG91ciAgICAgICAgICAgICAgICAgICAgfCA3MCAgICAgICB8IEggICAgIHwgMCwgMSwgLi4uIDIzICAgICAgICAgICAgICAgICAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICAgICAgIHwgSEggICAgfCAwMCwgMDEsIC4uLiAyMyAgICAgICAgICAgICAgICAgICB8XG4gKiB8IFRpbWUgb2YgZGF5IGhvdXIgICAgICAgIHwgNzAgICAgICAgfCBoICAgICB8IDEsIDIsIC4uLiwgMTIgICAgICAgICAgICAgICAgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgICAgICB8IGhoICAgIHwgMDEsIDAyLCAuLi4sIDEyICAgICAgICAgICAgICAgICAgfFxuICogfCBNaW51dGUgICAgICAgICAgICAgICAgICB8IDgwICAgICAgIHwgbSAgICAgfCAwLCAxLCAuLi4sIDU5ICAgICAgICAgICAgICAgICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgICAgICAgfCBtbSAgICB8IDAwLCAwMSwgLi4uLCA1OSAgICAgICAgICAgICAgICAgIHxcbiAqIHwgU2Vjb25kICAgICAgICAgICAgICAgICAgfCA5MCAgICAgICB8IHMgICAgIHwgMCwgMSwgLi4uLCA1OSAgICAgICAgICAgICAgICAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICAgICAgIHwgc3MgICAgfCAwMCwgMDEsIC4uLiwgNTkgICAgICAgICAgICAgICAgICB8XG4gKiB8IDEvMTAgb2Ygc2Vjb25kICAgICAgICAgIHwgMTAwICAgICAgfCBTICAgICB8IDAsIDEsIC4uLiwgOSAgICAgICAgICAgICAgICAgICAgIHxcbiAqIHwgMS8xMDAgb2Ygc2Vjb25kICAgICAgICAgfCAxMDAgICAgICB8IFNTICAgIHwgMDAsIDAxLCAuLi4sIDk5ICAgICAgICAgICAgICAgICAgfFxuICogfCBNaWxsaXNlY29uZCAgICAgICAgICAgICB8IDEwMCAgICAgIHwgU1NTICAgfCAwMDAsIDAwMSwgLi4uLCA5OTkgICAgICAgICAgICAgICB8XG4gKiB8IFRpbWV6b25lICAgICAgICAgICAgICAgIHwgMTEwICAgICAgfCBaICAgICB8IC0wMTowMCwgKzAwOjAwLCAuLi4gKzEyOjAwICAgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgICAgICB8IFpaICAgIHwgLTAxMDAsICswMDAwLCAuLi4sICsxMjAwICAgICAgICAgfFxuICogfCBTZWNvbmRzIHRpbWVzdGFtcCAgICAgICB8IDEyMCAgICAgIHwgWCAgICAgfCA1MTI5Njk1MjAgICAgICAgICAgICAgICAgICAgICAgICB8XG4gKiB8IE1pbGxpc2Vjb25kcyB0aW1lc3RhbXAgIHwgMTIwICAgICAgfCB4ICAgICB8IDUxMjk2OTUyMDkwMCAgICAgICAgICAgICAgICAgICAgIHxcbiAqXG4gKiBWYWx1ZXMgd2lsbCBiZSBhc3NpZ25lZCB0byB0aGUgZGF0ZSBpbiB0aGUgYXNjZW5kaW5nIG9yZGVyIG9mIGl0cyB1bml0J3MgcHJpb3JpdHkuXG4gKiBVbml0cyBvZiBhbiBlcXVhbCBwcmlvcml0eSBvdmVyd3JpdGUgZWFjaCBvdGhlciBpbiB0aGUgb3JkZXIgb2YgYXBwZWFyYW5jZS5cbiAqXG4gKiBJZiBubyB2YWx1ZXMgb2YgaGlnaGVyIHByaW9yaXR5IGFyZSBwYXJzZWQgKGUuZy4gd2hlbiBwYXJzaW5nIHN0cmluZyAnSmFudWFyeSAxc3QnIHdpdGhvdXQgYSB5ZWFyKSxcbiAqIHRoZSB2YWx1ZXMgd2lsbCBiZSB0YWtlbiBmcm9tIDNyZCBhcmd1bWVudCBgYmFzZURhdGVgIHdoaWNoIHdvcmtzIGFzIGEgY29udGV4dCBvZiBwYXJzaW5nLlxuICpcbiAqIGBiYXNlRGF0ZWAgbXVzdCBiZSBwYXNzZWQgZm9yIGNvcnJlY3Qgd29yayBvZiB0aGUgZnVuY3Rpb24uXG4gKiBJZiB5b3UncmUgbm90IHN1cmUgd2hpY2ggYGJhc2VEYXRlYCB0byBzdXBwbHksIGNyZWF0ZSBhIG5ldyBpbnN0YW5jZSBvZiBEYXRlOlxuICogYHBhcnNlKCcwMi8xMS8yMDE0JywgJ01NL0REL1lZWVknLCBuZXcgRGF0ZSgpKWBcbiAqIEluIHRoaXMgY2FzZSBwYXJzaW5nIHdpbGwgYmUgZG9uZSBpbiB0aGUgY29udGV4dCBvZiB0aGUgY3VycmVudCBkYXRlLlxuICogSWYgYGJhc2VEYXRlYCBpcyBgSW52YWxpZCBEYXRlYCBvciBhIHZhbHVlIG5vdCBjb252ZXJ0aWJsZSB0byB2YWxpZCBgRGF0ZWAsXG4gKiB0aGVuIGBJbnZhbGlkIERhdGVgIHdpbGwgYmUgcmV0dXJuZWQuXG4gKlxuICogQWxzbywgYHBhcnNlYCB1bmZvbGRzIGxvbmcgZm9ybWF0cyBsaWtlIHRob3NlIGluIFtmb3JtYXRde0BsaW5rIGh0dHBzOi8vZGF0ZS1mbnMub3JnL2RvY3MvZm9ybWF0fTpcbiAqIHwgVG9rZW4gfCBJbnB1dCBleGFtcGxlcyAgICAgICAgICAgICAgICAgfFxuICogfC0tLS0tLS18LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS18XG4gKiB8IExUICAgIHwgMDU6MzAgYS5tLiAgICAgICAgICAgICAgICAgICAgIHxcbiAqIHwgTFRTICAgfCAwNTozMDoxNSBhLm0uICAgICAgICAgICAgICAgICAgfFxuICogfCBMICAgICB8IDA3LzAyLzE5OTUgICAgICAgICAgICAgICAgICAgICB8XG4gKiB8IGwgICAgIHwgNy8yLzE5OTUgICAgICAgICAgICAgICAgICAgICAgIHxcbiAqIHwgTEwgICAgfCBKdWx5IDIgMTk5NSAgICAgICAgICAgICAgICAgICAgfFxuICogfCBsbCAgICB8IEp1bCAyIDE5OTUgICAgICAgICAgICAgICAgICAgICB8XG4gKiB8IExMTCAgIHwgSnVseSAyIDE5OTUgMDU6MzAgYS5tLiAgICAgICAgIHxcbiAqIHwgbGxsICAgfCBKdWwgMiAxOTk1IDA1OjMwIGEubS4gICAgICAgICAgfFxuICogfCBMTExMICB8IFN1bmRheSwgSnVseSAyIDE5OTUgMDU6MzAgYS5tLiB8XG4gKiB8IGxsbGwgIHwgU3VuLCBKdWwgMiAxOTk1IDA1OjMwIGEubS4gICAgIHxcbiAqXG4gKiBUaGUgY2hhcmFjdGVycyB3cmFwcGVkIGluIHNxdWFyZSBicmFja2V0cyBpbiB0aGUgZm9ybWF0IHN0cmluZyBhcmUgZXNjYXBlZC5cbiAqXG4gKiBUaGUgcmVzdWx0IG1heSB2YXJ5IGJ5IGxvY2FsZS5cbiAqXG4gKiBJZiBgZm9ybWF0U3RyaW5nYCBtYXRjaGVzIHdpdGggYGRhdGVTdHJpbmdgIGJ1dCBkb2VzIG5vdCBwcm92aWRlcyB0b2tlbnMsIGBiYXNlRGF0ZWAgd2lsbCBiZSByZXR1cm5lZC5cbiAqXG4gKiBJZiBwYXJzaW5nIGZhaWxlZCwgYEludmFsaWQgRGF0ZWAgd2lsbCBiZSByZXR1cm5lZC5cbiAqIEludmFsaWQgRGF0ZSBpcyBhIERhdGUsIHdob3NlIHRpbWUgdmFsdWUgaXMgTmFOLlxuICogVGltZSB2YWx1ZSBvZiBEYXRlOiBodHRwOi8vZXM1LmdpdGh1Yi5pby8jeDE1LjkuMS4xXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGRhdGVTdHJpbmcgLSB0aGUgc3RyaW5nIHRvIHBhcnNlXG4gKiBAcGFyYW0ge1N0cmluZ30gZm9ybWF0U3RyaW5nIC0gdGhlIHN0cmluZyBvZiB0b2tlbnNcbiAqIEBwYXJhbSB7RGF0ZXxTdHJpbmd8TnVtYmVyfSBiYXNlRGF0ZSAtIHRoZSBkYXRlIHRvIHRvb2sgdGhlIG1pc3NpbmcgaGlnaGVyIHByaW9yaXR5IHZhbHVlcyBmcm9tXG4gKiBAcGFyYW0ge09wdGlvbnN9IFtvcHRpb25zXSAtIHRoZSBvYmplY3Qgd2l0aCBvcHRpb25zLiBTZWUgW09wdGlvbnNde0BsaW5rIGh0dHBzOi8vZGF0ZS1mbnMub3JnL2RvY3MvT3B0aW9uc31cbiAqIEBwYXJhbSB7MHwxfDJ9IFtvcHRpb25zLmFkZGl0aW9uYWxEaWdpdHM9Ml0gLSBwYXNzZWQgdG8gYHRvRGF0ZWAuIFNlZSBbdG9EYXRlXXtAbGluayBodHRwczovL2RhdGUtZm5zLm9yZy9kb2NzL3RvRGF0ZX1cbiAqIEBwYXJhbSB7TG9jYWxlfSBbb3B0aW9ucy5sb2NhbGU9ZGVmYXVsdExvY2FsZV0gLSB0aGUgbG9jYWxlIG9iamVjdC4gU2VlIFtMb2NhbGVde0BsaW5rIGh0dHBzOi8vZGF0ZS1mbnMub3JnL2RvY3MvTG9jYWxlfVxuICogQHBhcmFtIHswfDF8MnwzfDR8NXw2fSBbb3B0aW9ucy53ZWVrU3RhcnRzT249MF0gLSB0aGUgaW5kZXggb2YgdGhlIGZpcnN0IGRheSBvZiB0aGUgd2VlayAoMCAtIFN1bmRheSlcbiAqIEByZXR1cm5zIHtEYXRlfSB0aGUgcGFyc2VkIGRhdGVcbiAqIEB0aHJvd3Mge1R5cGVFcnJvcn0gMyBhcmd1bWVudHMgcmVxdWlyZWRcbiAqIEB0aHJvd3Mge1JhbmdlRXJyb3J9IGBvcHRpb25zLmFkZGl0aW9uYWxEaWdpdHNgIG11c3QgYmUgMCwgMSBvciAyXG4gKiBAdGhyb3dzIHtSYW5nZUVycm9yfSBgb3B0aW9ucy53ZWVrU3RhcnRzT25gIG11c3QgYmUgYmV0d2VlbiAwIGFuZCA2XG4gKiBAdGhyb3dzIHtSYW5nZUVycm9yfSBgb3B0aW9ucy5sb2NhbGVgIG11c3QgY29udGFpbiBgbWF0Y2hgIHByb3BlcnR5XG4gKiBAdGhyb3dzIHtSYW5nZUVycm9yfSBgb3B0aW9ucy5sb2NhbGVgIG11c3QgY29udGFpbiBgZm9ybWF0TG9uZ2AgcHJvcGVydHlcbiAqXG4gKiBAZXhhbXBsZVxuICogLy8gUGFyc2UgMTEgRmVicnVhcnkgMjAxNCBmcm9tIG1pZGRsZS1lbmRpYW4gZm9ybWF0OlxuICogdmFyIHJlc3VsdCA9IHBhcnNlKFxuICogICAnMDIvMTEvMjAxNCcsXG4gKiAgICdNTS9ERC9ZWVlZJyxcbiAqICAgbmV3IERhdGUoKVxuICogKVxuICogLy89PiBUdWUgRmViIDExIDIwMTQgMDA6MDA6MDBcbiAqXG4gKiBAZXhhbXBsZVxuICogLy8gUGFyc2UgMjh0aCBvZiBGZWJydWFyeSBpbiBFbmdsaXNoIGxvY2FsZSBpbiB0aGUgY29udGV4dCBvZiAyMDEwIHllYXI6XG4gKiBpbXBvcnQgZW9Mb2NhbGUgZnJvbSAnZGF0ZS1mbnMvbG9jYWxlL2VvJ1xuICogdmFyIHJlc3VsdCA9IHBhcnNlKFxuICogICAnMjgtYSBkZSBmZWJydWFybycsXG4gKiAgICdEbyBbZGVdIE1NTU0nLFxuICogICBuZXcgRGF0ZSgyMDEwLCAwLCAxKVxuICogICB7bG9jYWxlOiBlb0xvY2FsZX1cbiAqIClcbiAqIC8vPT4gU3VuIEZlYiAyOCAyMDEwIDAwOjAwOjAwXG4gKi9cbmZ1bmN0aW9uIHBhcnNlIChkaXJ0eURhdGVTdHJpbmcsIGRpcnR5Rm9ybWF0U3RyaW5nLCBkaXJ0eUJhc2VEYXRlLCBkaXJ0eU9wdGlvbnMpIHtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAzKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignMyBhcmd1bWVudHMgcmVxdWlyZWQsIGJ1dCBvbmx5ICcgKyBhcmd1bWVudHMubGVuZ3RoICsgJyBwcmVzZW50JylcbiAgfVxuXG4gIHZhciBkYXRlU3RyaW5nID0gU3RyaW5nKGRpcnR5RGF0ZVN0cmluZyk7XG4gIHZhciBvcHRpb25zID0gZGlydHlPcHRpb25zIHx8IHt9O1xuXG4gIHZhciB3ZWVrU3RhcnRzT24gPSBvcHRpb25zLndlZWtTdGFydHNPbiA9PT0gdW5kZWZpbmVkID8gMCA6IE51bWJlcihvcHRpb25zLndlZWtTdGFydHNPbik7XG5cbiAgLy8gVGVzdCBpZiB3ZWVrU3RhcnRzT24gaXMgYmV0d2VlbiAwIGFuZCA2IF9hbmRfIGlzIG5vdCBOYU5cbiAgaWYgKCEod2Vla1N0YXJ0c09uID49IDAgJiYgd2Vla1N0YXJ0c09uIDw9IDYpKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3dlZWtTdGFydHNPbiBtdXN0IGJlIGJldHdlZW4gMCBhbmQgNiBpbmNsdXNpdmVseScpXG4gIH1cblxuICB2YXIgbG9jYWxlID0gb3B0aW9ucy5sb2NhbGUgfHwgbG9jYWxlJDE7XG4gIHZhciBsb2NhbGVQYXJzZXJzID0gbG9jYWxlLnBhcnNlcnMgfHwge307XG4gIHZhciBsb2NhbGVVbml0cyA9IGxvY2FsZS51bml0cyB8fCB7fTtcblxuICBpZiAoIWxvY2FsZS5tYXRjaCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdsb2NhbGUgbXVzdCBjb250YWluIG1hdGNoIHByb3BlcnR5JylcbiAgfVxuXG4gIGlmICghbG9jYWxlLmZvcm1hdExvbmcpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignbG9jYWxlIG11c3QgY29udGFpbiBmb3JtYXRMb25nIHByb3BlcnR5JylcbiAgfVxuXG4gIHZhciBmb3JtYXRTdHJpbmcgPSBTdHJpbmcoZGlydHlGb3JtYXRTdHJpbmcpXG4gICAgLnJlcGxhY2UobG9uZ0Zvcm1hdHRpbmdUb2tlbnNSZWdFeHAkMSwgZnVuY3Rpb24gKHN1YnN0cmluZykge1xuICAgICAgaWYgKHN1YnN0cmluZ1swXSA9PT0gJ1snKSB7XG4gICAgICAgIHJldHVybiBzdWJzdHJpbmdcbiAgICAgIH1cblxuICAgICAgaWYgKHN1YnN0cmluZ1swXSA9PT0gJ1xcXFwnKSB7XG4gICAgICAgIHJldHVybiBjbGVhbkVzY2FwZWRTdHJpbmckMShzdWJzdHJpbmcpXG4gICAgICB9XG5cbiAgICAgIHJldHVybiBsb2NhbGUuZm9ybWF0TG9uZyhzdWJzdHJpbmcpXG4gICAgfSk7XG5cbiAgaWYgKGZvcm1hdFN0cmluZyA9PT0gJycpIHtcbiAgICBpZiAoZGF0ZVN0cmluZyA9PT0gJycpIHtcbiAgICAgIHJldHVybiB0b0RhdGUoZGlydHlCYXNlRGF0ZSwgb3B0aW9ucylcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG5ldyBEYXRlKE5hTilcbiAgICB9XG4gIH1cblxuICB2YXIgc3ViRm5PcHRpb25zID0gY2xvbmVPYmplY3Qob3B0aW9ucyk7XG4gIHN1YkZuT3B0aW9ucy5sb2NhbGUgPSBsb2NhbGU7XG5cbiAgdmFyIHRva2VucyA9IGZvcm1hdFN0cmluZy5tYXRjaChsb2NhbGUucGFyc2luZ1Rva2Vuc1JlZ0V4cCB8fCBkZWZhdWx0UGFyc2luZ1Rva2Vuc1JlZ0V4cCk7XG4gIHZhciB0b2tlbnNMZW5ndGggPSB0b2tlbnMubGVuZ3RoO1xuXG4gIC8vIElmIHRpbWV6b25lIGlzbid0IHNwZWNpZmllZCwgaXQgd2lsbCBiZSBzZXQgdG8gdGhlIHN5c3RlbSB0aW1lem9uZVxuICB2YXIgc2V0dGVycyA9IFt7XG4gICAgcHJpb3JpdHk6IFRJTUVaT05FX1VOSVRfUFJJT1JJVFksXG4gICAgc2V0OiBkYXRlVG9TeXN0ZW1UaW1lem9uZSxcbiAgICBpbmRleDogMFxuICB9XTtcblxuICB2YXIgaTtcbiAgZm9yIChpID0gMDsgaSA8IHRva2Vuc0xlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHRva2VuID0gdG9rZW5zW2ldO1xuICAgIHZhciBwYXJzZXIgPSBsb2NhbGVQYXJzZXJzW3Rva2VuXSB8fCBwYXJzZXJzW3Rva2VuXTtcbiAgICBpZiAocGFyc2VyKSB7XG4gICAgICB2YXIgbWF0Y2hSZXN1bHQ7XG5cbiAgICAgIGlmIChwYXJzZXIubWF0Y2ggaW5zdGFuY2VvZiBSZWdFeHApIHtcbiAgICAgICAgbWF0Y2hSZXN1bHQgPSBwYXJzZXIubWF0Y2guZXhlYyhkYXRlU3RyaW5nKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG1hdGNoUmVzdWx0ID0gcGFyc2VyLm1hdGNoKGRhdGVTdHJpbmcsIHN1YkZuT3B0aW9ucyk7XG4gICAgICB9XG5cbiAgICAgIGlmICghbWF0Y2hSZXN1bHQpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBEYXRlKE5hTilcbiAgICAgIH1cblxuICAgICAgdmFyIHVuaXROYW1lID0gcGFyc2VyLnVuaXQ7XG4gICAgICB2YXIgdW5pdCA9IGxvY2FsZVVuaXRzW3VuaXROYW1lXSB8fCB1bml0c1t1bml0TmFtZV07XG5cbiAgICAgIHNldHRlcnMucHVzaCh7XG4gICAgICAgIHByaW9yaXR5OiB1bml0LnByaW9yaXR5LFxuICAgICAgICBzZXQ6IHVuaXQuc2V0LFxuICAgICAgICB2YWx1ZTogcGFyc2VyLnBhcnNlKG1hdGNoUmVzdWx0LCBzdWJGbk9wdGlvbnMpLFxuICAgICAgICBpbmRleDogc2V0dGVycy5sZW5ndGhcbiAgICAgIH0pO1xuXG4gICAgICB2YXIgc3Vic3RyaW5nID0gbWF0Y2hSZXN1bHRbMF07XG4gICAgICBkYXRlU3RyaW5nID0gZGF0ZVN0cmluZy5zbGljZShzdWJzdHJpbmcubGVuZ3RoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGhlYWQgPSB0b2tlbnNbaV0ubWF0Y2goL15cXFsuKl0kLykgPyB0b2tlbnNbaV0ucmVwbGFjZSgvXlxcW3xdJC9nLCAnJykgOiB0b2tlbnNbaV07XG4gICAgICBpZiAoZGF0ZVN0cmluZy5pbmRleE9mKGhlYWQpID09PSAwKSB7XG4gICAgICAgIGRhdGVTdHJpbmcgPSBkYXRlU3RyaW5nLnNsaWNlKGhlYWQubGVuZ3RoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBuZXcgRGF0ZShOYU4pXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgdmFyIHVuaXF1ZVByaW9yaXR5U2V0dGVycyA9IHNldHRlcnNcbiAgICAubWFwKGZ1bmN0aW9uIChzZXR0ZXIpIHtcbiAgICAgIHJldHVybiBzZXR0ZXIucHJpb3JpdHlcbiAgICB9KVxuICAgIC5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICByZXR1cm4gYSAtIGJcbiAgICB9KVxuICAgIC5maWx0ZXIoZnVuY3Rpb24gKHByaW9yaXR5LCBpbmRleCwgYXJyYXkpIHtcbiAgICAgIHJldHVybiBhcnJheS5pbmRleE9mKHByaW9yaXR5KSA9PT0gaW5kZXhcbiAgICB9KVxuICAgIC5tYXAoZnVuY3Rpb24gKHByaW9yaXR5KSB7XG4gICAgICByZXR1cm4gc2V0dGVyc1xuICAgICAgICAuZmlsdGVyKGZ1bmN0aW9uIChzZXR0ZXIpIHtcbiAgICAgICAgICByZXR1cm4gc2V0dGVyLnByaW9yaXR5ID09PSBwcmlvcml0eVxuICAgICAgICB9KVxuICAgICAgICAucmV2ZXJzZSgpXG4gICAgfSlcbiAgICAubWFwKGZ1bmN0aW9uIChzZXR0ZXJBcnJheSkge1xuICAgICAgcmV0dXJuIHNldHRlckFycmF5WzBdXG4gICAgfSk7XG5cbiAgdmFyIGRhdGUgPSB0b0RhdGUoZGlydHlCYXNlRGF0ZSwgb3B0aW9ucyk7XG5cbiAgaWYgKGlzTmFOKGRhdGUpKSB7XG4gICAgcmV0dXJuIG5ldyBEYXRlKE5hTilcbiAgfVxuXG4gIC8vIENvbnZlcnQgdGhlIGRhdGUgaW4gc3lzdGVtIHRpbWV6b25lIHRvIHRoZSBzYW1lIGRhdGUgaW4gVVRDKzAwOjAwIHRpbWV6b25lLlxuICAvLyBUaGlzIGVuc3VyZXMgdGhhdCB3aGVuIFVUQyBmdW5jdGlvbnMgd2lsbCBiZSBpbXBsZW1lbnRlZCwgbG9jYWxlcyB3aWxsIGJlIGNvbXBhdGlibGUgd2l0aCB0aGVtLlxuICAvLyBTZWUgYW4gaXNzdWUgYWJvdXQgVVRDIGZ1bmN0aW9uczogaHR0cHM6Ly9naXRodWIuY29tL2RhdGUtZm5zL2RhdGUtZm5zL2lzc3Vlcy8zN1xuICB2YXIgdXRjRGF0ZSA9IHN1Yk1pbnV0ZXMoZGF0ZSwgZGF0ZS5nZXRUaW1lem9uZU9mZnNldCgpKTtcblxuICB2YXIgZGF0ZVZhbHVlcyA9IHtkYXRlOiB1dGNEYXRlfTtcblxuICB2YXIgc2V0dGVyc0xlbmd0aCA9IHVuaXF1ZVByaW9yaXR5U2V0dGVycy5sZW5ndGg7XG4gIGZvciAoaSA9IDA7IGkgPCBzZXR0ZXJzTGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgc2V0dGVyID0gdW5pcXVlUHJpb3JpdHlTZXR0ZXJzW2ldO1xuICAgIGRhdGVWYWx1ZXMgPSBzZXR0ZXIuc2V0KGRhdGVWYWx1ZXMsIHNldHRlci52YWx1ZSwgc3ViRm5PcHRpb25zKTtcbiAgfVxuXG4gIHJldHVybiBkYXRlVmFsdWVzLmRhdGVcbn1cblxuZnVuY3Rpb24gZGF0ZVRvU3lzdGVtVGltZXpvbmUgKGRhdGVWYWx1ZXMpIHtcbiAgdmFyIGRhdGUgPSBkYXRlVmFsdWVzLmRhdGU7XG4gIHZhciB0aW1lID0gZGF0ZS5nZXRUaW1lKCk7XG5cbiAgLy8gR2V0IHRoZSBzeXN0ZW0gdGltZXpvbmUgb2Zmc2V0IGF0IChtb21lbnQgb2YgdGltZSAtIG9mZnNldClcbiAgdmFyIG9mZnNldCA9IGRhdGUuZ2V0VGltZXpvbmVPZmZzZXQoKTtcblxuICAvLyBHZXQgdGhlIHN5c3RlbSB0aW1lem9uZSBvZmZzZXQgYXQgdGhlIGV4YWN0IG1vbWVudCBvZiB0aW1lXG4gIG9mZnNldCA9IG5ldyBEYXRlKHRpbWUgKyBvZmZzZXQgKiBNSUxMSVNFQ09ORFNfSU5fTUlOVVRFJDYpLmdldFRpbWV6b25lT2Zmc2V0KCk7XG5cbiAgLy8gQ29udmVydCBkYXRlIGluIHRpbWV6b25lIFwiVVRDKzAwOjAwXCIgdG8gdGhlIHN5c3RlbSB0aW1lem9uZVxuICBkYXRlVmFsdWVzLmRhdGUgPSBuZXcgRGF0ZSh0aW1lICsgb2Zmc2V0ICogTUlMTElTRUNPTkRTX0lOX01JTlVURSQ2KTtcblxuICByZXR1cm4gZGF0ZVZhbHVlc1xufVxuXG5mdW5jdGlvbiBjbGVhbkVzY2FwZWRTdHJpbmckMSAoaW5wdXQpIHtcbiAgaWYgKGlucHV0Lm1hdGNoKC9cXFtbXFxzXFxTXS8pKSB7XG4gICAgcmV0dXJuIGlucHV0LnJlcGxhY2UoL15cXFt8XSQvZywgJycpXG4gIH1cbiAgcmV0dXJuIGlucHV0LnJlcGxhY2UoL1xcXFwvZywgJycpXG59XG5cbi8vIFRoaXMgZmlsZSBpcyBnZW5lcmF0ZWQgYXV0b21hdGljYWxseSBieSBgc2NyaXB0cy9idWlsZC9pbmRpY2VzLmpzYC4gUGxlYXNlLCBkb24ndCBjaGFuZ2UgaXQuXG5cbi8vIFxuXG4vKipcbiAqIEN1c3RvbSBwYXJzZSBiZWhhdmlvciBvbiB0b3Agb2YgZGF0ZS1mbnMgcGFyc2UgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIHBhcnNlRGF0ZSQxIChkYXRlLCBmb3JtYXQkJDEpIHtcbiAgaWYgKHR5cGVvZiBkYXRlICE9PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBpc1ZhbGlkKGRhdGUpID8gZGF0ZSA6IG51bGw7XG4gIH1cblxuICB2YXIgcGFyc2VkID0gcGFyc2UoZGF0ZSwgZm9ybWF0JCQxLCBuZXcgRGF0ZSgpKTtcblxuICAvLyBpZiBkYXRlIGlzIG5vdCB2YWxpZCBvciB0aGUgZm9ybWF0dGVkIG91dHB1dCBhZnRlciBwYXJzaW5nIGRvZXMgbm90IG1hdGNoXG4gIC8vIHRoZSBzdHJpbmcgdmFsdWUgcGFzc2VkIGluIChhdm9pZHMgb3ZlcmZsb3dzKVxuICBpZiAoIWlzVmFsaWQocGFyc2VkKSB8fCBmb3JtYXQocGFyc2VkLCBmb3JtYXQkJDEpICE9PSBkYXRlKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICByZXR1cm4gcGFyc2VkO1xufVxuXG52YXIgYWZ0ZXIgPSBmdW5jdGlvbiAodmFsdWUsIHJlZikge1xuICB2YXIgb3RoZXJWYWx1ZSA9IHJlZlswXTtcbiAgdmFyIGluY2x1c2lvbiA9IHJlZlsxXTtcbiAgdmFyIGZvcm1hdCA9IHJlZlsyXTtcblxuICBpZiAodHlwZW9mIGZvcm1hdCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBmb3JtYXQgPSBpbmNsdXNpb247XG4gICAgaW5jbHVzaW9uID0gZmFsc2U7XG4gIH1cbiAgdmFsdWUgPSBwYXJzZURhdGUkMSh2YWx1ZSwgZm9ybWF0KTtcbiAgb3RoZXJWYWx1ZSA9IHBhcnNlRGF0ZSQxKG90aGVyVmFsdWUsIGZvcm1hdCk7XG5cbiAgLy8gaWYgZWl0aGVyIGlzIG5vdCB2YWxpZC5cbiAgaWYgKCF2YWx1ZSB8fCAhb3RoZXJWYWx1ZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiBpc0FmdGVyKHZhbHVlLCBvdGhlclZhbHVlKSB8fCAoaW5jbHVzaW9uICYmIGlzRXF1YWwkMSh2YWx1ZSwgb3RoZXJWYWx1ZSkpO1xufTtcblxuLyoqXG4gKiBTb21lIEFscGhhIFJlZ2V4IGhlbHBlcnMuXG4gKiBodHRwczovL2dpdGh1Yi5jb20vY2hyaXNvL3ZhbGlkYXRvci5qcy9ibG9iL21hc3Rlci9zcmMvbGliL2FscGhhLmpzXG4gKi9cblxudmFyIGFscGhhJDEgPSB7XG4gIGVuOiAvXltBLVpdKiQvaSxcbiAgY3M6IC9eW0EtWsOBxIzEjsOJxJrDjcWHw5PFmMWgxaTDmsWuw53FvV0qJC9pLFxuICBkYTogL15bQS1aw4bDmMOFXSokL2ksXG4gIGRlOiAvXltBLVrDhMOWw5zDn10qJC9pLFxuICBlczogL15bQS1aw4HDicONw5HDk8Oaw5xdKiQvaSxcbiAgZnI6IC9eW0EtWsOAw4LDhsOHw4nDiMOKw4vDj8OOw5TFksOZw5vDnMW4XSokL2ksXG4gIGx0OiAvXltBLVrEhMSMxJjElsSuxaDFssWqxb1dKiQvaSxcbiAgbmw6IC9eW0EtWsOJw4vDj8OTw5bDnF0qJC9pLFxuICBodTogL15bQS1aw4HDicONw5PDlsWQw5rDnMWwXSokL2ksXG4gIHBsOiAvXltBLVrEhMSGxJjFmsWBxYPDk8W7xbldKiQvaSxcbiAgcHQ6IC9eW0EtWsODw4HDgMOCw4fDicOKw43DlcOTw5TDmsOcXSokL2ksXG4gIHJ1OiAvXlvQkC3Qr9CBXSokL2ksXG4gIHNrOiAvXltBLVrDgcOExIzEjsOJw43EucS9xYfDk8WUxaDFpMOaw53FvV0qJC9pLFxuICBzcjogL15bQS1axIzEhsW9xaDEkF0qJC9pLFxuICB0cjogL15bQS1aw4fEnsSwxLHDlsWew5xdKiQvaSxcbiAgdWs6IC9eW9CQLdCp0KzQrtCv0ITQhtCH0pBdKiQvaSxcbiAgYXI6IC9eW9ih2KLYo9ik2KXYptin2KjYqdiq2KvYrNit2K7Yr9iw2LHYstiz2LTYtdi22LfYuNi52LrZgdmC2YPZhNmF2YbZh9mI2YnZitmL2YzZjdmO2Y/ZkNmR2ZLZsF0qJC9cbn07XG5cbnZhciBhbHBoYVNwYWNlcyA9IHtcbiAgZW46IC9eW0EtWlxcc10qJC9pLFxuICBjczogL15bQS1aw4HEjMSOw4nEmsONxYfDk8WYxaDFpMOaxa7DncW9XFxzXSokL2ksXG4gIGRhOiAvXltBLVrDhsOYw4VcXHNdKiQvaSxcbiAgZGU6IC9eW0EtWsOEw5bDnMOfXFxzXSokL2ksXG4gIGVzOiAvXltBLVrDgcOJw43DkcOTw5rDnFxcc10qJC9pLFxuICBmcjogL15bQS1aw4DDgsOGw4fDicOIw4rDi8OPw47DlMWSw5nDm8OcxbhcXHNdKiQvaSxcbiAgbHQ6IC9eW0EtWsSExIzEmMSWxK7FoMWyxarFvVxcc10qJC9pLFxuICBubDogL15bQS1aw4nDi8OPw5PDlsOcXFxzXSokL2ksXG4gIGh1OiAvXltBLVrDgcOJw43Dk8OWxZDDmsOcxbBcXHNdKiQvaSxcbiAgcGw6IC9eW0EtWsSExIbEmMWaxYHFg8OTxbvFuVxcc10qJC9pLFxuICBwdDogL15bQS1aw4PDgcOAw4LDh8OJw4rDjcOVw5PDlMOaw5xcXHNdKiQvaSxcbiAgcnU6IC9eW9CQLdCv0IFcXHNdKiQvaSxcbiAgc2s6IC9eW0EtWsOBw4TEjMSOw4nDjcS5xL3Fh8OTxZTFoMWkw5rDncW9XFxzXSokL2ksXG4gIHNyOiAvXltBLVrEjMSGxb3FoMSQXFxzXSokL2ksXG4gIHRyOiAvXltBLVrDh8SexLDEscOWxZ7DnFxcc10qJC9pLFxuICB1azogL15b0JAt0KnQrNCu0K/QhNCG0IfSkFxcc10qJC9pLFxuICBhcjogL15b2KHYotij2KTYpdim2KfYqNip2KrYq9is2K3Yrtiv2LDYsdiy2LPYtNi12LbYt9i42LnYutmB2YLZg9mE2YXZhtmH2YjZidmK2YvZjNmN2Y7Zj9mQ2ZHZktmwXFxzXSokL1xufTtcblxudmFyIGFscGhhbnVtZXJpYyA9IHtcbiAgZW46IC9eWzAtOUEtWl0qJC9pLFxuICBjczogL15bMC05QS1aw4HEjMSOw4nEmsONxYfDk8WYxaDFpMOaxa7DncW9XSokL2ksXG4gIGRhOiAvXlswLTlBLVrDhsOYw4VdJC9pLFxuICBkZTogL15bMC05QS1aw4TDlsOcw59dKiQvaSxcbiAgZXM6IC9eWzAtOUEtWsOBw4nDjcORw5PDmsOcXSokL2ksXG4gIGZyOiAvXlswLTlBLVrDgMOCw4bDh8OJw4jDisOLw4/DjsOUxZLDmcObw5zFuF0qJC9pLFxuICBsdDogL15bMC05QS1axITEjMSYxJbErsWgxbLFqsW9XSokL2ksXG4gIGh1OiAvXlswLTlBLVrDgcOJw43Dk8OWxZDDmsOcxbBdKiQvaSxcbiAgbmw6IC9eWzAtOUEtWsOJw4vDj8OTw5bDnF0qJC9pLFxuICBwbDogL15bMC05QS1axITEhsSYxZrFgcWDw5PFu8W5XSokL2ksXG4gIHB0OiAvXlswLTlBLVrDg8OBw4DDgsOHw4nDisONw5XDk8OUw5rDnF0qJC9pLFxuICBydTogL15bMC050JAt0K/QgV0qJC9pLFxuICBzazogL15bMC05QS1aw4HDhMSMxI7DicONxLnEvcWHw5PFlMWgxaTDmsOdxb1dKiQvaSxcbiAgc3I6IC9eWzAtOUEtWsSMxIbFvcWgxJBdKiQvaSxcbiAgdHI6IC9eWzAtOUEtWsOHxJ7EsMSxw5bFnsOcXSokL2ksXG4gIHVrOiAvXlswLTnQkC3QqdCs0K7Qr9CE0IbQh9KQXSokL2ksXG4gIGFyOiAvXlvZoNmh2aLZo9mk2aXZptmn2ajZqTAtOdih2KLYo9ik2KXYptin2KjYqdiq2KvYrNit2K7Yr9iw2LHYstiz2LTYtdi22LfYuNi52LrZgdmC2YPZhNmF2YbZh9mI2YnZitmL2YzZjdmO2Y/ZkNmR2ZLZsF0qJC9cbn07XG5cbnZhciBhbHBoYURhc2ggPSB7XG4gIGVuOiAvXlswLTlBLVpfLV0qJC9pLFxuICBjczogL15bMC05QS1aw4HEjMSOw4nEmsONxYfDk8WYxaDFpMOaxa7DncW9Xy1dKiQvaSxcbiAgZGE6IC9eWzAtOUEtWsOGw5jDhV8tXSokL2ksXG4gIGRlOiAvXlswLTlBLVrDhMOWw5zDn18tXSokL2ksXG4gIGVzOiAvXlswLTlBLVrDgcOJw43DkcOTw5rDnF8tXSokL2ksXG4gIGZyOiAvXlswLTlBLVrDgMOCw4bDh8OJw4jDisOLw4/DjsOUxZLDmcObw5zFuF8tXSokL2ksXG4gIGx0OiAvXlswLTlBLVrEhMSMxJjElsSuxaDFssWqxb1fLV0qJC9pLFxuICBubDogL15bMC05QS1aw4nDi8OPw5PDlsOcXy1dKiQvaSxcbiAgaHU6IC9eWzAtOUEtWsOBw4nDjcOTw5bFkMOaw5zFsF8tXSokL2ksXG4gIHBsOiAvXlswLTlBLVrEhMSGxJjFmsWBxYPDk8W7xblfLV0qJC9pLFxuICBwdDogL15bMC05QS1aw4PDgcOAw4LDh8OJw4rDjcOVw5PDlMOaw5xfLV0qJC9pLFxuICBydTogL15bMC050JAt0K/QgV8tXSokL2ksXG4gIHNrOiAvXlswLTlBLVrDgcOExIzEjsOJw43EucS9xYfDk8WUxaDFpMOaw53FvV8tXSokL2ksXG4gIHNyOiAvXlswLTlBLVrEjMSGxb3FoMSQXy1dKiQvaSxcbiAgdHI6IC9eWzAtOUEtWsOHxJ7EsMSxw5bFnsOcXy1dKiQvaSxcbiAgdWs6IC9eWzAtOdCQLdCp0KzQrtCv0ITQhtCH0pBfLV0qJC9pLFxuICBhcjogL15b2aDZodmi2aPZpNml2abZp9mo2akwLTnYodii2KPYpNil2KbYp9io2KnYqtir2KzYrdiu2K/YsNix2LLYs9i02LXYtti32LjYudi62YHZgtmD2YTZhdmG2YfZiNmJ2YrZi9mM2Y3ZjtmP2ZDZkdmS2bBfLV0qJC9cbn07XG5cbnZhciB2YWxpZGF0ZSA9IGZ1bmN0aW9uICh2YWx1ZSwgcmVmKSB7XG4gIGlmICggcmVmID09PSB2b2lkIDAgKSByZWYgPSBbXTtcbiAgdmFyIGxvY2FsZSA9IHJlZlswXTsgaWYgKCBsb2NhbGUgPT09IHZvaWQgMCApIGxvY2FsZSA9IG51bGw7XG5cbiAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgcmV0dXJuIHZhbHVlLmV2ZXJ5KGZ1bmN0aW9uICh2YWwpIHsgcmV0dXJuIHZhbGlkYXRlKHZhbCwgW2xvY2FsZV0pOyB9KTtcbiAgfVxuXG4gIC8vIE1hdGNoIGF0IGxlYXN0IG9uZSBsb2NhbGUuXG4gIGlmICghIGxvY2FsZSkge1xuICAgIHJldHVybiBPYmplY3Qua2V5cyhhbHBoYSQxKS5zb21lKGZ1bmN0aW9uIChsb2MpIHsgcmV0dXJuIGFscGhhJDFbbG9jXS50ZXN0KHZhbHVlKTsgfSk7XG4gIH1cblxuICByZXR1cm4gKGFscGhhJDFbbG9jYWxlXSB8fCBhbHBoYSQxLmVuKS50ZXN0KHZhbHVlKTtcbn07XG5cbnZhciB2YWxpZGF0ZSQxID0gZnVuY3Rpb24gKHZhbHVlLCByZWYpIHtcbiAgaWYgKCByZWYgPT09IHZvaWQgMCApIHJlZiA9IFtdO1xuICB2YXIgbG9jYWxlID0gcmVmWzBdOyBpZiAoIGxvY2FsZSA9PT0gdm9pZCAwICkgbG9jYWxlID0gbnVsbDtcblxuICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICByZXR1cm4gdmFsdWUuZXZlcnkoZnVuY3Rpb24gKHZhbCkgeyByZXR1cm4gdmFsaWRhdGUkMSh2YWwsIFtsb2NhbGVdKTsgfSk7XG4gIH1cblxuICAvLyBNYXRjaCBhdCBsZWFzdCBvbmUgbG9jYWxlLlxuICBpZiAoISBsb2NhbGUpIHtcbiAgICByZXR1cm4gT2JqZWN0LmtleXMoYWxwaGFEYXNoKS5zb21lKGZ1bmN0aW9uIChsb2MpIHsgcmV0dXJuIGFscGhhRGFzaFtsb2NdLnRlc3QodmFsdWUpOyB9KTtcbiAgfVxuXG4gIHJldHVybiAoYWxwaGFEYXNoW2xvY2FsZV0gfHwgYWxwaGFEYXNoLmVuKS50ZXN0KHZhbHVlKTtcbn07XG5cbnZhciB2YWxpZGF0ZSQyID0gZnVuY3Rpb24gKHZhbHVlLCByZWYpIHtcbiAgaWYgKCByZWYgPT09IHZvaWQgMCApIHJlZiA9IFtdO1xuICB2YXIgbG9jYWxlID0gcmVmWzBdOyBpZiAoIGxvY2FsZSA9PT0gdm9pZCAwICkgbG9jYWxlID0gbnVsbDtcblxuICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICByZXR1cm4gdmFsdWUuZXZlcnkoZnVuY3Rpb24gKHZhbCkgeyByZXR1cm4gdmFsaWRhdGUkMih2YWwsIFtsb2NhbGVdKTsgfSk7XG4gIH1cblxuICAvLyBNYXRjaCBhdCBsZWFzdCBvbmUgbG9jYWxlLlxuICBpZiAoISBsb2NhbGUpIHtcbiAgICByZXR1cm4gT2JqZWN0LmtleXMoYWxwaGFudW1lcmljKS5zb21lKGZ1bmN0aW9uIChsb2MpIHsgcmV0dXJuIGFscGhhbnVtZXJpY1tsb2NdLnRlc3QodmFsdWUpOyB9KTtcbiAgfVxuXG4gIHJldHVybiAoYWxwaGFudW1lcmljW2xvY2FsZV0gfHwgYWxwaGFudW1lcmljLmVuKS50ZXN0KHZhbHVlKTtcbn07XG5cbnZhciB2YWxpZGF0ZSQzID0gZnVuY3Rpb24gKHZhbHVlLCByZWYpIHtcbiAgaWYgKCByZWYgPT09IHZvaWQgMCApIHJlZiA9IFtdO1xuICB2YXIgbG9jYWxlID0gcmVmWzBdOyBpZiAoIGxvY2FsZSA9PT0gdm9pZCAwICkgbG9jYWxlID0gbnVsbDtcblxuICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICByZXR1cm4gdmFsdWUuZXZlcnkoZnVuY3Rpb24gKHZhbCkgeyByZXR1cm4gdmFsaWRhdGUkMyh2YWwsIFtsb2NhbGVdKTsgfSk7XG4gIH1cblxuICAvLyBNYXRjaCBhdCBsZWFzdCBvbmUgbG9jYWxlLlxuICBpZiAoISBsb2NhbGUpIHtcbiAgICByZXR1cm4gT2JqZWN0LmtleXMoYWxwaGFTcGFjZXMpLnNvbWUoZnVuY3Rpb24gKGxvYykgeyByZXR1cm4gYWxwaGFTcGFjZXNbbG9jXS50ZXN0KHZhbHVlKTsgfSk7XG4gIH1cblxuICByZXR1cm4gKGFscGhhU3BhY2VzW2xvY2FsZV0gfHwgYWxwaGFTcGFjZXMuZW4pLnRlc3QodmFsdWUpO1xufTtcblxudmFyIGJlZm9yZSA9IGZ1bmN0aW9uICh2YWx1ZSwgcmVmKSB7XG4gIHZhciBvdGhlclZhbHVlID0gcmVmWzBdO1xuICB2YXIgaW5jbHVzaW9uID0gcmVmWzFdO1xuICB2YXIgZm9ybWF0ID0gcmVmWzJdO1xuXG4gIGlmICh0eXBlb2YgZm9ybWF0ID09PSAndW5kZWZpbmVkJykge1xuICAgIGZvcm1hdCA9IGluY2x1c2lvbjtcbiAgICBpbmNsdXNpb24gPSBmYWxzZTtcbiAgfVxuICB2YWx1ZSA9IHBhcnNlRGF0ZSQxKHZhbHVlLCBmb3JtYXQpO1xuICBvdGhlclZhbHVlID0gcGFyc2VEYXRlJDEob3RoZXJWYWx1ZSwgZm9ybWF0KTtcblxuICAvLyBpZiBlaXRoZXIgaXMgbm90IHZhbGlkLlxuICBpZiAoIXZhbHVlIHx8ICFvdGhlclZhbHVlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIGlzQmVmb3JlKHZhbHVlLCBvdGhlclZhbHVlKSB8fCAoaW5jbHVzaW9uICYmIGlzRXF1YWwkMSh2YWx1ZSwgb3RoZXJWYWx1ZSkpO1xufTtcblxudmFyIHZhbGlkYXRlJDQgPSBmdW5jdGlvbiAodmFsdWUsIHJlZikge1xuICB2YXIgbWluID0gcmVmWzBdO1xuICB2YXIgbWF4ID0gcmVmWzFdO1xuXG4gIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgIHJldHVybiB2YWx1ZS5ldmVyeShmdW5jdGlvbiAodmFsKSB7IHJldHVybiB2YWxpZGF0ZSQ0KHZhbCwgW21pbiwgbWF4XSk7IH0pO1xuICB9XG5cbiAgcmV0dXJuIE51bWJlcihtaW4pIDw9IHZhbHVlICYmIE51bWJlcihtYXgpID49IHZhbHVlO1xufTtcblxudmFyIGNvbmZpcm1lZCA9IGZ1bmN0aW9uICh2YWx1ZSwgb3RoZXIpIHsgcmV0dXJuIFN0cmluZyh2YWx1ZSkgPT09IFN0cmluZyhvdGhlcik7IH07XG5cbmZ1bmN0aW9uIHVud3JhcEV4cG9ydHMgKHgpIHtcblx0cmV0dXJuIHggJiYgeC5fX2VzTW9kdWxlICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh4LCAnZGVmYXVsdCcpID8geFsnZGVmYXVsdCddIDogeDtcbn1cblxuZnVuY3Rpb24gY3JlYXRlQ29tbW9uanNNb2R1bGUoZm4sIG1vZHVsZSkge1xuXHRyZXR1cm4gbW9kdWxlID0geyBleHBvcnRzOiB7fSB9LCBmbihtb2R1bGUsIG1vZHVsZS5leHBvcnRzKSwgbW9kdWxlLmV4cG9ydHM7XG59XG5cbnZhciBhc3NlcnRTdHJpbmdfMSA9IGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZ1bmN0aW9uIChtb2R1bGUsIGV4cG9ydHMpIHtcbid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IGFzc2VydFN0cmluZztcbmZ1bmN0aW9uIGFzc2VydFN0cmluZyhpbnB1dCkge1xuICB2YXIgaXNTdHJpbmcgPSB0eXBlb2YgaW5wdXQgPT09ICdzdHJpbmcnIHx8IGlucHV0IGluc3RhbmNlb2YgU3RyaW5nO1xuXG4gIGlmICghaXNTdHJpbmcpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGlzIGxpYnJhcnkgKHZhbGlkYXRvci5qcykgdmFsaWRhdGVzIHN0cmluZ3Mgb25seScpO1xuICB9XG59XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcbn0pO1xuXG51bndyYXBFeHBvcnRzKGFzc2VydFN0cmluZ18xKTtcblxudmFyIGlzQ3JlZGl0Q2FyZF8xID0gY3JlYXRlQ29tbW9uanNNb2R1bGUoZnVuY3Rpb24gKG1vZHVsZSwgZXhwb3J0cykge1xuJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gaXNDcmVkaXRDYXJkO1xuXG5cblxudmFyIF9hc3NlcnRTdHJpbmcyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChhc3NlcnRTdHJpbmdfMSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbi8qIGVzbGludC1kaXNhYmxlIG1heC1sZW4gKi9cbnZhciBjcmVkaXRDYXJkID0gL14oPzo0WzAtOV17MTJ9KD86WzAtOV17M30pP3w1WzEtNV1bMC05XXsxNH18KDIyMlsxLTldfDIyWzMtOV1bMC05XXwyWzMtNl1bMC05XXsyfXwyN1swMV1bMC05XXwyNzIwKVswLTldezEyfXw2KD86MDExfDVbMC05XVswLTldKVswLTldezEyfXwzWzQ3XVswLTldezEzfXwzKD86MFswLTVdfFs2OF1bMC05XSlbMC05XXsxMX18KD86MjEzMXwxODAwfDM1XFxkezN9KVxcZHsxMX18NjJbMC05XXsxNH0pJC87XG4vKiBlc2xpbnQtZW5hYmxlIG1heC1sZW4gKi9cblxuZnVuY3Rpb24gaXNDcmVkaXRDYXJkKHN0cikge1xuICAoMCwgX2Fzc2VydFN0cmluZzIuZGVmYXVsdCkoc3RyKTtcbiAgdmFyIHNhbml0aXplZCA9IHN0ci5yZXBsYWNlKC9bLSBdKy9nLCAnJyk7XG4gIGlmICghY3JlZGl0Q2FyZC50ZXN0KHNhbml0aXplZCkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIHN1bSA9IDA7XG4gIHZhciBkaWdpdCA9IHZvaWQgMDtcbiAgdmFyIHRtcE51bSA9IHZvaWQgMDtcbiAgdmFyIHNob3VsZERvdWJsZSA9IHZvaWQgMDtcbiAgZm9yICh2YXIgaSA9IHNhbml0aXplZC5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgIGRpZ2l0ID0gc2FuaXRpemVkLnN1YnN0cmluZyhpLCBpICsgMSk7XG4gICAgdG1wTnVtID0gcGFyc2VJbnQoZGlnaXQsIDEwKTtcbiAgICBpZiAoc2hvdWxkRG91YmxlKSB7XG4gICAgICB0bXBOdW0gKj0gMjtcbiAgICAgIGlmICh0bXBOdW0gPj0gMTApIHtcbiAgICAgICAgc3VtICs9IHRtcE51bSAlIDEwICsgMTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN1bSArPSB0bXBOdW07XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHN1bSArPSB0bXBOdW07XG4gICAgfVxuICAgIHNob3VsZERvdWJsZSA9ICFzaG91bGREb3VibGU7XG4gIH1cbiAgcmV0dXJuICEhKHN1bSAlIDEwID09PSAwID8gc2FuaXRpemVkIDogZmFsc2UpO1xufVxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG59KTtcblxudmFyIGlzQ3JlZGl0Q2FyZCA9IHVud3JhcEV4cG9ydHMoaXNDcmVkaXRDYXJkXzEpO1xuXG52YXIgY3JlZGl0X2NhcmQgPSBmdW5jdGlvbiAodmFsdWUpIHsgcmV0dXJuIGlzQ3JlZGl0Q2FyZChTdHJpbmcodmFsdWUpKTsgfTtcblxudmFyIHZhbGlkYXRlJDUgPSBmdW5jdGlvbiAodmFsdWUsIHJlZikge1xuICBpZiAoIHJlZiA9PT0gdm9pZCAwICkgcmVmID0gW107XG4gIHZhciBkZWNpbWFscyA9IHJlZlswXTsgaWYgKCBkZWNpbWFscyA9PT0gdm9pZCAwICkgZGVjaW1hbHMgPSAnKic7XG4gIHZhciBzZXBhcmF0b3IgPSByZWZbMV07IGlmICggc2VwYXJhdG9yID09PSB2b2lkIDAgKSBzZXBhcmF0b3IgPSAnLic7XG5cbiAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgcmV0dXJuIHZhbHVlLmV2ZXJ5KGZ1bmN0aW9uICh2YWwpIHsgcmV0dXJuIHZhbGlkYXRlJDUodmFsLCBbZGVjaW1hbHMsIHNlcGFyYXRvcl0pOyB9KTtcbiAgfVxuXG4gIGlmICh2YWx1ZSA9PT0gbnVsbCB8fCB2YWx1ZSA9PT0gdW5kZWZpbmVkIHx8IHZhbHVlID09PSAnJykge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgLy8gaWYgaXMgMC5cbiAgaWYgKE51bWJlcihkZWNpbWFscykgPT09IDApIHtcbiAgICByZXR1cm4gL14tP1xcZCokLy50ZXN0KHZhbHVlKTtcbiAgfVxuXG4gIHZhciByZWdleFBhcnQgPSBkZWNpbWFscyA9PT0gJyonID8gJysnIDogKFwiezEsXCIgKyBkZWNpbWFscyArIFwifVwiKTtcbiAgdmFyIHJlZ2V4ID0gbmV3IFJlZ0V4cCgoXCJeLT9cXFxcZCooXFxcXFwiICsgc2VwYXJhdG9yICsgXCJcXFxcZFwiICsgcmVnZXhQYXJ0ICsgXCIpPyRcIikpO1xuXG4gIGlmICghIHJlZ2V4LnRlc3QodmFsdWUpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgdmFyIHBhcnNlZFZhbHVlID0gcGFyc2VGbG9hdCh2YWx1ZSk7XG5cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXG4gICAgcmV0dXJuIHBhcnNlZFZhbHVlID09PSBwYXJzZWRWYWx1ZTtcbn07XG5cbnZhciBkYXRlX2JldHdlZW4gPSBmdW5jdGlvbiAodmFsdWUsIHBhcmFtcykge1xuICB2YXIgbWluO1xuICB2YXIgbWF4O1xuICB2YXIgZm9ybWF0O1xuICB2YXIgaW5jbHVzaXZpdHkgPSAnKCknO1xuXG4gIGlmIChwYXJhbXMubGVuZ3RoID4gMykge1xuICAgIHZhciBhc3NpZ247XG4gICAgKGFzc2lnbiA9IHBhcmFtcywgbWluID0gYXNzaWduWzBdLCBtYXggPSBhc3NpZ25bMV0sIGluY2x1c2l2aXR5ID0gYXNzaWduWzJdLCBmb3JtYXQgPSBhc3NpZ25bM10pO1xuICB9IGVsc2Uge1xuICAgIHZhciBhc3NpZ24kMTtcbiAgICAoYXNzaWduJDEgPSBwYXJhbXMsIG1pbiA9IGFzc2lnbiQxWzBdLCBtYXggPSBhc3NpZ24kMVsxXSwgZm9ybWF0ID0gYXNzaWduJDFbMl0pO1xuICB9XG5cbiAgdmFyIG1pbkRhdGUgPSBwYXJzZURhdGUkMShtaW4sIGZvcm1hdCk7XG4gIHZhciBtYXhEYXRlID0gcGFyc2VEYXRlJDEobWF4LCBmb3JtYXQpO1xuICB2YXIgZGF0ZVZhbCA9IHBhcnNlRGF0ZSQxKHZhbHVlLCBmb3JtYXQpO1xuXG4gIGlmICghbWluRGF0ZSB8fCAhbWF4RGF0ZSB8fCAhZGF0ZVZhbCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmIChpbmNsdXNpdml0eSA9PT0gJygpJykge1xuICAgIHJldHVybiBpc0FmdGVyKGRhdGVWYWwsIG1pbkRhdGUpICYmIGlzQmVmb3JlKGRhdGVWYWwsIG1heERhdGUpO1xuICB9XG5cbiAgaWYgKGluY2x1c2l2aXR5ID09PSAnKF0nKSB7XG4gICAgcmV0dXJuIGlzQWZ0ZXIoZGF0ZVZhbCwgbWluRGF0ZSkgJiYgKGlzRXF1YWwkMShkYXRlVmFsLCBtYXhEYXRlKSB8fCBpc0JlZm9yZShkYXRlVmFsLCBtYXhEYXRlKSk7XG4gIH1cblxuICBpZiAoaW5jbHVzaXZpdHkgPT09ICdbKScpIHtcbiAgICByZXR1cm4gaXNCZWZvcmUoZGF0ZVZhbCwgbWF4RGF0ZSkgJiYgKGlzRXF1YWwkMShkYXRlVmFsLCBtaW5EYXRlKSB8fCBpc0FmdGVyKGRhdGVWYWwsIG1pbkRhdGUpKTtcbiAgfVxuXG4gIHJldHVybiBpc0VxdWFsJDEoZGF0ZVZhbCwgbWF4RGF0ZSkgfHwgaXNFcXVhbCQxKGRhdGVWYWwsIG1pbkRhdGUpIHx8XG4gICAgICAgIChpc0JlZm9yZShkYXRlVmFsLCBtYXhEYXRlKSAmJiBpc0FmdGVyKGRhdGVWYWwsIG1pbkRhdGUpKTtcbn07XG5cbnZhciBkYXRlX2Zvcm1hdCA9IGZ1bmN0aW9uICh2YWx1ZSwgcmVmKSB7XG4gIHZhciBmb3JtYXQgPSByZWZbMF07XG5cbiAgcmV0dXJuICEhcGFyc2VEYXRlJDEodmFsdWUsIGZvcm1hdCk7XG59O1xuXG52YXIgdmFsaWRhdGUkNiA9IGZ1bmN0aW9uICh2YWx1ZSwgcmVmKSB7XG4gIHZhciBsZW5ndGggPSByZWZbMF07XG5cbiAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgcmV0dXJuIHZhbHVlLmV2ZXJ5KGZ1bmN0aW9uICh2YWwpIHsgcmV0dXJuIHZhbGlkYXRlJDYodmFsLCBbbGVuZ3RoXSk7IH0pO1xuICB9XG4gIHZhciBzdHJWYWwgPSBTdHJpbmcodmFsdWUpO1xuXG4gIHJldHVybiAvXlswLTldKiQvLnRlc3Qoc3RyVmFsKSAmJiBzdHJWYWwubGVuZ3RoID09PSBOdW1iZXIobGVuZ3RoKTtcbn07XG5cbnZhciB2YWxpZGF0ZUltYWdlID0gZnVuY3Rpb24gKGZpbGUsIHdpZHRoLCBoZWlnaHQpIHtcbiAgdmFyIFVSTCA9IHdpbmRvdy5VUkwgfHwgd2luZG93LndlYmtpdFVSTDtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlKSB7XG4gICAgdmFyIGltYWdlID0gbmV3IEltYWdlKCk7XG4gICAgaW1hZ2Uub25lcnJvciA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHJlc29sdmUoeyB2YWxpZDogZmFsc2UgfSk7IH07XG4gICAgaW1hZ2Uub25sb2FkID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gcmVzb2x2ZSh7XG4gICAgICB2YWxpZDogaW1hZ2Uud2lkdGggPT09IE51bWJlcih3aWR0aCkgJiYgaW1hZ2UuaGVpZ2h0ID09PSBOdW1iZXIoaGVpZ2h0KVxuICAgIH0pOyB9O1xuXG4gICAgaW1hZ2Uuc3JjID0gVVJMLmNyZWF0ZU9iamVjdFVSTChmaWxlKTtcbiAgfSk7XG59O1xuXG52YXIgZGltZW5zaW9ucyA9IGZ1bmN0aW9uIChmaWxlcywgcmVmKSB7XG4gIHZhciB3aWR0aCA9IHJlZlswXTtcbiAgdmFyIGhlaWdodCA9IHJlZlsxXTtcblxuICB2YXIgbGlzdCA9IFtdO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGZpbGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgLy8gaWYgZmlsZSBpcyBub3QgYW4gaW1hZ2UsIHJlamVjdC5cbiAgICBpZiAoISAvXFwuKGpwZ3xzdmd8anBlZ3xwbmd8Ym1wfGdpZikkL2kudGVzdChmaWxlc1tpXS5uYW1lKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGxpc3QucHVzaChmaWxlc1tpXSk7XG4gIH1cblxuICByZXR1cm4gUHJvbWlzZS5hbGwobGlzdC5tYXAoZnVuY3Rpb24gKGZpbGUpIHsgcmV0dXJuIHZhbGlkYXRlSW1hZ2UoZmlsZSwgd2lkdGgsIGhlaWdodCk7IH0pKTtcbn07XG5cbnZhciBtZXJnZV8xID0gY3JlYXRlQ29tbW9uanNNb2R1bGUoZnVuY3Rpb24gKG1vZHVsZSwgZXhwb3J0cykge1xuJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gbWVyZ2U7XG5mdW5jdGlvbiBtZXJnZSgpIHtcbiAgdmFyIG9iaiA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG4gIHZhciBkZWZhdWx0cyA9IGFyZ3VtZW50c1sxXTtcblxuICBmb3IgKHZhciBrZXkgaW4gZGVmYXVsdHMpIHtcbiAgICBpZiAodHlwZW9mIG9ialtrZXldID09PSAndW5kZWZpbmVkJykge1xuICAgICAgb2JqW2tleV0gPSBkZWZhdWx0c1trZXldO1xuICAgIH1cbiAgfVxuICByZXR1cm4gb2JqO1xufVxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG59KTtcblxudW53cmFwRXhwb3J0cyhtZXJnZV8xKTtcblxudmFyIGlzQnl0ZUxlbmd0aF8xID0gY3JlYXRlQ29tbW9uanNNb2R1bGUoZnVuY3Rpb24gKG1vZHVsZSwgZXhwb3J0cykge1xuJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX3R5cGVvZiA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiID8gZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfSA6IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07XG5cbmV4cG9ydHMuZGVmYXVsdCA9IGlzQnl0ZUxlbmd0aDtcblxuXG5cbnZhciBfYXNzZXJ0U3RyaW5nMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoYXNzZXJ0U3RyaW5nXzEpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG4vKiBlc2xpbnQtZGlzYWJsZSBwcmVmZXItcmVzdC1wYXJhbXMgKi9cbmZ1bmN0aW9uIGlzQnl0ZUxlbmd0aChzdHIsIG9wdGlvbnMpIHtcbiAgKDAsIF9hc3NlcnRTdHJpbmcyLmRlZmF1bHQpKHN0cik7XG4gIHZhciBtaW4gPSB2b2lkIDA7XG4gIHZhciBtYXggPSB2b2lkIDA7XG4gIGlmICgodHlwZW9mIG9wdGlvbnMgPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKG9wdGlvbnMpKSA9PT0gJ29iamVjdCcpIHtcbiAgICBtaW4gPSBvcHRpb25zLm1pbiB8fCAwO1xuICAgIG1heCA9IG9wdGlvbnMubWF4O1xuICB9IGVsc2Uge1xuICAgIC8vIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5OiBpc0J5dGVMZW5ndGgoc3RyLCBtaW4gWywgbWF4XSlcbiAgICBtaW4gPSBhcmd1bWVudHNbMV07XG4gICAgbWF4ID0gYXJndW1lbnRzWzJdO1xuICB9XG4gIHZhciBsZW4gPSBlbmNvZGVVUkkoc3RyKS5zcGxpdCgvJS4ufC4vKS5sZW5ndGggLSAxO1xuICByZXR1cm4gbGVuID49IG1pbiAmJiAodHlwZW9mIG1heCA9PT0gJ3VuZGVmaW5lZCcgfHwgbGVuIDw9IG1heCk7XG59XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcbn0pO1xuXG51bndyYXBFeHBvcnRzKGlzQnl0ZUxlbmd0aF8xKTtcblxudmFyIGlzRlFETiA9IGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZ1bmN0aW9uIChtb2R1bGUsIGV4cG9ydHMpIHtcbid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IGlzRkRRTjtcblxuXG5cbnZhciBfYXNzZXJ0U3RyaW5nMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoYXNzZXJ0U3RyaW5nXzEpO1xuXG5cblxudmFyIF9tZXJnZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG1lcmdlXzEpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG52YXIgZGVmYXVsdF9mcWRuX29wdGlvbnMgPSB7XG4gIHJlcXVpcmVfdGxkOiB0cnVlLFxuICBhbGxvd191bmRlcnNjb3JlczogZmFsc2UsXG4gIGFsbG93X3RyYWlsaW5nX2RvdDogZmFsc2Vcbn07XG5cbmZ1bmN0aW9uIGlzRkRRTihzdHIsIG9wdGlvbnMpIHtcbiAgKDAsIF9hc3NlcnRTdHJpbmcyLmRlZmF1bHQpKHN0cik7XG4gIG9wdGlvbnMgPSAoMCwgX21lcmdlMi5kZWZhdWx0KShvcHRpb25zLCBkZWZhdWx0X2ZxZG5fb3B0aW9ucyk7XG5cbiAgLyogUmVtb3ZlIHRoZSBvcHRpb25hbCB0cmFpbGluZyBkb3QgYmVmb3JlIGNoZWNraW5nIHZhbGlkaXR5ICovXG4gIGlmIChvcHRpb25zLmFsbG93X3RyYWlsaW5nX2RvdCAmJiBzdHJbc3RyLmxlbmd0aCAtIDFdID09PSAnLicpIHtcbiAgICBzdHIgPSBzdHIuc3Vic3RyaW5nKDAsIHN0ci5sZW5ndGggLSAxKTtcbiAgfVxuICB2YXIgcGFydHMgPSBzdHIuc3BsaXQoJy4nKTtcbiAgaWYgKG9wdGlvbnMucmVxdWlyZV90bGQpIHtcbiAgICB2YXIgdGxkID0gcGFydHMucG9wKCk7XG4gICAgaWYgKCFwYXJ0cy5sZW5ndGggfHwgIS9eKFthLXpcXHUwMGExLVxcdWZmZmZdezIsfXx4blthLXowLTktXXsyLH0pJC9pLnRlc3QodGxkKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICAvLyBkaXNhbGxvdyBzcGFjZXNcbiAgICBpZiAoL1tcXHNcXHUyMDAyLVxcdTIwMEJcXHUyMDJGXFx1MjA1RlxcdTMwMDBcXHVGRUZGXFx1REI0MFxcdURDMjBdLy50ZXN0KHRsZCkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgZm9yICh2YXIgcGFydCwgaSA9IDA7IGkgPCBwYXJ0cy5sZW5ndGg7IGkrKykge1xuICAgIHBhcnQgPSBwYXJ0c1tpXTtcbiAgICBpZiAob3B0aW9ucy5hbGxvd191bmRlcnNjb3Jlcykge1xuICAgICAgcGFydCA9IHBhcnQucmVwbGFjZSgvXy9nLCAnJyk7XG4gICAgfVxuICAgIGlmICghL15bYS16XFx1MDBhMS1cXHVmZmZmMC05LV0rJC9pLnRlc3QocGFydCkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgLy8gZGlzYWxsb3cgZnVsbC13aWR0aCBjaGFyc1xuICAgIGlmICgvW1xcdWZmMDEtXFx1ZmY1ZV0vLnRlc3QocGFydCkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKHBhcnRbMF0gPT09ICctJyB8fCBwYXJ0W3BhcnQubGVuZ3RoIC0gMV0gPT09ICctJykge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xufSk7XG5cbnVud3JhcEV4cG9ydHMoaXNGUUROKTtcblxudmFyIGlzRW1haWxfMSA9IGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZ1bmN0aW9uIChtb2R1bGUsIGV4cG9ydHMpIHtcbid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IGlzRW1haWw7XG5cblxuXG52YXIgX2Fzc2VydFN0cmluZzIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KGFzc2VydFN0cmluZ18xKTtcblxuXG5cbnZhciBfbWVyZ2UyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChtZXJnZV8xKTtcblxuXG5cbnZhciBfaXNCeXRlTGVuZ3RoMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoaXNCeXRlTGVuZ3RoXzEpO1xuXG5cblxudmFyIF9pc0ZRRE4yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChpc0ZRRE4pO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG52YXIgZGVmYXVsdF9lbWFpbF9vcHRpb25zID0ge1xuICBhbGxvd19kaXNwbGF5X25hbWU6IGZhbHNlLFxuICByZXF1aXJlX2Rpc3BsYXlfbmFtZTogZmFsc2UsXG4gIGFsbG93X3V0ZjhfbG9jYWxfcGFydDogdHJ1ZSxcbiAgcmVxdWlyZV90bGQ6IHRydWVcbn07XG5cbi8qIGVzbGludC1kaXNhYmxlIG1heC1sZW4gKi9cbi8qIGVzbGludC1kaXNhYmxlIG5vLWNvbnRyb2wtcmVnZXggKi9cbnZhciBkaXNwbGF5TmFtZSA9IC9eW2EtelxcZCEjXFwkJSYnXFwqXFwrXFwtXFwvPVxcP1xcXl9ge1xcfH1+XFwuXFx1MDBBMC1cXHVEN0ZGXFx1RjkwMC1cXHVGRENGXFx1RkRGMC1cXHVGRkVGXStbYS16XFxkISNcXCQlJidcXCpcXCtcXC1cXC89XFw/XFxeX2B7XFx8fX5cXCxcXC5cXHUwMEEwLVxcdUQ3RkZcXHVGOTAwLVxcdUZEQ0ZcXHVGREYwLVxcdUZGRUZcXHNdKjwoLispPiQvaTtcbnZhciBlbWFpbFVzZXJQYXJ0ID0gL15bYS16XFxkISNcXCQlJidcXCpcXCtcXC1cXC89XFw/XFxeX2B7XFx8fX5dKyQvaTtcbnZhciBxdW90ZWRFbWFpbFVzZXIgPSAvXihbXFxzXFx4MDEtXFx4MDhcXHgwYlxceDBjXFx4MGUtXFx4MWZcXHg3ZlxceDIxXFx4MjMtXFx4NWJcXHg1ZC1cXHg3ZV18KFxcXFxbXFx4MDEtXFx4MDlcXHgwYlxceDBjXFx4MGQtXFx4N2ZdKSkqJC9pO1xudmFyIGVtYWlsVXNlclV0ZjhQYXJ0ID0gL15bYS16XFxkISNcXCQlJidcXCpcXCtcXC1cXC89XFw/XFxeX2B7XFx8fX5cXHUwMEEwLVxcdUQ3RkZcXHVGOTAwLVxcdUZEQ0ZcXHVGREYwLVxcdUZGRUZdKyQvaTtcbnZhciBxdW90ZWRFbWFpbFVzZXJVdGY4ID0gL14oW1xcc1xceDAxLVxceDA4XFx4MGJcXHgwY1xceDBlLVxceDFmXFx4N2ZcXHgyMVxceDIzLVxceDViXFx4NWQtXFx4N2VcXHUwMEEwLVxcdUQ3RkZcXHVGOTAwLVxcdUZEQ0ZcXHVGREYwLVxcdUZGRUZdfChcXFxcW1xceDAxLVxceDA5XFx4MGJcXHgwY1xceDBkLVxceDdmXFx1MDBBMC1cXHVEN0ZGXFx1RjkwMC1cXHVGRENGXFx1RkRGMC1cXHVGRkVGXSkpKiQvaTtcbi8qIGVzbGludC1lbmFibGUgbWF4LWxlbiAqL1xuLyogZXNsaW50LWVuYWJsZSBuby1jb250cm9sLXJlZ2V4ICovXG5cbmZ1bmN0aW9uIGlzRW1haWwoc3RyLCBvcHRpb25zKSB7XG4gICgwLCBfYXNzZXJ0U3RyaW5nMi5kZWZhdWx0KShzdHIpO1xuICBvcHRpb25zID0gKDAsIF9tZXJnZTIuZGVmYXVsdCkob3B0aW9ucywgZGVmYXVsdF9lbWFpbF9vcHRpb25zKTtcblxuICBpZiAob3B0aW9ucy5yZXF1aXJlX2Rpc3BsYXlfbmFtZSB8fCBvcHRpb25zLmFsbG93X2Rpc3BsYXlfbmFtZSkge1xuICAgIHZhciBkaXNwbGF5X2VtYWlsID0gc3RyLm1hdGNoKGRpc3BsYXlOYW1lKTtcbiAgICBpZiAoZGlzcGxheV9lbWFpbCkge1xuICAgICAgc3RyID0gZGlzcGxheV9lbWFpbFsxXTtcbiAgICB9IGVsc2UgaWYgKG9wdGlvbnMucmVxdWlyZV9kaXNwbGF5X25hbWUpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICB2YXIgcGFydHMgPSBzdHIuc3BsaXQoJ0AnKTtcbiAgdmFyIGRvbWFpbiA9IHBhcnRzLnBvcCgpO1xuICB2YXIgdXNlciA9IHBhcnRzLmpvaW4oJ0AnKTtcblxuICB2YXIgbG93ZXJfZG9tYWluID0gZG9tYWluLnRvTG93ZXJDYXNlKCk7XG4gIGlmIChsb3dlcl9kb21haW4gPT09ICdnbWFpbC5jb20nIHx8IGxvd2VyX2RvbWFpbiA9PT0gJ2dvb2dsZW1haWwuY29tJykge1xuICAgIHVzZXIgPSB1c2VyLnJlcGxhY2UoL1xcLi9nLCAnJykudG9Mb3dlckNhc2UoKTtcbiAgfVxuXG4gIGlmICghKDAsIF9pc0J5dGVMZW5ndGgyLmRlZmF1bHQpKHVzZXIsIHsgbWF4OiA2NCB9KSB8fCAhKDAsIF9pc0J5dGVMZW5ndGgyLmRlZmF1bHQpKGRvbWFpbiwgeyBtYXg6IDI1NCB9KSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmICghKDAsIF9pc0ZRRE4yLmRlZmF1bHQpKGRvbWFpbiwgeyByZXF1aXJlX3RsZDogb3B0aW9ucy5yZXF1aXJlX3RsZCB9KSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmICh1c2VyWzBdID09PSAnXCInKSB7XG4gICAgdXNlciA9IHVzZXIuc2xpY2UoMSwgdXNlci5sZW5ndGggLSAxKTtcbiAgICByZXR1cm4gb3B0aW9ucy5hbGxvd191dGY4X2xvY2FsX3BhcnQgPyBxdW90ZWRFbWFpbFVzZXJVdGY4LnRlc3QodXNlcikgOiBxdW90ZWRFbWFpbFVzZXIudGVzdCh1c2VyKTtcbiAgfVxuXG4gIHZhciBwYXR0ZXJuID0gb3B0aW9ucy5hbGxvd191dGY4X2xvY2FsX3BhcnQgPyBlbWFpbFVzZXJVdGY4UGFydCA6IGVtYWlsVXNlclBhcnQ7XG5cbiAgdmFyIHVzZXJfcGFydHMgPSB1c2VyLnNwbGl0KCcuJyk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdXNlcl9wYXJ0cy5sZW5ndGg7IGkrKykge1xuICAgIGlmICghcGF0dGVybi50ZXN0KHVzZXJfcGFydHNbaV0pKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcbn0pO1xuXG52YXIgaXNFbWFpbCA9IHVud3JhcEV4cG9ydHMoaXNFbWFpbF8xKTtcblxudmFyIHZhbGlkYXRlJDcgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgcmV0dXJuIHZhbHVlLmV2ZXJ5KGZ1bmN0aW9uICh2YWwpIHsgcmV0dXJuIGlzRW1haWwoU3RyaW5nKHZhbCkpOyB9KTtcbiAgfVxuXG4gIHJldHVybiBpc0VtYWlsKFN0cmluZyh2YWx1ZSkpO1xufTtcblxudmFyIGV4dCA9IGZ1bmN0aW9uIChmaWxlcywgZXh0ZW5zaW9ucykge1xuICB2YXIgcmVnZXggPSBuZXcgUmVnRXhwKChcIi4oXCIgKyAoZXh0ZW5zaW9ucy5qb2luKCd8JykpICsgXCIpJFwiKSwgJ2knKTtcblxuICByZXR1cm4gZmlsZXMuZXZlcnkoZnVuY3Rpb24gKGZpbGUpIHsgcmV0dXJuIHJlZ2V4LnRlc3QoZmlsZS5uYW1lKTsgfSk7XG59O1xuXG52YXIgaW1hZ2UgPSBmdW5jdGlvbiAoZmlsZXMpIHsgcmV0dXJuIGZpbGVzLmV2ZXJ5KGZ1bmN0aW9uIChmaWxlKSB7IHJldHVybiAvXFwuKGpwZ3xzdmd8anBlZ3xwbmd8Ym1wfGdpZikkL2kudGVzdChmaWxlLm5hbWUpOyB9XG4pOyB9O1xuXG52YXIgdmFsaWRhdGUkOCA9IGZ1bmN0aW9uICh2YWx1ZSwgb3B0aW9ucykge1xuICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICByZXR1cm4gdmFsdWUuZXZlcnkoZnVuY3Rpb24gKHZhbCkgeyByZXR1cm4gdmFsaWRhdGUkOCh2YWwsIG9wdGlvbnMpOyB9KTtcbiAgfVxuXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxuICByZXR1cm4gISEgb3B0aW9ucy5maWx0ZXIoZnVuY3Rpb24gKG9wdGlvbikgeyByZXR1cm4gb3B0aW9uID09IHZhbHVlOyB9KS5sZW5ndGg7XG59O1xuXG52YXIgaXNJUF8xID0gY3JlYXRlQ29tbW9uanNNb2R1bGUoZnVuY3Rpb24gKG1vZHVsZSwgZXhwb3J0cykge1xuJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gaXNJUDtcblxuXG5cbnZhciBfYXNzZXJ0U3RyaW5nMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoYXNzZXJ0U3RyaW5nXzEpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG52YXIgaXB2NE1heWJlID0gL14oXFxkezEsM30pXFwuKFxcZHsxLDN9KVxcLihcXGR7MSwzfSlcXC4oXFxkezEsM30pJC87XG52YXIgaXB2NkJsb2NrID0gL15bMC05QS1GXXsxLDR9JC9pO1xuXG5mdW5jdGlvbiBpc0lQKHN0cikge1xuICB2YXIgdmVyc2lvbiA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogJyc7XG5cbiAgKDAsIF9hc3NlcnRTdHJpbmcyLmRlZmF1bHQpKHN0cik7XG4gIHZlcnNpb24gPSBTdHJpbmcodmVyc2lvbik7XG4gIGlmICghdmVyc2lvbikge1xuICAgIHJldHVybiBpc0lQKHN0ciwgNCkgfHwgaXNJUChzdHIsIDYpO1xuICB9IGVsc2UgaWYgKHZlcnNpb24gPT09ICc0Jykge1xuICAgIGlmICghaXB2NE1heWJlLnRlc3Qoc3RyKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICB2YXIgcGFydHMgPSBzdHIuc3BsaXQoJy4nKS5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICByZXR1cm4gYSAtIGI7XG4gICAgfSk7XG4gICAgcmV0dXJuIHBhcnRzWzNdIDw9IDI1NTtcbiAgfSBlbHNlIGlmICh2ZXJzaW9uID09PSAnNicpIHtcbiAgICB2YXIgYmxvY2tzID0gc3RyLnNwbGl0KCc6Jyk7XG4gICAgdmFyIGZvdW5kT21pc3Npb25CbG9jayA9IGZhbHNlOyAvLyBtYXJrZXIgdG8gaW5kaWNhdGUgOjpcblxuICAgIC8vIEF0IGxlYXN0IHNvbWUgT1MgYWNjZXB0IHRoZSBsYXN0IDMyIGJpdHMgb2YgYW4gSVB2NiBhZGRyZXNzXG4gICAgLy8gKGkuZS4gMiBvZiB0aGUgYmxvY2tzKSBpbiBJUHY0IG5vdGF0aW9uLCBhbmQgUkZDIDM0OTMgc2F5c1xuICAgIC8vIHRoYXQgJzo6ZmZmZjphLmIuYy5kJyBpcyB2YWxpZCBmb3IgSVB2NC1tYXBwZWQgSVB2NiBhZGRyZXNzZXMsXG4gICAgLy8gYW5kICc6OmEuYi5jLmQnIGlzIGRlcHJlY2F0ZWQsIGJ1dCBhbHNvIHZhbGlkLlxuICAgIHZhciBmb3VuZElQdjRUcmFuc2l0aW9uQmxvY2sgPSBpc0lQKGJsb2Nrc1tibG9ja3MubGVuZ3RoIC0gMV0sIDQpO1xuICAgIHZhciBleHBlY3RlZE51bWJlck9mQmxvY2tzID0gZm91bmRJUHY0VHJhbnNpdGlvbkJsb2NrID8gNyA6IDg7XG5cbiAgICBpZiAoYmxvY2tzLmxlbmd0aCA+IGV4cGVjdGVkTnVtYmVyT2ZCbG9ja3MpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgLy8gaW5pdGlhbCBvciBmaW5hbCA6OlxuICAgIGlmIChzdHIgPT09ICc6OicpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSBpZiAoc3RyLnN1YnN0cigwLCAyKSA9PT0gJzo6Jykge1xuICAgICAgYmxvY2tzLnNoaWZ0KCk7XG4gICAgICBibG9ja3Muc2hpZnQoKTtcbiAgICAgIGZvdW5kT21pc3Npb25CbG9jayA9IHRydWU7XG4gICAgfSBlbHNlIGlmIChzdHIuc3Vic3RyKHN0ci5sZW5ndGggLSAyKSA9PT0gJzo6Jykge1xuICAgICAgYmxvY2tzLnBvcCgpO1xuICAgICAgYmxvY2tzLnBvcCgpO1xuICAgICAgZm91bmRPbWlzc2lvbkJsb2NrID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJsb2Nrcy5sZW5ndGg7ICsraSkge1xuICAgICAgLy8gdGVzdCBmb3IgYSA6OiB3aGljaCBjYW4gbm90IGJlIGF0IHRoZSBzdHJpbmcgc3RhcnQvZW5kXG4gICAgICAvLyBzaW5jZSB0aG9zZSBjYXNlcyBoYXZlIGJlZW4gaGFuZGxlZCBhYm92ZVxuICAgICAgaWYgKGJsb2Nrc1tpXSA9PT0gJycgJiYgaSA+IDAgJiYgaSA8IGJsb2Nrcy5sZW5ndGggLSAxKSB7XG4gICAgICAgIGlmIChmb3VuZE9taXNzaW9uQmxvY2spIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7IC8vIG11bHRpcGxlIDo6IGluIGFkZHJlc3NcbiAgICAgICAgfVxuICAgICAgICBmb3VuZE9taXNzaW9uQmxvY2sgPSB0cnVlO1xuICAgICAgfSBlbHNlIGlmIChmb3VuZElQdjRUcmFuc2l0aW9uQmxvY2sgJiYgaSA9PT0gYmxvY2tzLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgLy8gaXQgaGFzIGJlZW4gY2hlY2tlZCBiZWZvcmUgdGhhdCB0aGUgbGFzdFxuICAgICAgICAvLyBibG9jayBpcyBhIHZhbGlkIElQdjQgYWRkcmVzc1xuICAgICAgfSBlbHNlIGlmICghaXB2NkJsb2NrLnRlc3QoYmxvY2tzW2ldKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChmb3VuZE9taXNzaW9uQmxvY2spIHtcbiAgICAgIHJldHVybiBibG9ja3MubGVuZ3RoID49IDE7XG4gICAgfVxuICAgIHJldHVybiBibG9ja3MubGVuZ3RoID09PSBleHBlY3RlZE51bWJlck9mQmxvY2tzO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xufSk7XG5cbnZhciBpc0lQID0gdW53cmFwRXhwb3J0cyhpc0lQXzEpO1xuXG52YXIgaXAgPSBmdW5jdGlvbiAodmFsdWUsIHJlZikge1xuICBpZiAoIHJlZiA9PT0gdm9pZCAwICkgcmVmID0gW107XG4gIHZhciB2ZXJzaW9uID0gcmVmWzBdOyBpZiAoIHZlcnNpb24gPT09IHZvaWQgMCApIHZlcnNpb24gPSA0O1xuXG4gIGlmIChpc051bGxPclVuZGVmaW5lZCh2YWx1ZSkpIHtcbiAgICB2YWx1ZSA9ICcnO1xuICB9XG5cbiAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgcmV0dXJuIHZhbHVlLmV2ZXJ5KGZ1bmN0aW9uICh2YWwpIHsgcmV0dXJuIGlzSVAodmFsLCB2ZXJzaW9uKTsgfSk7XG4gIH1cblxuICByZXR1cm4gaXNJUCh2YWx1ZSwgdmVyc2lvbik7XG59O1xuXG52YXIgaXMgPSBmdW5jdGlvbiAodmFsdWUsIHJlZikge1xuICBpZiAoIHJlZiA9PT0gdm9pZCAwICkgcmVmID0gW107XG4gIHZhciBvdGhlciA9IHJlZlswXTtcblxuICByZXR1cm4gdmFsdWUgPT09IG90aGVyO1xufTtcblxudmFyIGlzX25vdCA9IGZ1bmN0aW9uICh2YWx1ZSwgcmVmKSB7XG4gIGlmICggcmVmID09PSB2b2lkIDAgKSByZWYgPSBbXTtcbiAgdmFyIG90aGVyID0gcmVmWzBdO1xuXG4gIHJldHVybiB2YWx1ZSAhPT0gb3RoZXI7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7QXJyYXl8U3RyaW5nfSB2YWx1ZVxuICogQHBhcmFtIHtOdW1iZXJ9IGxlbmd0aFxuICogQHBhcmFtIHtOdW1iZXJ9IG1heFxuICovXG52YXIgY29tcGFyZSA9IGZ1bmN0aW9uICh2YWx1ZSwgbGVuZ3RoLCBtYXgpIHtcbiAgaWYgKG1heCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIHZhbHVlLmxlbmd0aCA9PT0gbGVuZ3RoO1xuICB9XG5cbiAgLy8gY2FzdCB0byBudW1iZXIuXG4gIG1heCA9IE51bWJlcihtYXgpO1xuXG4gIHJldHVybiB2YWx1ZS5sZW5ndGggPj0gbGVuZ3RoICYmIHZhbHVlLmxlbmd0aCA8PSBtYXg7XG59O1xuXG52YXIgbGVuZ3RoID0gZnVuY3Rpb24gKHZhbHVlLCByZWYpIHtcbiAgdmFyIGxlbmd0aCA9IHJlZlswXTtcbiAgdmFyIG1heCA9IHJlZlsxXTsgaWYgKCBtYXggPT09IHZvaWQgMCApIG1heCA9IHVuZGVmaW5lZDtcblxuICBsZW5ndGggPSBOdW1iZXIobGVuZ3RoKTtcbiAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQgfHwgdmFsdWUgPT09IG51bGwpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykge1xuICAgIHZhbHVlID0gU3RyaW5nKHZhbHVlKTtcbiAgfVxuXG4gIGlmICghdmFsdWUubGVuZ3RoKSB7XG4gICAgdmFsdWUgPSB0b0FycmF5KHZhbHVlKTtcbiAgfVxuXG4gIHJldHVybiBjb21wYXJlKHZhbHVlLCBsZW5ndGgsIG1heCk7XG59O1xuXG52YXIgaW50ZWdlciA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICByZXR1cm4gdmFsdWUuZXZlcnkoZnVuY3Rpb24gKHZhbCkgeyByZXR1cm4gL14tP1swLTldKyQvLnRlc3QoU3RyaW5nKHZhbCkpOyB9KTtcbiAgfVxuXG4gIHJldHVybiAvXi0/WzAtOV0rJC8udGVzdChTdHJpbmcodmFsdWUpKTtcbn07XG5cbnZhciBtYXgkMSA9IGZ1bmN0aW9uICh2YWx1ZSwgcmVmKSB7XG4gIHZhciBsZW5ndGggPSByZWZbMF07XG5cbiAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQgfHwgdmFsdWUgPT09IG51bGwpIHtcbiAgICByZXR1cm4gbGVuZ3RoID49IDA7XG4gIH1cblxuICByZXR1cm4gU3RyaW5nKHZhbHVlKS5sZW5ndGggPD0gbGVuZ3RoO1xufTtcblxudmFyIG1heF92YWx1ZSA9IGZ1bmN0aW9uICh2YWx1ZSwgcmVmKSB7XG4gIHZhciBtYXggPSByZWZbMF07XG5cbiAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpIHx8IHZhbHVlID09PSBudWxsIHx8IHZhbHVlID09PSB1bmRlZmluZWQgfHwgdmFsdWUgPT09ICcnKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIE51bWJlcih2YWx1ZSkgPD0gbWF4O1xufTtcblxudmFyIG1pbWVzID0gZnVuY3Rpb24gKGZpbGVzLCBtaW1lcykge1xuICB2YXIgcmVnZXggPSBuZXcgUmVnRXhwKCgobWltZXMuam9pbignfCcpLnJlcGxhY2UoJyonLCAnLisnKSkgKyBcIiRcIiksICdpJyk7XG5cbiAgcmV0dXJuIGZpbGVzLmV2ZXJ5KGZ1bmN0aW9uIChmaWxlKSB7IHJldHVybiByZWdleC50ZXN0KGZpbGUudHlwZSk7IH0pO1xufTtcblxudmFyIG1pbiQxID0gZnVuY3Rpb24gKHZhbHVlLCByZWYpIHtcbiAgdmFyIGxlbmd0aCA9IHJlZlswXTtcblxuICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCB8fCB2YWx1ZSA9PT0gbnVsbCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gU3RyaW5nKHZhbHVlKS5sZW5ndGggPj0gbGVuZ3RoO1xufTtcblxudmFyIG1pbl92YWx1ZSA9IGZ1bmN0aW9uICh2YWx1ZSwgcmVmKSB7XG4gIHZhciBtaW4gPSByZWZbMF07XG5cbiAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpIHx8IHZhbHVlID09PSBudWxsIHx8IHZhbHVlID09PSB1bmRlZmluZWQgfHwgdmFsdWUgPT09ICcnKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIE51bWJlcih2YWx1ZSkgPj0gbWluO1xufTtcblxudmFyIHZhbGlkYXRlJDkgPSBmdW5jdGlvbiAodmFsdWUsIG9wdGlvbnMpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgcmV0dXJuIHZhbHVlLmV2ZXJ5KGZ1bmN0aW9uICh2YWwpIHsgcmV0dXJuIHZhbGlkYXRlJDkodmFsLCBvcHRpb25zKTsgfSk7XG4gIH1cblxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcbiAgcmV0dXJuICEgb3B0aW9ucy5maWx0ZXIoZnVuY3Rpb24gKG9wdGlvbikgeyByZXR1cm4gb3B0aW9uID09IHZhbHVlOyB9KS5sZW5ndGg7XG59O1xuXG52YXIgbnVtZXJpYyA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICByZXR1cm4gdmFsdWUuZXZlcnkoZnVuY3Rpb24gKHZhbCkgeyByZXR1cm4gL15bMC05XSskLy50ZXN0KFN0cmluZyh2YWwpKTsgfSk7XG4gIH1cblxuICByZXR1cm4gL15bMC05XSskLy50ZXN0KFN0cmluZyh2YWx1ZSkpO1xufTtcblxudmFyIHJlZ2V4ID0gZnVuY3Rpb24gKHZhbHVlLCByZWYpIHtcbiAgdmFyIHJlZ2V4ID0gcmVmWzBdO1xuICB2YXIgZmxhZ3MgPSByZWYuc2xpY2UoMSk7XG5cbiAgaWYgKHJlZ2V4IGluc3RhbmNlb2YgUmVnRXhwKSB7XG4gICAgcmV0dXJuIHJlZ2V4LnRlc3QodmFsdWUpO1xuICB9XG5cbiAgcmV0dXJuIG5ldyBSZWdFeHAocmVnZXgsIGZsYWdzKS50ZXN0KFN0cmluZyh2YWx1ZSkpO1xufTtcblxudmFyIHJlcXVpcmVkID0gZnVuY3Rpb24gKHZhbHVlLCByZWYpIHtcbiAgaWYgKCByZWYgPT09IHZvaWQgMCApIHJlZiA9IFtdO1xuICB2YXIgaW52YWxpZGF0ZUZhbHNlID0gcmVmWzBdOyBpZiAoIGludmFsaWRhdGVGYWxzZSA9PT0gdm9pZCAwICkgaW52YWxpZGF0ZUZhbHNlID0gZmFsc2U7XG5cbiAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgcmV0dXJuICEhIHZhbHVlLmxlbmd0aDtcbiAgfVxuXG4gIC8vIGluY2FzZSBhIGZpZWxkIGNvbnNpZGVycyBgZmFsc2VgIGFzIGFuIGVtcHR5IHZhbHVlIGxpa2UgY2hlY2tib3hlcy5cbiAgaWYgKHZhbHVlID09PSBmYWxzZSAmJiBpbnZhbGlkYXRlRmFsc2UpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCB8fCB2YWx1ZSA9PT0gbnVsbCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiAhISBTdHJpbmcodmFsdWUpLnRyaW0oKS5sZW5ndGg7XG59O1xuXG52YXIgc2l6ZSA9IGZ1bmN0aW9uIChmaWxlcywgcmVmKSB7XG4gIHZhciBzaXplID0gcmVmWzBdO1xuXG4gIGlmIChpc05hTihzaXplKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHZhciBuU2l6ZSA9IE51bWJlcihzaXplKSAqIDEwMjQ7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgZmlsZXMubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoZmlsZXNbaV0uc2l6ZSA+IG5TaXplKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59O1xuXG52YXIgaXNVUkxfMSA9IGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZ1bmN0aW9uIChtb2R1bGUsIGV4cG9ydHMpIHtcbid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IGlzVVJMO1xuXG5cblxudmFyIF9hc3NlcnRTdHJpbmcyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChhc3NlcnRTdHJpbmdfMSk7XG5cblxuXG52YXIgX2lzRlFETjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KGlzRlFETik7XG5cblxuXG52YXIgX2lzSVAyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChpc0lQXzEpO1xuXG5cblxudmFyIF9tZXJnZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG1lcmdlXzEpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG52YXIgZGVmYXVsdF91cmxfb3B0aW9ucyA9IHtcbiAgcHJvdG9jb2xzOiBbJ2h0dHAnLCAnaHR0cHMnLCAnZnRwJ10sXG4gIHJlcXVpcmVfdGxkOiB0cnVlLFxuICByZXF1aXJlX3Byb3RvY29sOiBmYWxzZSxcbiAgcmVxdWlyZV9ob3N0OiB0cnVlLFxuICByZXF1aXJlX3ZhbGlkX3Byb3RvY29sOiB0cnVlLFxuICBhbGxvd191bmRlcnNjb3JlczogZmFsc2UsXG4gIGFsbG93X3RyYWlsaW5nX2RvdDogZmFsc2UsXG4gIGFsbG93X3Byb3RvY29sX3JlbGF0aXZlX3VybHM6IGZhbHNlXG59O1xuXG52YXIgd3JhcHBlZF9pcHY2ID0gL15cXFsoW15cXF1dKylcXF0oPzo6KFswLTldKykpPyQvO1xuXG5mdW5jdGlvbiBpc1JlZ0V4cChvYmopIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmopID09PSAnW29iamVjdCBSZWdFeHBdJztcbn1cblxuZnVuY3Rpb24gY2hlY2tIb3N0KGhvc3QsIG1hdGNoZXMpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBtYXRjaGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIG1hdGNoID0gbWF0Y2hlc1tpXTtcbiAgICBpZiAoaG9zdCA9PT0gbWF0Y2ggfHwgaXNSZWdFeHAobWF0Y2gpICYmIG1hdGNoLnRlc3QoaG9zdCkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGlzVVJMKHVybCwgb3B0aW9ucykge1xuICAoMCwgX2Fzc2VydFN0cmluZzIuZGVmYXVsdCkodXJsKTtcbiAgaWYgKCF1cmwgfHwgdXJsLmxlbmd0aCA+PSAyMDgzIHx8IC9bXFxzPD5dLy50ZXN0KHVybCkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKHVybC5pbmRleE9mKCdtYWlsdG86JykgPT09IDApIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgb3B0aW9ucyA9ICgwLCBfbWVyZ2UyLmRlZmF1bHQpKG9wdGlvbnMsIGRlZmF1bHRfdXJsX29wdGlvbnMpO1xuICB2YXIgcHJvdG9jb2wgPSB2b2lkIDAsXG4gICAgICBhdXRoID0gdm9pZCAwLFxuICAgICAgaG9zdCA9IHZvaWQgMCxcbiAgICAgIGhvc3RuYW1lID0gdm9pZCAwLFxuICAgICAgcG9ydCA9IHZvaWQgMCxcbiAgICAgIHBvcnRfc3RyID0gdm9pZCAwLFxuICAgICAgc3BsaXQgPSB2b2lkIDAsXG4gICAgICBpcHY2ID0gdm9pZCAwO1xuXG4gIHNwbGl0ID0gdXJsLnNwbGl0KCcjJyk7XG4gIHVybCA9IHNwbGl0LnNoaWZ0KCk7XG5cbiAgc3BsaXQgPSB1cmwuc3BsaXQoJz8nKTtcbiAgdXJsID0gc3BsaXQuc2hpZnQoKTtcblxuICBzcGxpdCA9IHVybC5zcGxpdCgnOi8vJyk7XG4gIGlmIChzcGxpdC5sZW5ndGggPiAxKSB7XG4gICAgcHJvdG9jb2wgPSBzcGxpdC5zaGlmdCgpO1xuICAgIGlmIChvcHRpb25zLnJlcXVpcmVfdmFsaWRfcHJvdG9jb2wgJiYgb3B0aW9ucy5wcm90b2NvbHMuaW5kZXhPZihwcm90b2NvbCkgPT09IC0xKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9IGVsc2UgaWYgKG9wdGlvbnMucmVxdWlyZV9wcm90b2NvbCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfSBlbHNlIGlmIChvcHRpb25zLmFsbG93X3Byb3RvY29sX3JlbGF0aXZlX3VybHMgJiYgdXJsLnN1YnN0cigwLCAyKSA9PT0gJy8vJykge1xuICAgIHNwbGl0WzBdID0gdXJsLnN1YnN0cigyKTtcbiAgfVxuICB1cmwgPSBzcGxpdC5qb2luKCc6Ly8nKTtcblxuICBpZiAodXJsID09PSAnJykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHNwbGl0ID0gdXJsLnNwbGl0KCcvJyk7XG4gIHVybCA9IHNwbGl0LnNoaWZ0KCk7XG5cbiAgaWYgKHVybCA9PT0gJycgJiYgIW9wdGlvbnMucmVxdWlyZV9ob3N0KSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBzcGxpdCA9IHVybC5zcGxpdCgnQCcpO1xuICBpZiAoc3BsaXQubGVuZ3RoID4gMSkge1xuICAgIGF1dGggPSBzcGxpdC5zaGlmdCgpO1xuICAgIGlmIChhdXRoLmluZGV4T2YoJzonKSA+PSAwICYmIGF1dGguc3BsaXQoJzonKS5sZW5ndGggPiAyKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIGhvc3RuYW1lID0gc3BsaXQuam9pbignQCcpO1xuXG4gIHBvcnRfc3RyID0gbnVsbDtcbiAgaXB2NiA9IG51bGw7XG4gIHZhciBpcHY2X21hdGNoID0gaG9zdG5hbWUubWF0Y2god3JhcHBlZF9pcHY2KTtcbiAgaWYgKGlwdjZfbWF0Y2gpIHtcbiAgICBob3N0ID0gJyc7XG4gICAgaXB2NiA9IGlwdjZfbWF0Y2hbMV07XG4gICAgcG9ydF9zdHIgPSBpcHY2X21hdGNoWzJdIHx8IG51bGw7XG4gIH0gZWxzZSB7XG4gICAgc3BsaXQgPSBob3N0bmFtZS5zcGxpdCgnOicpO1xuICAgIGhvc3QgPSBzcGxpdC5zaGlmdCgpO1xuICAgIGlmIChzcGxpdC5sZW5ndGgpIHtcbiAgICAgIHBvcnRfc3RyID0gc3BsaXQuam9pbignOicpO1xuICAgIH1cbiAgfVxuXG4gIGlmIChwb3J0X3N0ciAhPT0gbnVsbCkge1xuICAgIHBvcnQgPSBwYXJzZUludChwb3J0X3N0ciwgMTApO1xuICAgIGlmICghL15bMC05XSskLy50ZXN0KHBvcnRfc3RyKSB8fCBwb3J0IDw9IDAgfHwgcG9ydCA+IDY1NTM1KSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgaWYgKCEoMCwgX2lzSVAyLmRlZmF1bHQpKGhvc3QpICYmICEoMCwgX2lzRlFETjIuZGVmYXVsdCkoaG9zdCwgb3B0aW9ucykgJiYgKCFpcHY2IHx8ICEoMCwgX2lzSVAyLmRlZmF1bHQpKGlwdjYsIDYpKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGhvc3QgPSBob3N0IHx8IGlwdjY7XG5cbiAgaWYgKG9wdGlvbnMuaG9zdF93aGl0ZWxpc3QgJiYgIWNoZWNrSG9zdChob3N0LCBvcHRpb25zLmhvc3Rfd2hpdGVsaXN0KSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAob3B0aW9ucy5ob3N0X2JsYWNrbGlzdCAmJiBjaGVja0hvc3QoaG9zdCwgb3B0aW9ucy5ob3N0X2JsYWNrbGlzdCkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xufSk7XG5cbnZhciBpc1VSTCA9IHVud3JhcEV4cG9ydHMoaXNVUkxfMSk7XG5cbnZhciB1cmwgPSBmdW5jdGlvbiAodmFsdWUsIHJlZikge1xuICBpZiAoIHJlZiA9PT0gdm9pZCAwICkgcmVmID0gW107XG4gIHZhciByZXF1aXJlUHJvdG9jb2wgPSByZWZbMF07IGlmICggcmVxdWlyZVByb3RvY29sID09PSB2b2lkIDAgKSByZXF1aXJlUHJvdG9jb2wgPSBmYWxzZTtcblxuICB2YXIgb3B0aW9ucyA9IHsgcmVxdWlyZV9wcm90b2NvbDogISFyZXF1aXJlUHJvdG9jb2wsIGFsbG93X3VuZGVyc2NvcmVzOiB0cnVlIH07XG4gIGlmIChpc051bGxPclVuZGVmaW5lZCh2YWx1ZSkpIHtcbiAgICB2YWx1ZSA9ICcnO1xuICB9XG5cbiAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgcmV0dXJuIHZhbHVlLmV2ZXJ5KGZ1bmN0aW9uICh2YWwpIHsgcmV0dXJuIGlzVVJMKHZhbCwgb3B0aW9ucyk7IH0pO1xuICB9XG5cbiAgcmV0dXJuIGlzVVJMKHZhbHVlLCBvcHRpb25zKTtcbn07XG5cbi8qIGVzbGludC1kaXNhYmxlIGNhbWVsY2FzZSAqL1xudmFyIFJ1bGVzID0ge1xuICBhZnRlcjogYWZ0ZXIsXG4gIGFscGhhX2Rhc2g6IHZhbGlkYXRlJDEsXG4gIGFscGhhX251bTogdmFsaWRhdGUkMixcbiAgYWxwaGFfc3BhY2VzOiB2YWxpZGF0ZSQzLFxuICBhbHBoYTogdmFsaWRhdGUsXG4gIGJlZm9yZTogYmVmb3JlLFxuICBiZXR3ZWVuOiB2YWxpZGF0ZSQ0LFxuICBjb25maXJtZWQ6IGNvbmZpcm1lZCxcbiAgY3JlZGl0X2NhcmQ6IGNyZWRpdF9jYXJkLFxuICBkYXRlX2JldHdlZW46IGRhdGVfYmV0d2VlbixcbiAgZGF0ZV9mb3JtYXQ6IGRhdGVfZm9ybWF0LFxuICBkZWNpbWFsOiB2YWxpZGF0ZSQ1LFxuICBkaWdpdHM6IHZhbGlkYXRlJDYsXG4gIGRpbWVuc2lvbnM6IGRpbWVuc2lvbnMsXG4gIGVtYWlsOiB2YWxpZGF0ZSQ3LFxuICBleHQ6IGV4dCxcbiAgaW1hZ2U6IGltYWdlLFxuICBpbjogdmFsaWRhdGUkOCxcbiAgaW50ZWdlcjogaW50ZWdlcixcbiAgbGVuZ3RoOiBsZW5ndGgsXG4gIGlwOiBpcCxcbiAgaXNfbm90OiBpc19ub3QsXG4gIGlzOiBpcyxcbiAgbWF4OiBtYXgkMSxcbiAgbWF4X3ZhbHVlOiBtYXhfdmFsdWUsXG4gIG1pbWVzOiBtaW1lcyxcbiAgbWluOiBtaW4kMSxcbiAgbWluX3ZhbHVlOiBtaW5fdmFsdWUsXG4gIG5vdF9pbjogdmFsaWRhdGUkOSxcbiAgbnVtZXJpYzogbnVtZXJpYyxcbiAgcmVnZXg6IHJlZ2V4LFxuICByZXF1aXJlZDogcmVxdWlyZWQsXG4gIHNpemU6IHNpemUsXG4gIHVybDogdXJsXG59O1xuXG4vLyBcblxudmFyIG5vcm1hbGl6ZSA9IGZ1bmN0aW9uIChmaWVsZHMpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoZmllbGRzKSkge1xuICAgIHJldHVybiBmaWVsZHMucmVkdWNlKGZ1bmN0aW9uIChwcmV2LCBjdXJyKSB7XG4gICAgICBpZiAofmN1cnIuaW5kZXhPZignLicpKSB7XG4gICAgICAgIHByZXZbY3Vyci5zcGxpdCgnLicpWzFdXSA9IGN1cnI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwcmV2W2N1cnJdID0gY3VycjtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHByZXY7XG4gICAgfSwge30pO1xuICB9XG5cbiAgcmV0dXJuIGZpZWxkcztcbn07XG5cbi8vIENvbWJpbmVzIHR3byBmbGFncyB1c2luZyBlaXRoZXIgQU5EIG9yIE9SIGRlcGVuZGluZyBvbiB0aGUgZmxhZyB0eXBlLlxudmFyIGNvbWJpbmUgPSBmdW5jdGlvbiAobGhzLCByaHMpIHtcbiAgdmFyIG1hcHBlciA9IHtcbiAgICBwcmlzdGluZTogZnVuY3Rpb24gKGxocywgcmhzKSB7IHJldHVybiBsaHMgJiYgcmhzOyB9LFxuICAgIGRpcnR5OiBmdW5jdGlvbiAobGhzLCByaHMpIHsgcmV0dXJuIGxocyB8fCByaHM7IH0sXG4gICAgdG91Y2hlZDogZnVuY3Rpb24gKGxocywgcmhzKSB7IHJldHVybiBsaHMgfHwgcmhzOyB9LFxuICAgIHVudG91Y2hlZDogZnVuY3Rpb24gKGxocywgcmhzKSB7IHJldHVybiBsaHMgJiYgcmhzOyB9LFxuICAgIHZhbGlkOiBmdW5jdGlvbiAobGhzLCByaHMpIHsgcmV0dXJuIGxocyAmJiByaHM7IH0sXG4gICAgaW52YWxpZDogZnVuY3Rpb24gKGxocywgcmhzKSB7IHJldHVybiBsaHMgfHwgcmhzOyB9LFxuICAgIHBlbmRpbmc6IGZ1bmN0aW9uIChsaHMsIHJocykgeyByZXR1cm4gbGhzIHx8IHJoczsgfSxcbiAgICByZXF1aXJlZDogZnVuY3Rpb24gKGxocywgcmhzKSB7IHJldHVybiBsaHMgfHwgcmhzOyB9LFxuICAgIHZhbGlkYXRlZDogZnVuY3Rpb24gKGxocywgcmhzKSB7IHJldHVybiBsaHMgJiYgcmhzOyB9XG4gIH07XG5cbiAgcmV0dXJuIE9iamVjdC5rZXlzKG1hcHBlcikucmVkdWNlKGZ1bmN0aW9uIChmbGFncywgZmxhZykge1xuICAgIGZsYWdzW2ZsYWddID0gbWFwcGVyW2ZsYWddKGxoc1tmbGFnXSwgcmhzW2ZsYWddKTtcblxuICAgIHJldHVybiBmbGFncztcbiAgfSwge30pO1xufTtcblxudmFyIG1hcFNjb3BlID0gZnVuY3Rpb24gKHNjb3BlLCBkZWVwKSB7XG4gIGlmICggZGVlcCA9PT0gdm9pZCAwICkgZGVlcCA9IHRydWU7XG5cbiAgcmV0dXJuIE9iamVjdC5rZXlzKHNjb3BlKS5yZWR1Y2UoZnVuY3Rpb24gKGZsYWdzLCBmaWVsZCkge1xuICAgIGlmICghZmxhZ3MpIHtcbiAgICAgIGZsYWdzID0gYXNzaWduKHt9LCBzY29wZVtmaWVsZF0pO1xuICAgICAgcmV0dXJuIGZsYWdzO1xuICAgIH1cblxuICAgIC8vIHNjb3BlLlxuICAgIHZhciBpc1Njb3BlID0gZmllbGQuaW5kZXhPZignJCcpID09PSAwO1xuICAgIGlmIChkZWVwICYmIGlzU2NvcGUpIHtcbiAgICAgIHJldHVybiBjb21iaW5lKG1hcFNjb3BlKHNjb3BlW2ZpZWxkXSksIGZsYWdzKTtcbiAgICB9IGVsc2UgaWYgKCFkZWVwICYmIGlzU2NvcGUpIHtcbiAgICAgIHJldHVybiBmbGFncztcbiAgICB9XG5cbiAgICBmbGFncyA9IGNvbWJpbmUoZmxhZ3MsIHNjb3BlW2ZpZWxkXSk7XG5cbiAgICByZXR1cm4gZmxhZ3M7XG4gIH0sIG51bGwpO1xufTtcblxuLyoqXG4gKiBNYXBzIGZpZWxkcyB0byBjb21wdXRlZCBmdW5jdGlvbnMuXG4gKi9cbnZhciBtYXBGaWVsZHMgPSBmdW5jdGlvbiAoZmllbGRzKSB7XG4gIGlmICghZmllbGRzKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBtYXBTY29wZSh0aGlzLiR2YWxpZGF0b3IuZmxhZ3MpO1xuICAgIH07XG4gIH1cblxuICB2YXIgbm9ybWFsaXplZCA9IG5vcm1hbGl6ZShmaWVsZHMpO1xuICByZXR1cm4gT2JqZWN0LmtleXMobm9ybWFsaXplZCkucmVkdWNlKGZ1bmN0aW9uIChwcmV2LCBjdXJyKSB7XG4gICAgdmFyIGZpZWxkID0gbm9ybWFsaXplZFtjdXJyXTtcbiAgICBwcmV2W2N1cnJdID0gZnVuY3Rpb24gbWFwcGVkRmllbGQgKCkge1xuICAgICAgLy8gaWYgZmllbGQgZXhpc3RzXG4gICAgICBpZiAodGhpcy4kdmFsaWRhdG9yLmZsYWdzW2ZpZWxkXSkge1xuICAgICAgICByZXR1cm4gdGhpcy4kdmFsaWRhdG9yLmZsYWdzW2ZpZWxkXTtcbiAgICAgIH1cblxuICAgICAgLy8gc2NvcGVsZXNzIGZpZWxkcyB3ZXJlIHNlbGVjdGVkLlxuICAgICAgaWYgKG5vcm1hbGl6ZWRbY3Vycl0gPT09ICcqJykge1xuICAgICAgICByZXR1cm4gbWFwU2NvcGUodGhpcy4kdmFsaWRhdG9yLmZsYWdzLCBmYWxzZSk7XG4gICAgICB9XG5cbiAgICAgIC8vIGlmIGl0IGhhcyBhIHNjb3BlIGRlZmluZWRcbiAgICAgIHZhciBpbmRleCA9IGZpZWxkLmluZGV4T2YoJy4nKTtcbiAgICAgIGlmIChpbmRleCA8PSAwKSB7XG4gICAgICAgIHJldHVybiB7fTtcbiAgICAgIH1cblxuICAgICAgdmFyIHJlZiA9IGZpZWxkLnNwbGl0KCcuJyk7XG4gICAgICB2YXIgc2NvcGUgPSByZWZbMF07XG4gICAgICB2YXIgbmFtZSA9IHJlZi5zbGljZSgxKTtcblxuICAgICAgc2NvcGUgPSB0aGlzLiR2YWxpZGF0b3IuZmxhZ3NbKFwiJFwiICsgc2NvcGUpXTtcbiAgICAgIG5hbWUgPSBuYW1lLmpvaW4oJy4nKTtcblxuICAgICAgLy8gYW4gZW50aXJlIHNjb3BlIHdhcyBzZWxlY3RlZDogc2NvcGUuKlxuICAgICAgaWYgKG5hbWUgPT09ICcqJyAmJiBzY29wZSkge1xuICAgICAgICByZXR1cm4gbWFwU2NvcGUoc2NvcGUpO1xuICAgICAgfVxuXG4gICAgICBpZiAoc2NvcGUgJiYgc2NvcGVbbmFtZV0pIHtcbiAgICAgICAgcmV0dXJuIHNjb3BlW25hbWVdO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4ge307XG4gICAgfTtcblxuICAgIHJldHVybiBwcmV2O1xuICB9LCB7fSk7XG59O1xuXG52YXIgdmVyc2lvbiA9ICcyLjAuMSc7XG5cbnZhciBydWxlc1BsdWdpbiA9IGZ1bmN0aW9uIChyZWYpIHtcbiAgdmFyIFZhbGlkYXRvciQkMSA9IHJlZi5WYWxpZGF0b3I7XG5cbiAgT2JqZWN0LmtleXMoUnVsZXMpLmZvckVhY2goZnVuY3Rpb24gKHJ1bGUpIHtcbiAgICBWYWxpZGF0b3IkJDEuZXh0ZW5kKHJ1bGUsIFJ1bGVzW3J1bGVdKTtcbiAgfSk7XG5cbiAgLy8gTWVyZ2UgdGhlIGVuZ2xpc2ggbWVzc2FnZXMuXG4gIFZhbGlkYXRvciQkMS5sb2NhbGl6ZSgnZW4nLCBsb2NhbGUpO1xufTtcblxudXNlKHJ1bGVzUGx1Z2luKTtcblxudmFyIGluZGV4X2VzbSA9IHtcbiAgaW5zdGFsbDogaW5zdGFsbCxcbiAgdXNlOiB1c2UsXG4gIGRpcmVjdGl2ZTogZGlyZWN0aXZlLFxuICBtaXhpbjogbWl4aW4sXG4gIG1hcEZpZWxkczogbWFwRmllbGRzLFxuICBWYWxpZGF0b3I6IFZhbGlkYXRvcixcbiAgRXJyb3JCYWc6IEVycm9yQmFnLFxuICBSdWxlczogUnVsZXMsXG4gIHZlcnNpb246IHZlcnNpb25cbn07XG5cbmV4cG9ydCB7IGluc3RhbGwsIHVzZSwgZGlyZWN0aXZlLCBtaXhpbiwgbWFwRmllbGRzLCBWYWxpZGF0b3IsIEVycm9yQmFnLCBSdWxlcywgdmVyc2lvbiB9O1xuZXhwb3J0IGRlZmF1bHQgaW5kZXhfZXNtO1xuIiwiKGZ1bmN0aW9uKGUsdCl7XCJvYmplY3RcIj09dHlwZW9mIGV4cG9ydHMmJlwib2JqZWN0XCI9PXR5cGVvZiBtb2R1bGU/bW9kdWxlLmV4cG9ydHM9dCgpOlwiZnVuY3Rpb25cIj09dHlwZW9mIGRlZmluZSYmZGVmaW5lLmFtZD9kZWZpbmUoW10sdCk6XCJvYmplY3RcIj09dHlwZW9mIGV4cG9ydHM/ZXhwb3J0cy5WUmVzZXRJbnB1dD10KCk6ZS5WUmVzZXRJbnB1dD10KCl9KSh0aGlzLGZ1bmN0aW9uKCl7cmV0dXJuIGZ1bmN0aW9uKGUpe2Z1bmN0aW9uIHQocil7aWYobltyXSlyZXR1cm4gbltyXS5leHBvcnRzO3ZhciBvPW5bcl09e2k6cixsOiExLGV4cG9ydHM6e319O3JldHVybiBlW3JdLmNhbGwoby5leHBvcnRzLG8sby5leHBvcnRzLHQpLG8ubD0hMCxvLmV4cG9ydHN9dmFyIG49e307cmV0dXJuIHQubT1lLHQuYz1uLHQuaT1mdW5jdGlvbihlKXtyZXR1cm4gZX0sdC5kPWZ1bmN0aW9uKGUsbixyKXt0Lm8oZSxuKXx8T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsbix7Y29uZmlndXJhYmxlOiExLGVudW1lcmFibGU6ITAsZ2V0OnJ9KX0sdC5uPWZ1bmN0aW9uKGUpe3ZhciBuPWUmJmUuX19lc01vZHVsZT9mdW5jdGlvbigpe3JldHVybiBlLmRlZmF1bHR9OmZ1bmN0aW9uKCl7cmV0dXJuIGV9O3JldHVybiB0LmQobixcImFcIixuKSxufSx0Lm89ZnVuY3Rpb24oZSx0KXtyZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGUsdCl9LHQucD1cIi5cIix0KHQucz0yKX0oW2Z1bmN0aW9uKGUsdCxuKXt2YXIgcj1uKDEpO3IuaW5zdGFsbD1mdW5jdGlvbihlKXtyZXR1cm4gZS5kaXJlY3RpdmUoXCJyZXNldC1pbnB1dFwiLHIoZSkpfSxyLnZlcnNpb249XCIxLjEuMVwiLGUuZXhwb3J0cz1yfSxmdW5jdGlvbihlLHQpe3ZhciBuPW51bGw7ZS5leHBvcnRzPWZ1bmN0aW9uKGUpe3JldHVybntpbnNlcnRlZDpmdW5jdGlvbih0LHIsbyl7dC5vbmZvY3VzPWZ1bmN0aW9uKCl7by5lbG0ucGFyZW50RWxlbWVudC5zdHlsZS5wb3NpdGlvbj1cInJlbGF0aXZlXCIsdC52YWx1ZSYmbi4kZWwuY2xhc3NMaXN0LmFkZChcInYtcmVzZXQtaW5wdXQtYWN0aXZlXCIpfSx0Lm9uYmx1cj1mdW5jdGlvbigpe3NldFRpbWVvdXQoZnVuY3Rpb24oKXtuLiRlbC5jbGFzc0xpc3QucmVtb3ZlKFwidi1yZXNldC1pbnB1dC1hY3RpdmVcIil9LDE1MCl9O3ZhciB1PWZ1bmN0aW9uKCl7dC52YWx1ZT1cIlwiLHQuZGlzcGF0Y2hFdmVudChuZXcgRXZlbnQoXCJpbnB1dFwiKSl9LGk9ZS5leHRlbmQoe3JlbmRlcjpmdW5jdGlvbihlKXtyZXR1cm4gZShcInNwYW5cIix7b246e2NsaWNrOnV9LGRvbVByb3BzOntpbm5lckhUTUw6XCImIzEwMDA2O1wifSxjbGFzczp7XCJ2LXJlc2V0LWlucHV0XCI6ITB9LHN0eWxlOntwb3NpdGlvbjpcImFic29sdXRlXCIsY3Vyc29yOlwiZGVmYXVsdFwifX0pfX0pLHM9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNwYW5cIik7dC5hZnRlcihzKSxuPShuZXcgaSkuJG1vdW50KHMpfSx1cGRhdGU6ZnVuY3Rpb24oZSx0LHIpe2UudmFsdWU/bi4kZWwuY2xhc3NMaXN0LmFkZChcInYtcmVzZXQtaW5wdXQtYWN0aXZlXCIpOm4uJGVsLmNsYXNzTGlzdC5yZW1vdmUoXCJ2LXJlc2V0LWlucHV0LWFjdGl2ZVwiKX19fX0sZnVuY3Rpb24oZSx0LG4pe2UuZXhwb3J0cz1uKDApfV0pfSk7IiwiaW1wb3J0ICQgZnJvbSAnanF1ZXJ5JztcbmltcG9ydCBhcGkgZnJvbSAnLi9hcGknO1xuLy8gaW1wb3J0IFZ1ZSBmcm9tICcuL3Z1ZSc7XG5pbXBvcnQgVmVlVmFsaWRhdGUgZnJvbSAndmVlLXZhbGlkYXRlJztcbmltcG9ydCBSZXNldElucHV0IGZyb20gJ3YtcmVzZXQtaW5wdXQnO1xuXG5cbmNsYXNzIENoZWNrb3V0IHtcblxuICBjb25zdHJ1Y3RvciAoKSB7XG4gICAgLy8gYm9vdHN0cmFwXG4gICAgdGhpcy5fX3dyYXBwZXIgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnY2hlY2tvdXQnKTtcblxuICAgIGlmICh0aGlzLl9fd3JhcHBlcikge1xuICAgICAgdGhpcy4kb25Jbml0KCk7XG4gICAgICAkKGRvY3VtZW50KS5yZWFkeSh0aGlzLiRvblJlYWR5LmJpbmQodGhpcykpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBJbml0XG4gICAqL1xuICAkb25Jbml0ICgpIHtcbiAgICB0aGlzLl9kZWZhdWx0VmlldyA9ICdvdmVydmlldyc7XG4gICAgdGhpcy5fYnJlYWtwb2ludE1vYmlsZSA9IDYwMDtcbiAgICB0aGlzLl9icmVhZGNydW1icyA9IFsnb3ZlcnZpZXcnLCAncGF5bWVudCcsICd0aGFua3MnXTtcblxuICAgIGNvbnN0IGluaXRpYWxWaWV3ID0gd2luZG93LmxvY2F0aW9uLmhhc2gucmVwbGFjZSgnIycsICcnKSB8fCB0aGlzLl9kZWZhdWx0VmlldztcbiAgICB0aGlzLmRlZXBsaW5rKGluaXRpYWxWaWV3KTtcblxuICAgIFZ1ZS51c2UoVmVlVmFsaWRhdGUpO1xuICAgIFZ1ZS51c2UoUmVzZXRJbnB1dCk7XG5cbiAgICBWdWUuY29tcG9uZW50KCdhcHAtaW5wdXQnLCB7XG4gICAgICB0ZW1wbGF0ZTogJzxpbnB1dCBpZD1cIjwlIGlucHV0X2lkICU+XCIgbmFtZT1cIjwlIG5hbWUgJT5cIiB0eXBlPVwiPCUgdHlwZSAlPlwiIGNsYXNzPVwiZm9ybS1jb250cm9sXCIgdi1tb2RlbD1cIjwlIHZ1ZV9tb2RlbCAlPlwiPicsXG4gICAgICBkYXRhOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgaWQ6ICcnLFxuICAgICAgICAgIG5hbWU6ICcnLFxuICAgICAgICAgIHR5cGU6ICcnLFxuICAgICAgICAgIHJlcXVpcmVkOiAnJ1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSlcblxuICAgIHRoaXMudnVlID0gbmV3IFZ1ZSh7XG4gICAgICBlbDogdGhpcy5fX3dyYXBwZXIsXG4gICAgICBwZXJmb3JtYW5jZTogdHJ1ZSxcbiAgICAgIHByb2R1Y3Rpb25UaXA6IGZhbHNlLFxuICAgICAgZGVsaW1pdGVyczogWyc8JScsICclPiddLFxuICAgICAgZGF0YTogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gd2luZG93Wydoc0NoZWNrb3V0J11cbiAgICAgIH0sXG4gICAgICBmaWx0ZXJzOiB7XG4gICAgICAgIHByaWNlOiBmdW5jdGlvbiAodmFsdWUsIGxpbWl0KSB7XG4gICAgICAgICAgcmV0dXJuIHZhbHVlID8gdmFsdWUudG9GaXhlZChsaW1pdCB8fCAyKS5yZXBsYWNlKCcuJywgJywnKSA6IDA7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBtb3VudGVkOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKCd2dWUgaXMgbW91bnRlZCcpO1xuICAgICAgfSxcbiAgICAgIG1ldGhvZHM6IHtcbiAgICAgICAgb25TdWJtaXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBsZXQgZCA9IHRoaXMuZGF0YTtcbiAgICAgICAgICBsZXQgdiA9IHRoaXMudmFsdWU7XG4gICAgICAgICAgY29uc29sZS5sb2coXCJvbmNoYW5nZSB0aGlzIGlzIFwiLCB0aGlzLCBcImFyZ3VtZW50cyBhcmUgXCIsIGFyZ3VtZW50cylcbiAgICAgICAgfSxcbiAgICAgICAgY2xlYXJJbnB1dDogZnVuY3Rpb24gKG1vZGVsUHJvcCkge1xuICAgICAgICB9LFxuICAgICAgICBvbmNoYW5nZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGxldCBkID0gdGhpcy5kYXRhO1xuICAgICAgICAgIGxldCB2ID0gdGhpcy52YWx1ZTtcbiAgICAgICAgICBjb25zb2xlLmxvZyhcIm9uY2hhbmdlIGQgaXMgXCIsIGQsIFwidiBpcyBcIiwgdilcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pXG5cbiAgfVxuXG4gIGxvYWRlZCAoKSB7XG4gICAgLy8gdGhpcy5fXyRmb3JtLnNob3coKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBPbiBkb2N1bWVudCByZWFkeVxuICAgKi9cbiAgJG9uUmVhZHkgKCkge1xuICAgIC8vIGNvbnNvbGUubG9nKCdhcHAuanMgZG9jdW1lbnQgaXMgcmVhZHknKTtcbiAgICB0aGlzLl9fJGZvcm0gPSAkKCcjY2hlY2tvdXQnKTtcblxuICAgIC8vIGJhaWwgaWYgd2UgYXJlIG5vdCBvbiB0aGUgY2hlY2tvdXQgcGFnZVxuICAgIGlmICghdGhpcy5fXyRmb3JtLmxlbmd0aCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuX18kaHRtbEJvZHkgPSAkKCdodG1sLCBib2R5Jyk7XG4gICAgdGhpcy5fXyRtb2RhbEVkaXQgPSAkKCcjQ2hlY2tvdXRfX2VkaXQnKTtcbiAgICB0aGlzLl9fJGJyZWFkY3J1bWJzID0gJCgnLkNoZWNrb3V0X19icmVhZGNydW1icy1pdGVtJyk7XG4gICAgdGhpcy5fXyRtZXRob2RzTGlzdCA9ICQoJy5DaGVja291dF9fbWV0aG9kcycpO1xuICAgIHRoaXMuX18kbWV0aG9kRXhwYW5kYWJsZXMgPSAkKCcuQ2hlY2tvdXRfX21ldGhvZC1kZXRhaWxzJyk7XG5cbiAgICB0aGlzLl9pbml0TW9kYWxzKCk7XG4gICAgdGhpcy5faW5pdE1ldGhvZHMoKTtcbiAgICB0aGlzLmRpc3BsYXlWaWV3KCk7XG5cblxuXG5cblxuXG5cblxuXG5cblxuXG4gICAgLy8gdGhpcy5fXyR3cmFwcGVyTGVmdCA9ICQoJy5DaGVja291dF9fbWFpbi1sZWZ0Jyk7XG4gICAgLy8gLy8gdGhpcy5fXyRicmVhZGNydW1icyA9ICQoJy5DaGVja291dF9fYnJlYWRjcnVtYicpO1xuXG4gICAgLy8gdGhpcy5fXyRjb3Vwb25BcmVhID0gJCgnLkNoZWNrb3V0X19jb3Vwb24tYXJlYScpO1xuICAgIC8vIHRoaXMuX18kY291cG9uVHJpZ2dlciA9ICQoJy5DaGVja291dF9fY291cG9uLXRyaWdnZXInKTtcbiAgICAvLyB0aGlzLl9fJGNvdXBvbklucHV0ID0gJCgnLkNoZWNrb3V0X19jb3Vwb24taW5wdXQnKTtcbiAgICAvLyB0aGlzLl9fJGNvdXBvblN1Ym1pdCA9ICQoJy5DaGVja291dF9fY291cG9uLXN1Ym1pdCcpO1xuICAgIC8vIHRoaXMuX18kY291cG9uRmVlZGJhY2sgPSAkKCcuQ2hlY2tvdXRfX2NvdXBvbi1mZWVkYmFjaycpO1xuXG4gICAgLy8gdGhpcy5fXyRhZGRyZXNzUHJlZmlsbGVkID0gJCgnI2FwcEFkZHJlc3NfX3ByZWZpbGxlZCcpO1xuICAgIC8vIHRoaXMuX18kaW5wdXRWb29ybmFtID0gJCgnI3Zvb3JuYWFtJyk7XG4gICAgLy8gdGhpcy5fXyRpbnB1dEFjaHRlcm5hYW0gPSAkKCcjYWNodGVybmFhbScpO1xuICAgIC8vIHRoaXMuX18kaW5wdXRTdHJhYXQgPSAkKCcjc3RyYWF0Jyk7XG4gICAgLy8gdGhpcy5fXyRpbnB1dEh1aXNudW1tZXIgPSAkKCcjaHVpc251bW1lcicpO1xuICAgIC8vIHRoaXMuX18kaW5wdXRQb3N0Y29kZSA9ICQoJyNwb3N0Y29kZScpO1xuICAgIC8vIHRoaXMuX18kaW5wdXRXb29ucGxhYXRzID0gJCgnI3dvb25wbGFhdHMnKTtcbiAgICAvLyB0aGlzLl9fJGlucHV0TGFuZCA9ICQoJyNsYW5kJyk7XG4gICAgLy8gdGhpcy5fXyRhZGRyZXNzRGlzcGxheSA9ICQoJyNhcHBBZGRyZXNzX19kaXNwbGF5Jyk7XG5cbiAgICAvLyB0aGlzLl9fJGNvc3RXaW5iZWRyYWcgPSAkKCcuQ2hlY2tvdXRfX2Nvc3Qtd2luYmVkcmFnJyk7XG4gICAgLy8gdGhpcy5fXyRjb3N0V2luYmVkcmFnRGVsID0gJCgnLkNoZWNrb3V0X19jb3N0LXdpbmJlZHJhZy0tZGVsJyk7XG4gICAgLy8gdGhpcy5fXyRjb3N0VmVyemVuZGtvc3RlbiA9ICQoJy5DaGVja291dF9fY29zdC12ZXJ6ZW5ka29zdGVuJyk7XG4gICAgLy8gdGhpcy5fXyRjb3N0VmVpbGluZ2tvc3RlbiA9ICQoJy5DaGVja291dF9fY29zdC12ZWlsaW5na29zdGVuJyk7XG4gICAgLy8gdGhpcy5fXyRjb3N0VG90YWFsID0gJCgnLkNoZWNrb3V0X19jb3N0LXRvdGFhbCcpO1xuXG4gICAgLy8gdGhpcy5fXyRleHBhbmRlciA9ICQoJy5DaGVja291dF9fZXhwYW5kZXInKTtcbiAgICAvLyB0aGlzLl9fJHN0ZXAwID0gJCgnI0NoZWNrb3V0X19zdGVwLTAnKTtcbiAgICAvLyB0aGlzLl9fJHN0ZXAxID0gJCgnI0NoZWNrb3V0X19zdGVwLTEnKTtcbiAgICAvLyB0aGlzLl9fJGJ0blRvU3RlcDEgPSAkKCcuQ2hlY2tvdXRfX3Rvc3RlcDEnKTtcbiAgICAvLyB0aGlzLl9fJGJ0blRvU3RlcDIgPSAkKCcuQ2hlY2tvdXRfX3Rvc3RlcDInKTtcbiAgICAvLyB0aGlzLl9fJHN1bW1hcnkgPSAkKCcuQ2hlY2tvdXRfX21haW4tc3VtbWFyeScpO1xuXG4gICAgLy8gdGhpcy5fXyRwYXltZW50TWV0aG9kcyA9ICQoJ2lucHV0W25hbWU9XCJwYXktbWV0aG9kXCJdJyk7XG4gICAgLy8gdGhpcy5fXyRwYXltZW50QmFua3MgPSAkKCdpbnB1dFtuYW1lPVwicGF5LWJhbmtcIl0nKTtcbiAgICAvLyB0aGlzLl9fJG1ldGhvZElkZWFsID0gJCgnLkNoZWNrb3V0X19tZXRob2QtLWlkZWFsJyk7XG4gICAgLy8gdGhpcy5fXyRiYW5rU2VsZWN0b3IgPSAkKCcuQ2hlY2tvdXRfX2JhbmtzJyk7XG4gICAgLy8gdGhpcy5fXyRidG5TdWJtaXQgPSAkKCcuQ2hlY2tvdXRfX3N1Ym1pdCcpO1xuXG4gICAgLy8gdGhpcy5fXyRkZXRhaWxzID0gJCgnLkNoZWNrb3V0X19kZXRhaWxzJyk7XG5cbiAgICAvLyBhbmltYXRlIHN0ZXBzIEBAZGlzYWJsZWRcbiAgICAvLyBjb25zdCBtaW5IZWlnaHQgPSB0aGlzLl9fJHN0ZXAwLm91dGVySGVpZ2h0KCkgKiAxLjU7XG4gICAgLy8gdGhpcy5fXyR3cmFwcGVyLmNzcygnbWluLWhlaWdodCcsIG1pbkhlaWdodCk7XG4gICAgLy8gdGhpcy5fXyR3cmFwcGVyTGVmdC5jc3MoJ21pbi1oZWlnaHQnLCBtaW5IZWlnaHQpO1xuXG4gICAgLy8gdGhpcy5tYW5hZ2VWYWxpZGF0aW9uKCk7XG5cbiAgfVxuXG4gIC8qKlxuICAgKiBEZWVwbGluayB0aHJvdWdoIGhhc2ggdGFnXG4gICAqXG4gICAqIEBwYXJhbSAge1N0cmluZ31cbiAgICovXG4gIGRlZXBsaW5rICh2aWV3TmFtZSkge1xuICAgIHdpbmRvdy5sb2NhdGlvbi5oYXNoID0gdmlld05hbWU7XG4gICAgdGhpcy5fbGFzdFZpZXcgPSB0aGlzLnZpZXc7XG4gICAgdGhpcy52aWV3ID0gdmlld05hbWU7XG4gIH1cblxuICAvKipcbiAgICogSW5pdCBtb2RhbHNcbiAgICovXG4gIF9pbml0TW9kYWxzICgpIHtcbiAgICB0aGlzLl9fJG1vZGFsRWRpdFxuICAgICAgLm1vZGFsKCdoaWRlJylcbiAgICAgIC5vbignc2hvdy5icy5tb2RhbCcsICgpID0+IHtcbiAgICAgICAgdGhpcy5kZWVwbGluaygnZWRpdCcpO1xuICAgICAgfSlcbiAgICAgIC5vbignaGlkZS5icy5tb2RhbCcsICgpID0+IHtcbiAgICAgICAgbGV0IHRvVmlldyA9IHRoaXMuX2xhc3RWaWV3O1xuICAgICAgICBpZiAodG9WaWV3ID09PSAnZWRpdCcpIHtcbiAgICAgICAgICB0b1ZpZXcgPSB0aGlzLl9kZWZhdWx0VmlldztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmRlZXBsaW5rKHRvVmlldyk7XG4gICAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJbml0IG1ldGhvZHMgY29sbGFwc2FibGVcbiAgICovXG4gIF9pbml0TWV0aG9kcyAoKSB7XG4gICAgY29uc3QgaXNQYXlWaWV3ID0gdGhpcy52aWV3LnN1YnN0cigwLCA0KSA9PT0gJ3BheS0nO1xuICAgIGNvbnN0IHBheVN1YnZpZXcgPSBpc1BheVZpZXcgPyB0aGlzLnZpZXcuc3Vic3RyKDQsIHRoaXMudmlldy5sZW5ndGgpIDogZmFsc2U7XG5cbiAgICB0aGlzLl9fJG1ldGhvZEV4cGFuZGFibGVzLmVhY2goKGlkeCwgZWxlbWVudCkgPT4ge1xuICAgICAgY29uc3QgJGV4cGFuZGFibGUgPSAkKGVsZW1lbnQpO1xuICAgICAgY29uc3QgbmFtZSA9ICRleHBhbmRhYmxlLmF0dHIoJ2RhdGEtY2hlY2tvdXQtbWV0aG9kJyk7XG4gICAgICBsZXQgaXNkZWVwbGlua2VkID0gcGF5U3VidmlldyA/IHBheVN1YnZpZXcgPT09IG5hbWUgOiBmYWxzZTtcblxuICAgICAgJGV4cGFuZGFibGVcbiAgICAgICAgLmNvbGxhcHNlKHtcbiAgICAgICAgICB0YXJnZXQ6IGAjQ2hlY2tvdXRfX21ldGhvZC1leHBhbmRhYmxlLSR7bmFtZX1gLFxuICAgICAgICAgIHBhcmVudDogJyNDaGVja291dF9fbWV0aG9kcycsXG4gICAgICAgICAgdG9nZ2xlOiBpc2RlZXBsaW5rZWQsXG4gICAgICAgIH0pXG4gICAgICAgIC5vbignc2hvdy5icy5jb2xsYXBzZScsICgpID0+IHtcbiAgICAgICAgICB0aGlzLmRlZXBsaW5rKGBwYXktJHtuYW1lfWApO1xuICAgICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEaXNwbGF5IHZpZXdcbiAgICpcbiAgICogQHBhcmFtICB7P1N0cmluZ30gZ2l2ZW5WaWV3XG4gICAqIEByZXR1cm4ge1N0cmluZ30gICAgICAgICAgICAgVGhlIHZpZXcgbmFtZVxuICAgKi9cbiAgZGlzcGxheVZpZXcgKGdpdmVuVmlldykge1xuICAgIGNvbnN0IHZpZXcgPSBnaXZlblZpZXcgfHwgdGhpcy52aWV3O1xuXG4gICAgaWYgKHZpZXcgPT09ICdlZGl0Jykge1xuICAgICAgdGhpcy5fXyRtb2RhbEVkaXQubW9kYWwoJ3Nob3cnKTtcbiAgICB9XG5cbiAgICAvLyB1c2VmdWwgZm9yIGdsb2JhbCBzdHlsaW5nIGFuZCBoaWRpbmcvc2hvd2luZyBiYXNlZCBvbiBjdXJyZW50IHN0ZXBcbiAgICB0aGlzLl9fJGZvcm0uYXR0cignZGF0YS1jaGVja291dC12aWV3Jywgdmlldyk7XG5cbiAgICAvLyBoaWdobGlnaHQgY3VycmVudCBicmVhZGNydW1iIGlmIHZpZXcgbmFtZSBjb3JyZXNwb25kc1xuICAgIGxldCBicmVhZGNydW1iVmlldyA9IGZhbHNlO1xuICAgIGZvciAobGV0IGkgPSB0aGlzLl9icmVhZGNydW1icy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgaWYgKHRoaXMuX2JyZWFkY3J1bWJzW2ldID09PSB2aWV3KSB7XG4gICAgICAgIGJyZWFkY3J1bWJWaWV3ID0gdmlldztcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChicmVhZGNydW1iVmlldykge1xuICAgICAgdGhpcy5fXyRicmVhZGNydW1icy5maWx0ZXIoKGluZGV4LCBlbGVtKSA9PiB7XG4gICAgICAgIGlmIChlbGVtLmdldEF0dHJpYnV0ZSgnZGF0YS1jaGVja291dC12aWV3JykgPT09IGJyZWFkY3J1bWJWaWV3KSB7XG4gICAgICAgICAgJChlbGVtKS5hZGRDbGFzcygnZG9uZScpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICQoZWxlbSkucmVtb3ZlQ2xhc3MoJ2RvbmUnKVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogU2V0IHZpZXcgXCJlZGl0XCJcbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IHZpZXcgVGhlIHZpZXcgbmFtZSBhcyBpbiB0aGUgYGxvY2F0aW9uLmhhc2hgXG4gICAqL1xuICAvLyBfc2V0Vmlld0VkaXQgKHZpZXcpIHtcbiAgLy8gICB0aGlzLl9fJG1vZGFsRWRpdC5tb2RhbCgnc2hvdycpO1xuICAvLyB9XG5cbiAgLyoqXG4gICAqIE1hbmFnZSBmb3JtIHZhbGlkYXRpb25cbiAgICpcbiAgICogQHNlZSBvcHRpb25zIGhlcmUgaHR0cHM6Ly9qcXVlcnl2YWxpZGF0aW9uLm9yZy92YWxpZGF0ZS9cbiAgICogQEB0b2RvIHBlcmhhcHMgdXNlIHRoaXMgdG8gc3R5bGUgdGhlIHZhbGlkYXRvciBvbiB0aGUgYWxsXG4gICAqIHdlYnNpdGU6IGAkLnZhbGlkYXRvci5zZXREZWZhdWx0cyh7fSlgXG4gICAqL1xuICAvLyBtYW5hZ2VWYWxpZGF0aW9uICgpIHtcbiAgLy8gICB0aGlzLl92YWxpZGF0aW9uID0gdGhpcy5fXyRmb3JtLnZhbGlkYXRlKHtcbiAgLy8gICAgIGVycm9yQ2xhc3M6ICdoYXMtZmVlZGJhY2sgaGFzLWVycm9yJyxcbiAgLy8gICAgIHZhbGlkQ2xhc3M6ICdoYXMtZmVlZGJhY2sgaGFzLXN1Y2Nlc3MnLFxuICAvLyAgICAgZXJyb3JFbGVtZW50OiAnc3BhbicsXG4gIC8vICAgICBlcnJvckNsYXNzOiAnaGVscC1mZWVkYmFjaycsXG4gIC8vICAgICBlcnJvclBsYWNlbWVudDogZnVuY3Rpb24oZXJyb3IsIGVsZW1lbnQpIHtcbiAgLy8gICAgICAgY29uc3QgJHBhcmVudCA9IGVsZW1lbnQucGFyZW50KCk7XG4gIC8vICAgICAgIGlmICgkcGFyZW50Lmhhc0NsYXNzKCdpbnB1dC1ncm91cCcpKSB7XG4gIC8vICAgICAgICAgZXJyb3IuaW5zZXJ0QWZ0ZXIoJHBhcmVudCk7XG4gIC8vICAgICAgIH1cbiAgLy8gICAgICAgZWxzZSBpZiAoJHBhcmVudC5oYXNDbGFzcygnY3VzdG9tLWNvbnRyb2wnKSkge1xuICAvLyAgICAgICAgICRwYXJlbnQuYWZ0ZXIoZXJyb3IpO1xuICAvLyAgICAgICB9IGVsc2Uge1xuICAvLyAgICAgICAgIGVycm9yLmluc2VydEFmdGVyKGVsZW1lbnQpO1xuICAvLyAgICAgICB9XG4gIC8vICAgICB9LFxuICAvLyAgICAgaGlnaGxpZ2h0OiBmdW5jdGlvbihlbGVtZW50KSB7XG4gIC8vICAgICAgICQoZWxlbWVudCkucGFyZW50cygnLmZvcm0tZ3JvdXAnKS5hZGRDbGFzcygnaGFzLWZlZWRiYWNrIGhhcy1lcnJvcicpXG4gIC8vICAgICAgICAgLnJlbW92ZUNsYXNzKCdoYXMtd2FybmluZyBoYXMtc3VjY2VzcycpO1xuICAvLyAgICAgfSxcbiAgLy8gICAgIHVuaGlnaGxpZ2h0OiBmdW5jdGlvbihlbGVtZW50KSB7XG4gIC8vICAgICAgICQoZWxlbWVudCkucGFyZW50cygnLmZvcm0tZ3JvdXAnKS5hZGRDbGFzcygnaGFzLWZlZWRiYWNrIGhhcy1zdWNjZXNzJylcbiAgLy8gICAgICAgICAucmVtb3ZlQ2xhc3MoJ2hhcy1lcnJvciBoYXMtd2FybmluZycpO1xuICAvLyAgICAgfVxuICAvLyAgICAgLy8gc3VibWl0SGFuZGxlcjogKCkgPT4ge1xuICAvLyAgICAgLy8gICB0aGlzLmdvVG9TdGVwKDEpO1xuICAvLyAgICAgLy8gfSxcblxuICAvLyAgICAgLy8gZXJyb3JDbGFzczogJ2hhcy1kYW5nZXInLFxuICAvLyAgICAgLy8gdmFsaWRDbGFzczogJ2hhcy1zdWNjZXNzJyxcblxuICAvLyAgICAgLy8gZXJyb3JFbGVtZW50OiAnPGRpdiBjbGFzcz1cImZvcm0tY29udHJvbC1mZWVkYmFja1wiPicsXG4gIC8vICAgICAvLyBoaWdobGlnaHQ6IGZ1bmN0aW9uKGVsZW1lbnQsIGVycm9yQ2xhc3MsIHZhbGlkQ2xhc3MpIHtcbiAgLy8gICAgIC8vICAgJChlbGVtZW50KS5wYXJlbnQoKS5hZGRDbGFzcyhlcnJvckNsYXNzKS5yZW1vdmVDbGFzcyh2YWxpZENsYXNzKTtcbiAgLy8gICAgIC8vIH0sXG4gIC8vICAgICAvLyB1bmhpZ2hsaWdodDogZnVuY3Rpb24oZWxlbWVudCwgZXJyb3JDbGFzcywgdmFsaWRDbGFzcykge1xuICAvLyAgICAgLy8gICAkKGVsZW1lbnQpLnBhcmVudCgpLnJlbW92ZUNsYXNzKGVycm9yQ2xhc3MpLmFkZENsYXNzKHZhbGlkQ2xhc3MpO1xuICAvLyAgICAgLy8gfVxuICAvLyAgIH0pO1xuICAvLyAgIGNvbnNvbGUubG9nKHRoaXMuX3ZhbGlkYXRpb24pXG4gIC8vIH1cblxuICAvKipcbiAgICogSXMgZm9ybSB2YWxpZFxuICAgKlxuICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgKi9cbiAgaXNGb3JtVmFsaWQgKCkge1xuICAgIGNvbnNvbGUubG9nKHRoaXMudnVlLiR2YWxpZGF0b3IuZXJyb3JzLml0ZW1zKTtcbiAgICByZXR1cm4gdGhpcy5fXyRmb3JtLnZhbGlkKCk7XG4gIH1cblxuICAvKipcbiAgICogQXBwbHkgY291cG9uXG4gICAqIEBwYXJhbSAge051bWJlcn0gZGlzY291bnQgVGhlIGFtb3VudCBvZiBkaXNjb3VudCBpbiBjYXNoXG4gICAqL1xuICBhcHBseUNvdXBvbiAoZGlzY291bnQpIHtcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGQgemVyb2VzXG4gICAqIEBzZWUgaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMjQwMzk0NDgvMTkzODk3MFxuICAgKiBAcGFyYW0ge051bWJlcn0gdmFsdWVcbiAgICogQHJldHVybiB7U3RyaW5nfVxuICAgKi9cbiAgZm9ybWF0UHJpY2UgKHZhbHVlKSB7XG4gICAgY29uc3QgYXNOdW1iZXIgPSBwYXJzZUZsb2F0KHZhbHVlKTtcbiAgICAvLyByZXBsYWNlIGRvdCB3aXRoIGNvbW1hIGFzIGluIGRlc2lnblxuICAgIGNvbnN0IHByaWNlID0gYXNOdW1iZXIudG9GaXhlZCgyKS5yZXBsYWNlKCcuJywgJywnKTtcbiAgICByZXR1cm4gdGhpcy5nZXRDdXJyZW5jeSgpICsgJyAnICsgcHJpY2U7XG4gIH1cbn1cblxuLy8gZXhwb3J0IHRvIHB1YmxpYyBBUElcbmFwaVsnY2hlY2tvdXQnXSA9IG5ldyBDaGVja291dCgpO1xuXG5leHBvcnQgZGVmYXVsdCBDaGVja291dDtcbiIsImltcG9ydCAkIGZyb20gJ2pxdWVyeSc7XG5pbXBvcnQgYXBpIGZyb20gJy4vYXBpJztcblxuY2xhc3MgU2VsbGVyIHtcblxuICBjb25zdHJ1Y3RvciAoKSB7XG4gICAgLy8gYm9vdHN0cmFwXG4gICAgJChkb2N1bWVudCkucmVhZHkodGhpcy4kb25SZWFkeS5iaW5kKHRoaXMpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBPbiBkb2N1bWVudCByZWFkeVxuICAgKi9cbiAgJG9uUmVhZHkgKCkge1xuICAgIC8vIGNvbnNvbGUubG9nKCdhcHAuanMgZG9jdW1lbnQgaXMgcmVhZHknKTtcbiAgICB0aGlzLl9fJHdyYXBwZXIgPSAkKCcjaHNTZWxsZXJjb250YWN0Jyk7XG5cbiAgICAvLyBiYWlsIGlmIHdlIGFyZSBub3Qgb24gdGhlIHJpZ2h0IHBhZ2VcbiAgICBpZiAoIXRoaXMuX18kd3JhcHBlci5sZW5ndGgpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLl9fJGNvdW50cnlTZWxlY3RvciA9ICQoJy5oc0xldmVyZW5Db3VudHJ5Jyk7XG5cbiAgICB0aGlzLl9iaW5kVUkoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBCaW5kIFVJXG4gICAqL1xuICBfYmluZFVJICgpIHtcbiAgICBjb25zdCBzZWxmID0gdGhpcztcblxuICAgIHNlbGYuX18kY291bnRyeVNlbGVjdG9yLmhpZGUoKTtcbiAgICAvLyBpZiAoISEkKCdpbnB1dFtuYW1lPVwibGV2ZXJlblwiXTpjaGVja2VkJykudmFsKCkpIHtcbiAgICAvLyAgIHNlbGYuX18kY291bnRyeVNlbGVjdG9yLnNsaWRlRG93bigpO1xuICAgIC8vIH1cblxuICAgICQoJ2lucHV0W25hbWU9XCJsZXZlcmVuXCJdJykub24oJ2NoYW5nZScsIGZ1bmN0aW9uICgpIHtcbiAgICAgIGNvbnN0IGlzWWVzID0gdGhpcy52YWx1ZSA9PT0gJ2phJztcbiAgICAgIGlmIChpc1llcykge1xuICAgICAgICBzZWxmLl9fJGNvdW50cnlTZWxlY3Rvci5zbGlkZURvd24oKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNlbGYuX18kY291bnRyeVNlbGVjdG9yLnNsaWRlVXAoKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxufVxuXG4vLyBleHBvcnQgdG8gcHVibGljIEFQSVxuYXBpWydzZWxsZXInXSA9IG5ldyBTZWxsZXIoKTtcblxuZXhwb3J0IGRlZmF1bHQgU2VsbGVyO1xuIiwiaW1wb3J0ICQgZnJvbSAnanF1ZXJ5JztcbmltcG9ydCBhcGkgZnJvbSAnLi9hcGknO1xuXG5jbGFzcyBBY2NvdW50IHtcblxuICBjb25zdHJ1Y3RvciAoKSB7XG4gICAgLy8gYm9vdHN0cmFwXG4gICAgdGhpcy4kb25Jbml0KCk7XG4gICAgJChkb2N1bWVudCkucmVhZHkodGhpcy4kb25SZWFkeS5iaW5kKHRoaXMpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJbml0XG4gICAqL1xuICAkb25Jbml0ICgpIHtcbiAgICB0aGlzLl9icmVha3BvaW50TW9iaWxlID0gNjAwO1xuICB9XG5cbiAgLyoqXG4gICAqIE9uIGRvY3VtZW50IHJlYWR5XG4gICAqL1xuICAkb25SZWFkeSAoKSB7XG4gICAgLy8gY29uc29sZS5sb2coJ2FwcC5qcyBkb2N1bWVudCBpcyByZWFkeScpO1xuICAgIHRoaXMuX18kd3JhcHBlciA9ICQoJy5oc0FjY291bnQnKTtcblxuICAgIC8vIGJhaWwgaWYgd2UgYXJlIG5vdCBvbiB0aGUgYWNjb3VudCBwYWdlXG4gICAgaWYgKCF0aGlzLl9fJHdyYXBwZXIubGVuZ3RoKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5fdHRNb2RhbCgpO1xuICAgIHRoaXMuX2dlZ2V2ZW5zKCk7XG4gIH1cblxuICAvKipcbiAgICogVHJhY2sgYW5kIHRyYWNlIG1vZGFsXG4gICAqL1xuICBfdHRNb2RhbCAoKSB7XG4gICAgbGV0ICR0dE1vZGFsID0gJCgnI2hzVHRNb2RhbCcpO1xuICAgIGlmICghJHR0TW9kYWwubGVuZ3RoKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgICQoZG9jdW1lbnQpLm9uKCdjbGljaycsICcuaHNBY2NvdW50X190YWJsZS10dCcsIGZ1bmN0aW9uIChlKSB7XG4gICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAkdHRNb2RhbC5tb2RhbCgpO1xuICAgICAgJHR0TW9kYWwuZmluZCgnLnR0X192ZXJ6ZW5kcGFydGlqJykudGV4dCh0aGlzLmdldEF0dHJpYnV0ZSgnZGF0YS12ZXJ6ZW5kcGFydGlqJykpO1xuICAgICAgJHR0TW9kYWwuZmluZCgnLnR0X19jb2RlJykudGV4dCh0aGlzLmdldEF0dHJpYnV0ZSgnZGF0YS1jb2RlJykpO1xuICAgICAgLy8gJHR0TW9kYWwub24oJ3Nob3cuYnMubW9kYWwnLCBmdW5jdGlvbiAoZSkge1xuICAgICAgLy8gICAvLyBkbyBzb21ldGhpbmcuLi5cbiAgICAgIC8vIH0pXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogR2VnZXZlbnMgdmlld3Mgc3dpdGNoXG4gICAqL1xuICBfZ2VnZXZlbnMgKCkge1xuICAgIGNvbnN0ICRidG5Ub0VkaXQgPSAkKCcjZ2VnZXZlbnNfc3dpdGNoZWRpdCcpO1xuICAgIGNvbnN0ICR2aWV3U2hvdyA9ICQoJyNnZWdldmVuc19zaG93Jyk7XG4gICAgY29uc3QgJHZpZXdFZGl0ID0gJCgnI2dlZ2V2ZW5zX2VkaXQnKTtcblxuICAgIGlmICghJGJ0blRvRWRpdC5sZW5ndGgpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBfc3dpdGNoVmlldyA9IChldmVudCwgbmFtZSkgPT4ge1xuICAgICAgbGV0IG5ld1ZpZXcgPSBuYW1lO1xuICAgICAgbGV0IGN1cnJlbnRWaWV3ID0gdGhpcy5fY3VycmVudFZpZXc7XG4gICAgICBpZiAoZXZlbnQpIHtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgIH1cbiAgICAgIGlmICghbmV3Vmlldykge1xuICAgICAgICBuZXdWaWV3ID0gbG9jYXRpb24uaGFzaC5yZXBsYWNlKCcjJywgJycpO1xuICAgICAgfVxuICAgICAgaWYgKCFuZXdWaWV3KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChuZXdWaWV3ID09PSAnc2hvdycgJiYgY3VycmVudFZpZXcgIT09ICdzaG93Jykge1xuICAgICAgICAkdmlld0VkaXQuc2xpZGVVcCgpO1xuICAgICAgICAkdmlld1Nob3cuc2xpZGVEb3duKCk7XG4gICAgICAgIGxvY2F0aW9uLmhhc2ggPSB0aGlzLl9jdXJyZW50VmlldyA9ICdzaG93JztcbiAgICAgIH0gZWxzZSBpZiAobmV3VmlldyA9PT0gJ2VkaXQnICYmIGN1cnJlbnRWaWV3ICE9PSAnZWRpdCcpIHtcbiAgICAgICAgJHZpZXdTaG93LnNsaWRlVXAoKTtcbiAgICAgICAgJHZpZXdFZGl0LnNsaWRlRG93bigpO1xuICAgICAgICBsb2NhdGlvbi5oYXNoID0gdGhpcy5fY3VycmVudFZpZXcgPSAnZWRpdCc7XG4gICAgICB9XG4gICAgfVxuXG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ2hhc2hjaGFuZ2UnLCBfc3dpdGNoVmlldywgZmFsc2UpO1xuXG4gICAgX3N3aXRjaFZpZXcobnVsbCwgJ3Nob3cnKTtcblxuICAgICRidG5Ub0VkaXQuY2xpY2soKGUpID0+IHsgX3N3aXRjaFZpZXcoZSwgJ2VkaXQnICl9KTtcbiAgfVxufVxuXG4vLyBleHBvcnQgdG8gcHVibGljIEFQSVxuYXBpWydhY2NvdW50J10gPSBuZXcgQWNjb3VudCgpO1xuXG5leHBvcnQgZGVmYXVsdCBBY2NvdW50O1xuIiwiaW1wb3J0ICQgZnJvbSAnanF1ZXJ5JztcbmltcG9ydCBhcGkgZnJvbSAnLi9hcGknO1xuXG5jbGFzcyBDb3VudGRvd24ge1xuXG4gIGNvbnN0cnVjdG9yICgpIHtcbiAgICB0aGlzLiRvbkluaXQoKTtcbiAgICAkKGRvY3VtZW50KS5yZWFkeSh0aGlzLiRvblJlYWR5LmJpbmQodGhpcykpO1xuICB9XG5cbiAgLyoqXG4gICAqIEluaXRcbiAgICovXG4gICRvbkluaXQgKCkge1xuICB9XG5cbiAgLyoqXG4gICAqIE9uIGRvY3VtZW50IHJlYWR5XG4gICAqL1xuICAkb25SZWFkeSAoKSB7XG4gICAgdGhpcy5fXyR3cmFwcGVyID0gJCgnLmNvdW50ZG93bicpO1xuXG4gICAgaWYgKCF0aGlzLl9fJHdyYXBwZXIubGVuZ3RoKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5fXyRkYXlzID0gdGhpcy5fXyR3cmFwcGVyLmZpbmQoJ1tkYXRhLWNvdW50ZG93bj1cImRheXNcIl0nKTtcbiAgICB0aGlzLl9fJGhvdXJzID0gdGhpcy5fXyR3cmFwcGVyLmZpbmQoJ1tkYXRhLWNvdW50ZG93bj1cImhvdXJzXCJdJyk7XG4gICAgdGhpcy5fXyRtaW51dGVzID0gdGhpcy5fXyR3cmFwcGVyLmZpbmQoJ1tkYXRhLWNvdW50ZG93bj1cIm1pbnV0ZXNcIl0nKTtcbiAgICB0aGlzLl9fJHNlY29uZHMgPSB0aGlzLl9fJHdyYXBwZXIuZmluZCgnW2RhdGEtY291bnRkb3duPVwic2Vjb25kc1wiXScpO1xuXG4gICAgdGhpcy5fc3RhcnRDb3VudGVyKCk7XG4gIH1cblxuICAvKipcbiAgICogTWFudWFsbHkgaW5pdFxuICAgKi9cbiAgaW5pdCAoKSB7XG4gICAgdGhpcy4kb25SZWFkeSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFN0YXJ0IGNvdW50ZXI7XG4gICAqIEByZXR1cm4ge1t0eXBlXX0gW2Rlc2NyaXB0aW9uXVxuICAgKi9cbiAgX3N0YXJ0Q291bnRlciAoKSB7XG4gICAgdGhpcy5fc2Vjb25kcyA9IDA7XG4gICAgaWYgKHRoaXMuX2ludGVydmFsKSB7XG4gICAgICBjbGVhckludGVydmFsKHRoaXMuX2ludGVydmFsKTtcbiAgICB9XG4gICAgdGhpcy5faW50ZXJ2YWwgPSBzZXRJbnRlcnZhbCgoKSA9PiB7XG4gICAgICB0aGlzLl9zZWNvbmRzID0gdGhpcy5fc2Vjb25kcyArIDE7XG4gICAgICB0aGlzLl91cGRhdGUoKTtcbiAgICB9LCAxMDAwKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBVcGRhdGUgVUkgZXZlcnkgc2Vjb25kXG4gICAqL1xuICBfdXBkYXRlICgpIHtcbiAgICBjb25zdCBjdXJyZW50U2Vjb25kcyA9IHBhcnNlSW50KHRoaXMuX18kc2Vjb25kcy5odG1sKCksIDEwKTtcbiAgICBjb25zdCBjdXJyZW50TWludXRlcyA9IHBhcnNlSW50KHRoaXMuX18kbWludXRlcy5odG1sKCksIDEwKTtcbiAgICBjb25zdCBjdXJyZW50SG91cnMgPSBwYXJzZUludCh0aGlzLl9fJGhvdXJzLmh0bWwoKSwgMTApO1xuICAgIGNvbnN0IGN1cnJlbnREYXlzID0gcGFyc2VJbnQodGhpcy5fXyRkYXlzLmh0bWwoKSwgMTApO1xuXG4gICAgbGV0IG5ld1NlY29uZHMgPSBNYXRoLm1heCgtMSwgTWF0aC5taW4oY3VycmVudFNlY29uZHMgLSAxLCA2MCkpO1xuICAgIGxldCBuZXdNaW51dGVzID0gY3VycmVudE1pbnV0ZXM7XG4gICAgbGV0IG5ld0hvdXJzID0gY3VycmVudEhvdXJzO1xuICAgIGxldCBuZXdEYXlzID0gY3VycmVudERheXM7XG5cbiAgICBpZiAobmV3U2Vjb25kcyA9PT0gLTEpIHtcbiAgICAgIG5ld1NlY29uZHMgPSA1OTtcbiAgICAgIG5ld01pbnV0ZXMgPSBNYXRoLm1heCgtMSwgTWF0aC5taW4oY3VycmVudE1pbnV0ZXMgLSAxLCA1OSkpO1xuXG4gICAgICBpZiAobmV3TWludXRlcyA9PT0gLTEpIHtcbiAgICAgICAgbmV3TWludXRlcyA9IDU5O1xuICAgICAgICBuZXdIb3VycyA9IE1hdGgubWF4KC0xLCBNYXRoLm1pbihjdXJyZW50SG91cnMgLSAxLCAyMykpO1xuXG4gICAgICAgIGlmIChuZXdIb3VycyA9PT0gLTEpIHtcbiAgICAgICAgICBuZXdIb3VycyA9IDIzO1xuICAgICAgICAgIG5ld0RheXMgPSBNYXRoLm1heCgtMSwgTWF0aC5taW4obmV3RGF5cyAtIDEsIDM2NCkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5fXyRzZWNvbmRzLmh0bWwodGhpcy5fcGFkKG5ld1NlY29uZHMpKTtcbiAgICB0aGlzLl9fJG1pbnV0ZXMuaHRtbCh0aGlzLl9wYWQobmV3TWludXRlcykpO1xuICAgIHRoaXMuX18kaG91cnMuaHRtbCh0aGlzLl9wYWQobmV3SG91cnMpKTtcbiAgICB0aGlzLl9fJGRheXMuaHRtbCh0aGlzLl9wYWQobmV3RGF5cykpO1xuICB9XG5cbiAgLyoqXG4gICAqIFBhZCBudW1iZXJzIChhZGQgbGVhZGluZyB6ZXJvKVxuICAgKlxuICAgKiBAcGFyYW0gIHtOdW1iZXJ9IG51bVxuICAgKiBAcGFyYW0gIHtOdW1iZXJ9IHNpemVcbiAgICogQHJldHVybiB7U3RyaW5nfVxuICAgKi9cbiAgX3BhZCAobnVtLCBzaXplPTIpIHtcbiAgICBsZXQgcyA9IG51bSArICcnO1xuICAgIHdoaWxlIChzLmxlbmd0aCA8IHNpemUpIHMgPSAnMCcgKyBzO1xuICAgIHJldHVybiBzO1xuICB9XG59XG5cbi8vIGV4cG9ydCB0byBwdWJsaWMgQVBJXG5hcGlbJ2NvdW50ZG93biddID0gbmV3IENvdW50ZG93bigpO1xuXG5leHBvcnQgZGVmYXVsdCBDb3VudGRvd247XG4iLCJpbXBvcnQgJCBmcm9tICdqcXVlcnknO1xuLy8gaW1wb3J0IHRldGhlciBmcm9tICd0ZXRoZXInO1xuaW1wb3J0ICdib290c3RyYXAvanMvc3JjL2NvbGxhcHNlJztcbmltcG9ydCAnYm9vdHN0cmFwL2pzL3NyYy9hbGVydCc7XG5pbXBvcnQgJ2Jvb3RzdHJhcC9qcy9zcmMvbW9kYWwnO1xuaW1wb3J0ICdib290c3RyYXAvanMvc3JjL3Rvb2x0aXAnO1xuaW1wb3J0ICdib290c3RyYXAvanMvc3JjL2Ryb3Bkb3duJztcbi8vIGltcG9ydCAnLi9ib290c3RyYXAtNC1kZXYvY29sbGFwc2UnOyAvLyAnYm9vdHN0cmFwL2pzL3NyYy9jb2xsYXBzZSc7XG4vLyBpbXBvcnQgJy4vYm9vdHN0cmFwLTQtZGV2L2FsZXJ0JzsgLy8gJ2Jvb3RzdHJhcC9qcy9zcmMvYWxlcnQnO1xuLy8gaW1wb3J0ICcuL2Jvb3RzdHJhcC00LWRldi9tb2RhbCc7IC8vICdib290c3RyYXAvanMvc3JjL21vZGFsJztcbi8vIGltcG9ydCAnLi9ib290c3RyYXAtNC1kZXYvdG9vbHRpcCc7IC8vICdib290c3RyYXAvanMvc3JjL3Rvb2x0aXAnO1xuLy8gaW1wb3J0ICcuL2Jvb3RzdHJhcC00LWRldi9kcm9wZG93bic7IC8vICdib290c3RyYXAvanMvc3JjL2Ryb3Bkb3duJztcblxuLy8gaW1wb3J0ICdqcXVlcnktbWF0Y2gtaGVpZ2h0L2Rpc3QvanF1ZXJ5Lm1hdGNoSGVpZ2h0Jztcbi8vIGltcG9ydCAnZGF0YXRhYmxlcy5uZXQnO1xuLy8gaW1wb3J0ICdzbGljay1jYXJvdXNlbC9zbGljay9zbGljay5qcyc7XG5cbmltcG9ydCBhcGkgZnJvbSAnLi9hcGknO1xuaW1wb3J0ICcuL2RlbW8nO1xuaW1wb3J0ICcuL2FidGVzdGluZyc7XG5pbXBvcnQgJy4vY29va2llYW5ub3VuY2VtZW50J1xuLy8gaW1wb3J0ICcuL2Zvcm1zJztcbmltcG9ydCAnLi9uYXNrJztcbmltcG9ydCAnLi9mYXEnO1xuaW1wb3J0ICcuL2l0ZW0nO1xuaW1wb3J0ICcuL2l0ZW1EZXRhaWwnO1xuaW1wb3J0ICcuL2Jyb3dzZXJzJztcbmltcG9ydCAnLi9jaGVja291dCc7XG5pbXBvcnQgJy4vc2VsbGVyJztcbmltcG9ydCAnLi9hY2NvdW50JztcbmltcG9ydCAnLi9jb3VudGRvd24nO1xuXG5jbGFzcyBBcHAge1xuXG4gIGNvbnN0cnVjdG9yICgpIHtcbiAgICAvLyBib290c3RyYXBcbiAgICB0aGlzLiRvbkluaXQoKTtcbiAgICAkKGRvY3VtZW50KS5yZWFkeSh0aGlzLiRvblJlYWR5LmJpbmQodGhpcykpO1xuICB9XG5cbiAgLyoqXG4gICAqIEluaXRcbiAgICovXG4gICRvbkluaXQgKCkge1xuICAgIC8vIGNvbnNvbGUubG9nKCdhcHAuanMgaW5pdGlhbGl6ZWQnKTtcbiAgICB0aGlzLl91cGRhdGVDb3B5cmlnaHRZZWFyKCk7XG4gICAgdGhpcy5fYWNjb3VudE1lbnUoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBPbiBkb2N1bWVudCByZWFkeVxuICAgKi9cbiAgJG9uUmVhZHkgKCkge1xuICAgIC8vIGNvbnNvbGUubG9nKCdhcHAuanMgZG9jdW1lbnQgaXMgcmVhZHknKTtcbiAgICB0aGlzLl9fJGl0ZW1Db2xzID0gJCgnLmhzSXRlbV9fY29sJyk7XG5cbiAgICB0aGlzLl8kd2luID0gJCh3aW5kb3cpO1xuXG4gICAgLy8gdGhpcy5fbW9iaWxlSW1hZ2VzKCk7XG4gICAgdGhpcy5fbWF0Y2hDb2xzSGVpZ2h0KCk7XG4gICAgdGhpcy5fbWFuYWdlQ2F0c1NsaWRlcigpO1xuICAgIHRoaXMuX2luaXRNb2RhbHMoKTtcbiAgICB0aGlzLl9pbml0Rm9ybXMoKTtcbiAgICB0aGlzLl9pbml0VGFibGVzKCk7XG4gICAgdGhpcy5faW5pdERyb3Bkb3ducygpO1xuICAgIHRoaXMuX2luaXRBdXRoTW9kYWwoKTtcbiAgICB0aGlzLl8kd2luLnJlc2l6ZSh0aGlzLl9tYXRjaENvbHNIZWlnaHQuYmluZCh0aGlzKSk7XG4gICAgdGhpcy5fJHdpbi5yZXNpemUodGhpcy5fbWFuYWdlQ2F0c1NsaWRlci5iaW5kKHRoaXMpKTtcbiAgICAvLyB0aGlzLl8kd2luLnJlc2l6ZSh0aGlzLl9tb2JpbGVJbWFnZXMuYmluZCh0aGlzKSk7XG4gIH1cblxuICAvKipcbiAgICogSW5pdCB0b29sdGlwc1xuICAgKlxuICAgKi9cbiAgX2luaXRUb29sdGlwcyAoKSB7XG4gICAgLy8gYm9vdHN0cmFwIHRvb2x0aXBzXG4gICAgLy8gJCgnLmpzLXRvb2x0aXAnKS50b29sdGlwKHt9KTtcbiAgICAkKCcuc2hpcHBpbmd0aW1lLXRvb2x0aXAnKS50b29sdGlwKHtcbiAgICAgIGFuaW1hdGlvbjogZmFsc2UsXG4gICAgICBvZmZzZXQ6ICctMTBweCAwJyxcbiAgICAgIC8vIGRlbGF5OiB7IGhpZGU6IDEwMDAwMDAgfSwgLy8gZm9yIGRlYnVnZ2luZ1xuICAgICAgdGVtcGxhdGU6ICc8ZGl2IGNsYXNzPVwidG9vbHRpcCB0b29sdGlwLXRvcCB0b29sdGlwLS1saWdodCBzaGlwcGluZ3RpbWVfX3Rvb2x0aXBcIiByb2xlPVwidG9vbHRpcFwiPjxkaXYgY2xhc3M9XCJ0b29sdGlwLWFycm93XCI+PC9kaXY+PGRpdiBjbGFzcz1cInRvb2x0aXAtaW5uZXJcIj48L2Rpdj48L2Rpdj4nXG4gICAgfSk7XG4gICAgLy8gJCgnLnNoaXBwaW5ndGltZScpLmVhY2goZnVuY3Rpb24gKCkge1xuICAgIC8vICAgJCh0aGlzKS50b29sdGlwKHtcbiAgICAvLyAgICAgdGVtcGxhdGU6ICc8ZGl2IGNsYXNzPVwidG9vbHRpcCB0b29sdGlwLS1saWdodFwiIHJvbGU9XCJ0b29sdGlwXCI+PGRpdiBjbGFzcz1cInRvb2x0aXAtYXJyb3dcIj48L2Rpdj48ZGl2IGNsYXNzPVwidG9vbHRpcC1pbm5lclwiPjwvZGl2PjwvZGl2PidcbiAgICAvLyAgICAgY29udGFpbmVyOiB0aGlzLFxuICAgIC8vICAgICBvZmZzZXQ6ICcwIC04MCUnLFxuICAgIC8vICAgICBkZWxheTogeyBoaWRlOiAxMDAwMDAwIH0gLy8gZm9yIGRlYnVnZ2luZ1xuICAgIC8vICAgfSk7XG4gICAgLy8gfSk7XG4gIH1cblxuICAvKipcbiAgICogTWFuYWdlIGl0ZW0gY2FyZCdzIG1vYmlsZSBpbWFnZXNcbiAgICovXG4gIF9tb2JpbGVJbWFnZXMgKCkge1xuICAgIGlmICgkKHdpbmRvdykud2lkdGgoKSA8IDk5Mikge1xuICAgICAgbGV0IG1vYmlsZVByb2R1Y3RJbWFnZXMgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKCdoc0l0ZW1DYXJkX19ib3R0b20taW1nJyk7XG4gICAgICBpZiAobW9iaWxlUHJvZHVjdEltYWdlcykge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG1vYmlsZVByb2R1Y3RJbWFnZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBsZXQgdG1wSW1nID0gbmV3IEltYWdlKCk7XG4gICAgICAgICAgbGV0IGltZyA9IG1vYmlsZVByb2R1Y3RJbWFnZXNbaV07XG4gICAgICAgICAgdG1wSW1nLnNyYyA9IGltZy5zcmM7XG5cbiAgICAgICAgICBsZXQgJHdyYXBwZXIgPSAkKGltZy5wYXJlbnROb2RlKTtcblxuICAgICAgICAgIGxldCBpbWdDc3NTdHJpbmcgPSAnJztcblxuICAgICAgICAgIHRtcEltZy5vbmxvYWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBsZXQgd3JhcHBlcldpZHRoID0gJHdyYXBwZXIub3V0ZXJXaWR0aCh0cnVlKTsvLy5vZmZzZXRXaWR0aDtcbiAgICAgICAgICAgIGxldCB3cmFwcGVySGVpZ2h0ID0gJHdyYXBwZXIub3V0ZXJIZWlnaHQodHJ1ZSk7Ly8gLm9mZnNldEhlaWdodDtcbiAgICAgICAgICAgIGxldCBpbWdXaWR0aCA9IHRtcEltZy5uYXR1cmFsV2lkdGg7XG4gICAgICAgICAgICBsZXQgaW1nSGVpZ2h0ID0gdG1wSW1nLm5hdHVyYWxIZWlnaHQ7XG4gICAgICAgICAgICBsZXQgYSA9IE1hdGgubWF4KHdyYXBwZXJIZWlnaHQsIGltZy5oZWlnaHQpO1xuICAgICAgICAgICAgY29uc29sZS5sb2coJ3dyYXBwZXJIZWlnaHQnLCB3cmFwcGVySGVpZ2h0LCAnd3JhcHBlckhlaWdodCcsIHdyYXBwZXJIZWlnaHQpO1xuICAgICAgICAgICAgaWYgKGltZ0hlaWdodCA+IGltZ1dpZHRoKSB7XG4gICAgICAgICAgICAgIGltZ0Nzc1N0cmluZyArPSBgbWF4LXdpZHRoOiR7d3JhcHBlcldpZHRofXB4O2hlaWdodDphdXRvO2xlZnQ6MDt0b3A6NTAlO21hcmdpbi10b3A6LSR7aW1nLmhlaWdodCAvIDJ9cHg7YDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGltZ0Nzc1N0cmluZyArPSBgbWF4LWhlaWdodDoke3dyYXBwZXJIZWlnaHR9cHg7d2lkdGg6YXV0bztsZWZ0OjUwJTt0b3A6MDttYXJnaW4tbGVmdDotJHtpbWcud2lkdGggLyAyfXB4O2A7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGltZy5zdHlsZS5jc3NUZXh0ID0gaW1nQ3NzU3RyaW5nICsgJ29wYWNpdHk6MTsnO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBNYXRjaCB0aGUgaGVpZ2h0IG9mIHRoZSBpdGVtIGNhcmRzJyBjb2x1bW5zXG4gICAqL1xuICBfbWF0Y2hDb2xzSGVpZ2h0ICgpIHtcbiAgICBpZiAodGhpcy5fXyRpdGVtQ29scy5sZW5ndGgpIHtcbiAgICAgIGlmICgkKHdpbmRvdykud2lkdGgoKSA+PSA5OTIpIHtcbiAgICAgICAgdGhpcy5fXyRpdGVtQ29scy5tYXRjaEhlaWdodCh7fSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9fJGl0ZW1Db2xzLm1hdGNoSGVpZ2h0KHsgcmVtb3ZlOiB0cnVlIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBNYW5hZ2UgY2F0ZWdvcmllcyBzbGlkZXJcbiAgICovXG4gIF9tYW5hZ2VDYXRzU2xpZGVyICgpIHtcbiAgICBjb25zdCAkc3ViaGVhZGVyTGlzdCA9ICQoJy5hcHBTdWJoZWFkZXJfX2xpc3QnKTtcbiAgICBjb25zdCAkc3ViaGVhZGVyTGlua3MgPSAkKCcuYXBwU3ViaGVhZGVyX19saW5rJyk7XG4gICAgbGV0IGxpc3RGdWxsV2lkdGggPSAwO1xuICAgIGxldCBjdXJyZW50TGlua0lkeDtcbiAgICBsZXQgb25lU2xpZGVXaWR0aDtcblxuICAgIC8qKlxuICAgICAqIFNob3cgaGludCBzY3JvbGxzIG9ubHkgd2hlbiBpdCdzIG5lZWRlZFxuICAgICAqXG4gICAgICovXG4gICAgY29uc3QgX21heWJlU2hvd0hpbnRTY3JvbGxzID0gZnVuY3Rpb24gKGUsIHNsaWNrLCBjdXJyZW50LCBuZXh0SWR4KSB7XG4gICAgICBpZiAobmV4dElkeCA8ICRzdWJoZWFkZXJMaW5rcy5sZW5ndGggLSAzKSB7XG4gICAgICAgICRzdWJoZWFkZXJMaXN0LmFkZENsYXNzKCdzbGljay1oaW50LW5leHQnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgICRzdWJoZWFkZXJMaXN0LnJlbW92ZUNsYXNzKCdzbGljay1oaW50LW5leHQnKTtcbiAgICAgIH1cblxuICAgICAgaWYgKG5leHRJZHggPiAxKSB7XG4gICAgICAgICRzdWJoZWFkZXJMaXN0LmFkZENsYXNzKCdzbGljay1oaW50LXByZXYnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgICRzdWJoZWFkZXJMaXN0LnJlbW92ZUNsYXNzKCdzbGljay1oaW50LXByZXYnKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoISRzdWJoZWFkZXJMaXN0Lmxlbmd0aCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAkc3ViaGVhZGVyTGlua3MuZWFjaCgoaWR4LCBpdGVtKSA9PiB7XG4gICAgICBsZXQgJGl0ZW0gPSAkKGl0ZW0pO1xuICAgICAgb25lU2xpZGVXaWR0aCA9ICRpdGVtLndpZHRoKCk7XG4gICAgICBsaXN0RnVsbFdpZHRoID0gbGlzdEZ1bGxXaWR0aCArIG9uZVNsaWRlV2lkdGg7XG4gICAgICBpZiAoJGl0ZW0uaGFzQ2xhc3MoJ2FjdGl2ZScpKSB7XG4gICAgICAgIGN1cnJlbnRMaW5rSWR4ID0gaWR4O1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgLy8gaWYgd2UgaGF2ZSBhIHNsaWRlclxuICAgIGlmICgkc3ViaGVhZGVyTGlzdC53aWR0aCgpIDwgbGlzdEZ1bGxXaWR0aCkge1xuICAgICAgLy8ganVzdCB1cGRhdGUgdGhlIGN1cnJlbnQgc2xpZGVcbiAgICAgIGlmICh0aGlzLl9jYXRzU2xpZGVyKSB7XG4gICAgICAgIGlmIChjdXJyZW50TGlua0lkeCB8fCBjdXJyZW50TGlua0lkeCA9PT0gMCkge1xuICAgICAgICAgIHRoaXMuX2NhdHNTbGlkZXIudHJpZ2dlcignc2xpY2tHb1RvJywgY3VycmVudExpbmtJZHgpO1xuICAgICAgICB9XG4gICAgICAvLyBvciBpbml0IHRoZSBzbGlkZXJcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX2NhdHNTbGlkZXJIdG1sUHJlU2xpY2sgPSAkc3ViaGVhZGVyTGlzdC5odG1sKCk7XG5cbiAgICAgICAgdGhpcy5fY2F0c1NsaWRlciA9ICRzdWJoZWFkZXJMaXN0LnNsaWNrKHtcbiAgICAgICAgICAvLyBzbGlkZXNUb1Nob3c6IDQsIC8vICRzdWJoZWFkZXJMaW5rcy5sZW5ndGgsXG4gICAgICAgICAgZG90czogZmFsc2UsXG4gICAgICAgICAgYXJyb3dzOiBmYWxzZSxcbiAgICAgICAgICB2YXJpYWJsZVdpZHRoOiB0cnVlLFxuICAgICAgICAgIHNsaWRlc1RvU2Nyb2xsOiAxLFxuICAgICAgICAgIGNlbnRlck1vZGU6IHRoaXMuX2RldGVybWluZUlmQ2VudGVyTW9kZShsaXN0RnVsbFdpZHRoLCBvbmVTbGlkZVdpZHRoLCBjdXJyZW50TGlua0lkeCksXG4gICAgICAgICAgaW5maW5pdGU6IGZhbHNlLFxuICAgICAgICAgIGluaXRpYWxTbGlkZTogY3VycmVudExpbmtJZHhcbiAgICAgICAgfSk7XG5cbiAgICAgICAgX21heWJlU2hvd0hpbnRTY3JvbGxzKG51bGwsIG51bGwsIG51bGwsIGN1cnJlbnRMaW5rSWR4KTtcblxuICAgICAgICB0aGlzLl9jYXRzU2xpZGVyLm9uKCdiZWZvcmVDaGFuZ2UnLCBfbWF5YmVTaG93SGludFNjcm9sbHMpO1xuICAgICAgfVxuICAgIC8vIGlmIHdlIGRvbid0IHdhbnQgdG8gaGF2ZSBhIHNsaWRlclxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAodGhpcy5fY2F0c1NsaWRlcikge1xuICAgICAgICB0aGlzLl9jYXRzU2xpZGVyLnNsaWNrKCd1bnNsaWNrJylcbiAgICAgICAgICAucmVtb3ZlQ2xhc3MoJ3NsaWNrLWhpbnQtcHJldicpXG4gICAgICAgICAgLnJlbW92ZUNsYXNzKCdzbGljay1oaW50LW5leHQnKTtcbiAgICAgICAgJHN1YmhlYWRlckxpc3QuaHRtbCh0aGlzLl9jYXRzU2xpZGVySHRtbFByZVNsaWNrKTtcbiAgICAgICAgdGhpcy5fY2F0c1NsaWRlciA9IG51bGw7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIERldGVybWluZSBpZiB0aGUgY2F0ZWdvcmllcyBzbGlkZXIgc2hvdWxkIHB1dCB0aGUgY3VycmVudCBpY29uXG4gICAqIGluIHRoZSBjZW50ZXIsIHRoaXMgaXMgdG8gcHJldmVudCB0byBoYXZlIGEgcGFydGlhbGx5IGVtcHR5IHNsaWRlclxuICAgKiBvbiB0aGUgbGVmdCBoYW5kIHNpZGUuXG4gICAqXG4gICAqIEBwYXJhbSAge051bWJlcn0gIGxpc3RGdWxsV2lkdGhcbiAgICogQHBhcmFtICB7TnVtYmVyfSAgb25lU2xpZGVXaWR0aFxuICAgKiBAcGFyYW0gIHtOdW1iZXJ9ICBjdXJyZW50TGlua0lkeFxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cbiAgX2RldGVybWluZUlmQ2VudGVyTW9kZSAobGlzdEZ1bGxXaWR0aCwgb25lU2xpZGVXaWR0aCwgY3VycmVudExpbmtJZHgpIHtcbiAgICBjb25zdCBjb250YWluZXJXaWR0aCA9ICQod2luZG93KS53aWR0aCgpO1xuICAgIGNvbnN0IHNsaWRlc1RoYXRGaXQgPSBjb250YWluZXJXaWR0aCAvIG9uZVNsaWRlV2lkdGg7XG4gICAgLy8gY29uc29sZS5sb2coYGN1cnJlbnRMaW5rSWR4ID0gJHtjdXJyZW50TGlua0lkeH0sIHNsaWRlc1RoYXRGaXQgPSAke3NsaWRlc1RoYXRGaXR9YCk7XG4gICAgLy8gaWYgKGN1cnJlbnRMaW5rSWR4IDwgc2xpZGVzVGhhdEZpdCkge1xuICAgIC8vICAgcmV0dXJuIGZhbHNlO1xuICAgIC8vIH1cbiAgICBpZiAoY3VycmVudExpbmtJZHggPT09IDApIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICAvKipcbiAgICogRm9yIGNlbnRlcmVkIG1vZGFsXG4gICAqXG4gICAqIEBzZWUgIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vYS80MTM3NzUwMi8xOTM4OTcwXG4gICAqL1xuICBfaW5pdE1vZGFscyAoKSB7XG4gICAgJCgnLm1vZGFsLWRpYWxvZycpLm9uKCdjbGljayB0YXAnLCBmdW5jdGlvbihlKSB7XG4gICAgICBjb25zdCBfXyRtb2RhbERpYWxvZyA9ICQodGhpcyk7XG4gICAgICBpZiAoJChlLnRhcmdldCkuaGFzQ2xhc3MoJ21vZGFsLWRpYWxvZycpKSB7XG4gICAgICAgIF9fJG1vZGFsRGlhbG9nLnBhcmVudCgpLm1vZGFsKCdoaWRlJyk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogSW5pdCBmb3JtcyAodmFsaWRhdGlvbilcbiAgICovXG4gIF9pbml0Rm9ybXMgKCkge1xuICAgICQoJy5mb3JtLXZhbGlkYXRlJykudmFsaWRhdGUoe1xuICAgICAgZXJyb3JDbGFzczogJ2hhcy1kYW5nZXInLFxuICAgICAgdmFsaWRDbGFzczogJ2hhcy1zdWNjZXNzJyxcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJbml0IHRhYmxlc1xuICAgKi9cbiAgX2luaXRUYWJsZXMgKCkge1xuICAgIC8vIGRhdGFibGUgb24gJ215IGFjY291bnQnIHBhZ2VzXG4gICAgJCgnLmRhdGF0YWJsZScpLkRhdGFUYWJsZSh7XG4gICAgICBzZWFyY2hpbmc6IGZhbHNlLFxuICAgICAgb3JkZXJpbmc6IGZhbHNlLFxuICAgICAgZHJhd0NhbGxiYWNrOiB0aGlzLl9pbml0VG9vbHRpcHMuYmluZCh0aGlzKVxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEluaXQgZHJvcGRvd25zXG4gICAqL1xuICBfaW5pdERyb3Bkb3ducyAoKSB7XG4gICAgLy8gZHJvcGRvd25cbiAgICAkKCcjaHNMYW5nX19oZWFkZXInKVxuICAgICAgLm9uKCdzaG93LmJzLmRyb3Bkb3duJywgKCkgPT4ge1xuICAgICAgICAkKCcjaHNIZWFkZXInKS5hZGRDbGFzcygnbGFzdC1kcm9wZG93bi1vcGVuJyk7XG4gICAgICB9KVxuICAgICAgLm9uKCdoaWRlLmJzLmRyb3Bkb3duJywgKCkgPT4ge1xuICAgICAgICAkKCcjaHNIZWFkZXInKS5yZW1vdmVDbGFzcygnbGFzdC1kcm9wZG93bi1vcGVuJyk7XG4gICAgICB9KTtcblxuICAgIC8vICQoJy5uYXZzZWxlY3RvcicpIC8vIDk5MSBjaGFuZ2UgdG8gPG9wdGlvbj5cbiAgICAkKCcuSlNuYXZzZWxfX3NlbGVjdCcpLm9uKCdjaGFuZ2UnLCBmdW5jdGlvbiAoKSB7XG4gICAgICB3aW5kb3cubG9jYXRpb24uaHJlZiA9IHRoaXMudmFsdWU7XG4gICAgICAvLyBnZXRBdHRyaWJ1dGUoJ2RhdGEtaHJlZicpO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFVwZGF0ZSBjb3B5cmlnaHQgeWVhclxuICAgKi9cbiAgX3VwZGF0ZUNvcHlyaWdodFllYXIoKSB7XG4gICAgdmFyIGVsID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2pzLWNvcHl5ZWFyJyk7XG4gICAgaWYgKGVsKSB7XG4gICAgICBlbC5pbm5lckhUTUwgPSBuZXcgRGF0ZSgpLmdldEZ1bGxZZWFyKCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEFjY291bnQgbWVudVxuICAgKi9cbiAgX2FjY291bnRNZW51ICgpIHtcbiAgICB2YXIgZWwgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnanMtbXlhY2NvdW50X2J0bicpO1xuICAgIGlmIChlbCkge1xuICAgICAgZWwub25jbGljayA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZG9jdW1lbnQuYm9keS5jbGFzc0xpc3QuYWRkKCdoc0FjY291bnQtLW1lbnUtb3BlbicpO1xuICAgICAgfTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogSW5pdCBhdXRoZW50aWNhdGlvbiBtb2RhbHNcbiAgICovXG4gIF9pbml0QXV0aE1vZGFsICgpIHtcbiAgICBsZXQgJGF1dGhNb2RhbCA9ICQoJyNoc0F1dGhNb2RhbCcpO1xuICAgIHRoaXMuX18kYXV0aE1vZGFsID0gJGF1dGhNb2RhbDtcbiAgICBpZiAoISRhdXRoTW9kYWwubGVuZ3RoKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgJGF1dGhNb2RhbC5vbignc2hvdy5icy5tb2RhbCcsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAkKCdib2R5JykuYWRkQ2xhc3MoJ2FwcEF1dGhNb2RhbC0tb3BlbicpO1xuICAgIH0pO1xuICAgICRhdXRoTW9kYWwub24oJ2hpZGRlbi5icy5tb2RhbCcsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAkKCdib2R5JykucmVtb3ZlQ2xhc3MoJ2FwcEF1dGhNb2RhbC0tb3BlbicpO1xuICAgIH0pO1xuICAgICRhdXRoTW9kYWwubW9kYWwoJ2hpZGUnKTtcbiAgICAvLyAkYXV0aE1vZGFsLm1vZGFsKCdoaWRlJyk7XG5cbiAgICAkKGRvY3VtZW50KS5vbignY2xpY2snLCAnW2RhdGEtYXV0aG1vZGFsXScsIGZ1bmN0aW9uIChlKSB7XG4gICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICBsZXQgYnRuID0gdGhpcztcbiAgICAgIGxldCAkYnRuID0gJCh0aGlzKTtcbiAgICAgIGxldCB2aWV3ID0gdGhpcy5nZXRBdHRyaWJ1dGUoJ2RhdGEtYXV0aG1vZGFsJyk7XG4gICAgICBpZiAoIXZpZXcpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdgZGF0YS1hdXRobW9kYWxgIG11c3QgaGF2ZSBhIHZhbHVlIChlLmcuIGBsb2dpbmAgb3IgYHJlZ2lzdGVyYCknKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgJGF1dGhNb2RhbC5hdHRyKCdkYXRhLXZpZXcnLCB2aWV3KTtcbiAgICAgIHRyeSB7XG4gICAgICAgICRhdXRoTW9kYWwubW9kYWwoJ3Nob3cnKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY29uc29sZS5sb2coZSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogUHJvbXB0IGxvZ2luIG1vZGFsXG4gICAqXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIHByb21wdExvZ2luICgpIHtcbiAgICBpZiAodGhpcy5fXyRhdXRoTW9kYWwpIHtcbiAgICAgIHRoaXMuX18kYXV0aE1vZGFsLmF0dHIoJ2RhdGEtdmlldycsICdsb2dpbicpO1xuICAgICAgdGhpcy5fXyRhdXRoTW9kYWwubW9kYWwoKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUHJvbXB0IHJlZ2lzdGVyIG1vZGFsXG4gICAqXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIHByb21wdFJlZ2lzdGVyICgpIHtcbiAgICBpZiAodGhpcy5fXyRhdXRoTW9kYWwpIHtcbiAgICAgIHRoaXMuX18kYXV0aE1vZGFsLmF0dHIoJ2RhdGEtdmlldycsICdyZWdpc3RlcicpO1xuICAgICAgdGhpcy5fXyRhdXRoTW9kYWwubW9kYWwoKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogVXBkYXRlIFVJIChFcndpbiBjYWxsJ3MgdGhpcyB3aGVuIG9wZW5pbmcgdGhlIGl0ZW0gbW9kYWwpXG4gICAqXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIHVwZGF0ZVVJICgpIHtcbiAgICB0cnkge1xuICAgICAgYXBpWydpdGVtRGV0YWlsJ10uJG9uUmVhZHkoKTtcbiAgICB9IGNhdGNoIChlKSB7fVxuICB9XG59XG5cbi8vIGV4cG9ydCB0byBwdWJsaWMgQVBJXG5hcGlbJ2FwcCddID0gbmV3IEFwcCgpO1xuIl0sIm5hbWVzIjpbImNvbnN0IiwibGV0IiwidGhpcyIsImFwaSIsIiQiLCJhcmd1bWVudHMiLCJWdWUiLCJWZWVWYWxpZGF0ZSIsImkiXSwibWFwcGluZ3MiOiI7Ozs7RUFBQTs7Ozs7OztBQU9BQSxNQUFNLElBQUksR0FBRyxXQUFFLENBQUMsRUFBRTs7Ozs7Ozs7O0lBU2hCQyxJQUFJLFVBQVUsR0FBRyxNQUFLOztJQUV0QkQsSUFBTSxPQUFPLEdBQUcsUUFBTzs7SUFFdkJBLElBQU0sa0JBQWtCLEdBQUc7TUFDekIsZ0JBQWdCLEdBQUcscUJBQXFCO01BQ3hDLGFBQWEsTUFBTSxlQUFlO01BQ2xDLFdBQVcsUUFBUSwrQkFBK0I7TUFDbEQsVUFBVSxTQUFTLGVBQWU7TUFDbkM7OztJQUdELFNBQVMsTUFBTSxDQUFDLEdBQUcsRUFBRTtNQUNuQixPQUFPLEVBQUUsQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDLEtBQUssQ0FBQyxlQUFlLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxXQUFXLEVBQUU7S0FDckU7O0lBRUQsU0FBUyxTQUFTLENBQUMsR0FBRyxFQUFFO01BQ3RCLE9B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LENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxFQUFFLENBQUMsQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLENBQUMsRUFBRSxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsTUFBTSxDQUFDLGNBQWMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsWUFBWSxDQUFDLENBQUMsQ0FBQyxDQUFDLFVBQVUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLEVBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLFVBQVUsQ0FBQyxVQUFVLENBQUMsT0FBTyxDQUFDLENBQUMsT0FBTyxDQUFDLENBQUMsVUFBVSxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxPQUFPLE1BQU0sQ0FBQyxTQUFTLENBQUMsY0FBYyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsT0FBTyxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUMsT0FBTyxDQUFDLENBQUMsU0FBUyxDQUFDLGFBQWEsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxPQUFPLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxPQUFPLENBQUMsRUFBQyxDQUFDLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxPQUFPLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxNQUFNLENBQUMsUUFBUSxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsT0FBTyxDQUFDLFVBQVUsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLGFBQWEsQ0FBQyxLQUFLLENBQUMsUUFBUSxDQUFDLFVBQVUsQ0FBQyxDQUFDLENBQUMsS0FBSyxFQUFFLENBQUMsQ0FBQyxHQUFHLENBQUMsU0FBUyxDQUFDLEdBQUcsQ0FBQyxzQkFBc0IsRUFBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxVQUFVLENBQUMsVUFBVSxDQUFDLFVBQVUsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLFNBQVMsQ0FBQyxNQUFNLENBQUMsc0JBQXNCLEVBQUMsQ0FBQyxDQUFDLEdBQUcsRUFBQyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsVUFBVSxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxhQUFhLENBQUMsSUFBSSxLQUFLLENBQUMsT0FBTyxDQUFDLEVBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsTUFBTSxDQUFDLENBQUMsTUFBTSxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUMsT0FBTyxDQUFDLENBQUMsTUFBTSxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLFFBQVEsQ0FBQyxDQUFDLFNBQVMsQ0FBQyxVQUFVLENBQUMsQ0FBQyxLQUFLLENBQUMsQ0FBQyxlQUFlLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUMsQ0FBQyxRQUFRLENBQUMsVUFBVSxDQUFDLE1BQU0sQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLFFBQVEsQ0FBQyxhQUFhLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsRUFBRSxNQUFNLENBQUMsQ0FBQyxFQUFDLENBQUMsQ0FBQyxNQUFNLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxTQUFTLENBQUMsR0FBRyxDQUFDLHNCQUFzQixDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxTQUFTLENBQUMsTUFBTSxDQUFDLHNCQUFzQixFQUFDLENBQUMsQ0FBQyxFQUFDLENBQUMsQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQzs7Ozs7O0FDRzlqRCxBQUlBLE1BQU0sUUFBUSxHQUVaLGlCQUFXLElBQUk7O0lBRWYsSUFBTSxDQUFDLFNBQVMsR0FBRyxRQUFRLENBQUMsY0FBYyxDQUFDLFVBQVUsQ0FBQyxDQUFDOztJQUV2RCxJQUFNLElBQUksQ0FBQyxTQUFTLEVBQUU7TUFDcEIsSUFBTSxDQUFDLE9BQU8sRUFBRSxDQUFDO01BQ2pCRSxHQUFHLENBQUMsUUFBUSxDQUFDLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUM7S0FDN0M7RUFDTCxFQUFHOztFQUVIOzs7RUFHQSxtQkFBRSxPQUFPLHVCQUFJO0lBQ1gsSUFBTSxDQUFDLFlBQVksR0FBRyxVQUFVLENBQUM7SUFDakMsSUFBTSxDQUFDLGlCQUFpQixHQUFHLEdBQUcsQ0FBQztJQUMvQixJQUFNLENBQUMsWUFBWSxHQUFHLENBQUMsVUFBVSxFQUFFLFNBQVMsRUFBRSxRQUFRLENBQUMsQ0FBQzs7SUFFeEQsSUFBUSxXQUFXLEdBQUcsTUFBTSxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLEdBQUcsRUFBRSxFQUFFLENBQUMsSUFBSSxJQUFJLENBQUMsWUFBWSxDQUFDO0lBQ2pGLElBQU0sQ0FBQyxRQUFRLENBQUMsV0FBVyxDQUFDLENBQUM7O0lBRTdCLEdBQUssQ0FBQyxHQUFHLENBQUNHLFNBQVcsQ0FBQyxDQUFDO0lBQ3ZCLEdBQUssQ0FBQyxHQUFHLENBQUMsVUFBVSxDQUFDLENBQUM7O0lBRXRCLEdBQUssQ0FBQyxTQUFTLENBQUMsV0FBVyxFQUFFO01BQzNCLFFBQVUsRUFBRSxnSEFBZ0g7TUFDNUgsSUFBTSxFQUFFLFlBQVk7UUFDbEIsT0FBUztVQUNQLEVBQUksRUFBRSxFQUFFO1VBQ1IsSUFBTSxFQUFFLEVBQUU7VUFDVixJQUFNLEVBQUUsRUFBRTtVQUNWLFFBQVUsRUFBRSxFQUFFO1NBQ2I7T0FDRjtLQUNGLEVBQUM7O0lBRUosSUFBTSxDQUFDLEdBQUcsR0FBRyxJQUFJLEdBQUcsQ0FBQztNQUNuQixFQUFJLEVBQUUsSUFBSSxDQUFDLFNBQVM7TUFDcEIsV0FBYSxFQUFFLElBQUk7TUFDbkIsYUFBZSxFQUFFLEtBQUs7TUFDdEIsVUFBWSxFQUFFLENBQUMsSUFBSSxFQUFFLElBQUksQ0FBQztNQUMxQixJQUFNLEVBQUUsWUFBWTtRQUNsQixPQUFTLE1BQU0sQ0FBQyxZQUFZLENBQUM7T0FDNUI7TUFDSCxPQUFTLEVBQUU7UUFDVCxLQUFPLEVBQUUsVUFBVSxLQUFLLEVBQUUsS0FBSyxFQUFFO1VBQy9CLE9BQVMsS0FBSyxHQUFHLEtBQUssQ0FBQyxPQUFPLENBQUMsS0FBSyxJQUFJLENBQUMsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxHQUFHLEVBQUUsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDO1NBQ2hFO09BQ0Y7TUFDSCxPQUFTLEVBQUUsWUFBWTtRQUNyQixPQUFTLENBQUMsR0FBRyxDQUFDLGdCQUFnQixDQUFDLENBQUM7T0FDL0I7TUFDSCxPQUFTLEVBQUU7UUFDVCxRQUFVLEVBQUUsWUFBWTtVQUN0QixBQUVBLE9BQVMsQ0FBQyxHQUFHLENBQUMsbUJBQW1CLEVBQUUsSUFBSSxFQUFFLGdCQUFnQixFQUFFLFNBQVMsRUFBQztTQUNwRTtRQUNILFVBQVksRUFBRSxVQUFVLFNBQVMsRUFBRTtTQUNoQztRQUNILFFBQVUsRUFBRSxZQUFZO1VBQ3RCLElBQU0sQ0FBQyxHQUFHLElBQUksQ0FBQyxJQUFJLENBQUM7VUFDcEIsSUFBTSxDQUFDLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQztVQUNyQixPQUFTLENBQUMsR0FBRyxDQUFDLGdCQUFnQixFQUFFLENBQUMsRUFBRSxPQUFPLEVBQUUsQ0FBQyxFQUFDO1NBQzdDO09BQ0Y7S0FDRixFQUFDOztFQUVOLEVBQUc7O0VBRUgsbUJBQUUsTUFBTSxzQkFBSTs7RUFFWixFQUFHOztFQUVIOzs7RUFHQSxtQkFBRSxRQUFRLHdCQUFJOztJQUVaLElBQU0sQ0FBQyxPQUFPLEdBQUdILEdBQUMsQ0FBQyxXQUFXLENBQUMsQ0FBQzs7O0lBR2hDLElBQU0sQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLE1BQU0sRUFBRTtNQUMxQixPQUFTO0tBQ1I7O0lBRUgsSUFBTSxDQUFDLFdBQVcsR0FBR0EsR0FBQyxDQUFDLFlBQVksQ0FBQyxDQUFDO0lBQ3JDLElBQU0sQ0FBQyxZQUFZLEdBQUdBLEdBQUMsQ0FBQyxpQkFBaUIsQ0FBQyxDQUFDO0lBQzNDLElBQU0sQ0FBQyxjQUFjLEdBQUdBLEdBQUMsQ0FBQyw2QkFBNkIsQ0FBQyxDQUFDO0lBQ3pELElBQU0sQ0FBQyxjQUFjLEdBQUdBLEdBQUMsQ0FBQyxvQkFBb0IsQ0FBQyxDQUFDO0lBQ2hELElBQU0sQ0FBQyxvQkFBb0IsR0FBR0EsR0FBQyxDQUFDLDJCQUEyQixDQUFDLENBQUM7O0lBRTdELElBQU0sQ0FBQyxXQUFXLEVBQUUsQ0FBQztJQUNyQixJQUFNLENBQUMsWUFBWSxFQUFFLENBQUM7SUFDdEIsSUFBTSxDQUFDLFdBQVcsRUFBRSxDQUFDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7RUE0RHZCLEVBQUc7O0VBRUg7Ozs7O0VBS0EsbUJBQUUsUUFBUSxzQkFBRSxRQUFRLEVBQUU7SUFDcEIsTUFBUSxDQUFDLFFBQVEsQ0FBQyxJQUFJLEdBQUcsUUFBUSxDQUFDO0lBQ2xDLElBQU0sQ0FBQyxTQUFTLEdBQUcsSUFBSSxDQUFDLElBQUksQ0FBQztJQUM3QixJQUFNLENBQUMsSUFBSSxHQUFHLFFBQVEsQ0FBQztFQUN6QixFQUFHOztFQUVIOzs7RUFHQSxtQkFBRSxXQUFXLDJCQUFJOzs7SUFDZixJQUFNLENBQUMsWUFBWTtPQUNkLEtBQUssQ0FBQyxNQUFNLENBQUM7T0FDYixFQUFFLENBQUMsZUFBZSxjQUFLO1FBQ3hCLE1BQU0sQ0FBQyxRQUFRLENBQUMsTUFBTSxDQUFDLENBQUM7T0FDdkIsQ0FBQztPQUNELEVBQUUsQ0FBQyxlQUFlLGNBQUs7UUFDeEIsSUFBTSxNQUFNLEdBQUdGLE1BQUksQ0FBQyxTQUFTLENBQUM7UUFDOUIsSUFBTSxNQUFNLEtBQUssTUFBTSxFQUFFO1VBQ3ZCLE1BQVEsR0FBR0EsTUFBSSxDQUFDLFlBQVksQ0FBQztTQUM1QjtRQUNILE1BQU0sQ0FBQyxRQUFRLENBQUMsTUFBTSxDQUFDLENBQUM7T0FDdkIsQ0FBQyxDQUFDO0VBQ1QsRUFBRzs7RUFFSDs7O0VBR0EsbUJBQUUsWUFBWSw0QkFBSTs7O0lBQ2hCLElBQVEsU0FBUyxHQUFHLElBQUksQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsS0FBSyxNQUFNLENBQUM7SUFDdEQsSUFBUSxVQUFVLEdBQUcsU0FBUyxHQUFHLElBQUksQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUMsRUFBRSxJQUFJLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxHQUFHLEtBQUssQ0FBQzs7SUFFL0UsSUFBTSxDQUFDLG9CQUFvQixDQUFDLElBQUksV0FBRSxHQUFHLEVBQUUsT0FBTyxFQUFFO01BQzlDLElBQVEsV0FBVyxHQUFHRSxHQUFDLENBQUMsT0FBTyxDQUFDLENBQUM7TUFDakMsSUFBUSxJQUFJLEdBQUcsV0FBVyxDQUFDLElBQUksQ0FBQyxzQkFBc0IsQ0FBQyxDQUFDO01BQ3hELElBQU0sWUFBWSxHQUFHLFVBQVUsR0FBRyxVQUFVLEtBQUssSUFBSSxHQUFHLEtBQUssQ0FBQzs7TUFFOUQsV0FBYTtTQUNSLFFBQVEsQ0FBQztVQUNWLE1BQVEscUNBQWtDLElBQUksQ0FBRTtVQUNoRCxNQUFRLEVBQUUsb0JBQW9CO1VBQzlCLE1BQVEsRUFBRSxZQUFZO1NBQ3JCLENBQUM7U0FDRCxFQUFFLENBQUMsa0JBQWtCLGNBQUs7VUFDM0IsTUFBTSxDQUFDLFFBQVEsV0FBUSxJQUFJLEVBQUcsQ0FBQztTQUM5QixDQUFDLENBQUM7S0FDTixDQUFDLENBQUM7RUFDUCxFQUFHOztFQUVIOzs7Ozs7RUFNQSxtQkFBRSxXQUFXLHlCQUFFLFNBQVMsRUFBRTs7O0lBQ3hCLElBQVEsSUFBSSxHQUFHLFNBQVMsSUFBSSxJQUFJLENBQUMsSUFBSSxDQUFDOztJQUV0QyxJQUFNLElBQUksS0FBSyxNQUFNLEVBQUU7TUFDckIsSUFBTSxDQUFDLFlBQVksQ0FBQyxLQUFLLENBQUMsTUFBTSxDQUFDLENBQUM7S0FDakM7OztJQUdILElBQU0sQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLG9CQUFvQixFQUFFLElBQUksQ0FBQyxDQUFDOzs7SUFHaEQsSUFBTSxjQUFjLEdBQUcsS0FBSyxDQUFDO0lBQzdCLEtBQU9ILElBQUksQ0FBQyxHQUFHLElBQUksQ0FBQyxZQUFZLENBQUMsTUFBTSxHQUFHLENBQUMsRUFBRSxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsRUFBRSxFQUFFO01BQ3hELElBQU1DLE1BQUksQ0FBQyxZQUFZLENBQUMsQ0FBQyxDQUFDLEtBQUssSUFBSSxFQUFFO1FBQ25DLGNBQWdCLEdBQUcsSUFBSSxDQUFDO1FBQ3hCLE1BQVE7T0FDUDtLQUNGO0lBQ0gsSUFBTSxjQUFjLEVBQUU7TUFDcEIsSUFBTSxDQUFDLGNBQWMsQ0FBQyxNQUFNLFdBQUUsS0FBSyxFQUFFLElBQUksRUFBRTtRQUN6QyxJQUFNLElBQUksQ0FBQyxZQUFZLENBQUMsb0JBQW9CLENBQUMsS0FBSyxjQUFjLEVBQUU7VUFDaEVFLEdBQUcsQ0FBQyxJQUFJLENBQUMsQ0FBQyxRQUFRLENBQUMsTUFBTSxDQUFDLENBQUM7U0FDMUIsTUFBTTtVQUNQQSxHQUFHLENBQUMsSUFBSSxDQUFDLENBQUMsV0FBVyxDQUFDLE1BQU0sRUFBQztTQUM1QjtPQUNGLENBQUMsQ0FBQztLQUNKO0VBQ0wsRUFBRzs7RUFFSDs7Ozs7RUFLQTtFQUNBO0VBQ0E7O0VBRUE7Ozs7Ozs7RUFPQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTs7RUFFQTtFQUNBOztFQUVBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBOztFQUVBOzs7OztFQUtBLG1CQUFFLFdBQVcsMkJBQUk7SUFDZixPQUFTLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsVUFBVSxDQUFDLE1BQU0sQ0FBQyxLQUFLLENBQUMsQ0FBQztJQUNoRCxPQUFTLElBQUksQ0FBQyxPQUFPLENBQUMsS0FBSyxFQUFFLENBQUM7RUFDaEMsRUFBRzs7RUFFSDs7OztFQUlBLG1CQUFFLFdBQVcseUJBQUUsUUFBUSxFQUFFO0VBQ3pCLEVBQUc7O0VBRUg7Ozs7OztFQU1BLG1CQUFFLFdBQVcseUJBQUUsS0FBSyxFQUFFO0lBQ3BCLElBQVEsUUFBUSxHQUFHLFVBQVUsQ0FBQyxLQUFLLENBQUMsQ0FBQzs7SUFFckMsSUFBUSxLQUFLLEdBQUcsUUFBUSxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsQ0FBQyxPQUFPLENBQUMsR0FBRyxFQUFFLEdBQUcsQ0FBQyxDQUFDO0lBQ3RELE9BQVMsSUFBSSxDQUFDLFdBQVcsRUFBRSxHQUFHLEdBQUcsR0FBRyxLQUFLLENBQUM7RUFDNUMsQ0FBRyxDQUNGOzs7QUFHREQsT0FBRyxDQUFDLFVBQVUsQ0FBQyxHQUFHLElBQUksUUFBUSxFQUFFLENBQUM7O0FDclZqQyxNQUFNLE1BQU0sR0FFVixlQUFXLElBQUk7O0lBRWZDLEdBQUcsQ0FBQyxRQUFRLENBQUMsQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQztFQUNoRCxFQUFHOztFQUVIOzs7RUFHQSxpQkFBRSxRQUFRLHdCQUFJOztJQUVaLElBQU0sQ0FBQyxVQUFVLEdBQUdBLEdBQUMsQ0FBQyxrQkFBa0IsQ0FBQyxDQUFDOzs7SUFHMUMsSUFBTSxDQUFDLElBQUksQ0FBQyxVQUFVLENBQUMsTUFBTSxFQUFFO01BQzdCLE9BQVM7S0FDUjs7SUFFSCxJQUFNLENBQUMsa0JBQWtCLEdBQUdBLEdBQUMsQ0FBQyxtQkFBbUIsQ0FBQyxDQUFDOztJQUVuRCxJQUFNLENBQUMsT0FBTyxFQUFFLENBQUM7RUFDbkIsRUFBRzs7RUFFSDs7O0VBR0EsaUJBQUUsT0FBTyx1QkFBSTtJQUNYLElBQVEsSUFBSSxHQUFHLElBQUksQ0FBQzs7SUFFcEIsSUFBTSxDQUFDLGtCQUFrQixDQUFDLElBQUksRUFBRSxDQUFDOzs7OztJQUtqQ0EsR0FBRyxDQUFDLHVCQUF1QixDQUFDLENBQUMsRUFBRSxDQUFDLFFBQVEsRUFBRSxZQUFZO01BQ3BELElBQVEsS0FBSyxHQUFHLElBQUksQ0FBQyxLQUFLLEtBQUssSUFBSSxDQUFDO01BQ3BDLElBQU0sS0FBSyxFQUFFO1FBQ1gsSUFBTSxDQUFDLGtCQUFrQixDQUFDLFNBQVMsRUFBRSxDQUFDO09BQ3JDLE1BQU07UUFDUCxJQUFNLENBQUMsa0JBQWtCLENBQUMsT0FBTyxFQUFFLENBQUM7T0FDbkM7S0FDRixDQUFDLENBQUM7RUFDUCxDQUFHLENBQ0Y7OztBQUdERCxPQUFHLENBQUMsUUFBUSxDQUFDLEdBQUcsSUFBSSxNQUFNLEVBQUUsQ0FBQzs7QUMvQzdCLE1BQU0sT0FBTyxHQUVYLGdCQUFXLElBQUk7O0lBRWYsSUFBTSxDQUFDLE9BQU8sRUFBRSxDQUFDO0lBQ2pCQyxHQUFHLENBQUMsUUFBUSxDQUFDLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUM7RUFDaEQsRUFBRzs7RUFFSDs7O0VBR0Esa0JBQUUsT0FBTyx1QkFBSTtJQUNYLElBQU0sQ0FBQyxpQkFBaUIsR0FBRyxHQUFHLENBQUM7RUFDakMsRUFBRzs7RUFFSDs7O0VBR0Esa0JBQUUsUUFBUSx3QkFBSTs7SUFFWixJQUFNLENBQUMsVUFBVSxHQUFHQSxHQUFDLENBQUMsWUFBWSxDQUFDLENBQUM7OztJQUdwQyxJQUFNLENBQUMsSUFBSSxDQUFDLFVBQVUsQ0FBQyxNQUFNLEVBQUU7TUFDN0IsT0FBUztLQUNSOztJQUVILElBQU0sQ0FBQyxRQUFRLEVBQUUsQ0FBQztJQUNsQixJQUFNLENBQUMsU0FBUyxFQUFFLENBQUM7RUFDckIsRUFBRzs7RUFFSDs7O0VBR0Esa0JBQUUsUUFBUSx3QkFBSTtJQUNaLElBQU0sUUFBUSxHQUFHQSxHQUFDLENBQUMsWUFBWSxDQUFDLENBQUM7SUFDakMsSUFBTSxDQUFDLFFBQVEsQ0FBQyxNQUFNLEVBQUU7TUFDdEIsT0FBUztLQUNSO0lBQ0hBLEdBQUcsQ0FBQyxRQUFRLENBQUMsQ0FBQyxFQUFFLENBQUMsT0FBTyxFQUFFLHNCQUFzQixFQUFFLFVBQVUsQ0FBQyxFQUFFO01BQzdELENBQUcsQ0FBQyxjQUFjLEVBQUUsQ0FBQztNQUNyQixRQUFVLENBQUMsS0FBSyxFQUFFLENBQUM7TUFDbkIsUUFBVSxDQUFDLElBQUksQ0FBQyxvQkFBb0IsQ0FBQyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsWUFBWSxDQUFDLG9CQUFvQixDQUFDLENBQUMsQ0FBQztNQUNwRixRQUFVLENBQUMsSUFBSSxDQUFDLFdBQVcsQ0FBQyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsWUFBWSxDQUFDLFdBQVcsQ0FBQyxDQUFDLENBQUM7Ozs7S0FJakUsQ0FBQyxDQUFDO0VBQ1AsRUFBRzs7RUFFSDs7O0VBR0Esa0JBQUUsU0FBUyx5QkFBSTs7O0lBQ2IsSUFBUSxVQUFVLEdBQUdBLEdBQUMsQ0FBQyxzQkFBc0IsQ0FBQyxDQUFDO0lBQy9DLElBQVEsU0FBUyxHQUFHQSxHQUFDLENBQUMsZ0JBQWdCLENBQUMsQ0FBQztJQUN4QyxJQUFRLFNBQVMsR0FBR0EsR0FBQyxDQUFDLGdCQUFnQixDQUFDLENBQUM7O0lBRXhDLElBQU0sQ0FBQyxVQUFVLENBQUMsTUFBTSxFQUFFO01BQ3hCLE9BQVM7S0FDUjs7SUFFSCxJQUFRLFdBQVcsYUFBSSxLQUFLLEVBQUUsSUFBSSxFQUFFO01BQ2xDLElBQU0sT0FBTyxHQUFHLElBQUksQ0FBQztNQUNyQixJQUFNLFdBQVcsR0FBR0YsTUFBSSxDQUFDLFlBQVksQ0FBQztNQUN0QyxJQUFNLEtBQUssRUFBRTtRQUNYLEtBQU8sQ0FBQyxjQUFjLEVBQUUsQ0FBQztPQUN4QjtNQUNILElBQU0sQ0FBQyxPQUFPLEVBQUU7UUFDZCxPQUFTLEdBQUcsUUFBUSxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsR0FBRyxFQUFFLEVBQUUsQ0FBQyxDQUFDO09BQzFDO01BQ0gsSUFBTSxDQUFDLE9BQU8sRUFBRTtRQUNkLE9BQVM7T0FDUjtNQUNILElBQU0sT0FBTyxLQUFLLE1BQU0sSUFBSSxXQUFXLEtBQUssTUFBTSxFQUFFO1FBQ2xELFNBQVcsQ0FBQyxPQUFPLEVBQUUsQ0FBQztRQUN0QixTQUFXLENBQUMsU0FBUyxFQUFFLENBQUM7UUFDeEIsUUFBVSxDQUFDLElBQUksR0FBR0EsTUFBSSxDQUFDLFlBQVksR0FBRyxNQUFNLENBQUM7T0FDNUMsTUFBTSxJQUFJLE9BQU8sS0FBSyxNQUFNLElBQUksV0FBVyxLQUFLLE1BQU0sRUFBRTtRQUN6RCxTQUFXLENBQUMsT0FBTyxFQUFFLENBQUM7UUFDdEIsU0FBVyxDQUFDLFNBQVMsRUFBRSxDQUFDO1FBQ3hCLFFBQVUsQ0FBQyxJQUFJLEdBQUdBLE1BQUksQ0FBQyxZQUFZLEdBQUcsTUFBTSxDQUFDO09BQzVDO01BQ0Y7O0lBRUgsTUFBUSxDQUFDLGdCQUFnQixDQUFDLFlBQVksRUFBRSxXQUFXLEVBQUUsS0FBSyxDQUFDLENBQUM7O0lBRTVELFdBQWEsQ0FBQyxJQUFJLEVBQUUsTUFBTSxDQUFDLENBQUM7O0lBRTVCLFVBQVksQ0FBQyxLQUFLLFdBQUUsQ0FBQyxFQUFFLEVBQUssV0FBVyxDQUFDLENBQUMsRUFBRSxNQUFNLEdBQUUsQ0FBQyxDQUFDLENBQUM7RUFDeEQsQ0FBRyxDQUNGOzs7QUFHREMsT0FBRyxDQUFDLFNBQVMsQ0FBQyxHQUFHLElBQUksT0FBTyxFQUFFLENBQUM7O0FDOUYvQixNQUFNLFNBQVMsR0FFYixrQkFBVyxJQUFJO0lBQ2YsSUFBTSxDQUFDLE9BQU8sRUFBRSxDQUFDO0lBQ2pCQyxHQUFHLENBQUMsUUFBUSxDQUFDLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUM7RUFDaEQsRUFBRzs7RUFFSDs7O0VBR0Esb0JBQUUsT0FBTyx1QkFBSTtFQUNiLEVBQUc7O0VBRUg7OztFQUdBLG9CQUFFLFFBQVEsd0JBQUk7SUFDWixJQUFNLENBQUMsVUFBVSxHQUFHQSxHQUFDLENBQUMsWUFBWSxDQUFDLENBQUM7O0lBRXBDLElBQU0sQ0FBQyxJQUFJLENBQUMsVUFBVSxDQUFDLE1BQU0sRUFBRTtNQUM3QixPQUFTO0tBQ1I7O0lBRUgsSUFBTSxDQUFDLE9BQU8sR0FBRyxJQUFJLENBQUMsVUFBVSxDQUFDLElBQUksQ0FBQyx5QkFBeUIsQ0FBQyxDQUFDO0lBQ2pFLElBQU0sQ0FBQyxRQUFRLEdBQUcsSUFBSSxDQUFDLFVBQVUsQ0FBQyxJQUFJLENBQUMsMEJBQTBCLENBQUMsQ0FBQztJQUNuRSxJQUFNLENBQUMsVUFBVSxHQUFHLElBQUksQ0FBQyxVQUFVLENBQUMsSUFBSSxDQUFDLDRCQUE0QixDQUFDLENBQUM7SUFDdkUsSUFBTSxDQUFDLFVBQVUsR0FBRyxJQUFJLENBQUMsVUFBVSxDQUFDLElBQUksQ0FBQyw0QkFBNEIsQ0FBQyxDQUFDOztJQUV2RSxJQUFNLENBQUMsYUFBYSxFQUFFLENBQUM7RUFDekIsRUFBRzs7RUFFSDs7O0VBR0Esb0JBQUUsSUFBSSxvQkFBSTtJQUNSLElBQU0sQ0FBQyxRQUFRLEVBQUUsQ0FBQztFQUNwQixFQUFHOztFQUVIOzs7O0VBSUEsb0JBQUUsYUFBYSw2QkFBSTs7O0lBQ2pCLElBQU0sQ0FBQyxRQUFRLEdBQUcsQ0FBQyxDQUFDO0lBQ3BCLElBQU0sSUFBSSxDQUFDLFNBQVMsRUFBRTtNQUNwQixhQUFlLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxDQUFDO0tBQy9CO0lBQ0gsSUFBTSxDQUFDLFNBQVMsR0FBRyxXQUFXLGFBQUk7TUFDaEMsTUFBTSxDQUFDLFFBQVEsR0FBR0YsTUFBSSxDQUFDLFFBQVEsR0FBRyxDQUFDLENBQUM7TUFDcEMsTUFBTSxDQUFDLE9BQU8sRUFBRSxDQUFDO0tBQ2hCLEVBQUUsSUFBSSxDQUFDLENBQUM7RUFDYixFQUFHOztFQUVIOzs7RUFHQSxvQkFBRSxPQUFPLHVCQUFJO0lBQ1gsSUFBUSxjQUFjLEdBQUcsUUFBUSxDQUFDLElBQUksQ0FBQyxVQUFVLENBQUMsSUFBSSxFQUFFLEVBQUUsRUFBRSxDQUFDLENBQUM7SUFDOUQsSUFBUSxjQUFjLEdBQUcsUUFBUSxDQUFDLElBQUksQ0FBQyxVQUFVLENBQUMsSUFBSSxFQUFFLEVBQUUsRUFBRSxDQUFDLENBQUM7SUFDOUQsSUFBUSxZQUFZLEdBQUcsUUFBUSxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsSUFBSSxFQUFFLEVBQUUsRUFBRSxDQUFDLENBQUM7SUFDMUQsSUFBUSxXQUFXLEdBQUcsUUFBUSxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsSUFBSSxFQUFFLEVBQUUsRUFBRSxDQUFDLENBQUM7O0lBRXhELElBQU0sVUFBVSxHQUFHLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLEVBQUUsSUFBSSxDQUFDLEdBQUcsQ0FBQyxjQUFjLEdBQUcsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxDQUFDLENBQUM7SUFDbEUsSUFBTSxVQUFVLEdBQUcsY0FBYyxDQUFDO0lBQ2xDLElBQU0sUUFBUSxHQUFHLFlBQVksQ0FBQztJQUM5QixJQUFNLE9BQU8sR0FBRyxXQUFXLENBQUM7O0lBRTVCLElBQU0sVUFBVSxLQUFLLENBQUMsQ0FBQyxFQUFFO01BQ3ZCLFVBQVksR0FBRyxFQUFFLENBQUM7TUFDbEIsVUFBWSxHQUFHLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLEVBQUUsSUFBSSxDQUFDLEdBQUcsQ0FBQyxjQUFjLEdBQUcsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxDQUFDLENBQUM7O01BRTlELElBQU0sVUFBVSxLQUFLLENBQUMsQ0FBQyxFQUFFO1FBQ3ZCLFVBQVksR0FBRyxFQUFFLENBQUM7UUFDbEIsUUFBVSxHQUFHLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLEVBQUUsSUFBSSxDQUFDLEdBQUcsQ0FBQyxZQUFZLEdBQUcsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxDQUFDLENBQUM7O1FBRTFELElBQU0sUUFBUSxLQUFLLENBQUMsQ0FBQyxFQUFFO1VBQ3JCLFFBQVUsR0FBRyxFQUFFLENBQUM7VUFDaEIsT0FBUyxHQUFHLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLEVBQUUsSUFBSSxDQUFDLEdBQUcsQ0FBQyxPQUFPLEdBQUcsQ0FBQyxFQUFFLEdBQUcsQ0FBQyxDQUFDLENBQUM7U0FDcEQ7T0FDRjtLQUNGOztJQUVILElBQU0sQ0FBQyxVQUFVLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsVUFBVSxDQUFDLENBQUMsQ0FBQztJQUM5QyxJQUFNLENBQUMsVUFBVSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLFVBQVUsQ0FBQyxDQUFDLENBQUM7SUFDOUMsSUFBTSxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDO0lBQzFDLElBQU0sQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQztFQUMxQyxFQUFHOztFQUVIOzs7Ozs7O0VBT0Esb0JBQUUsSUFBSSxrQkFBRSxHQUFHLEVBQUUsSUFBTSxFQUFFO2lDQUFKLENBQUM7O0lBQ2hCLElBQU0sQ0FBQyxHQUFHLEdBQUcsR0FBRyxFQUFFLENBQUM7SUFDbkIsT0FBUyxDQUFDLENBQUMsTUFBTSxHQUFHLElBQUksSUFBRSxDQUFDLEdBQUcsR0FBRyxHQUFHLENBQUMsR0FBQztJQUN0QyxPQUFTLENBQUMsQ0FBQztFQUNiLENBQUcsQ0FDRjs7O0FBR0RDLE9BQUcsQ0FBQyxXQUFXLENBQUMsR0FBRyxJQUFJLFNBQVMsRUFBRSxDQUFDOzs7QUN4R25DOzs7Ozs7Ozs7O0FBZUE7QUFLQSxBQVVBLE1BQU0sR0FBRyxHQUVQLFlBQVcsSUFBSTs7SUFFZixJQUFNLENBQUMsT0FBTyxFQUFFLENBQUM7SUFDakJDLEdBQUcsQ0FBQyxRQUFRLENBQUMsQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQztFQUNoRCxFQUFHOztFQUVIOzs7RUFHQSxjQUFFLE9BQU8sdUJBQUk7O0lBRVgsSUFBTSxDQUFDLG9CQUFvQixFQUFFLENBQUM7SUFDOUIsSUFBTSxDQUFDLFlBQVksRUFBRSxDQUFDO0VBQ3hCLEVBQUc7O0VBRUg7OztFQUdBLGNBQUUsUUFBUSx3QkFBSTs7SUFFWixJQUFNLENBQUMsV0FBVyxHQUFHQSxHQUFDLENBQUMsY0FBYyxDQUFDLENBQUM7O0lBRXZDLElBQU0sQ0FBQyxLQUFLLEdBQUdBLEdBQUMsQ0FBQyxNQUFNLENBQUMsQ0FBQzs7O0lBR3pCLElBQU0sQ0FBQyxnQkFBZ0IsRUFBRSxDQUFDO0lBQzFCLElBQU0sQ0FBQyxpQkFBaUIsRUFBRSxDQUFDO0lBQzNCLElBQU0sQ0FBQyxXQUFXLEVBQUUsQ0FBQztJQUNyQixJQUFNLENBQUMsVUFBVSxFQUFFLENBQUM7SUFDcEIsSUFBTSxDQUFDLFdBQVcsRUFBRSxDQUFDO0lBQ3JCLElBQU0sQ0FBQyxjQUFjLEVBQUUsQ0FBQztJQUN4QixJQUFNLENBQUMsY0FBYyxFQUFFLENBQUM7SUFDeEIsSUFBTSxDQUFDLEtBQUssQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLGdCQUFnQixDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDO0lBQ3RELElBQU0sQ0FBQyxLQUFLLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxpQkFBaUIsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQzs7RUFFekQsRUFBRzs7RUFFSDs7OztFQUlBLGNBQUUsYUFBYSw2QkFBSTs7O0lBR2pCQSxHQUFHLENBQUMsdUJBQXVCLENBQUMsQ0FBQyxPQUFPLENBQUM7TUFDbkMsU0FBVyxFQUFFLEtBQUs7TUFDbEIsTUFBUSxFQUFFLFNBQVM7O01BRW5CLFFBQVUsRUFBRSwrSkFBK0o7S0FDMUssQ0FBQyxDQUFDOzs7Ozs7Ozs7RUFTUCxFQUFHOztFQUVIOzs7RUFHQSxjQUFFLGFBQWEsNkJBQUk7SUFDakIsSUFBTUEsR0FBQyxDQUFDLE1BQU0sQ0FBQyxDQUFDLEtBQUssRUFBRSxHQUFHLEdBQUcsRUFBRTtNQUM3QixJQUFNLG1CQUFtQixHQUFHLFFBQVEsQ0FBQyxzQkFBc0IsQ0FBQyx3QkFBd0IsQ0FBQyxDQUFDO01BQ3RGLElBQU0sbUJBQW1CLEVBQUU7UUFDekIsMEJBQXVEO1VBQ3JELElBQU0sTUFBTSxHQUFHLElBQUksS0FBSyxFQUFFLENBQUM7VUFDM0IsSUFBTSxHQUFHLEdBQUcsbUJBQW1CLENBQUMsQ0FBQyxDQUFDLENBQUM7VUFDbkMsTUFBUSxDQUFDLEdBQUcsR0FBRyxHQUFHLENBQUMsR0FBRyxDQUFDOztVQUV2QixJQUFNLFFBQVEsR0FBR0EsR0FBQyxDQUFDLEdBQUcsQ0FBQyxVQUFVLENBQUMsQ0FBQzs7VUFFbkMsSUFBTSxZQUFZLEdBQUcsRUFBRSxDQUFDOztVQUV4QixNQUFRLENBQUMsTUFBTSxHQUFHLFlBQVk7WUFDNUIsSUFBTSxZQUFZLEdBQUcsUUFBUSxDQUFDLFVBQVUsQ0FBQyxJQUFJLENBQUMsQ0FBQztZQUMvQyxJQUFNLGFBQWEsR0FBRyxRQUFRLENBQUMsV0FBVyxDQUFDLElBQUksQ0FBQyxDQUFDO1lBQ2pELElBQU0sUUFBUSxHQUFHLE1BQU0sQ0FBQyxZQUFZLENBQUM7WUFDckMsSUFBTSxTQUFTLEdBQUcsTUFBTSxDQUFDLGFBQWEsQ0FBQztZQUN2QyxBQUNBLE9BQVMsQ0FBQyxHQUFHLENBQUMsZUFBZSxFQUFFLGFBQWEsRUFBRSxlQUFlLEVBQUUsYUFBYSxDQUFDLENBQUM7WUFDOUUsSUFBTSxTQUFTLEdBQUcsUUFBUSxFQUFFO2NBQzFCLFlBQWMsSUFBSSxlQUFhLFlBQVksbURBQTZDLEdBQUcsQ0FBQyxNQUFNLEdBQUcsRUFBQyxRQUFLLENBQUM7YUFDM0csTUFBTTtjQUNQLFlBQWMsSUFBSSxnQkFBYyxhQUFhLG1EQUE2QyxHQUFHLENBQUMsS0FBSyxHQUFHLEVBQUMsUUFBSyxDQUFDO2FBQzVHOztZQUVILEdBQUssQ0FBQyxLQUFLLENBQUMsT0FBTyxHQUFHLFlBQVksR0FBRyxZQUFZLENBQUM7WUFDakQ7OztVQXZCSCxLQUFLSCxJQUFJTyxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxtQkFBbUIsQ0FBQyxNQUFNLEVBQUUsQ0FBQyxFQUFFLFlBd0JsRDtPQUNGO0tBQ0Y7RUFDTCxFQUFHOztFQUVIOzs7RUFHQSxjQUFFLGdCQUFnQixnQ0FBSTtJQUNwQixJQUFNLElBQUksQ0FBQyxXQUFXLENBQUMsTUFBTSxFQUFFO01BQzdCLElBQU1KLEdBQUMsQ0FBQyxNQUFNLENBQUMsQ0FBQyxLQUFLLEVBQUUsSUFBSSxHQUFHLEVBQUU7UUFDOUIsSUFBTSxDQUFDLFdBQVcsQ0FBQyxXQUFXLENBQUMsRUFBRSxDQUFDLENBQUM7T0FDbEMsTUFBTTtRQUNQLElBQU0sQ0FBQyxXQUFXLENBQUMsV0FBVyxDQUFDLEVBQUUsTUFBTSxFQUFFLElBQUksRUFBRSxDQUFDLENBQUM7T0FDaEQ7S0FDRjtFQUNMLEVBQUc7O0VBRUg7OztFQUdBLGNBQUUsaUJBQWlCLGlDQUFJO0lBQ3JCLElBQVEsY0FBYyxHQUFHQSxHQUFDLENBQUMscUJBQXFCLENBQUMsQ0FBQztJQUNsRCxJQUFRLGVBQWUsR0FBR0EsR0FBQyxDQUFDLHFCQUFxQixDQUFDLENBQUM7SUFDbkQsSUFBTSxhQUFhLEdBQUcsQ0FBQyxDQUFDO0lBQ3hCLElBQU0sY0FBYyxDQUFDO0lBQ3JCLElBQU0sYUFBYSxDQUFDOzs7Ozs7SUFNcEIsSUFBUSxxQkFBcUIsR0FBRyxVQUFVLENBQUMsRUFBRSxLQUFLLEVBQUUsT0FBTyxFQUFFLE9BQU8sRUFBRTtNQUNwRSxJQUFNLE9BQU8sR0FBRyxlQUFlLENBQUMsTUFBTSxHQUFHLENBQUMsRUFBRTtRQUMxQyxjQUFnQixDQUFDLFFBQVEsQ0FBQyxpQkFBaUIsQ0FBQyxDQUFDO09BQzVDLE1BQU07UUFDUCxjQUFnQixDQUFDLFdBQVcsQ0FBQyxpQkFBaUIsQ0FBQyxDQUFDO09BQy9DOztNQUVILElBQU0sT0FBTyxHQUFHLENBQUMsRUFBRTtRQUNqQixjQUFnQixDQUFDLFFBQVEsQ0FBQyxpQkFBaUIsQ0FBQyxDQUFDO09BQzVDLE1BQU07UUFDUCxjQUFnQixDQUFDLFdBQVcsQ0FBQyxpQkFBaUIsQ0FBQyxDQUFDO09BQy9DO01BQ0Y7O0lBRUgsSUFBTSxDQUFDLGNBQWMsQ0FBQyxNQUFNLEVBQUU7TUFDNUIsT0FBUztLQUNSO0lBQ0gsZUFBaUIsQ0FBQyxJQUFJLFdBQUUsR0FBRyxFQUFFLElBQUksRUFBRTtNQUNqQyxJQUFNLEtBQUssR0FBR0EsR0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDO01BQ3RCLGFBQWUsR0FBRyxLQUFLLENBQUMsS0FBSyxFQUFFLENBQUM7TUFDaEMsYUFBZSxHQUFHLGFBQWEsR0FBRyxhQUFhLENBQUM7TUFDaEQsSUFBTSxLQUFLLENBQUMsUUFBUSxDQUFDLFFBQVEsQ0FBQyxFQUFFO1FBQzlCLGNBQWdCLEdBQUcsR0FBRyxDQUFDO09BQ3RCO0tBQ0YsQ0FBQyxDQUFDOzs7SUFHTCxJQUFNLGNBQWMsQ0FBQyxLQUFLLEVBQUUsR0FBRyxhQUFhLEVBQUU7O01BRTVDLElBQU0sSUFBSSxDQUFDLFdBQVcsRUFBRTtRQUN0QixJQUFNLGNBQWMsSUFBSSxjQUFjLEtBQUssQ0FBQyxFQUFFO1VBQzVDLElBQU0sQ0FBQyxXQUFXLENBQUMsT0FBTyxDQUFDLFdBQVcsRUFBRSxjQUFjLENBQUMsQ0FBQztTQUN2RDs7T0FFRixNQUFNO1FBQ1AsSUFBTSxDQUFDLHVCQUF1QixHQUFHLGNBQWMsQ0FBQyxJQUFJLEVBQUUsQ0FBQzs7UUFFdkQsSUFBTSxDQUFDLFdBQVcsR0FBRyxjQUFjLENBQUMsS0FBSyxDQUFDOztVQUV4QyxJQUFNLEVBQUUsS0FBSztVQUNiLE1BQVEsRUFBRSxLQUFLO1VBQ2YsYUFBZSxFQUFFLElBQUk7VUFDckIsY0FBZ0IsRUFBRSxDQUFDO1VBQ25CLFVBQVksRUFBRSxJQUFJLENBQUMsc0JBQXNCLENBQUMsYUFBYSxFQUFFLGFBQWEsRUFBRSxjQUFjLENBQUM7VUFDdkYsUUFBVSxFQUFFLEtBQUs7VUFDakIsWUFBYyxFQUFFLGNBQWM7U0FDN0IsQ0FBQyxDQUFDOztRQUVMLHFCQUF1QixDQUFDLElBQUksRUFBRSxJQUFJLEVBQUUsSUFBSSxFQUFFLGNBQWMsQ0FBQyxDQUFDOztRQUUxRCxJQUFNLENBQUMsV0FBVyxDQUFDLEVBQUUsQ0FBQyxjQUFjLEVBQUUscUJBQXFCLENBQUMsQ0FBQztPQUM1RDs7S0FFRixNQUFNO01BQ1AsSUFBTSxJQUFJLENBQUMsV0FBVyxFQUFFO1FBQ3RCLElBQU0sQ0FBQyxXQUFXLENBQUMsS0FBSyxDQUFDLFNBQVMsQ0FBQztXQUM5QixXQUFXLENBQUMsaUJBQWlCLENBQUM7V0FDOUIsV0FBVyxDQUFDLGlCQUFpQixDQUFDLENBQUM7UUFDcEMsY0FBZ0IsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLHVCQUF1QixDQUFDLENBQUM7UUFDcEQsSUFBTSxDQUFDLFdBQVcsR0FBRyxJQUFJLENBQUM7T0FDekI7S0FDRjtFQUNMLEVBQUc7O0VBRUg7Ozs7Ozs7Ozs7RUFVQSxjQUFFLHNCQUFzQixvQ0FBRSxhQUFhLEVBQUUsYUFBYSxFQUFFLGNBQWMsRUFBRTtJQUN0RSxJQUFRLGNBQWMsR0FBR0EsR0FBQyxDQUFDLE1BQU0sQ0FBQyxDQUFDLEtBQUssRUFBRSxDQUFDO0lBQzNDLEFBS0EsSUFBTSxjQUFjLEtBQUssQ0FBQyxFQUFFO01BQzFCLE9BQVMsS0FBSyxDQUFDO0tBQ2Q7SUFDSCxPQUFTLElBQUksQ0FBQztFQUNoQixFQUFHOztFQUVIOzs7OztFQUtBLGNBQUUsV0FBVywyQkFBSTtJQUNmQSxHQUFHLENBQUMsZUFBZSxDQUFDLENBQUMsRUFBRSxDQUFDLFdBQVcsRUFBRSxTQUFTLENBQUMsRUFBRTtNQUMvQyxJQUFRLGNBQWMsR0FBR0EsR0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDO01BQ2pDLElBQU1BLEdBQUMsQ0FBQyxDQUFDLENBQUMsTUFBTSxDQUFDLENBQUMsUUFBUSxDQUFDLGNBQWMsQ0FBQyxFQUFFO1FBQzFDLGNBQWdCLENBQUMsTUFBTSxFQUFFLENBQUMsS0FBSyxDQUFDLE1BQU0sQ0FBQyxDQUFDO09BQ3ZDO0tBQ0YsQ0FBQyxDQUFDO0VBQ1AsRUFBRzs7RUFFSDs7O0VBR0EsY0FBRSxVQUFVLDBCQUFJO0lBQ2RBLEdBQUcsQ0FBQyxnQkFBZ0IsQ0FBQyxDQUFDLFFBQVEsQ0FBQztNQUM3QixVQUFZLEVBQUUsWUFBWTtNQUMxQixVQUFZLEVBQUUsYUFBYTtLQUMxQixDQUFDLENBQUM7RUFDUCxFQUFHOztFQUVIOzs7RUFHQSxjQUFFLFdBQVcsMkJBQUk7O0lBRWZBLEdBQUcsQ0FBQyxZQUFZLENBQUMsQ0FBQyxTQUFTLENBQUM7TUFDMUIsU0FBVyxFQUFFLEtBQUs7TUFDbEIsUUFBVSxFQUFFLEtBQUs7TUFDakIsWUFBYyxFQUFFLElBQUksQ0FBQyxhQUFhLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQztLQUM1QyxDQUFDLENBQUM7RUFDUCxFQUFHOztFQUVIOzs7RUFHQSxjQUFFLGNBQWMsOEJBQUk7O0lBRWxCQSxHQUFHLENBQUMsaUJBQWlCLENBQUM7T0FDakIsRUFBRSxDQUFDLGtCQUFrQixjQUFLO1FBQzNCQSxHQUFHLENBQUMsV0FBVyxDQUFDLENBQUMsUUFBUSxDQUFDLG9CQUFvQixDQUFDLENBQUM7T0FDL0MsQ0FBQztPQUNELEVBQUUsQ0FBQyxrQkFBa0IsY0FBSztRQUMzQkEsR0FBRyxDQUFDLFdBQVcsQ0FBQyxDQUFDLFdBQVcsQ0FBQyxvQkFBb0IsQ0FBQyxDQUFDO09BQ2xELENBQUMsQ0FBQzs7O0lBR1BBLEdBQUcsQ0FBQyxtQkFBbUIsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxRQUFRLEVBQUUsWUFBWTtNQUNoRCxNQUFRLENBQUMsUUFBUSxDQUFDLElBQUksR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDOztLQUVuQyxDQUFDLENBQUM7RUFDUCxFQUFHOztFQUVIOzs7RUFHQSxjQUFFLHdEQUF1QjtJQUN2QixJQUFNLEVBQUUsR0FBRyxRQUFRLENBQUMsY0FBYyxDQUFDLGFBQWEsQ0FBQyxDQUFDO0lBQ2xELElBQU0sRUFBRSxFQUFFO01BQ1IsRUFBSSxDQUFDLFNBQVMsR0FBRyxJQUFJLElBQUksRUFBRSxDQUFDLFdBQVcsRUFBRSxDQUFDO0tBQ3pDO0VBQ0wsRUFBRzs7RUFFSDs7O0VBR0EsY0FBRSxZQUFZLDRCQUFJO0lBQ2hCLElBQU0sRUFBRSxHQUFHLFFBQVEsQ0FBQyxjQUFjLENBQUMsa0JBQWtCLENBQUMsQ0FBQztJQUN2RCxJQUFNLEVBQUUsRUFBRTtNQUNSLEVBQUksQ0FBQyxPQUFPLEdBQUcsWUFBWTtRQUN6QixRQUFVLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxHQUFHLENBQUMsc0JBQXNCLENBQUMsQ0FBQztPQUNyRCxDQUFDO0tBQ0g7RUFDTCxFQUFHOztFQUVIOzs7RUFHQSxjQUFFLGNBQWMsOEJBQUk7SUFDbEIsSUFBTSxVQUFVLEdBQUdBLEdBQUMsQ0FBQyxjQUFjLENBQUMsQ0FBQztJQUNyQyxJQUFNLENBQUMsWUFBWSxHQUFHLFVBQVUsQ0FBQztJQUNqQyxJQUFNLENBQUMsVUFBVSxDQUFDLE1BQU0sRUFBRTtNQUN4QixPQUFTO0tBQ1I7O0lBRUgsVUFBWSxDQUFDLEVBQUUsQ0FBQyxlQUFlLEVBQUUsVUFBVSxDQUFDLEVBQUU7TUFDNUNBLEdBQUcsQ0FBQyxNQUFNLENBQUMsQ0FBQyxRQUFRLENBQUMsb0JBQW9CLENBQUMsQ0FBQztLQUMxQyxDQUFDLENBQUM7SUFDTCxVQUFZLENBQUMsRUFBRSxDQUFDLGlCQUFpQixFQUFFLFVBQVUsQ0FBQyxFQUFFO01BQzlDQSxHQUFHLENBQUMsTUFBTSxDQUFDLENBQUMsV0FBVyxDQUFDLG9CQUFvQixDQUFDLENBQUM7S0FDN0MsQ0FBQyxDQUFDO0lBQ0wsVUFBWSxDQUFDLEtBQUssQ0FBQyxNQUFNLENBQUMsQ0FBQzs7O0lBRzNCQSxHQUFHLENBQUMsUUFBUSxDQUFDLENBQUMsRUFBRSxDQUFDLE9BQU8sRUFBRSxrQkFBa0IsRUFBRSxVQUFVLENBQUMsRUFBRTtNQUN6RCxDQUFHLENBQUMsY0FBYyxFQUFFLENBQUM7TUFDckIsQUFDQSxJQUFNLElBQUksR0FBR0EsR0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDO01BQ3JCLElBQU0sSUFBSSxHQUFHLElBQUksQ0FBQyxZQUFZLENBQUMsZ0JBQWdCLENBQUMsQ0FBQztNQUNqRCxJQUFNLENBQUMsSUFBSSxFQUFFO1FBQ1gsTUFBUSxJQUFJLEtBQUssQ0FBQyxpRUFBaUUsQ0FBQyxDQUFDO1FBQ3JGLE9BQVM7T0FDUjtNQUNILFVBQVksQ0FBQyxJQUFJLENBQUMsV0FBVyxFQUFFLElBQUksQ0FBQyxDQUFDO01BQ3JDLElBQU07UUFDSixVQUFZLENBQUMsS0FBSyxDQUFDLE1BQU0sQ0FBQyxDQUFDO09BQzFCLENBQUMsT0FBTyxDQUFDLEVBQUU7UUFDWixPQUFTLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDO09BQ2hCO0tBQ0YsQ0FBQyxDQUFDO0VBQ1AsRUFBRzs7RUFFSDs7Ozs7RUFLQSxjQUFFLFdBQVcsMkJBQUk7SUFDZixJQUFNLElBQUksQ0FBQyxZQUFZLEVBQUU7TUFDdkIsSUFBTSxDQUFDLFlBQVksQ0FBQyxJQUFJLENBQUMsV0FBVyxFQUFFLE9BQU8sQ0FBQyxDQUFDO01BQy9DLElBQU0sQ0FBQyxZQUFZLENBQUMsS0FBSyxFQUFFLENBQUM7S0FDM0I7RUFDTCxFQUFHOztFQUVIOzs7OztFQUtBLGNBQUUsY0FBYyw4QkFBSTtJQUNsQixJQUFNLElBQUksQ0FBQyxZQUFZLEVBQUU7TUFDdkIsSUFBTSxDQUFDLFlBQVksQ0FBQyxJQUFJLENBQUMsV0FBVyxFQUFFLFVBQVUsQ0FBQyxDQUFDO01BQ2xELElBQU0sQ0FBQyxZQUFZLENBQUMsS0FBSyxFQUFFLENBQUM7S0FDM0I7RUFDTCxFQUFHOztFQUVIOzs7OztFQUtBLGNBQUUsUUFBUSx3QkFBSTtJQUNaLElBQU07TUFDSkQsS0FBSyxDQUFDLFlBQVksQ0FBQyxDQUFDLFFBQVEsRUFBRSxDQUFDO0tBQzlCLENBQUMsT0FBTyxDQUFDLEVBQUUsRUFBRTtFQUNsQixDQUFHLENBQ0Y7OztBQUdEQSxPQUFHLENBQUMsS0FBSyxDQUFDLEdBQUcsSUFBSSxHQUFHLEVBQUUsQ0FBQzs7OzsifQ==